"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createCoreMiddleware;

var _react = _interopRequireDefault(require("react"));

var _CarouselLayout = _interopRequireDefault(require("../../Activity/CarouselLayout"));

var _StackedLayout = _interopRequireDefault(require("../../Activity/StackedLayout"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function createCoreMiddleware() {
  return [function () {
    return function (next) {
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var activity = args[0].activity; // TODO: [P4] Can we simplify these if-statement to something more readable?

        var type = activity.type; // Filter out activities that should not be visible

        if (type === 'conversationUpdate' || type === 'event' || type === 'invoke' || type === 'typing') {
          return false;
        } else if (type === 'message') {
          var attachments = activity.attachments,
              channelData = activity.channelData,
              text = activity.text;

          if ( // Do not show postback
          channelData !== null && channelData !== void 0 && channelData.postBack || // Do not show messageBack if displayText is undefined
          channelData !== null && channelData !== void 0 && channelData.messageBack && !channelData.messageBack.displayText || // Do not show empty bubbles (no text and attachments, and not "typing")
          !(text || attachments !== null && attachments !== void 0 && attachments.length)) {
            return false;
          }
        }

        if (type === 'message' || type === 'typing') {
          var _activity$attachments;

          if (type === 'message' && (((_activity$attachments = activity.attachments) === null || _activity$attachments === void 0 ? void 0 : _activity$attachments.length) || 0) > 1 && activity.attachmentLayout === 'carousel') {
            // The following line is not a React functional component, it's a render function called by useCreateActivityRenderer() hook.
            // The function signature need to be compatible with older version of activity middleware, which was:
            //
            // renderActivity(
            //   renderAttachment: ({ activity, attachment }) => React.Element
            // ) => React.Element
            return function renderCarouselLayout(renderAttachment, props) {
              typeof props === 'undefined' && console.warn('botframework-webchat: One or more arguments were missing after passing through the activity middleware. Please check your custom activity middleware to make sure it passes all arguments.');
              return /*#__PURE__*/_react.default.createElement(_CarouselLayout.default, _extends({
                activity: activity,
                renderAttachment: renderAttachment
              }, props));
            };
          } // The following line is not a React functional component, it's a render function called by useCreateActivityRenderer() hook.


          return function renderStackedLayout(renderAttachment, props) {
            typeof props === 'undefined' && console.warn('botframework-webchat: One or more arguments were missing after passing through the activity middleware. Please check your custom activity middleware to make sure it passes all arguments.');
            return /*#__PURE__*/_react.default.createElement(_StackedLayout.default, _extends({
              activity: activity,
              renderAttachment: renderAttachment
            }, props));
          };
        }

        return next.apply(void 0, args);
      };
    };
  }];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjcmVhdGVDb3JlTWlkZGxld2FyZSIsIm5leHQiLCJhcmdzIiwiYWN0aXZpdHkiLCJ0eXBlIiwiYXR0YWNobWVudHMiLCJjaGFubmVsRGF0YSIsInRleHQiLCJwb3N0QmFjayIsIm1lc3NhZ2VCYWNrIiwiZGlzcGxheVRleHQiLCJsZW5ndGgiLCJhdHRhY2htZW50TGF5b3V0IiwicmVuZGVyQ2Fyb3VzZWxMYXlvdXQiLCJyZW5kZXJBdHRhY2htZW50IiwicHJvcHMiLCJjb25zb2xlIiwid2FybiIsInJlbmRlclN0YWNrZWRMYXlvdXQiXSwic291cmNlUm9vdCI6ImNvbXBvbmVudDovLy8iLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9NaWRkbGV3YXJlL0FjdGl2aXR5L2NyZWF0ZUNvcmVNaWRkbGV3YXJlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBY3Rpdml0eU1pZGRsZXdhcmUgfSBmcm9tICdib3RmcmFtZXdvcmstd2ViY2hhdC1hcGknO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IENhcm91c2VsTGF5b3V0IGZyb20gJy4uLy4uL0FjdGl2aXR5L0Nhcm91c2VsTGF5b3V0JztcbmltcG9ydCBTdGFja2VkTGF5b3V0IGZyb20gJy4uLy4uL0FjdGl2aXR5L1N0YWNrZWRMYXlvdXQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVDb3JlTWlkZGxld2FyZSgpOiBBY3Rpdml0eU1pZGRsZXdhcmVbXSB7XG4gIHJldHVybiBbXG4gICAgKCkgPT5cbiAgICAgIG5leHQgPT5cbiAgICAgICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IFt7IGFjdGl2aXR5IH1dID0gYXJncztcblxuICAgICAgICAvLyBUT0RPOiBbUDRdIENhbiB3ZSBzaW1wbGlmeSB0aGVzZSBpZi1zdGF0ZW1lbnQgdG8gc29tZXRoaW5nIG1vcmUgcmVhZGFibGU/XG5cbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBhY3Rpdml0eTtcblxuICAgICAgICAvLyBGaWx0ZXIgb3V0IGFjdGl2aXRpZXMgdGhhdCBzaG91bGQgbm90IGJlIHZpc2libGVcbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb252ZXJzYXRpb25VcGRhdGUnIHx8IHR5cGUgPT09ICdldmVudCcgfHwgdHlwZSA9PT0gJ2ludm9rZScgfHwgdHlwZSA9PT0gJ3R5cGluZycpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgICAgY29uc3QgeyBhdHRhY2htZW50cywgY2hhbm5lbERhdGEsIHRleHQgfSA9IGFjdGl2aXR5O1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gRG8gbm90IHNob3cgcG9zdGJhY2tcbiAgICAgICAgICAgIGNoYW5uZWxEYXRhPy5wb3N0QmFjayB8fFxuICAgICAgICAgICAgLy8gRG8gbm90IHNob3cgbWVzc2FnZUJhY2sgaWYgZGlzcGxheVRleHQgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICAoY2hhbm5lbERhdGE/Lm1lc3NhZ2VCYWNrICYmICFjaGFubmVsRGF0YS5tZXNzYWdlQmFjay5kaXNwbGF5VGV4dCkgfHxcbiAgICAgICAgICAgIC8vIERvIG5vdCBzaG93IGVtcHR5IGJ1YmJsZXMgKG5vIHRleHQgYW5kIGF0dGFjaG1lbnRzLCBhbmQgbm90IFwidHlwaW5nXCIpXG4gICAgICAgICAgICAhKHRleHQgfHwgYXR0YWNobWVudHM/Lmxlbmd0aClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ21lc3NhZ2UnIHx8IHR5cGUgPT09ICd0eXBpbmcnKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZSA9PT0gJ21lc3NhZ2UnICYmXG4gICAgICAgICAgICAoYWN0aXZpdHkuYXR0YWNobWVudHM/Lmxlbmd0aCB8fCAwKSA+IDEgJiZcbiAgICAgICAgICAgIGFjdGl2aXR5LmF0dGFjaG1lbnRMYXlvdXQgPT09ICdjYXJvdXNlbCdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbGluZSBpcyBub3QgYSBSZWFjdCBmdW5jdGlvbmFsIGNvbXBvbmVudCwgaXQncyBhIHJlbmRlciBmdW5jdGlvbiBjYWxsZWQgYnkgdXNlQ3JlYXRlQWN0aXZpdHlSZW5kZXJlcigpIGhvb2suXG4gICAgICAgICAgICAvLyBUaGUgZnVuY3Rpb24gc2lnbmF0dXJlIG5lZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIG9sZGVyIHZlcnNpb24gb2YgYWN0aXZpdHkgbWlkZGxld2FyZSwgd2hpY2ggd2FzOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHJlbmRlckFjdGl2aXR5KFxuICAgICAgICAgICAgLy8gICByZW5kZXJBdHRhY2htZW50OiAoeyBhY3Rpdml0eSwgYXR0YWNobWVudCB9KSA9PiBSZWFjdC5FbGVtZW50XG4gICAgICAgICAgICAvLyApID0+IFJlYWN0LkVsZW1lbnRcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbmRlckNhcm91c2VsTGF5b3V0KHJlbmRlckF0dGFjaG1lbnQsIHByb3BzKSB7XG4gICAgICAgICAgICAgIHR5cGVvZiBwcm9wcyA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAnYm90ZnJhbWV3b3JrLXdlYmNoYXQ6IE9uZSBvciBtb3JlIGFyZ3VtZW50cyB3ZXJlIG1pc3NpbmcgYWZ0ZXIgcGFzc2luZyB0aHJvdWdoIHRoZSBhY3Rpdml0eSBtaWRkbGV3YXJlLiBQbGVhc2UgY2hlY2sgeW91ciBjdXN0b20gYWN0aXZpdHkgbWlkZGxld2FyZSB0byBtYWtlIHN1cmUgaXQgcGFzc2VzIGFsbCBhcmd1bWVudHMuJ1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIDxDYXJvdXNlbExheW91dCBhY3Rpdml0eT17YWN0aXZpdHl9IHJlbmRlckF0dGFjaG1lbnQ9e3JlbmRlckF0dGFjaG1lbnR9IHsuLi5wcm9wc30gLz47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbGluZSBpcyBub3QgYSBSZWFjdCBmdW5jdGlvbmFsIGNvbXBvbmVudCwgaXQncyBhIHJlbmRlciBmdW5jdGlvbiBjYWxsZWQgYnkgdXNlQ3JlYXRlQWN0aXZpdHlSZW5kZXJlcigpIGhvb2suXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbmRlclN0YWNrZWRMYXlvdXQocmVuZGVyQXR0YWNobWVudCwgcHJvcHMpIHtcbiAgICAgICAgICAgIHR5cGVvZiBwcm9wcyA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdib3RmcmFtZXdvcmstd2ViY2hhdDogT25lIG9yIG1vcmUgYXJndW1lbnRzIHdlcmUgbWlzc2luZyBhZnRlciBwYXNzaW5nIHRocm91Z2ggdGhlIGFjdGl2aXR5IG1pZGRsZXdhcmUuIFBsZWFzZSBjaGVjayB5b3VyIGN1c3RvbSBhY3Rpdml0eSBtaWRkbGV3YXJlIHRvIG1ha2Ugc3VyZSBpdCBwYXNzZXMgYWxsIGFyZ3VtZW50cy4nXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiA8U3RhY2tlZExheW91dCBhY3Rpdml0eT17YWN0aXZpdHl9IHJlbmRlckF0dGFjaG1lbnQ9e3JlbmRlckF0dGFjaG1lbnR9IHsuLi5wcm9wc30gLz47XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0KC4uLmFyZ3MpO1xuICAgICAgfVxuICBdO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7OztBQUVlLFNBQVNBLG9CQUFULEdBQXNEO0VBQ25FLE9BQU8sQ0FDTDtJ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