"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FocusRedirector = function FocusRedirector(_ref) {
  var className = _ref.className,
      onFocus = _ref.onFocus,
      redirectRef = _ref.redirectRef;
  var handleFocus = (0, _react.useCallback)(function () {
    var _redirectRef$current;

    redirectRef === null || redirectRef === void 0 ? void 0 : (_redirectRef$current = redirectRef.current) === null || _redirectRef$current === void 0 ? void 0 : _redirectRef$current.focus();
    onFocus && onFocus();
  }, [onFocus, redirectRef]); // 2023-02-23: With NVDA 2022.1 and 2022.4, when in browse mode, up/down arrow keys no longer focus.
  //             We no longer need to set aria-hidden="true" to hide it from browse mode.
  // 2021-09-21: For NVDA, we should set aria-hidden="true".
  //             When using NVDA in browse mode, press up/down arrow keys will focus on this redirector.
  //             This redirector is designed to capture TAB only and should not react on browse mode.
  //             However, reacting with browse mode is currently okay. Just better to leave it alone.

  return /*#__PURE__*/_react.default.createElement("div", {
    className: className,
    onFocus: handleFocus,
    tabIndex: 0
  });
};

FocusRedirector.defaultProps = {
  className: undefined,
  onFocus: undefined,
  redirectRef: undefined
};
FocusRedirector.propTypes = {
  className: _propTypes.default.string,
  onFocus: _propTypes.default.func,
  // PropTypes is not fully compatible with TypeScript.
  // @ts-ignore
  redirectRef: _propTypes.default.shape({
    current: _propTypes.default.instanceOf(HTMLElement)
  })
};
var _default = FocusRedirector;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJGb2N1c1JlZGlyZWN0b3IiLCJjbGFzc05hbWUiLCJvbkZvY3VzIiwicmVkaXJlY3RSZWYiLCJoYW5kbGVGb2N1cyIsInVzZUNhbGxiYWNrIiwiY3VycmVudCIsImZvY3VzIiwiZGVmYXVsdFByb3BzIiwidW5kZWZpbmVkIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwic3RyaW5nIiwiZnVuYyIsInNoYXBlIiwiaW5zdGFuY2VPZiIsIkhUTUxFbGVtZW50Il0sInNvdXJjZVJvb3QiOiJjb21wb25lbnQ6Ly8vIiwic291cmNlcyI6WyIuLi8uLi9zcmMvVXRpbHMvRm9jdXNSZWRpcmVjdG9yLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgdHlwZSB7IEZDLCBNdXRhYmxlUmVmT2JqZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vLyBUaGlzIGlzIGFuIGVsZW1lbnQsIHdoZW4gZm9jdXNlZCwgd2lsbCBzZW5kIHRoZSBmb2N1cyB0byB0aGUgcmVmIHNwZWNpZmllZCBpbiBcInJlZGlyZWN0UmVmXCIuXG4vLyBBbHRob3VnaCB0aGUgZm9jdXMgaXMgYmVpbmcgcmVkaXJlY3RlZCwgYnJvd3NlciB3aWxsIHNjcm9sbCB0aGlzIHJlZGlyZWN0b3IgZWxlbWVudCBpbnRvIHZpZXcuXG5cbi8vIEJyb3dzZXIncyBcInNjcm9sbEludG9WaWV3KClcIiBjYWxsIGNhbm5vdCBiZSBwcmV2ZW50ZWQgdGhyb3VnaCBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGluIGJvdGhcbi8vIGJ1YmJsZSBhbmQgY2FwdHVyZSBwaGFzZSBvZiBcImZvY3VzXCIgZXZlbnQuXG5cbi8vIFdoZW4gdGhpcyBmb2N1cyByZWRpcmVjdG9yIGlzIHB1dCBpbnNpZGUgYSBzY3JvbGxhYmxlIGNvbnRhaW5lciwgeW91IG1heSB3YW50IHRvIHJlc2l6ZSBvciByZXBvc2l0aW9uXG4vLyBpdCB0byBwcmV2ZW50IHVuaW50ZW50aW9uYWwgc2Nyb2xsIGRvbmUgYnkgdGhlIGJyb3dzZXIgZGVmYXVsdCBiZWhhdmlvci5cblxudHlwZSBGb2N1c1JlZGlyZWN0b3JQcm9wcyA9IHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBvbkZvY3VzPzogKCkgPT4gdm9pZDtcbiAgcmVkaXJlY3RSZWY/OiBNdXRhYmxlUmVmT2JqZWN0PEhUTUxFbGVtZW50Pjtcbn07XG5cbmNvbnN0IEZvY3VzUmVkaXJlY3RvcjogRkM8Rm9jdXNSZWRpcmVjdG9yUHJvcHM+ID0gKHsgY2xhc3NOYW1lLCBvbkZvY3VzLCByZWRpcmVjdFJlZiB9KSA9PiB7XG4gIGNvbnN0IGhhbmRsZUZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJlZGlyZWN0UmVmPy5jdXJyZW50Py5mb2N1cygpO1xuICAgIG9uRm9jdXMgJiYgb25Gb2N1cygpO1xuICB9LCBbb25Gb2N1cywgcmVkaXJlY3RSZWZdKTtcblxuICAvLyAyMDIzLTAyLTIzOiBXaXRoIE5WREEgMjAyMi4xIGFuZCAyMDIyLjQsIHdoZW4gaW4gYnJvd3NlIG1vZGUsIHVwL2Rvd24gYXJyb3cga2V5cyBubyBsb25nZXIgZm9jdXMuXG4gIC8vICAgICAgICAgICAgIFdlIG5vIGxvbmdlciBuZWVkIHRvIHNldCBhcmlhLWhpZGRlbj1cInRydWVcIiB0byBoaWRlIGl0IGZyb20gYnJvd3NlIG1vZGUuXG4gIC8vIDIwMjEtMDktMjE6IEZvciBOVkRBLCB3ZSBzaG91bGQgc2V0IGFyaWEtaGlkZGVuPVwidHJ1ZVwiLlxuICAvLyAgICAgICAgICAgICBXaGVuIHVzaW5nIE5WREEgaW4gYnJvd3NlIG1vZGUsIHByZXNzIHVwL2Rvd24gYXJyb3cga2V5cyB3aWxsIGZvY3VzIG9uIHRoaXMgcmVkaXJlY3Rvci5cbiAgLy8gICAgICAgICAgICAgVGhpcyByZWRpcmVjdG9yIGlzIGRlc2lnbmVkIHRvIGNhcHR1cmUgVEFCIG9ubHkgYW5kIHNob3VsZCBub3QgcmVhY3Qgb24gYnJvd3NlIG1vZGUuXG4gIC8vICAgICAgICAgICAgIEhvd2V2ZXIsIHJlYWN0aW5nIHdpdGggYnJvd3NlIG1vZGUgaXMgY3VycmVudGx5IG9rYXkuIEp1c3QgYmV0dGVyIHRvIGxlYXZlIGl0IGFsb25lLlxuXG4gIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBvbkZvY3VzPXtoYW5kbGVGb2N1c30gdGFiSW5kZXg9ezB9IC8+O1xufTtcblxuRm9jdXNSZWRpcmVjdG9yLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIG9uRm9jdXM6IHVuZGVmaW5lZCxcbiAgcmVkaXJlY3RSZWY6IHVuZGVmaW5lZFxufTtcblxuRm9jdXNSZWRpcmVjdG9yLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgLy8gUHJvcFR5cGVzIGlzIG5vdCBmdWxseSBjb21wYXRpYmxlIHdpdGggVHlwZVNjcmlwdC5cbiAgLy8gQHRzLWlnbm9yZVxuICByZWRpcmVjdFJlZjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjdXJyZW50OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihIVE1MRWxlbWVudClcbiAgfSlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZvY3VzUmVkaXJlY3RvcjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7Ozs7Ozs7O0FBbUJBLElBQU1BLGVBQXlDLEdBQUcsU0FBNUNBLGVBQTRDLE9BQXlDO0VBQUEsSUFBdENDLFNBQXNDLFFBQXRDQSxTQUFzQztFQUFBLElBQTNCQyxPQUEyQixRQUEzQkEsT0FBMkI7RUFBQSxJQUFsQkMsV0FBa0IsUUFBbEJBLFdBQWtCO0VBQ3pGLElBQU1DLFdBQVcsR0FBRyxJQUFBQyxrQkFBQSxFQUFZLFlBQU07SUFBQTs7SUFDcENGLFdBQVcsU0FBWCxJQUFBQSxXQUFXLFdBQVgsb0NBQUFBLFdBQVcsQ0FBRUcsT0FBYiw4RUFBc0JDLEtBQXRCO0lBQ0FMLE9BQU8sSUFBSUEsT0FBTyxFQUFsQjtFQUNELENBSG1CLEVBR2pCLENBQUNBLE9BQUQsRUFBVUMsV0FBVixDQUhpQixDQUFwQixDQUR5RixDQU16RjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0VBRUEsb0JBQU87SUFBSyxTQUFTLEVBQUVGLFNBQWhCO0lBQTJCLE9BQU8sRUFBRUcsV0FBcEM7SUFBaUQsUUFBUSxFQUFFO0VBQTNELEVBQVA7QUFDRCxDQWREOztBQWdCQUosZUFBZSxDQUFDUSxZQUFoQixHQUErQjtFQUM3QlAsU0FBUyxFQUFFUSxTQURrQjtFQUU3QlAsT0FBTyxFQUFFTyxTQUZvQjtFQUc3Qk4sV0FBVyxFQUFFTTtBQUhnQixDQUEvQjtBQU1BVCxlQUFlLENBQUNVLFNBQWhCLEdBQTRCO0VBQzFCVCxTQUFTLEVBQUVVLGtCQUFBLENBQVVDLE1BREs7RUFFMUJWLE9BQU8sRUFBRVMsa0JBQUEsQ0FBVUUsSUFGTztFQUcxQjtFQUNBO0VBQ0FWLFdBQVcsRUFBRVEsa0JBQUEsQ0FBVUcsS0FBVixDQUFnQjtJQUMzQlIsT0FBTyxFQUFFSyxrQkFBQSxDQUFVSSxVQUFWLENBQXFCQyxXQUFyQjtFQURrQixDQUFoQjtBQUxhLENBQTVCO2VBVWVoQixlIn0=