"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _useEnterKeyHint = _interopRequireDefault(require("../hooks/internal/useEnterKeyHint"));

var _excluded = ["aria-errormessage", "className", "disabled", "enterKeyHint", "onChange", "onFocus", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onSelect", "placeholder", "readOnly", "tabIndex", "value"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var AccessibleInputText = /*#__PURE__*/(0, _react.forwardRef)(function (_ref, forwardedRef) {
  var ariaErrorMessage = _ref['aria-errormessage'],
      className = _ref.className,
      disabled = _ref.disabled,
      enterKeyHint = _ref.enterKeyHint,
      onChange = _ref.onChange,
      onFocus = _ref.onFocus,
      onKeyDown = _ref.onKeyDown,
      onKeyDownCapture = _ref.onKeyDownCapture,
      onKeyPress = _ref.onKeyPress,
      onSelect = _ref.onSelect,
      placeholder = _ref.placeholder,
      readOnly = _ref.readOnly,
      tabIndex = _ref.tabIndex,
      value = _ref.value,
      props = _objectWithoutProperties(_ref, _excluded);

  var targetRef = (0, _react.useRef)();
  var ref = forwardedRef || targetRef;
  (0, _useEnterKeyHint.default)(ref, enterKeyHint);
  return /*#__PURE__*/_react.default.createElement("input", _extends({
    "aria-disabled": disabled || undefined,
    "aria-errormessage": ariaErrorMessage,
    className: className,
    onChange: disabled ? undefined : onChange,
    onFocus: disabled ? undefined : onFocus,
    onKeyDown: disabled ? undefined : onKeyDown,
    onKeyDownCapture: disabled ? undefined : onKeyDownCapture,
    onKeyPress: disabled ? undefined : onKeyPress,
    onSelect: disabled ? undefined : onSelect,
    placeholder: placeholder,
    readOnly: readOnly || disabled,
    ref: ref,
    tabIndex: disabled ? -1 : tabIndex,
    value: value
  }, props, {
    type: "text"
  }));
});
AccessibleInputText.defaultProps = {
  'aria-errormessage': undefined,
  className: undefined,
  disabled: undefined,
  enterKeyHint: undefined,
  inputMode: undefined,
  onChange: undefined,
  onFocus: undefined,
  onKeyDown: undefined,
  onKeyDownCapture: undefined,
  onKeyPress: undefined,
  onSelect: undefined,
  placeholder: undefined,
  readOnly: undefined,
  tabIndex: undefined,
  value: undefined
};
AccessibleInputText.displayName = 'AccessibleInputText';
AccessibleInputText.propTypes = {
  'aria-errormessage': _propTypes.default.string,
  className: _propTypes.default.string,
  disabled: _propTypes.default.bool,
  enterKeyHint: _propTypes.default.string,
  inputMode: _propTypes.default.oneOf(['text', 'none', 'tel', 'url', 'email', 'numeric', 'decimal', 'search']),
  onChange: _propTypes.default.func,
  onFocus: _propTypes.default.func,
  onKeyDown: _propTypes.default.func,
  onKeyDownCapture: _propTypes.default.func,
  onKeyPress: _propTypes.default.func,
  onSelect: _propTypes.default.func,
  placeholder: _propTypes.default.string,
  readOnly: _propTypes.default.bool,
  tabIndex: _propTypes.default.number,
  // @ts-ignore PropTypes and TypeScript type do not well understood each other.
  type: _propTypes.default.oneOf(['text']).isRequired,
  value: _propTypes.default.string
};
var _default = AccessibleInputText;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJBY2Nlc3NpYmxlSW5wdXRUZXh0IiwiZm9yd2FyZFJlZiIsImZvcndhcmRlZFJlZiIsImFyaWFFcnJvck1lc3NhZ2UiLCJjbGFzc05hbWUiLCJkaXNhYmxlZCIsImVudGVyS2V5SGludCIsIm9uQ2hhbmdlIiwib25Gb2N1cyIsIm9uS2V5RG93biIsIm9uS2V5RG93bkNhcHR1cmUiLCJvbktleVByZXNzIiwib25TZWxlY3QiLCJwbGFjZWhvbGRlciIsInJlYWRPbmx5IiwidGFiSW5kZXgiLCJ2YWx1ZSIsInByb3BzIiwidGFyZ2V0UmVmIiwidXNlUmVmIiwicmVmIiwidXNlRW50ZXJLZXlIaW50IiwidW5kZWZpbmVkIiwiZGVmYXVsdFByb3BzIiwiaW5wdXRNb2RlIiwiZGlzcGxheU5hbWUiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJib29sIiwib25lT2YiLCJmdW5jIiwibnVtYmVyIiwidHlwZSIsImlzUmVxdWlyZWQiXSwic291cmNlUm9vdCI6ImNvbXBvbmVudDovLy8iLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9VdGlscy9BY2Nlc3NpYmxlSW5wdXRUZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogW1wiZXJyb3JcIiwgeyBcImlnbm9yZVwiOiBbLTFdIH1dICovXG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHtcbiAgQ2hhbmdlRXZlbnRIYW5kbGVyLFxuICBGb2N1c0V2ZW50SGFuZGxlcixcbiAgZm9yd2FyZFJlZixcbiAgS2V5Ym9hcmRFdmVudEhhbmRsZXIsXG4gIFJlYWN0RXZlbnRIYW5kbGVyLFxuICB1c2VSZWZcbn0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgdXNlRW50ZXJLZXlIaW50IGZyb20gJy4uL2hvb2tzL2ludGVybmFsL3VzZUVudGVyS2V5SGludCc7XG5cbi8vIERpZmZlcmVuY2VzIGJldHdlZW4gPGlucHV0IHR5cGU9XCJ0ZXh0XCI+IGFuZCA8QWNjZXNzaWJsZUlucHV0VGV4dD46XG4vLyAtIERpc2FibGUgYmVoYXZpb3Jcbi8vICAgLSBXaGVuIHRoZSB3aWRnZXQgaXMgZGlzYWJsZWRcbi8vICAgICAtIFNldCBcImFyaWEtZGlzYWJsZWRcIiBhdHRyaWJ1dGUgdG8gXCJ0cnVlXCJcbi8vICAgICAtIFNldCBcInJlYWRvbmx5XCIgYXR0cmlidXRlXG4vLyAgICAgLSBTZXQgXCJ0YWJJbmRleFwiIHRvIC0xXG4vLyAgICAgLSBSZW1vdmUgXCJvbkNoYW5nZVwiIGhhbmRsZXJcbi8vICAgLSBXaHkgdGhpcyBpcyBuZWVkZWRcbi8vICAgICAtIEJyb3dzZXIgY29tcGF0aWJpbGl0eTogd2hlbiB0aGUgd2lkZ2V0IGlzIGRpc2FibGVkLCBkaWZmZXJlbnQgYnJvd3NlciBzZW5kIGZvY3VzIHRvIGRpZmZlcmVudCBwbGFjZXNcbi8vICAgICAtIFdoZW4gdGhlIHdpZGdldCBpcyBkaXNhYmxlZCwgaXQncyByZWFzb25hYmxlIHRvIGtlZXAgdGhlIGZvY3VzIG9uIHRoZSBzYW1lIHdpZGdldCBmb3IgYW4gZXh0ZW5kZWQgcGVyaW9kIG9mIHRpbWVcbi8vICAgICAgIC0gV2hlbiB0aGUgdXNlciBwcmVzc2VzIFRBQiBhZnRlciB0aGUgY3VycmVudCB3aWRnZXQgaXMgZGlzYWJsZWQsIGl0IHNob3VsZCBqdW1wIHRvIHRoZSBuZXh0IG5vbi1kaXNhYmxlZCB3aWRnZXRcblxuLy8gRGV2ZWxvcGVycyB1c2luZyB0aGlzIGFjY2Vzc2libGUgd2lkZ2V0IHdpbGwgbmVlZCB0bzpcbi8vIC0gU3R5bGUgdGhlIGRpc2FibGVkIHdpZGdldCB0aGVtc2VsdmVzLCB1c2luZyBDU1MgcXVlcnkgYDpkaXNhYmxlZCwgW2FyaWEtZGlzYWJsZWQ9XCJ0cnVlXCJdIHt9YFxuLy8gLSBNb2RpZnkgYWxsIHRoZSBjb2RlIHRoYXQgY2hlY2tzIGRpc2FibGVkIHRocm91Z2ggdGhlIFwiZGlzYWJsZWRcIiBhdHRyaWJ1dGUgdG8gdXNlIGFyaWEtZGlzYWJsZWQ9XCJ0cnVlXCIgaW5zdGVhZFxuLy8gICAtIGFyaWEtZGlzYWJsZWQ9XCJ0cnVlXCIgaXMgdGhlIHNvdXJjZSBvZiB0cnV0aFxuLy8gLSBJZiB0aGUgd2lkZ2V0IGlzIGNvbnRhaW5lZCBieSBhIDxmb3JtPiwgdGhlIGRldmVsb3BlciBuZWVkIHRvIGZpbHRlciBvdXQgc29tZSBgb25TdWJtaXRgIGV2ZW50IGNhdXNlZCBieSB0aGlzIHdpZGdldFxuXG50eXBlIEFjY2Vzc2libGVJbnB1dFRleHRQcm9wcyA9IHtcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJz86IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG4gIGVudGVyS2V5SGludD86IHN0cmluZztcbiAgaW5wdXRNb2RlPzogJ3RleHQnIHwgJ25vbmUnIHwgJ3RlbCcgfCAndXJsJyB8ICdlbWFpbCcgfCAnbnVtZXJpYycgfCAnZGVjaW1hbCcgfCAnc2VhcmNoJztcbiAgb25DaGFuZ2U/OiBDaGFuZ2VFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG4gIG9uRm9jdXM/OiBGb2N1c0V2ZW50SGFuZGxlcjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgb25LZXlEb3duPzogS2V5Ym9hcmRFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG4gIG9uS2V5RG93bkNhcHR1cmU/OiBLZXlib2FyZEV2ZW50SGFuZGxlcjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgb25LZXlQcmVzcz86IEtleWJvYXJkRXZlbnRIYW5kbGVyPEhUTUxJbnB1dEVsZW1lbnQ+O1xuICBvblNlbGVjdD86IFJlYWN0RXZlbnRIYW5kbGVyPEhUTUxJbnB1dEVsZW1lbnQ+O1xuICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgcmVhZE9ubHk/OiBib29sZWFuO1xuICB0YWJJbmRleD86IG51bWJlcjtcbiAgdHlwZTogJ3RleHQnO1xuICB2YWx1ZT86IHN0cmluZztcbn07XG5cbmNvbnN0IEFjY2Vzc2libGVJbnB1dFRleHQgPSBmb3J3YXJkUmVmPEhUTUxJbnB1dEVsZW1lbnQsIEFjY2Vzc2libGVJbnB1dFRleHRQcm9wcz4oXG4gIChcbiAgICB7XG4gICAgICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiBhcmlhRXJyb3JNZXNzYWdlLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBlbnRlcktleUhpbnQsXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIG9uRm9jdXMsXG4gICAgICBvbktleURvd24sXG4gICAgICBvbktleURvd25DYXB0dXJlLFxuICAgICAgb25LZXlQcmVzcyxcbiAgICAgIG9uU2VsZWN0LFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICByZWFkT25seSxcbiAgICAgIHRhYkluZGV4LFxuICAgICAgdmFsdWUsXG4gICAgICAuLi5wcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkgPT4ge1xuICAgIGNvbnN0IHRhcmdldFJlZiA9IHVzZVJlZigpO1xuXG4gICAgY29uc3QgcmVmID0gZm9yd2FyZGVkUmVmIHx8IHRhcmdldFJlZjtcblxuICAgIHVzZUVudGVyS2V5SGludChyZWYsIGVudGVyS2V5SGludCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGlucHV0XG4gICAgICAgIGFyaWEtZGlzYWJsZWQ9e2Rpc2FibGVkIHx8IHVuZGVmaW5lZH1cbiAgICAgICAgYXJpYS1lcnJvcm1lc3NhZ2U9e2FyaWFFcnJvck1lc3NhZ2V9XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICBvbkNoYW5nZT17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBvbkNoYW5nZX1cbiAgICAgICAgb25Gb2N1cz17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBvbkZvY3VzfVxuICAgICAgICBvbktleURvd249e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogb25LZXlEb3dufVxuICAgICAgICBvbktleURvd25DYXB0dXJlPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IG9uS2V5RG93bkNhcHR1cmV9XG4gICAgICAgIG9uS2V5UHJlc3M9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogb25LZXlQcmVzc31cbiAgICAgICAgb25TZWxlY3Q9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogb25TZWxlY3R9XG4gICAgICAgIHBsYWNlaG9sZGVyPXtwbGFjZWhvbGRlcn1cbiAgICAgICAgcmVhZE9ubHk9e3JlYWRPbmx5IHx8IGRpc2FibGVkfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgdGFiSW5kZXg9e2Rpc2FibGVkID8gLTEgOiB0YWJJbmRleH1cbiAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuQWNjZXNzaWJsZUlucHV0VGV4dC5kZWZhdWx0UHJvcHMgPSB7XG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IHVuZGVmaW5lZCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIGRpc2FibGVkOiB1bmRlZmluZWQsXG4gIGVudGVyS2V5SGludDogdW5kZWZpbmVkLFxuICBpbnB1dE1vZGU6IHVuZGVmaW5lZCxcbiAgb25DaGFuZ2U6IHVuZGVmaW5lZCxcbiAgb25Gb2N1czogdW5kZWZpbmVkLFxuICBvbktleURvd246IHVuZGVmaW5lZCxcbiAgb25LZXlEb3duQ2FwdHVyZTogdW5kZWZpbmVkLFxuICBvbktleVByZXNzOiB1bmRlZmluZWQsXG4gIG9uU2VsZWN0OiB1bmRlZmluZWQsXG4gIHBsYWNlaG9sZGVyOiB1bmRlZmluZWQsXG4gIHJlYWRPbmx5OiB1bmRlZmluZWQsXG4gIHRhYkluZGV4OiB1bmRlZmluZWQsXG4gIHZhbHVlOiB1bmRlZmluZWRcbn07XG5cbkFjY2Vzc2libGVJbnB1dFRleHQuZGlzcGxheU5hbWUgPSAnQWNjZXNzaWJsZUlucHV0VGV4dCc7XG5cbkFjY2Vzc2libGVJbnB1dFRleHQucHJvcFR5cGVzID0ge1xuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgZW50ZXJLZXlIaW50OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBpbnB1dE1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ3RleHQnLCAnbm9uZScsICd0ZWwnLCAndXJsJywgJ2VtYWlsJywgJ251bWVyaWMnLCAnZGVjaW1hbCcsICdzZWFyY2gnXSksXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uS2V5RG93bkNhcHR1cmU6IFByb3BUeXBlcy5mdW5jLFxuICBvbktleVByZXNzOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgcmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuICB0YWJJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gQHRzLWlnbm9yZSBQcm9wVHlwZXMgYW5kIFR5cGVTY3JpcHQgdHlwZSBkbyBub3Qgd2VsbCB1bmRlcnN0b29kIGVhY2ggb3RoZXIuXG4gIHR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ3RleHQnXSkuaXNSZXF1aXJlZCxcbiAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFjY2Vzc2libGVJbnB1dFRleHQ7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVBOztBQUNBOztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBLElBQU1BLG1CQUFtQixnQkFBRyxJQUFBQyxpQkFBQSxFQUMxQixnQkFrQkVDLFlBbEJGLEVBbUJLO0VBQUEsSUFqQm9CQyxnQkFpQnBCLFFBakJELG1CQWlCQztFQUFBLElBaEJEQyxTQWdCQyxRQWhCREEsU0FnQkM7RUFBQSxJQWZEQyxRQWVDLFFBZkRB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