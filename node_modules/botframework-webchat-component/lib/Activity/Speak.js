"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.connectSpeakActivity = void 0;

var _botframeworkWebchatApi = require("botframework-webchat-api");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _reactSay = _interopRequireWildcard(require("react-say"));

var _connectToWebChat = _interopRequireDefault(require("../connectToWebChat"));

var _SayAlt = _interopRequireDefault(require("./SayAlt"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useMarkActivityAsSpoken = _botframeworkWebchatApi.hooks.useMarkActivityAsSpoken,
    useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions,
    useVoiceSelector = _botframeworkWebchatApi.hooks.useVoiceSelector; // TODO: [P4] Consider moving this feature into BasicActivity
//       And it has better DOM position for showing visual spoken text
// TODO: [P3] We should add a "spoken" or "speakState" flag to indicate whether this activity is going to speak, or spoken

var connectSpeakActivity = function connectSpeakActivity() {
  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {
    selectors[_key] = arguments[_key];
  }

  return _connectToWebChat.default.apply(void 0, [function (_ref, _ref2) {
    var language = _ref.language,
        markActivity = _ref.markActivity,
        _selectVoice = _ref.selectVoice;
    var activity = _ref2.activity;
    return {
      language: language,
      markAsSpoken: function markAsSpoken() {
        return markActivity(activity, 'speak', false);
      },
      selectVoice: function selectVoice(voices) {
        return _selectVoice(voices, activity);
      }
    };
  }].concat(selectors));
};

exports.connectSpeakActivity = connectSpeakActivity;

var Speak = function Speak(_ref3) {
  var _activity$channelData;

  var activity = _ref3.activity;

  var _useStyleOptions = useStyleOptions(),
      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),
      showSpokenText = _useStyleOptions2[0].showSpokenText;

  var markActivityAsSpoken = useMarkActivityAsSpoken();
  var selectVoice = useVoiceSelector(activity);
  var markAsSpoken = (0, _react.useCallback)(function () {
    markActivityAsSpoken(activity);
  }, [activity, markActivityAsSpoken]);
  var singleLine = (0, _react.useMemo)(function () {
    if (activity.type !== 'message') {
      return false;
    }

    var _activity$attachments = activity.attachments,
        attachments = _activity$attachments === void 0 ? [] : _activity$attachments,
        speak = activity.speak,
        text = activity.text;
    return [speak || text].concat(_toConsumableArray(attachments.filter(function (_ref4) {
      var contentType = _ref4.contentType;
      return contentType === 'application/vnd.microsoft.card.adaptive';
    }).map(function (attachment) {
      var _attachment$content;

      return attachment === null || attachment === void 0 ? void 0 : (_attachment$content = attachment.content) === null || _attachment$content === void 0 ? void 0 : _attachment$content.speak;
    }))).filter(function (line) {
      return line;
    }).join('\r\n');
  }, [activity]);
  var speechSynthesisUtterance = activity.type === 'message' && ((_activity$channelData = activity.channelData) === null || _activity$channelData === void 0 ? void 0 : _activity$channelData.speechSynthesisUtterance);
  return !!activity && /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, speechSynthesisUtterance ? /*#__PURE__*/_react.default.createElement(_reactSay.SayUtterance, {
    onEnd: markAsSpoken,
    onError: markAsSpoken,
    utterance: speechSynthesisUtterance
  }) : /*#__PURE__*/_react.default.createElement(_reactSay.default, {
    onEnd: markAsSpoken,
    onError: markAsSpoken,
    text: singleLine,
    voice: selectVoice
  }), !!showSpokenText && /*#__PURE__*/_react.default.createElement(_SayAlt.default, {
    speak: singleLine
  }));
};

Speak.propTypes = {
  // PropTypes cannot fully capture TypeScript types.
  // @ts-ignore
  activity: _propTypes.default.shape({
    attachments: _propTypes.default.arrayOf(_propTypes.default.shape({
      speak: _propTypes.default.string,
      subtitle: _propTypes.default.string,
      text: _propTypes.default.string,
      title: _propTypes.default.string
    })),
    channelData: _propTypes.default.shape({
      speechSynthesisUtterance: _propTypes.default.any
    }),
    speak: _propTypes.default.string,
    text: _propTypes.default.string,
    type: _propTypes.default.string.isRequired
  }).isRequired
};
var _default = Speak;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1c2VNYXJrQWN0aXZpdHlBc1Nwb2tlbiIsImhvb2tzIiwidXNlU3R5bGVPcHRpb25zIiwidXNlVm9pY2VTZWxlY3RvciIsImNvbm5lY3RTcGVha0FjdGl2aXR5Iiwic2VsZWN0b3JzIiwiY29ubmVjdFRvV2ViQ2hhdCIsImxhbmd1YWdlIiwibWFya0FjdGl2aXR5Iiwic2VsZWN0Vm9pY2UiLCJhY3Rpdml0eSIsIm1hcmtBc1Nwb2tlbiIsInZvaWNlcyIsIlNwZWFrIiwic2hvd1Nwb2tlblRleHQiLCJtYXJrQWN0aXZpdHlBc1Nwb2tlbiIsInVzZUNhbGxiYWNrIiwic2luZ2xlTGluZSIsInVzZU1lbW8iLCJ0eXBlIiwiYXR0YWNobWVudHMiLCJzcGVhayIsInRleHQiLCJmaWx0ZXIiLCJjb250ZW50VHlwZSIsIm1hcCIsImF0dGFjaG1lbnQiLCJjb250ZW50IiwibGluZSIsImpvaW4iLCJzcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UiLCJjaGFubmVsRGF0YSIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsInNoYXBlIiwiYXJyYXlPZiIsInN0cmluZyIsInN1YnRpdGxlIiwidGl0bGUiLCJhbnkiLCJpc1JlcXVpcmVkIl0sInNvdXJjZVJvb3QiOiJjb21wb25lbnQ6Ly8vIiwic291cmNlcyI6WyIuLi8uLi9zcmMvQWN0aXZpdHkvU3BlYWsudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhvb2tzIH0gZnJvbSAnYm90ZnJhbWV3b3JrLXdlYmNoYXQtYXBpJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgRkMsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFNheSwgeyBTYXlVdHRlcmFuY2UgfSBmcm9tICdyZWFjdC1zYXknO1xuaW1wb3J0IHR5cGUgeyBXZWJDaGF0QWN0aXZpdHkgfSBmcm9tICdib3RmcmFtZXdvcmstd2ViY2hhdC1jb3JlJztcblxuaW1wb3J0IGNvbm5lY3RUb1dlYkNoYXQgZnJvbSAnLi4vY29ubmVjdFRvV2ViQ2hhdCc7XG5pbXBvcnQgU2F5QWx0IGZyb20gJy4vU2F5QWx0JztcblxuY29uc3QgeyB1c2VNYXJrQWN0aXZpdHlBc1Nwb2tlbiwgdXNlU3R5bGVPcHRpb25zLCB1c2VWb2ljZVNlbGVjdG9yIH0gPSBob29rcztcblxuLy8gVE9ETzogW1A0XSBDb25zaWRlciBtb3ZpbmcgdGhpcyBmZWF0dXJlIGludG8gQmFzaWNBY3Rpdml0eVxuLy8gICAgICAgQW5kIGl0IGhhcyBiZXR0ZXIgRE9NIHBvc2l0aW9uIGZvciBzaG93aW5nIHZpc3VhbCBzcG9rZW4gdGV4dFxuXG4vLyBUT0RPOiBbUDNdIFdlIHNob3VsZCBhZGQgYSBcInNwb2tlblwiIG9yIFwic3BlYWtTdGF0ZVwiIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIGFjdGl2aXR5IGlzIGdvaW5nIHRvIHNwZWFrLCBvciBzcG9rZW5cbmNvbnN0IGNvbm5lY3RTcGVha0FjdGl2aXR5ID0gKC4uLnNlbGVjdG9ycykgPT5cbiAgY29ubmVjdFRvV2ViQ2hhdChcbiAgICAoeyBsYW5ndWFnZSwgbWFya0FjdGl2aXR5LCBzZWxlY3RWb2ljZSB9LCB7IGFjdGl2aXR5IH0pID0+ICh7XG4gICAgICBsYW5ndWFnZSxcbiAgICAgIG1hcmtBc1Nwb2tlbjogKCkgPT4gbWFya0FjdGl2aXR5KGFjdGl2aXR5LCAnc3BlYWsnLCBmYWxzZSksXG4gICAgICBzZWxlY3RWb2ljZTogdm9pY2VzID0+IHNlbGVjdFZvaWNlKHZvaWNlcywgYWN0aXZpdHkpXG4gICAgfSksXG4gICAgLi4uc2VsZWN0b3JzXG4gICk7XG5cbnR5cGUgU3BlYWtQcm9wcyA9IHtcbiAgYWN0aXZpdHk6IFdlYkNoYXRBY3Rpdml0eTtcbn07XG5cbmNvbnN0IFNwZWFrOiBGQzxTcGVha1Byb3BzPiA9ICh7IGFjdGl2aXR5IH0pID0+IHtcbiAgY29uc3QgW3sgc2hvd1Nwb2tlblRleHQgfV0gPSB1c2VTdHlsZU9wdGlvbnMoKTtcbiAgY29uc3QgbWFya0FjdGl2aXR5QXNTcG9rZW4gPSB1c2VNYXJrQWN0aXZpdHlBc1Nwb2tlbigpO1xuICBjb25zdCBzZWxlY3RWb2ljZSA9IHVzZVZvaWNlU2VsZWN0b3IoYWN0aXZpdHkpO1xuXG4gIGNvbnN0IG1hcmtBc1Nwb2tlbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBtYXJrQWN0aXZpdHlBc1Nwb2tlbihhY3Rpdml0eSk7XG4gIH0sIFthY3Rpdml0eSwgbWFya0FjdGl2aXR5QXNTcG9rZW5dKTtcblxuICBjb25zdCBzaW5nbGVMaW5lOiBmYWxzZSB8IHN0cmluZyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChhY3Rpdml0eS50eXBlICE9PSAnbWVzc2FnZScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGF0dGFjaG1lbnRzID0gW10sIHNwZWFrLCB0ZXh0IH0gPSBhY3Rpdml0eTtcblxuICAgIHJldHVybiBbXG4gICAgICBzcGVhayB8fCB0ZXh0LFxuICAgICAgLi4uYXR0YWNobWVudHNcbiAgICAgICAgLmZpbHRlcigoeyBjb250ZW50VHlwZSB9KSA9PiBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3ZuZC5taWNyb3NvZnQuY2FyZC5hZGFwdGl2ZScpXG4gICAgICAgIC5tYXAoYXR0YWNobWVudCA9PiBhdHRhY2htZW50Py5jb250ZW50Py5zcGVhaylcbiAgICBdXG4gICAgICAuZmlsdGVyKGxpbmUgPT4gbGluZSlcbiAgICAgIC5qb2luKCdcXHJcXG4nKTtcbiAgfSwgW2FjdGl2aXR5XSk7XG5cbiAgY29uc3Qgc3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlOiBmYWxzZSB8IFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSB8IHVuZGVmaW5lZCA9XG4gICAgYWN0aXZpdHkudHlwZSA9PT0gJ21lc3NhZ2UnICYmIGFjdGl2aXR5LmNoYW5uZWxEYXRhPy5zcGVlY2hTeW50aGVzaXNVdHRlcmFuY2U7XG5cbiAgcmV0dXJuIChcbiAgICAhIWFjdGl2aXR5ICYmIChcbiAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAge3NwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSA/IChcbiAgICAgICAgICA8U2F5VXR0ZXJhbmNlIG9uRW5kPXttYXJrQXNTcG9rZW59IG9uRXJyb3I9e21hcmtBc1Nwb2tlbn0gdXR0ZXJhbmNlPXtzcGVlY2hTeW50aGVzaXNVdHRlcmFuY2V9IC8+XG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPFNheSBvbkVuZD17bWFya0FzU3Bva2VufSBvbkVycm9yPXttYXJrQXNTcG9rZW59IHRleHQ9e3NpbmdsZUxpbmV9IHZvaWNlPXtzZWxlY3RWb2ljZX0gLz5cbiAgICAgICAgKX1cbiAgICAgICAgeyEhc2hvd1Nwb2tlblRleHQgJiYgPFNheUFsdCBzcGVhaz17c2luZ2xlTGluZX0gLz59XG4gICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgIClcbiAgKTtcbn07XG5cblNwZWFrLnByb3BUeXBlcyA9IHtcbiAgLy8gUHJvcFR5cGVzIGNhbm5vdCBmdWxseSBjYXB0dXJlIFR5cGVTY3JpcHQgdHlwZXMuXG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZpdHk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgYXR0YWNobWVudHM6IFByb3BUeXBlcy5hcnJheU9mKFxuICAgICAgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgc3BlYWs6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHN1YnRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICB0ZXh0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZ1xuICAgICAgfSlcbiAgICApLFxuICAgIGNoYW5uZWxEYXRhOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgc3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlOiBQcm9wVHlwZXMuYW55XG4gICAgfSksXG4gICAgc3BlYWs6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgdGV4dDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0eXBlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgU3BlYWs7XG5cbmV4cG9ydCB7IGNvbm5lY3RTcGVha0FjdGl2aXR5IH07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUdBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBUUEsdUJBQVIsR0FBdUVDLDZCQUF2RSxDQUFRRCx1QkFBUjtBQUFBLElBQWlDRSxlQUFqQyxHQUF1RUQsNkJBQXZFLENBQWlDQyxlQUFqQztBQUFBLElBQWtEQyxnQkFBbEQsR0FBdUVGLDZCQUF2RSxDQUFrREUsZ0JBQWxELEMsQ0FFQTtBQUNBO0FBRUE7O0FBQ0EsSUFBTUMsb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUF1QjtFQUFBLGtDQUFJQyxTQUFKO0lBQUlBLFNBQUo7RUFBQTs7RUFBQSxPQUMzQkMseUJBQUEsZ0JBQ0U7SUFBQSxJQUFHQyxRQUFILFFBQUdBLFFBQUg7SUFBQSxJQUFhQyxZQUFiLFFBQWFBLFlBQWI7SUFBQSxJQUEyQkMsWUFBM0IsUUFBMkJBLFdBQTNCO0lBQUEsSUFBNENDLFFBQTVDLFNBQTRDQSxRQUE1QztJQUFBLE9BQTREO01BQzFESCxRQUFRLEVBQVJBLFFBRDBEO01BRTFESSxZQUFZLEVBQUU7UUFBQSxPQUFNSCxZQUFZLENBQUNFLFFBQUQsRUFBVyxPQUFYLEVBQW9CLEtBQXBCLENBQWxCO01BQUEsQ0FGNEM7TUFHMURELFdBQVcsRUFBRSxxQkFBQUcsTUFBTTtRQUFBLE9BQUlILFlBQVcsQ0FBQ0csTUFBRCxFQUFTRixRQUFULENBQWY7TUFBQTtJQUh1QyxDQUE1RDtFQUFBLENBREYsU0FNS0wsU0FOTCxFQUQyQjtBQUFBLENBQTdCOzs7O0FBY0EsSUFBTVEsS0FBcUIsR0FBRyxTQUF4QkEsS0FBd0IsUUFBa0I7RUFBQTs7RUFBQSxJQUFmSCxRQUFlLFNBQWZBLFFB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