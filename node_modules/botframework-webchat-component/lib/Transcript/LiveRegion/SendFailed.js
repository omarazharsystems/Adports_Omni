"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _botframeworkWebchatApi = require("botframework-webchat-api");

var _react = require("react");

var _SendStatus = require("../../types/internal/SendStatus");

var _isPresentational = _interopRequireDefault(require("./isPresentational"));

var _usePrevious = _interopRequireDefault(require("../../hooks/internal/usePrevious"));

var _useQueueStaticElement = _interopRequireDefault(require("../../providers/LiveRegionTwin/useQueueStaticElement"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useGetActivityByKey = _botframeworkWebchatApi.hooks.useGetActivityByKey,
    useLocalizer = _botframeworkWebchatApi.hooks.useLocalizer,
    useSendStatusByActivityKey = _botframeworkWebchatApi.hooks.useSendStatusByActivityKey;
/**
 * React component to on-demand narrate "Failed to send message" at the end of the live region.
 *
 * We cannot narrate "failed to send message" next to the activity. At the time when the activity is being sent,
 * the activity is also queued to the screen reader. And at that moment, we not yet know if the activity can be sent or not.
 *
 * We only know when the activity was failed to send at a later time.
 *
 * Thus, we need to use a live region "footnote" to indicate the message was failed to send.
 */

var LiveRegionSendFailed = function LiveRegionSendFailed() {
  var _useSendStatusByActiv = useSendStatusByActivityKey(),
      _useSendStatusByActiv2 = _slicedToArray(_useSendStatusByActiv, 1),
      sendStatusByActivityKey = _useSendStatusByActiv2[0];

  var getActivityByKey = useGetActivityByKey();
  var localize = useLocalizer();
  var queueStaticElement = (0, _useQueueStaticElement.default)();
  /**
   * List of keys of outgoing and non-presentational activities that are failed to send.
   *
   * Activities which are presentational, such as `event` or `typing`, are ignored to reduce confusions.
   * "Failed to send message" should not be narrated for presentational activities.
   */

  var activityKeysOfSendFailed = (0, _react.useMemo)(function () {
    return Array.from(sendStatusByActivityKey).reduce(function (activityKeysOfSendFailed, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          sendStatus = _ref2[1];

      return sendStatus === _SendStatus.SEND_FAILED && !(0, _isPresentational.default)(getActivityByKey(key)) ? activityKeysOfSendFailed.add(key) : activityKeysOfSendFailed;
    }, new Set());
  }, [getActivityByKey, sendStatusByActivityKey]);
  /** Returns localized "Failed to send message." */

  var liveRegionSendFailedAlt = localize('TRANSCRIPT_LIVE_REGION_SEND_FAILED_ALT');
  var prevActivityKeysOfSendFailed = (0, _usePrevious.default)(activityKeysOfSendFailed);
  /** True, if one or more non-presentational activities start appears as "send failed", otherwise, false. */

  var hasNewSendFailed = (0, _react.useMemo)(function () {
    if (activityKeysOfSendFailed === prevActivityKeysOfSendFailed) {
      return false;
    }

    var _iterator = _createForOfIteratorHelper(activityKeysOfSendFailed.keys()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var key = _step.value;

        if (!prevActivityKeysOfSendFailed.has(key)) {
          return true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return false;
  }, [activityKeysOfSendFailed, prevActivityKeysOfSendFailed]);
  (0, _react.useEffect)(function () {
    hasNewSendFailed && queueStaticElement(liveRegionSendFailedAlt);
  }, [hasNewSendFailed, liveRegionSendFailedAlt, queueStaticElement]);
  return null;
};

var _default = LiveRegionSendFailed;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1c2VHZXRBY3Rpdml0eUJ5S2V5IiwiaG9va3MiLCJ1c2VMb2NhbGl6ZXIiLCJ1c2VTZW5kU3RhdHVzQnlBY3Rpdml0eUtleSIsIkxpdmVSZWdpb25TZW5kRmFpbGVkIiwic2VuZFN0YXR1c0J5QWN0aXZpdHlLZXkiLCJnZXRBY3Rpdml0eUJ5S2V5IiwibG9jYWxpemUiLCJxdWV1ZVN0YXRpY0VsZW1lbnQiLCJ1c2VRdWV1ZVN0YXRpY0VsZW1lbnQiLCJhY3Rpdml0eUtleXNPZlNlbmRGYWlsZWQiLCJ1c2VNZW1vIiwiQXJyYXkiLCJmcm9tIiwicmVkdWNlIiwia2V5Iiwic2VuZFN0YXR1cyIsIlNFTkRfRkFJTEVEIiwiaXNQcmVzZW50YXRpb25hbCIsImFkZCIsIlNldCIsImxpdmVSZWdpb25TZW5kRmFpbGVkQWx0IiwicHJldkFjdGl2aXR5S2V5c09mU2VuZEZhaWxlZCIsInVzZVByZXZpb3VzIiwiaGFzTmV3U2VuZEZhaWxlZCIsImtleXMiLCJoYXMiLCJ1c2VFZmZlY3QiXSwic291cmNlUm9vdCI6ImNvbXBvbmVudDovLy8iLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9UcmFuc2NyaXB0L0xpdmVSZWdpb24vU2VuZEZhaWxlZC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaG9va3MgfSBmcm9tICdib3RmcmFtZXdvcmstd2ViY2hhdC1hcGknO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHR5cGUgeyBWRkMgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNFTkRfRkFJTEVEIH0gZnJvbSAnLi4vLi4vdHlwZXMvaW50ZXJuYWwvU2VuZFN0YXR1cyc7XG5pbXBvcnQgaXNQcmVzZW50YXRpb25hbCBmcm9tICcuL2lzUHJlc2VudGF0aW9uYWwnO1xuaW1wb3J0IHVzZVByZXZpb3VzIGZyb20gJy4uLy4uL2hvb2tzL2ludGVybmFsL3VzZVByZXZpb3VzJztcbmltcG9ydCB1c2VRdWV1ZVN0YXRpY0VsZW1lbnQgZnJvbSAnLi4vLi4vcHJvdmlkZXJzL0xpdmVSZWdpb25Ud2luL3VzZVF1ZXVlU3RhdGljRWxlbWVudCc7XG5cbmNvbnN0IHsgdXNlR2V0QWN0aXZpdHlCeUtleSwgdXNlTG9jYWxpemVyLCB1c2VTZW5kU3RhdHVzQnlBY3Rpdml0eUtleSB9ID0gaG9va3M7XG5cbi8qKlxuICogUmVhY3QgY29tcG9uZW50IHRvIG9uLWRlbWFuZCBuYXJyYXRlIFwiRmFpbGVkIHRvIHNlbmQgbWVzc2FnZVwiIGF0IHRoZSBlbmQgb2YgdGhlIGxpdmUgcmVnaW9uLlxuICpcbiAqIFdlIGNhbm5vdCBuYXJyYXRlIFwiZmFpbGVkIHRvIHNlbmQgbWVzc2FnZVwiIG5leHQgdG8gdGhlIGFjdGl2aXR5LiBBdCB0aGUgdGltZSB3aGVuIHRoZSBhY3Rpdml0eSBpcyBiZWluZyBzZW50LFxuICogdGhlIGFjdGl2aXR5IGlzIGFsc28gcXVldWVkIHRvIHRoZSBzY3JlZW4gcmVhZGVyLiBBbmQgYXQgdGhhdCBtb21lbnQsIHdlIG5vdCB5ZXQga25vdyBpZiB0aGUgYWN0aXZpdHkgY2FuIGJlIHNlbnQgb3Igbm90LlxuICpcbiAqIFdlIG9ubHkga25vdyB3aGVuIHRoZSBhY3Rpdml0eSB3YXMgZmFpbGVkIHRvIHNlbmQgYXQgYSBsYXRlciB0aW1lLlxuICpcbiAqIFRodXMsIHdlIG5lZWQgdG8gdXNlIGEgbGl2ZSByZWdpb24gXCJmb290bm90ZVwiIHRvIGluZGljYXRlIHRoZSBtZXNzYWdlIHdhcyBmYWlsZWQgdG8gc2VuZC5cbiAqL1xuY29uc3QgTGl2ZVJlZ2lvblNlbmRGYWlsZWQ6IFZGQzx7fT4gPSAoKSA9PiB7XG4gIGNvbnN0IFtzZW5kU3RhdHVzQnlBY3Rpdml0eUtleV0gPSB1c2VTZW5kU3RhdHVzQnlBY3Rpdml0eUtleSgpO1xuICBjb25zdCBnZXRBY3Rpdml0eUJ5S2V5ID0gdXNlR2V0QWN0aXZpdHlCeUtleSgpO1xuICBjb25zdCBsb2NhbGl6ZSA9IHVzZUxvY2FsaXplcigpO1xuICBjb25zdCBxdWV1ZVN0YXRpY0VsZW1lbnQgPSB1c2VRdWV1ZVN0YXRpY0VsZW1lbnQoKTtcblxuICAvKipcbiAgICogTGlzdCBvZiBrZXlzIG9mIG91dGdvaW5nIGFuZCBub24tcHJlc2VudGF0aW9uYWwgYWN0aXZpdGllcyB0aGF0IGFyZSBmYWlsZWQgdG8gc2VuZC5cbiAgICpcbiAgICogQWN0aXZpdGllcyB3aGljaCBhcmUgcHJlc2VudGF0aW9uYWwsIHN1Y2ggYXMgYGV2ZW50YCBvciBgdHlwaW5nYCwgYXJlIGlnbm9yZWQgdG8gcmVkdWNlIGNvbmZ1c2lvbnMuXG4gICAqIFwiRmFpbGVkIHRvIHNlbmQgbWVzc2FnZVwiIHNob3VsZCBub3QgYmUgbmFycmF0ZWQgZm9yIHByZXNlbnRhdGlvbmFsIGFjdGl2aXRpZXMuXG4gICAqL1xuICBjb25zdCBhY3Rpdml0eUtleXNPZlNlbmRGYWlsZWQgPSB1c2VNZW1vPFNldDxzdHJpbmc+PihcbiAgICAoKSA9PlxuICAgICAgQXJyYXkuZnJvbShzZW5kU3RhdHVzQnlBY3Rpdml0eUtleSkucmVkdWNlKFxuICAgICAgICAoYWN0aXZpdHlLZXlzT2ZTZW5kRmFpbGVkLCBba2V5LCBzZW5kU3RhdHVzXSkgPT5cbiAgICAgICAgICBzZW5kU3RhdHVzID09PSBTRU5EX0ZBSUxFRCAmJiAhaXNQcmVzZW50YXRpb25hbChnZXRBY3Rpdml0eUJ5S2V5KGtleSkpXG4gICAgICAgICAgICA/IGFjdGl2aXR5S2V5c09mU2VuZEZhaWxlZC5hZGQoa2V5KVxuICAgICAgICAgICAgOiBhY3Rpdml0eUtleXNPZlNlbmRGYWlsZWQsXG4gICAgICAgIG5ldyBTZXQ8c3RyaW5nPigpXG4gICAgICApLFxuICAgIFtnZXRBY3Rpdml0eUJ5S2V5LCBzZW5kU3RhdHVzQnlBY3Rpdml0eUtleV1cbiAgKTtcblxuICAvKiogUmV0dXJucyBsb2NhbGl6ZWQgXCJGYWlsZWQgdG8gc2VuZCBtZXNzYWdlLlwiICovXG4gIGNvbnN0IGxpdmVSZWdpb25TZW5kRmFpbGVkQWx0ID0gbG9jYWxpemUoJ1RSQU5TQ1JJUFRfTElWRV9SRUdJT05fU0VORF9GQUlMRURfQUxUJyk7XG5cbiAgY29uc3QgcHJldkFjdGl2aXR5S2V5c09mU2VuZEZhaWxlZCA9IHVzZVByZXZpb3VzKGFjdGl2aXR5S2V5c09mU2VuZEZhaWxlZCk7XG5cbiAgLyoqIFRydWUsIGlmIG9uZSBvciBtb3JlIG5vbi1wcmVzZW50YXRpb25hbCBhY3Rpdml0aWVzIHN0YXJ0IGFwcGVhcnMgYXMgXCJzZW5kIGZhaWxlZFwiLCBvdGhlcndpc2UsIGZhbHNlLiAqL1xuICBjb25zdCBoYXNOZXdTZW5kRmFpbGVkID0gdXNlTWVtbzxib29sZWFuPigoKSA9PiB7XG4gICAgaWYgKGFjdGl2aXR5S2V5c09mU2VuZEZhaWxlZCA9PT0gcHJldkFjdGl2aXR5S2V5c09mU2VuZEZhaWxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGFjdGl2aXR5S2V5c09mU2VuZEZhaWxlZC5rZXlzKCkpIHtcbiAgICAgIGlmICghcHJldkFjdGl2aXR5S2V5c09mU2VuZEZhaWxlZC5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIFthY3Rpdml0eUtleXNPZlNlbmRGYWlsZWQsIHByZXZBY3Rpdml0eUtleXNPZlNlbmRGYWlsZWRdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGhhc05ld1NlbmRGYWlsZWQgJiYgcXVldWVTdGF0aWNFbGVtZW50KGxpdmVSZWdpb25TZW5kRmFpbGVkQWx0KTtcbiAgfSwgW2hhc05ld1NlbmRGYWlsZWQsIGxpdmVSZWdpb25TZW5kRmFpbGVkQWx0LCBxdWV1ZVN0YXRpY0VsZW1lbnRdKTtcblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExpdmVSZWdpb25TZW5kRmFpbGVkO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQVFBLG1CQUFSLEdBQTBFQyw2QkFBMUUsQ0FBUUQsbUJBQVI7QUFBQSxJQUE2QkUsWUFBN0IsR0FBMEVELDZCQUExRSxDQUE2QkMsWUFBN0I7QUFBQSxJQUEyQ0MsMEJBQTNDLEdBQTBFRiw2QkFBMUUsQ0FBMkNFLDBCQUEzQztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLElBQU1DLG9CQUE2QixHQUFHLFNBQWhDQSxvQkFBZ0MsR0FBTTtFQUMxQyw0QkFBa0NELDBCQUEwQixFQUE1RDtFQUFBO0VBQUEsSUFBT0UsdUJBQVA7O0VBQ0EsSUFBTUMsZ0JBQWdCLEdBQUdOLG1CQUFtQixFQUE1QztFQUNBLElBQU1PLFFBQVEsR0FBR0wsWUFBWSxFQUE3QjtFQUNBLElBQU1NLGtCQUFrQixHQUFHLElBQUFDLDhCQUFBLEdBQTNCO0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztFQUNFLElBQU1DLHdCQUF3QixHQUFHLElBQUFDLGNBQUEsRUFDL0I7SUFBQSxPQUNFQyxLQUFLLENBQUNDLElBQU4sQ0FBV1IsdUJBQVgsRUFBb0NTLE1BQXBDLENBQ0UsVUFBQ0osd0JBQUQ7TUFBQTtNQUFBLElBQTRCSyxHQUE1QjtNQUFBLElBQWlDQyxVQUFqQzs7TUFBQSxPQUNFQSxVQUFVLEtBQUtDLHVCQUFmLElBQThCLENBQUMsSUFBQUMseUJBQUEsRUFBaUJaLGdCQUFnQixDQUFDUyxHQUFELENBQWpDLENBQS9CLEdBQ0lMLHdCQUF3QixDQUFDUyxHQUF6QixDQUE2QkosR0FBN0IsQ0FESixHQUVJTCx3QkFITjtJQUFBLENBREYsRUFLRSxJQUFJVSxHQUFKLEVBTEYsQ0FERjtFQUFBLENBRCtCLEVBUy9CLENBQUNkLGdCQUFELEVBQW1CRCx1QkFBbkIsQ0FUK0IsQ0FBakM7RUFZQTs7RUFDQSxJQUFNZ0IsdUJBQXVCLEdBQUdkLFFBQVEsQ0FBQyx3Q0FBRCxDQUF4QztFQUVBLElBQU1lLDRCQUE0QixHQUFHLElBQUFDLG9CQUFBLEVBQVliLHdCQUFaLENBQXJDO0VBRUE7O0VBQ0EsSUFBTWMsZ0JBQWdCLEdBQUcsSUFBQWIsY0FBQSxFQUFpQixZQUFNO0lBQzlDLElBQUlELHdCQUF3QixLQUFLWSw0QkFBakMsRUFBK0Q7TUFDN0QsT0FBTyxLQUFQO0lBQ0Q7O0lBSDZDLDJDQUs1Qlosd0JBQXdCLENBQUNlLElBQXpCLEVBTDRCO0lBQUE7O0lBQUE7TUFLOUMsb0RBQW1EO1FBQUEsSUFBeENWLEdBQXdDOztRQUNqRCxJQUFJLENBQUNPLDRCQUE0QixDQUFDSSxHQUE3QixDQUFpQ1gsR0FBakMsQ0FBTCxFQUE0QztVQUMxQyxPQUFPLElBQVA7UUFDRDtNQUNGO0lBVDZDO01BQUE7SUFBQTtNQUFBO0lBQUE7O0lBVzlDLE9BQU8sS0FBUDtFQUNELENBWndCLEVBWXRCLENBQUNMLHdCQUFELEVBQTJCWSw0QkFBM0IsQ0Fac0IsQ0FBekI7RUFjQSxJQUFBSyxnQkFBQSxFQUFVLFlBQU07SUFDZEgsZ0JBQWdCLElBQUloQixrQkFBa0IsQ0FBQ2EsdUJBQUQsQ0FBdEM7RUFDRCxDQUZELEVBRUcsQ0FBQ0csZ0JBQUQsRUFBbUJILHVCQUFuQixFQUE0Q2Isa0JBQTVDLENBRkg7RUFJQSxPQUFPLElBQVA7QUFDRCxDQWpERDs7ZUFtRGVKLG9CIn0=