"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _botframeworkWebchatApi = require("botframework-webchat-api");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _mathRandom = _interopRequireDefault(require("math-random"));

var _react = _interopRequireWildcard(require("react"));

var _scrollIntoViewWithBlockNearest = _interopRequireDefault(require("../../Utils/scrollIntoViewWithBlockNearest"));

var _Context = _interopRequireDefault(require("./private/Context"));

var _useActivityTreeWithRenderer = _interopRequireDefault(require("../ActivityTree/useActivityTreeWithRenderer"));

var _usePrevious = _interopRequireDefault(require("../../hooks/internal/usePrevious"));

var _useStateRef3 = _interopRequireDefault(require("../../hooks/internal/useStateRef"));

var _useValueRef = _interopRequireDefault(require("../../hooks/internal/useValueRef"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useGetKeyByActivity = _botframeworkWebchatApi.hooks.useGetKeyByActivity;

function last(array) {
  return array[array.length - 1];
}

function uniqueId() {
  var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;
  return (0, _mathRandom.default)() // eslint-disable-next-line no-magic-numbers
  .toString(36) // eslint-disable-next-line no-magic-numbers
  .substring(2, 2 + count);
}

var TranscriptFocusComposer = function TranscriptFocusComposer(_ref) {
  var _containerRef$current;

  var children = _ref.children,
      containerRef = _ref.containerRef;

  var _useActivityTreeWithR = (0, _useActivityTreeWithRenderer.default)({
    flat: true
  }),
      _useActivityTreeWithR2 = _slicedToArray(_useActivityTreeWithR, 1),
      flattenedActivityTree = _useActivityTreeWithR2[0];

  var _useStateRef = (0, _useStateRef3.default)(),
      _useStateRef2 = _slicedToArray(_useStateRef, 3),
      _ = _useStateRef2[0],
      setRawFocusedActivityKey = _useStateRef2[1],
      rawFocusedActivityKeyRef = _useStateRef2[2];

  var getKeyByActivity = useGetKeyByActivity(); // As we need to use IDREF for `aria-activedescendant`,
  // this prefix will differentiate multiple instances of transcript on the same page.
  // eslint-disable-next-line no-magic-numbers

  var prefix = (0, _react.useMemo)(function () {
    return uniqueId(3);
  }, []);
  var getDescendantIdByActivityKey = (0, _react.useCallback)(function (activityKey) {
    return activityKey && "webchat__transcript-focus-".concat(prefix, "__activity-").concat(activityKey);
  }, [prefix]);
  var renderingActivityKeys = (0, _react.useMemo)(function () {
    return Object.freeze(flattenedActivityTree.map(function (_ref2) {
      var activity = _ref2.activity;
      return getKeyByActivity(activity);
    }));
  }, [flattenedActivityTree, getKeyByActivity]);
  var renderingActivityKeysRef = (0, _useValueRef.default)(renderingActivityKeys); // While the transcript or any descendants are not focused, if the transcript is updated, reset the user-selected active descendant.
  // This will assume the last activity, if any, will be the active descendant.

  var prevRenderingActivityKeys = (0, _usePrevious.default)(renderingActivityKeys);

  if (renderingActivityKeys !== prevRenderingActivityKeys && !((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(document.activeElement))) {
    rawFocusedActivityKeyRef.current = undefined;
  }

  var rawFocusedActivityKey = rawFocusedActivityKeyRef.current;
  var focusedActivityKey = (0, _react.useMemo)(function () {
    return renderingActivityKeys.includes(rawFocusedActivityKey) ? rawFocusedActivityKey : last(renderingActivityKeys);
  }, [renderingActivityKeys, rawFocusedActivityKey]);
  var focusedActivityKeyRef = (0, _useValueRef.default)(focusedActivityKey);
  var activeDescendantId = (0, _react.useMemo)(function () {
    return getDescendantIdByActivityKey(focusedActivityKey);
  }, [getDescendantIdByActivityKey, focusedActivityKey]);
  var focusByActivityKey = (0, _react.useCallback)(function (activityKey) {
    var withFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (activityKey === false) {
      // `false` means set it to nothing.
      setRawFocusedActivityKey(undefined);
    } else if (activityKey === true) {
      // `true` means set to something if it is not set.
      setRawFocusedActivityKey(function (key) {
        return key || focusedActivityKeyRef.current;
      });
    } else if (activityKey) {
      setRawFocusedActivityKey(activityKey);
    }

    if (withFocus) {
      var _containerRef$current2;

      (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.focus();

      var _activeDescendantId = getDescendantIdByActivityKey(activityKey === false ? // If "activityKey" is false, it means "focus nothing and reset it to the last activity".
      last(renderingActivityKeysRef.current) : activityKey && activityKey !== true ? // If "activity" is not "undefined" and not "true", it means "focus on this activity".
      activityKey : // If "activityKey" is "undefined", it means "don't modify the focus".
      // If "activityKey" is "true", it means "try to focus on anything".
      rawFocusedActivityKeyRef.current);

      var activeDescendantElement = _activeDescendantId && document.getElementById(_activeDescendantId); // Don't scroll active descendant into view if the focus is already inside it.
      // Otherwise, given the focus is on the send box, clicking on any <input> inside the Adaptive Cards may cause the view to move.
      // This UX is not desirable because click should not cause scroll.


      if (activeDescendantElement && !activeDescendantElement.contains(document.activeElement)) {
        (0, _scrollIntoViewWithBlockNearest.default)(activeDescendantElement);
      }
    }
  }, [getDescendantIdByActivityKey, containerRef, focusedActivityKeyRef, renderingActivityKeysRef, rawFocusedActivityKeyRef, setRawFocusedActivityKey]);
  var focusRelativeActivity = (0, _react.useCallback)(function (delta) {
    var orderedActivityKeys = renderingActivityKeysRef.current;

    if (isNaN(delta) || !orderedActivityKeys.length) {
      return focusByActivityKey(false, true);
    }

    var focusedActivityKey = focusedActivityKeyRef.current;
    var index = orderedActivityKeys.indexOf(focusedActivityKey);
    var nextIndex = ~index ? Math.max(0, Math.min(orderedActivityKeys.length - 1, index + delta)) : orderedActivityKeys.length - 1;
    focusByActivityKey(orderedActivityKeys[+nextIndex], true);
  }, [focusedActivityKeyRef, renderingActivityKeysRef, focusByActivityKey]);
  var contextValue = (0, _react.useMemo)(function () {
    return {
      activeDescendantIdState: Object.freeze([activeDescendantId]),
      getDescendantIdByActivityKey: getDescendantIdByActivityKey,
      focusByActivityKey: focusByActivityKey,
      focusedActivityKeyState: Object.freeze([focusedActivityKey]),
      focusedExplicitlyState: Object.freeze([!!rawFocusedActivityKey]),
      focusRelativeActivity: focusRelativeActivity
    };
  }, [activeDescendantId, getDescendantIdByActivityKey, focusByActivityKey, focusedActivityKey, focusRelativeActivity, rawFocusedActivityKey]);
  return /*#__PURE__*/_react.default.createElement(_Context.default.Provider, {
    value: contextValue
  }, children);
};

TranscriptFocusComposer.propTypes = {
  // PropTypes is not fully compatible with TypeScript.
  // @ts-ignore
  containerRef: _propTypes.default.shape({
    current: _propTypes.default.instanceOf(HTMLElement)
  }).isRequired
};
var _default = TranscriptFocusComposer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1c2VHZXRLZXlCeUFjdGl2aXR5IiwiaG9va3MiLCJsYXN0IiwiYXJyYXkiLCJsZW5ndGgiLCJ1bmlxdWVJZCIsImNvdW50IiwiSW5maW5pdHkiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsIlRyYW5zY3JpcHRGb2N1c0NvbXBvc2VyIiwiY2hpbGRyZW4iLCJjb250YWluZXJSZWYiLCJ1c2VBY3Rpdml0eVRyZWVXaXRoUmVuZGVyZXIiLCJmbGF0IiwiZmxhdHRlbmVkQWN0aXZpdHlUcmVlIiwidXNlU3RhdGVSZWYiLCJfIiwic2V0UmF3Rm9jdXNlZEFjdGl2aXR5S2V5IiwicmF3Rm9jdXNlZEFjdGl2aXR5S2V5UmVmIiwiZ2V0S2V5QnlBY3Rpdml0eSIsInByZWZpeCIsInVzZU1lbW8iLCJnZXREZXNjZW5kYW50SWRCeUFjdGl2aXR5S2V5IiwidXNlQ2FsbGJhY2siLCJhY3Rpdml0eUtleSIsInJlbmRlcmluZ0FjdGl2aXR5S2V5cyIsIk9iamVjdCIsImZyZWV6ZSIsIm1hcCIsImFjdGl2aXR5IiwicmVuZGVyaW5nQWN0aXZpdHlLZXlzUmVmIiwidXNlVmFsdWVSZWYiLCJwcmV2UmVuZGVyaW5nQWN0aXZpdHlLZXlzIiwidXNlUHJldmlvdXMiLCJjdXJyZW50IiwiY29udGFpbnMiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJ1bmRlZmluZWQiLCJyYXdGb2N1c2VkQWN0aXZpdHlLZXkiLCJmb2N1c2VkQWN0aXZpdHlLZXkiLCJpbmNsdWRlcyIsImZvY3VzZWRBY3Rpdml0eUtleVJlZiIsImFjdGl2ZURlc2NlbmRhbnRJZCIsImZvY3VzQnlBY3Rpdml0eUtleSIsIndpdGhGb2N1cyIsImtleSIsImZvY3VzIiwiYWN0aXZlRGVzY2VuZGFudEVsZW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3V2l0aEJsb2NrTmVhcmVzdCIsImZvY3VzUmVsYXRpdmVBY3Rpdml0eSIsImRlbHRhIiwib3JkZXJlZEFjdGl2aXR5S2V5cyIsImlzTmFOIiwiaW5kZXgiLCJpbmRleE9mIiwibmV4dEluZGV4IiwiTWF0aCIsIm1heCIsIm1pbiIsImNvbnRleHRWYWx1ZSIsImFjdGl2ZURlc2NlbmRhbnRJZFN0YXRlIiwiZm9jdXNlZEFjdGl2aXR5S2V5U3RhdGUiLCJmb2N1c2VkRXhwbGljaXRseVN0YXRlIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwic2hhcGUiLCJpbnN0YW5jZU9mIiwiSFRNTEVsZW1lbnQiLCJpc1JlcXVpcmVkIl0sInNvdXJjZVJvb3QiOiJjb21wb25lbnQ6Ly8vIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcHJvdmlkZXJzL1RyYW5zY3JpcHRGb2N1cy9UcmFuc2NyaXB0Rm9jdXNDb21wb3Nlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaG9va3MgfSBmcm9tICdib3RmcmFtZXdvcmstd2ViY2hhdC1hcGknO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCByYW5kb20gZnJvbSAnbWF0aC1yYW5kb20nO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgc2Nyb2xsSW50b1ZpZXdXaXRoQmxvY2tOZWFyZXN0IGZyb20gJy4uLy4uL1V0aWxzL3Njcm9sbEludG9WaWV3V2l0aEJsb2NrTmVhcmVzdCc7XG5pbXBvcnQgVHJhbnNjcmlwdEZvY3VzQ29udGV4dCBmcm9tICcuL3ByaXZhdGUvQ29udGV4dCc7XG5pbXBvcnQgdXNlQWN0aXZpdHlUcmVlV2l0aFJlbmRlcmVyIGZyb20gJy4uL0FjdGl2aXR5VHJlZS91c2VBY3Rpdml0eVRyZWVXaXRoUmVuZGVyZXInO1xuaW1wb3J0IHVzZVByZXZpb3VzIGZyb20gJy4uLy4uL2hvb2tzL2ludGVybmFsL3VzZVByZXZpb3VzJztcbmltcG9ydCB1c2VTdGF0ZVJlZiBmcm9tICcuLi8uLi9ob29rcy9pbnRlcm5hbC91c2VTdGF0ZVJlZic7XG5pbXBvcnQgdXNlVmFsdWVSZWYgZnJvbSAnLi4vLi4vaG9va3MvaW50ZXJuYWwvdXNlVmFsdWVSZWYnO1xuXG5pbXBvcnQgdHlwZSB7IEZDLCBNdXRhYmxlUmVmT2JqZWN0LCBQcm9wc1dpdGhDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgVHJhbnNjcmlwdEZvY3VzQ29udGV4dFR5cGUgfSBmcm9tICcuL3ByaXZhdGUvQ29udGV4dCc7XG5cbmNvbnN0IHsgdXNlR2V0S2V5QnlBY3Rpdml0eSB9ID0gaG9va3M7XG5cbnR5cGUgVHJhbnNjcmlwdEZvY3VzQ29tcG9zZXJQcm9wcyA9IFByb3BzV2l0aENoaWxkcmVuPHtcbiAgY29udGFpbmVyUmVmOiBNdXRhYmxlUmVmT2JqZWN0PEhUTUxFbGVtZW50Pjtcbn0+O1xuXG5mdW5jdGlvbiBsYXN0PFQ+KGFycmF5OiBBcnJheUxpa2U8VD4pIHtcbiAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xufVxuXG5mdW5jdGlvbiB1bmlxdWVJZChjb3VudCA9IEluZmluaXR5KSB7XG4gIHJldHVybiAoXG4gICAgcmFuZG9tKClcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgICAudG9TdHJpbmcoMzYpXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgLnN1YnN0cmluZygyLCAyICsgY291bnQpXG4gICk7XG59XG5cbmNvbnN0IFRyYW5zY3JpcHRGb2N1c0NvbXBvc2VyOiBGQzxUcmFuc2NyaXB0Rm9jdXNDb21wb3NlclByb3BzPiA9ICh7IGNoaWxkcmVuLCBjb250YWluZXJSZWYgfSkgPT4ge1xuICBjb25zdCBbZmxhdHRlbmVkQWN0aXZpdHlUcmVlXSA9IHVzZUFjdGl2aXR5VHJlZVdpdGhSZW5kZXJlcih7IGZsYXQ6IHRydWUgfSk7XG4gIGNvbnN0IFtfLCBzZXRSYXdGb2N1c2VkQWN0aXZpdHlLZXksIHJhd0ZvY3VzZWRBY3Rpdml0eUtleVJlZl0gPSB1c2VTdGF0ZVJlZjxzdHJpbmcgfCB1bmRlZmluZWQ+KCk7XG4gIGNvbnN0IGdldEtleUJ5QWN0aXZpdHkgPSB1c2VHZXRLZXlCeUFjdGl2aXR5KCk7XG5cbiAgLy8gQXMgd2UgbmVlZCB0byB1c2UgSURSRUYgZm9yIGBhcmlhLWFjdGl2ZWRlc2NlbmRhbnRgLFxuICAvLyB0aGlzIHByZWZpeCB3aWxsIGRpZmZlcmVudGlhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHRyYW5zY3JpcHQgb24gdGhlIHNhbWUgcGFnZS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgY29uc3QgcHJlZml4ID0gdXNlTWVtbzxzdHJpbmc+KCgpID0+IHVuaXF1ZUlkKDMpLCBbXSk7XG5cbiAgY29uc3QgZ2V0RGVzY2VuZGFudElkQnlBY3Rpdml0eUtleTogKGFjdGl2aXR5S2V5Pzogc3RyaW5nKSA9PiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1c2VDYWxsYmFjayhcbiAgICAoYWN0aXZpdHlLZXk/OiBzdHJpbmcpID0+IGFjdGl2aXR5S2V5ICYmIGB3ZWJjaGF0X190cmFuc2NyaXB0LWZvY3VzLSR7cHJlZml4fV9fYWN0aXZpdHktJHthY3Rpdml0eUtleX1gLFxuICAgIFtwcmVmaXhdXG4gICk7XG5cbiAgY29uc3QgcmVuZGVyaW5nQWN0aXZpdHlLZXlzID0gdXNlTWVtbzxyZWFkb25seSBzdHJpbmdbXT4oXG4gICAgKCkgPT4gT2JqZWN0LmZyZWV6ZShmbGF0dGVuZWRBY3Rpdml0eVRyZWUubWFwKCh7IGFjdGl2aXR5IH0pID0+IGdldEtleUJ5QWN0aXZpdHkoYWN0aXZpdHkpKSksXG4gICAgW2ZsYXR0ZW5lZEFjdGl2aXR5VHJlZSwgZ2V0S2V5QnlBY3Rpdml0eV1cbiAgKTtcblxuICBjb25zdCByZW5kZXJpbmdBY3Rpdml0eUtleXNSZWYgPSB1c2VWYWx1ZVJlZjxyZWFkb25seSBzdHJpbmdbXT4ocmVuZGVyaW5nQWN0aXZpdHlLZXlzKTtcblxuICAvLyBXaGlsZSB0aGUgdHJhbnNjcmlwdCBvciBhbnkgZGVzY2VuZGFudHMgYXJlIG5vdCBmb2N1c2VkLCBpZiB0aGUgdHJhbnNjcmlwdCBpcyB1cGRhdGVkLCByZXNldCB0aGUgdXNlci1zZWxlY3RlZCBhY3RpdmUgZGVzY2VuZGFudC5cbiAgLy8gVGhpcyB3aWxsIGFzc3VtZSB0aGUgbGFzdCBhY3Rpdml0eSwgaWYgYW55LCB3aWxsIGJlIHRoZSBhY3RpdmUgZGVzY2VuZGFudC5cbiAgY29uc3QgcHJldlJlbmRlcmluZ0FjdGl2aXR5S2V5cyA9IHVzZVByZXZpb3VzKHJlbmRlcmluZ0FjdGl2aXR5S2V5cyk7XG5cbiAgaWYgKHJlbmRlcmluZ0FjdGl2aXR5S2V5cyAhPT0gcHJldlJlbmRlcmluZ0FjdGl2aXR5S2V5cyAmJiAhY29udGFpbmVyUmVmLmN1cnJlbnQ/LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgcmF3Rm9jdXNlZEFjdGl2aXR5S2V5UmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCB7IGN1cnJlbnQ6IHJhd0ZvY3VzZWRBY3Rpdml0eUtleSB9ID0gcmF3Rm9jdXNlZEFjdGl2aXR5S2V5UmVmO1xuXG4gIGNvbnN0IGZvY3VzZWRBY3Rpdml0eUtleSA9IHVzZU1lbW88c3RyaW5nPihcbiAgICAoKSA9PiAocmVuZGVyaW5nQWN0aXZpdHlLZXlzLmluY2x1ZGVzKHJhd0ZvY3VzZWRBY3Rpdml0eUtleSkgPyByYXdGb2N1c2VkQWN0aXZpdHlLZXkgOiBsYXN0KHJlbmRlcmluZ0FjdGl2aXR5S2V5cykpLFxuICAgIFtyZW5kZXJpbmdBY3Rpdml0eUtleXMsIHJhd0ZvY3VzZWRBY3Rpdml0eUtleV1cbiAgKTtcblxuICBjb25zdCBmb2N1c2VkQWN0aXZpdHlLZXlSZWYgPSB1c2VWYWx1ZVJlZihmb2N1c2VkQWN0aXZpdHlLZXkpO1xuXG4gIGNvbnN0IGFjdGl2ZURlc2NlbmRhbnRJZCA9IHVzZU1lbW88c3RyaW5nPihcbiAgICAoKSA9PiBnZXREZXNjZW5kYW50SWRCeUFjdGl2aXR5S2V5KGZvY3VzZWRBY3Rpdml0eUtleSksXG4gICAgW2dldERlc2NlbmRhbnRJZEJ5QWN0aXZpdHlLZXksIGZvY3VzZWRBY3Rpdml0eUtleV1cbiAgKTtcblxuICBjb25zdCBmb2N1c0J5QWN0aXZpdHlLZXkgPSB1c2VDYWxsYmFjazxcbiAgICAoYWN0aXZpdHlLZXk6IGJvb2xlYW4gfCBzdHJpbmcgfCB1bmRlZmluZWQsIHdpdGhGb2N1czogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4gdm9pZFxuICA+KFxuICAgIChhY3Rpdml0eUtleTogYm9vbGVhbiB8IHN0cmluZyB8IHVuZGVmaW5lZCwgd2l0aEZvY3VzOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdHJ1ZSkgPT4ge1xuICAgICAgaWYgKGFjdGl2aXR5S2V5ID09PSBmYWxzZSkge1xuICAgICAgICAvLyBgZmFsc2VgIG1lYW5zIHNldCBpdCB0byBub3RoaW5nLlxuICAgICAgICBzZXRSYXdGb2N1c2VkQWN0aXZpdHlLZXkodW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0aXZpdHlLZXkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gYHRydWVgIG1lYW5zIHNldCB0byBzb21ldGhpbmcgaWYgaXQgaXMgbm90IHNldC5cbiAgICAgICAgc2V0UmF3Rm9jdXNlZEFjdGl2aXR5S2V5KGtleSA9PiBrZXkgfHwgZm9jdXNlZEFjdGl2aXR5S2V5UmVmLmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpdml0eUtleSkge1xuICAgICAgICBzZXRSYXdGb2N1c2VkQWN0aXZpdHlLZXkoYWN0aXZpdHlLZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAod2l0aEZvY3VzKSB7XG4gICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50Py5mb2N1cygpO1xuXG4gICAgICAgIGNvbnN0IGFjdGl2ZURlc2NlbmRhbnRJZCA9IGdldERlc2NlbmRhbnRJZEJ5QWN0aXZpdHlLZXkoXG4gICAgICAgICAgYWN0aXZpdHlLZXkgPT09IGZhbHNlXG4gICAgICAgICAgICA/IC8vIElmIFwiYWN0aXZpdHlLZXlcIiBpcyBmYWxzZSwgaXQgbWVhbnMgXCJmb2N1cyBub3RoaW5nIGFuZCByZXNldCBpdCB0byB0aGUgbGFzdCBhY3Rpdml0eVwiLlxuICAgICAgICAgICAgICBsYXN0KHJlbmRlcmluZ0FjdGl2aXR5S2V5c1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgOiBhY3Rpdml0eUtleSAmJiBhY3Rpdml0eUtleSAhPT0gdHJ1ZVxuICAgICAgICAgICAgPyAvLyBJZiBcImFjdGl2aXR5XCIgaXMgbm90IFwidW5kZWZpbmVkXCIgYW5kIG5vdCBcInRydWVcIiwgaXQgbWVhbnMgXCJmb2N1cyBvbiB0aGlzIGFjdGl2aXR5XCIuXG4gICAgICAgICAgICAgIGFjdGl2aXR5S2V5XG4gICAgICAgICAgICA6IC8vIElmIFwiYWN0aXZpdHlLZXlcIiBpcyBcInVuZGVmaW5lZFwiLCBpdCBtZWFucyBcImRvbid0IG1vZGlmeSB0aGUgZm9jdXNcIi5cbiAgICAgICAgICAgICAgLy8gSWYgXCJhY3Rpdml0eUtleVwiIGlzIFwidHJ1ZVwiLCBpdCBtZWFucyBcInRyeSB0byBmb2N1cyBvbiBhbnl0aGluZ1wiLlxuICAgICAgICAgICAgICByYXdGb2N1c2VkQWN0aXZpdHlLZXlSZWYuY3VycmVudFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGFjdGl2ZURlc2NlbmRhbnRFbGVtZW50ID0gYWN0aXZlRGVzY2VuZGFudElkICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFjdGl2ZURlc2NlbmRhbnRJZCk7XG5cbiAgICAgICAgLy8gRG9uJ3Qgc2Nyb2xsIGFjdGl2ZSBkZXNjZW5kYW50IGludG8gdmlldyBpZiB0aGUgZm9jdXMgaXMgYWxyZWFkeSBpbnNpZGUgaXQuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZ2l2ZW4gdGhlIGZvY3VzIGlzIG9uIHRoZSBzZW5kIGJveCwgY2xpY2tpbmcgb24gYW55IDxpbnB1dD4gaW5zaWRlIHRoZSBBZGFwdGl2ZSBDYXJkcyBtYXkgY2F1c2UgdGhlIHZpZXcgdG8gbW92ZS5cbiAgICAgICAgLy8gVGhpcyBVWCBpcyBub3QgZGVzaXJhYmxlIGJlY2F1c2UgY2xpY2sgc2hvdWxkIG5vdCBjYXVzZSBzY3JvbGwuXG4gICAgICAgIGlmIChhY3RpdmVEZXNjZW5kYW50RWxlbWVudCAmJiAhYWN0aXZlRGVzY2VuZGFudEVsZW1lbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBzY3JvbGxJbnRvVmlld1dpdGhCbG9ja05lYXJlc3QoYWN0aXZlRGVzY2VuZGFudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBnZXREZXNjZW5kYW50SWRCeUFjdGl2aXR5S2V5LFxuICAgICAgY29udGFpbmVyUmVmLFxuICAgICAgZm9jdXNlZEFjdGl2aXR5S2V5UmVmLFxuICAgICAgcmVuZGVyaW5nQWN0aXZpdHlLZXlzUmVmLFxuICAgICAgcmF3Rm9jdXNlZEFjdGl2aXR5S2V5UmVmLFxuICAgICAgc2V0UmF3Rm9jdXNlZEFjdGl2aXR5S2V5XG4gICAgXVxuICApO1xuXG4gIGNvbnN0IGZvY3VzUmVsYXRpdmVBY3Rpdml0eSA9IHVzZUNhbGxiYWNrKFxuICAgIChkZWx0YTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCB7IGN1cnJlbnQ6IG9yZGVyZWRBY3Rpdml0eUtleXMgfSA9IHJlbmRlcmluZ0FjdGl2aXR5S2V5c1JlZjtcblxuICAgICAgaWYgKGlzTmFOKGRlbHRhKSB8fCAhb3JkZXJlZEFjdGl2aXR5S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZvY3VzQnlBY3Rpdml0eUtleShmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgY3VycmVudDogZm9jdXNlZEFjdGl2aXR5S2V5IH0gPSBmb2N1c2VkQWN0aXZpdHlLZXlSZWY7XG5cbiAgICAgIGNvbnN0IGluZGV4ID0gb3JkZXJlZEFjdGl2aXR5S2V5cy5pbmRleE9mKGZvY3VzZWRBY3Rpdml0eUtleSk7XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSB+aW5kZXhcbiAgICAgICAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbihvcmRlcmVkQWN0aXZpdHlLZXlzLmxlbmd0aCAtIDEsIGluZGV4ICsgZGVsdGEpKVxuICAgICAgICA6IG9yZGVyZWRBY3Rpdml0eUtleXMubGVuZ3RoIC0gMTtcblxuICAgICAgZm9jdXNCeUFjdGl2aXR5S2V5KG9yZGVyZWRBY3Rpdml0eUtleXNbK25leHRJbmRleF0sIHRydWUpO1xuICAgIH0sXG4gICAgW2ZvY3VzZWRBY3Rpdml0eUtleVJlZiwgcmVuZGVyaW5nQWN0aXZpdHlLZXlzUmVmLCBmb2N1c0J5QWN0aXZpdHlLZXldXG4gICk7XG5cbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbzxUcmFuc2NyaXB0Rm9jdXNDb250ZXh0VHlwZT4oXG4gICAgKCkgPT4gKHtcbiAgICAgIGFjdGl2ZURlc2NlbmRhbnRJZFN0YXRlOiBPYmplY3QuZnJlZXplKFthY3RpdmVEZXNjZW5kYW50SWRdKSBhcyByZWFkb25seSBbc3RyaW5nXSxcbiAgICAgIGdldERlc2NlbmRhbnRJZEJ5QWN0aXZpdHlLZXksXG4gICAgICBmb2N1c0J5QWN0aXZpdHlLZXksXG4gICAgICBmb2N1c2VkQWN0aXZpdHlLZXlTdGF0ZTogT2JqZWN0LmZyZWV6ZShbZm9jdXNlZEFjdGl2aXR5S2V5XSkgYXMgcmVhZG9ubHkgW3N0cmluZ10sXG4gICAgICBmb2N1c2VkRXhwbGljaXRseVN0YXRlOiBPYmplY3QuZnJlZXplKFshIXJhd0ZvY3VzZWRBY3Rpdml0eUtleV0pIGFzIHJlYWRvbmx5IFtib29sZWFuXSxcbiAgICAgIGZvY3VzUmVsYXRpdmVBY3Rpdml0eVxuICAgIH0pLFxuICAgIFtcbiAgICAgIGFjdGl2ZURlc2NlbmRhbnRJZCxcbiAgICAgIGdldERlc2NlbmRhbnRJZEJ5QWN0aXZpdHlLZXksXG4gICAgICBmb2N1c0J5QWN0aXZpdHlLZXksXG4gICAgICBmb2N1c2VkQWN0aXZpdHlLZXksXG4gICAgICBmb2N1c1JlbGF0aXZlQWN0aXZpdHksXG4gICAgICByYXdGb2N1c2VkQWN0aXZpdHlLZXlcbiAgICBdXG4gICk7XG5cbiAgcmV0dXJuIDxUcmFuc2NyaXB0Rm9jdXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VmFsdWV9PntjaGlsZHJlbn08L1RyYW5zY3JpcHRGb2N1c0NvbnRleHQuUHJvdmlkZXI+O1xufTtcblxuVHJhbnNjcmlwdEZvY3VzQ29tcG9zZXIucHJvcFR5cGVzID0ge1xuICAvLyBQcm9wVHlwZXMgaXMgbm90IGZ1bGx5IGNvbXBhdGlibGUgd2l0aCBUeXBlU2NyaXB0LlxuICAvLyBAdHMtaWdub3JlXG4gIGNvbnRhaW5lclJlZjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjdXJyZW50OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihIVE1MRWxlbWVudClcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNjcmlwdEZvY3VzQ29tcG9zZXI7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtBLElBQVFBLG1CQUFSLEdBQWdDQyw2QkFBaEMsQ0FBUUQsbUJBQVI7O0FBTUEsU0FBU0UsSUFBVCxDQUFpQkMsS0FBakIsRUFBc0M7RUFDcEMsT0FBT0EsS0FBSyxDQUFDQSxLQUFLLENBQUNDLE1BQU4sR0FBZSxDQUFoQixDQUFaO0FBQ0Q7O0FBRUQsU0FBU0MsUUFBVCxHQUFvQztFQUFBLElBQWxCQyxLQUFrQix1RUFBVkMsUUFBVTtFQUNsQyxPQUNFLElBQUFDLG1CQUFBLElBQ0U7RUFERixDQUVHQyxRQUZILENBRVksRUFGWixFQUdFO0VBSEYsQ0FJR0MsU0FKSCxDQUlhLENBSmIsRUFJZ0IsSUFBSUosS0FKcEIsQ0FERjtBQU9EOztBQUVELElBQU1LLHVCQUF5RCxHQUFHLFNBQTVEQSx1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