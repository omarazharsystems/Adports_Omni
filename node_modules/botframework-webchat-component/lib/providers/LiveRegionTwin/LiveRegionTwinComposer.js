"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _botframeworkWebchatApi = require("botframework-webchat-api");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _LiveRegionTwinContainer = _interopRequireDefault(require("./private/LiveRegionTwinContainer"));

var _Context = _interopRequireDefault(require("./private/Context"));

var _useValueRef = _interopRequireDefault(require("../../hooks/internal/useValueRef"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var usePonyfill = _botframeworkWebchatApi.hooks.usePonyfill;
var DEFAULT_ARIA_LIVE = 'polite';
var DEFAULT_FADE_AFTER = 1000;

/**
 * Live region twin is an UI component for queueing texts or elements to the screen reader using
 * a container element with `aria-live` attribute set.
 *
 * After the text is rendered and queued, it will be removed to reduce burden on the DOM tree.
 * Currently, we assume the assistive technologies should pick up the text within 1 second of rendering.
 * This value is configurable.
 *
 * By default, the live region is visible. If is is not desirable, the caller can use `className` prop to
 * hide its visuals.
 */
var LiveRegionTwinComposer = function LiveRegionTwinComposer(_ref) {
  var ariaLabel = _ref['aria-label'],
      _ref$ariaLive = _ref['aria-live'],
      ariaLive = _ref$ariaLive === void 0 ? DEFAULT_ARIA_LIVE : _ref$ariaLive,
      ariaRoleDescription = _ref['aria-roledescription'],
      children = _ref.children,
      className = _ref.className,
      _ref$fadeAfter = _ref.fadeAfter,
      fadeAfter = _ref$fadeAfter === void 0 ? DEFAULT_FADE_AFTER : _ref$fadeAfter,
      role = _ref.role,
      textElementClassName = _ref.textElementClassName;

  var _usePonyfill = usePonyfill(),
      _usePonyfill2 = _slicedToArray(_usePonyfill, 1),
      _usePonyfill2$ = _usePonyfill2[0],
      clearTimeout = _usePonyfill2$.clearTimeout,
      setTimeout = _usePonyfill2$.setTimeout;

  var _useState = (0, _react.useState)([]),
      _useState2 = _slicedToArray(_useState, 2),
      staticElementEntries = _useState2[0],
      setStaticElementEntries = _useState2[1];

  var fadeAfterRef = (0, _useValueRef.default)(fadeAfter);
  var markAllAsRenderedTimeoutIdRef = (0, _react.useRef)();
  var nextKeyRef = (0, _react.useRef)(1);
  var staticElementEntriesRef = (0, _useValueRef.default)(staticElementEntries); // This function is called by an effect hook `useMarkAllAsRenderedEffect`, it must be designed with converging in mind.
  // To prevent infinite render loop, after multiple calls to this function, it should eventually no-op.

  var markAllAsRendered = (0, _react.useCallback)(function () {
    if (!staticElementEntriesRef.current.length) {
      // Nothing to remove.
      return;
    } // When removing each element one-by-one based on an individual timeout, Narrator would narrate them twice occasionally.
    // Possibly it think some elements that is not removed during the current cycle, are new elements and queued them twice.
    // Thus, we are removing all at once to prevent bugs in Narrator.


    markAllAsRenderedTimeoutIdRef.current && clearTimeout(markAllAsRenderedTimeoutIdRef.current);
    markAllAsRenderedTimeoutIdRef.current = setTimeout(function () {
      // We are playing safe by using value ref to check its length here.
      // If we are certain that `setStaticElements(emptyArray => emptyArray)` is a no-op,
      // we could replace it with just the setter function.
      staticElementEntriesRef.current.length && setStaticElementEntries([]);
    }, fadeAfterRef.current);
  }, [clearTimeout, fadeAfterRef, markAllAsRenderedTimeoutIdRef, setStaticElementEntries, setTimeout, staticElementEntriesRef]); // When this component is unmounting, make sure all future `setTimeout` are cleared and should not be fired.

  (0, _react.useEffect)(function () {
    return function () {
      return markAllAsRenderedTimeoutIdRef.current && clearTimeout(markAllAsRenderedTimeoutIdRef.current);
    };
  }, [clearTimeout, markAllAsRenderedTimeoutIdRef]);
  var queueStaticElement = (0, _react.useCallback)(function (element) {
    var key = nextKeyRef.current;
    nextKeyRef.current = nextKeyRef.current + 1;
    setStaticElementEntries(function (entries) {
      return [].concat(_toConsumableArray(entries), [{
        element: element,
        key: key
      }]);
    });
  }, [nextKeyRef, setStaticElementEntries]);
  var staticElementEntriesState = (0, _react.useMemo)(function () {
    return Object.freeze([Object.freeze(staticElementEntries)]);
  }, [staticElementEntries]);
  var context = (0, _react.useMemo)(function () {
    return {
      markAllAsRendered: markAllAsRendered,
      queueStaticElement: queueStaticElement,
      staticElementEntriesState: staticElementEntriesState
    };
  }, [markAllAsRendered, queueStaticElement, staticElementEntriesState]);
  return /*#__PURE__*/_react.default.createElement(_Context.default.Provider, {
    value: context
  }, /*#__PURE__*/_react.default.createElement(_LiveRegionTwinContainer.default, {
    "aria-label": ariaLabel,
    "aria-live": ariaLive,
    "aria-roledescription": ariaRoleDescription,
    className: className,
    role: role,
    textElementClassName: textElementClassName
  }), children);
};

LiveRegionTwinComposer.defaultProps = {
  'aria-label': undefined,
  'aria-live': DEFAULT_ARIA_LIVE,
  'aria-roledescription': undefined,
  children: undefined,
  className: undefined,
  fadeAfter: DEFAULT_FADE_AFTER,
  role: undefined,
  textElementClassName: undefined
};
LiveRegionTwinComposer.propTypes = {
  'aria-label': _propTypes.default.string,
  'aria-live': _propTypes.default.oneOf(['assertive', 'polite']),
  'aria-roledescription': _propTypes.default.string,
  children: _propTypes.default.any,
  className: _propTypes.default.string,
  fadeAfter: _propTypes.default.number,
  role: _propTypes.default.string,
  textElementClassName: _propTypes.default.string
};
var _default = LiveRegionTwinComposer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1c2VQb255ZmlsbCIsImhvb2tzIiwiREVGQVVMVF9BUklBX0xJVkUiLCJERUZBVUxUX0ZBREVfQUZURVIiLCJMaXZlUmVnaW9uVHdpbkNvbXBvc2VyIiwiYXJpYUxhYmVsIiwiYXJpYUxpdmUiLCJhcmlhUm9sZURlc2NyaXB0aW9uIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJmYWRlQWZ0ZXIiLCJyb2xlIiwidGV4dEVsZW1lbnRDbGFzc05hbWUiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwidXNlU3RhdGUiLCJzdGF0aWNFbGVtZW50RW50cmllcyIsInNldFN0YXRpY0VsZW1lbnRFbnRyaWVzIiwiZmFkZUFmdGVyUmVmIiwidXNlVmFsdWVSZWYiLCJtYXJrQWxsQXNSZW5kZXJlZFRpbWVvdXRJZFJlZiIsInVzZVJlZiIsIm5leHRLZXlSZWYiLCJzdGF0aWNFbGVtZW50RW50cmllc1JlZiIsIm1hcmtBbGxBc1JlbmRlcmVkIiwidXNlQ2FsbGJhY2siLCJjdXJyZW50IiwibGVuZ3RoIiwidXNlRWZmZWN0IiwicXVldWVTdGF0aWNFbGVtZW50IiwiZWxlbWVudCIsImtleSIsImVudHJpZXMiLCJzdGF0aWNFbGVtZW50RW50cmllc1N0YXRlIiwidXNlTWVtbyIsIk9iamVjdCIsImZyZWV6ZSIsImNvbnRleHQiLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJvbmVPZiIsImFueSIsIm51bWJlciJdLCJzb3VyY2VSb290IjoiY29tcG9uZW50Oi8vLyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3Byb3ZpZGVycy9MaXZlUmVnaW9uVHdpbi9MaXZlUmVnaW9uVHdpbkNvbXBvc2VyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBob29rcyB9IGZyb20gJ2JvdGZyYW1ld29yay13ZWJjaGF0LWFwaSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB0eXBlIHsgRkMsIFByb3BzV2l0aENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgTGl2ZVJlZ2lvblR3aW5Db250YWluZXIgZnJvbSAnLi9wcml2YXRlL0xpdmVSZWdpb25Ud2luQ29udGFpbmVyJztcbmltcG9ydCBMaXZlUmVnaW9uVHdpbkNvbnRleHQgZnJvbSAnLi9wcml2YXRlL0NvbnRleHQnO1xuaW1wb3J0IHVzZVZhbHVlUmVmIGZyb20gJy4uLy4uL2hvb2tzL2ludGVybmFsL3VzZVZhbHVlUmVmJztcblxuaW1wb3J0IHR5cGUgeyBTdGF0aWNFbGVtZW50LCBTdGF0aWNFbGVtZW50RW50cnkgfSBmcm9tICcuL3ByaXZhdGUvdHlwZXMnO1xuXG5jb25zdCB7IHVzZVBvbnlmaWxsIH0gPSBob29rcztcblxuY29uc3QgREVGQVVMVF9BUklBX0xJVkUgPSAncG9saXRlJztcbmNvbnN0IERFRkFVTFRfRkFERV9BRlRFUiA9IDEwMDA7XG5cbnR5cGUgTGl2ZVJlZ2lvblR3aW5Db21wb3NlclByb3BzID0gUHJvcHNXaXRoQ2hpbGRyZW48e1xuICAvKiogT3B0aW9uYWwgXCJhcmlhLWxhYmVsXCIgYXR0cmlidXRlIGZvciB0aGUgbGl2ZSByZWdpb24gdHdpbiBjb250YWluZXIuICovXG4gICdhcmlhLWxhYmVsJz86IHN0cmluZztcblxuICAvKiogXCJhcmlhLWxpdmVcIiBhdHRyaWJ1dGUgZm9yIHRoZSBsaXZlIHJlZ2lvbiB0d2luIGNvbnRhaW5lciwgZGVmYXVsdHMgdG8gYCdwb2xpdGUnYC4gKi9cbiAgJ2FyaWEtbGl2ZSc/OiAnYXNzZXJ0aXZlJyB8ICdwb2xpdGUnO1xuXG4gIC8qKiBPcHRpb25hbCBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIgYXR0cmlidXRlIGZvciB0aGUgbGl2ZSByZWdpb24gdHdpbiBjb250YWluZXIuICovXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic/OiBzdHJpbmc7XG5cbiAgLyoqIE9wdGlvbmFsIFwiY2xhc3NOYW1lXCIgYXR0cmlidXRlIGZvciB0aGUgbGl2ZSByZWdpb24gdHdpbiBjb250YWluZXIuICovXG4gIGNsYXNzTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3RhdGljIGVsZW1lbnRzIHdpbGwgZmFkZSBvdXQgYWZ0ZXIgdGhpcyB0aW1lb3V0IHZhbHVlIHNwZWNpZmllZCBpbiBtaWxsaXNlY29uZHMsIGRlZmF1bHRzIHRvIGAxMDAwYC5cbiAgICpcbiAgICogV2hlbiBsb3dlcmluZyB0aGlzIHZhbHVlLCBtYWtlIHN1cmUgc2NyZWVuIHJlYWRlciBjYW4gY29udGludWUgdG8gcGljayB1cCBuZXcgc3RhdGljIGVsZW1lbnRzIGJlZm9yZSBmYWRpbmcgb3V0LlxuICAgKlxuICAgKiBJZiB0aGlzIHByb3AgaXMgdXBkYXRlZCwgaXQgd2lsbCBiZSByZWZsZWN0ZWQgaW4gbmV4dCBxdWV1ZWluZyBlbGVtZW50cy5cbiAgICovXG4gIGZhZGVBZnRlcj86IG51bWJlcjtcblxuICAvKiogT3B0aW9uYWwgXCJyb2xlXCIgYXR0cmlidXRlIGZvciB0aGUgbGl2ZSByZWdpb24gdHdpbiBjb250YWluZXIuICovXG4gIHJvbGU/OiBzdHJpbmc7XG5cbiAgLyoqIE9wdGlvbmFsIFwiY2xhc3NOYW1lXCIgYXR0cmlidXRlIGZvciBzdGF0aWMgdGV4dCBlbGVtZW50LiAqL1xuICB0ZXh0RWxlbWVudENsYXNzTmFtZT86IHN0cmluZztcbn0+O1xuXG4vKipcbiAqIExpdmUgcmVnaW9uIHR3aW4gaXMgYW4gVUkgY29tcG9uZW50IGZvciBxdWV1ZWluZyB0ZXh0cyBvciBlbGVtZW50cyB0byB0aGUgc2NyZWVuIHJlYWRlciB1c2luZ1xuICogYSBjb250YWluZXIgZWxlbWVudCB3aXRoIGBhcmlhLWxpdmVgIGF0dHJpYnV0ZSBzZXQuXG4gKlxuICogQWZ0ZXIgdGhlIHRleHQgaXMgcmVuZGVyZWQgYW5kIHF1ZXVlZCwgaXQgd2lsbCBiZSByZW1vdmVkIHRvIHJlZHVjZSBidXJkZW4gb24gdGhlIERPTSB0cmVlLlxuICogQ3VycmVudGx5LCB3ZSBhc3N1bWUgdGhlIGFzc2lzdGl2ZSB0ZWNobm9sb2dpZXMgc2hvdWxkIHBpY2sgdXAgdGhlIHRleHQgd2l0aGluIDEgc2Vjb25kIG9mIHJlbmRlcmluZy5cbiAqIFRoaXMgdmFsdWUgaXMgY29uZmlndXJhYmxlLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBsaXZlIHJlZ2lvbiBpcyB2aXNpYmxlLiBJZiBpcyBpcyBub3QgZGVzaXJhYmxlLCB0aGUgY2FsbGVyIGNhbiB1c2UgYGNsYXNzTmFtZWAgcHJvcCB0b1xuICogaGlkZSBpdHMgdmlzdWFscy5cbiAqL1xuY29uc3QgTGl2ZVJlZ2lvblR3aW5Db21wb3NlcjogRkM8TGl2ZVJlZ2lvblR3aW5Db21wb3NlclByb3BzPiA9ICh7XG4gICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLFxuICAnYXJpYS1saXZlJzogYXJpYUxpdmUgPSBERUZBVUxUX0FSSUFfTElWRSxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogYXJpYVJvbGVEZXNjcmlwdGlvbixcbiAgY2hpbGRyZW4sXG4gIGNsYXNzTmFtZSxcbiAgZmFkZUFmdGVyID0gREVGQVVMVF9GQURFX0FGVEVSLFxuICByb2xlLFxuICB0ZXh0RWxlbWVudENsYXNzTmFtZVxufSkgPT4ge1xuICBjb25zdCBbeyBjbGVhclRpbWVvdXQsIHNldFRpbWVvdXQgfV0gPSB1c2VQb255ZmlsbCgpO1xuICBjb25zdCBbc3RhdGljRWxlbWVudEVudHJpZXMsIHNldFN0YXRpY0VsZW1lbnRFbnRyaWVzXSA9IHVzZVN0YXRlPFN0YXRpY0VsZW1lbnRFbnRyeVtdPihbXSk7XG4gIGNvbnN0IGZhZGVBZnRlclJlZiA9IHVzZVZhbHVlUmVmKGZhZGVBZnRlcik7XG4gIGNvbnN0IG1hcmtBbGxBc1JlbmRlcmVkVGltZW91dElkUmVmID0gdXNlUmVmPGFueT4oKTtcbiAgY29uc3QgbmV4dEtleVJlZiA9IHVzZVJlZjxudW1iZXI+KDEpO1xuXG4gIGNvbnN0IHN0YXRpY0VsZW1lbnRFbnRyaWVzUmVmID0gdXNlVmFsdWVSZWYoc3RhdGljRWxlbWVudEVudHJpZXMpO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGFuIGVmZmVjdCBob29rIGB1c2VNYXJrQWxsQXNSZW5kZXJlZEVmZmVjdGAsIGl0IG11c3QgYmUgZGVzaWduZWQgd2l0aCBjb252ZXJnaW5nIGluIG1pbmQuXG4gIC8vIFRvIHByZXZlbnQgaW5maW5pdGUgcmVuZGVyIGxvb3AsIGFmdGVyIG11bHRpcGxlIGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24sIGl0IHNob3VsZCBldmVudHVhbGx5IG5vLW9wLlxuICBjb25zdCBtYXJrQWxsQXNSZW5kZXJlZCA9IHVzZUNhbGxiYWNrPCgpID0+IHZvaWQ+KCgpID0+IHtcbiAgICBpZiAoIXN0YXRpY0VsZW1lbnRFbnRyaWVzUmVmLmN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIHJlbW92ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHJlbW92aW5nIGVhY2ggZWxlbWVudCBvbmUtYnktb25lIGJhc2VkIG9uIGFuIGluZGl2aWR1YWwgdGltZW91dCwgTmFycmF0b3Igd291bGQgbmFycmF0ZSB0aGVtIHR3aWNlIG9jY2FzaW9uYWxseS5cbiAgICAvLyBQb3NzaWJseSBpdCB0aGluayBzb21lIGVsZW1lbnRzIHRoYXQgaXMgbm90IHJlbW92ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGN5Y2xlLCBhcmUgbmV3IGVsZW1lbnRzIGFuZCBxdWV1ZWQgdGhlbSB0d2ljZS5cbiAgICAvLyBUaHVzLCB3ZSBhcmUgcmVtb3ZpbmcgYWxsIGF0IG9uY2UgdG8gcHJldmVudCBidWdzIGluIE5hcnJhdG9yLlxuICAgIG1hcmtBbGxBc1JlbmRlcmVkVGltZW91dElkUmVmLmN1cnJlbnQgJiYgY2xlYXJUaW1lb3V0KG1hcmtBbGxBc1JlbmRlcmVkVGltZW91dElkUmVmLmN1cnJlbnQpO1xuXG4gICAgbWFya0FsbEFzUmVuZGVyZWRUaW1lb3V0SWRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gV2UgYXJlIHBsYXlpbmcgc2FmZSBieSB1c2luZyB2YWx1ZSByZWYgdG8gY2hlY2sgaXRzIGxlbmd0aCBoZXJlLlxuICAgICAgLy8gSWYgd2UgYXJlIGNlcnRhaW4gdGhhdCBgc2V0U3RhdGljRWxlbWVudHMoZW1wdHlBcnJheSA9PiBlbXB0eUFycmF5KWAgaXMgYSBuby1vcCxcbiAgICAgIC8vIHdlIGNvdWxkIHJlcGxhY2UgaXQgd2l0aCBqdXN0IHRoZSBzZXR0ZXIgZnVuY3Rpb24uXG4gICAgICBzdGF0aWNFbGVtZW50RW50cmllc1JlZi5jdXJyZW50Lmxlbmd0aCAmJiBzZXRTdGF0aWNFbGVtZW50RW50cmllcyhbXSk7XG4gICAgfSwgZmFkZUFmdGVyUmVmLmN1cnJlbnQpO1xuICB9LCBbXG4gICAgY2xlYXJUaW1lb3V0LFxuICAgIGZhZGVBZnRlclJlZixcbiAgICBtYXJrQWxsQXNSZW5kZXJlZFRpbWVvdXRJZFJlZixcbiAgICBzZXRTdGF0aWNFbGVtZW50RW50cmllcyxcbiAgICBzZXRUaW1lb3V0LFxuICAgIHN0YXRpY0VsZW1lbnRFbnRyaWVzUmVmXG4gIF0pO1xuXG4gIC8vIFdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGluZywgbWFrZSBzdXJlIGFsbCBmdXR1cmUgYHNldFRpbWVvdXRgIGFyZSBjbGVhcmVkIGFuZCBzaG91bGQgbm90IGJlIGZpcmVkLlxuICB1c2VFZmZlY3QoXG4gICAgKCkgPT4gKCkgPT4gbWFya0FsbEFzUmVuZGVyZWRUaW1lb3V0SWRSZWYuY3VycmVudCAmJiBjbGVhclRpbWVvdXQobWFya0FsbEFzUmVuZGVyZWRUaW1lb3V0SWRSZWYuY3VycmVudCksXG4gICAgW2NsZWFyVGltZW91dCwgbWFya0FsbEFzUmVuZGVyZWRUaW1lb3V0SWRSZWZdXG4gICk7XG5cbiAgY29uc3QgcXVldWVTdGF0aWNFbGVtZW50ID0gdXNlQ2FsbGJhY2s8KHN0YXRpY0VsZW1lbnQ6IFN0YXRpY0VsZW1lbnQpID0+IHZvaWQ+KFxuICAgIChlbGVtZW50OiBTdGF0aWNFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBuZXh0S2V5UmVmLmN1cnJlbnQ7XG5cbiAgICAgIG5leHRLZXlSZWYuY3VycmVudCA9IG5leHRLZXlSZWYuY3VycmVudCArIDE7XG5cbiAgICAgIHNldFN0YXRpY0VsZW1lbnRFbnRyaWVzKGVudHJpZXMgPT4gWy4uLmVudHJpZXMsIHsgZWxlbWVudCwga2V5IH1dKTtcbiAgICB9LFxuICAgIFtuZXh0S2V5UmVmLCBzZXRTdGF0aWNFbGVtZW50RW50cmllc11cbiAgKTtcblxuICBjb25zdCBzdGF0aWNFbGVtZW50RW50cmllc1N0YXRlID0gdXNlTWVtbzxyZWFkb25seSBbcmVhZG9ubHkgU3RhdGljRWxlbWVudEVudHJ5W11dPihcbiAgICAoKSA9PiBPYmplY3QuZnJlZXplKFtPYmplY3QuZnJlZXplKHN0YXRpY0VsZW1lbnRFbnRyaWVzKV0pIGFzIHJlYWRvbmx5IFtyZWFkb25seSBTdGF0aWNFbGVtZW50RW50cnlbXV0sXG4gICAgW3N0YXRpY0VsZW1lbnRFbnRyaWVzXVxuICApO1xuXG4gIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBtYXJrQWxsQXNSZW5kZXJlZCxcbiAgICAgIHF1ZXVlU3RhdGljRWxlbWVudCxcbiAgICAgIHN0YXRpY0VsZW1lbnRFbnRyaWVzU3RhdGVcbiAgICB9KSxcbiAgICBbbWFya0FsbEFzUmVuZGVyZWQsIHF1ZXVlU3RhdGljRWxlbWVudCwgc3RhdGljRWxlbWVudEVudHJpZXNTdGF0ZV1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxMaXZlUmVnaW9uVHdpbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHR9PlxuICAgICAgPExpdmVSZWdpb25Ud2luQ29udGFpbmVyXG4gICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbH1cbiAgICAgICAgYXJpYS1saXZlPXthcmlhTGl2ZX1cbiAgICAgICAgYXJpYS1yb2xlZGVzY3JpcHRpb249e2FyaWFSb2xlRGVzY3JpcHRpb259XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICByb2xlPXtyb2xlfVxuICAgICAgICB0ZXh0RWxlbWVudENsYXNzTmFtZT17dGV4dEVsZW1lbnRDbGFzc05hbWV9XG4gICAgICAvPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvTGl2ZVJlZ2lvblR3aW5Db250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcblxuTGl2ZVJlZ2lvblR3aW5Db21wb3Nlci5kZWZhdWx0UHJvcHMgPSB7XG4gICdhcmlhLWxhYmVsJzogdW5kZWZpbmVkLFxuICAnYXJpYS1saXZlJzogREVGQVVMVF9BUklBX0xJVkUsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IHVuZGVmaW5lZCxcbiAgY2hpbGRyZW46IHVuZGVmaW5lZCxcbiAgY2xhc3NOYW1lOiB1bmRlZmluZWQsXG4gIGZhZGVBZnRlcjogREVGQVVMVF9GQURFX0FGVEVSLFxuICByb2xlOiB1bmRlZmluZWQsXG4gIHRleHRFbGVtZW50Q2xhc3NOYW1lOiB1bmRlZmluZWRcbn07XG5cbkxpdmVSZWdpb25Ud2luQ29tcG9zZXIucHJvcFR5cGVzID0ge1xuICAnYXJpYS1sYWJlbCc6IFByb3BUeXBlcy5zdHJpbmcsXG4gICdhcmlhLWxpdmUnOiBQcm9wVHlwZXMub25lT2YoWydhc3NlcnRpdmUnLCAncG9saXRlJ10pLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmYWRlQWZ0ZXI6IFByb3BUeXBlcy5udW1iZXIsXG4gIHJvbGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRleHRFbGVtZW50Q2xhc3NOYW1lOiBQcm9wVHlwZXMu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