"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _botframeworkWebchatApi = require("botframework-webchat-api");

var _reactScrollToBottom = require("react-scroll-to-bottom");

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _detectBrowser = require("./Utils/detectBrowser");

var _ActivityRow = _interopRequireDefault(require("./Transcript/ActivityRow"));

var _BasicTypingIndicator = _interopRequireDefault(require("./BasicTypingIndicator"));

var _FocusRedirector = _interopRequireDefault(require("./Utils/FocusRedirector"));

var _inputtableKey = _interopRequireDefault(require("./Utils/TypeFocusSink/inputtableKey"));

var _isZeroOrPositive = _interopRequireDefault(require("./Utils/isZeroOrPositive"));

var _KeyboardHelp = _interopRequireDefault(require("./Transcript/KeyboardHelp"));

var _LiveRegionTranscript = _interopRequireDefault(require("./Transcript/LiveRegionTranscript"));

var _tabbableElements = _interopRequireDefault(require("./Utils/tabbableElements"));

var _TranscriptFocusComposer = _interopRequireDefault(require("./providers/TranscriptFocus/TranscriptFocusComposer"));

var _useActiveDescendantId = _interopRequireDefault(require("./providers/TranscriptFocus/useActiveDescendantId"));

var _useActivityTreeWithRenderer = _interopRequireDefault(require("./providers/ActivityTree/useActivityTreeWithRenderer"));

var _useDispatchScrollPosition = _interopRequireDefault(require("./hooks/internal/useDispatchScrollPosition"));

var _useDispatchTranscriptFocusByActivityKey = _interopRequireDefault(require("./hooks/internal/useDispatchTranscriptFocusByActivityKey"));

var _useFocus = _interopRequireDefault(require("./hooks/useFocus"));

var _useFocusByActivityKey = _interopRequireDefault(require("./providers/TranscriptFocus/useFocusByActivityKey"));

var _useFocusedActivityKey = _interopRequireDefault(require("./providers/TranscriptFocus/useFocusedActivityKey"));

var _useFocusedExplicitly3 = _interopRequireDefault(require("./providers/TranscriptFocus/useFocusedExplicitly"));

var _useFocusRelativeActivity = _interopRequireDefault(require("./providers/TranscriptFocus/useFocusRelativeActivity"));

var _useObserveFocusVisible = _interopRequireDefault(require("./hooks/internal/useObserveFocusVisible"));

var _usePrevious = _interopRequireDefault(require("./hooks/internal/usePrevious"));

var _useRegisterFocusTranscript = _interopRequireDefault(require("./hooks/internal/useRegisterFocusTranscript"));

var _useRegisterScrollRelative = _interopRequireDefault(require("./hooks/internal/useRegisterScrollRelative"));

var _useRegisterScrollTo = _interopRequireDefault(require("./hooks/internal/useRegisterScrollTo"));

var _useRegisterScrollToEnd = _interopRequireDefault(require("./hooks/internal/useRegisterScrollToEnd"));

var _useStyleSet5 = _interopRequireDefault(require("./hooks/useStyleSet"));

var _useStyleToEmotionObject = _interopRequireDefault(require("./hooks/internal/useStyleToEmotionObject"));

var _useUniqueId = _interopRequireDefault(require("./hooks/internal/useUniqueId"));

var _useValueRef = _interopRequireDefault(require("./hooks/internal/useValueRef"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useActivityKeys = _botframeworkWebchatApi.hooks.useActivityKeys,
    useActivityKeysByRead = _botframeworkWebchatApi.hooks.useActivityKeysByRead,
    useCreateActivityStatusRenderer = _botframeworkWebchatApi.hooks.useCreateActivityStatusRenderer,
    useCreateAvatarRenderer = _botframeworkWebchatApi.hooks.useCreateAvatarRenderer,
    useCreateScrollToEndButtonRenderer = _botframeworkWebchatApi.hooks.useCreateScrollToEndButtonRenderer,
    useDirection = _botframeworkWebchatApi.hooks.useDirection,
    useGetActivityByKey = _botframeworkWebchatApi.hooks.useGetActivityByKey,
    useGetKeyByActivity = _botframeworkWebchatApi.hooks.useGetKeyByActivity,
    useGetKeyByActivityId = _botframeworkWebchatApi.hooks.useGetKeyByActivityId,
    useLastAcknowledgedActivityKey = _botframeworkWebchatApi.hooks.useLastAcknowledgedActivityKey,
    useLocalizer = _botframeworkWebchatApi.hooks.useLocalizer,
    useMarkActivityKeyAsRead = _botframeworkWebchatApi.hooks.useMarkActivityKeyAsRead,
    useMarkAllAsAcknowledged = _botframeworkWebchatApi.hooks.useMarkAllAsAcknowledged,
    useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions;
var ROOT_STYLE = {
  '&.webchat__basic-transcript': {
    display: 'flex',
    flexDirection: 'column',
    overflow: 'hidden',
    // Make sure to set "position: relative" here to form another stacking context for the scroll-to-end button.
    // Stacking context help isolating elements that use "z-index" from global pollution.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
    position: 'relative',
    '& .webchat__basic-transcript__filler': {
      flex: 1
    },
    '& .webchat__basic-transcript__scrollable': {
      display: 'flex',
      flexDirection: 'column',
      overflowX: 'hidden',
      WebkitOverflowScrolling: 'touch'
    },
    '& .webchat__basic-transcript__transcript': {
      listStyleType: 'none'
    }
  }
};
// TODO: [P1] #4133 Add telemetry for computing how many re-render done so far.
var InternalTranscript = /*#__PURE__*/(0, _react.forwardRef)(function (_ref, ref) {
  var activityElementMapRef = _ref.activityElementMapRef,
      className = _ref.className;

  var _useStyleSet = (0, _useStyleSet5.default)(),
      _useStyleSet2 = _slicedToArray(_useStyleSet, 1),
      basicTranscriptStyleSet = _useStyleSet2[0].basicTranscript;

  var _useStyleOptions = useStyleOptions(),
      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),
      _useStyleOptions2$ = _useStyleOptions2[0],
      bubbleFromUserNubOffset = _useStyleOptions2$.bubbleFromUserNubOffset,
      bubbleNubOffset = _useStyleOptions2$.bubbleNubOffset,
      groupTimestamp = _useStyleOptions2$.groupTimestamp,
      showAvatarInGroup = _useStyleOptions2$.showAvatarInGroup;

  var _useActiveDescendantI = (0, _useActiveDescendantId.default)(),
      _useActiveDescendantI2 = _slicedToArray(_useActiveDescendantI, 1),
      activeDescendantId = _useActiveDescendantI2[0];

  var _useActivityTreeWithR = (0, _useActivityTreeWithRenderer.default)(),
      _useActivityTreeWithR2 = _slicedToArray(_useActivityTreeWithR, 1),
      activityWithRendererTree = _useActivityTreeWithR2[0];

  var _useDirection = useDirection(),
      _useDirection2 = _slicedToArray(_useDirection, 1),
      direction = _useDirection2[0];

  var _useFocusedActivityKe = (0, _useFocusedActivityKey.default)(),
      _useFocusedActivityKe2 = _slicedToArray(_useFocusedActivityKe, 1),
      focusedActivityKey = _useFocusedActivityKe2[0];

  var _useFocusedExplicitly = (0, _useFocusedExplicitly3.default)(),
      _useFocusedExplicitly2 = _slicedToArray(_useFocusedExplicitly, 1),
      focusedExplicitly = _useFocusedExplicitly2[0];

  var createActivityStatusRenderer = useCreateActivityStatusRenderer();
  var createAvatarRenderer = useCreateAvatarRenderer();
  var focus = (0, _useFocus.default)();
  var focusByActivityKey = (0, _useFocusByActivityKey.default)();
  var focusRelativeActivity = (0, _useFocusRelativeActivity.default)();
  var getActivityByKey = useGetActivityByKey();
  var getKeyByActivity = useGetKeyByActivity();
  var getKeyByActivityId = useGetKeyByActivityId();
  var localize = useLocalizer();
  var rootClassName = (0, _useStyleToEmotionObject.default)()(ROOT_STYLE) + '';
  var rootElementRef = (0, _react.useRef)();
  var terminatorLabelId = (0, _useUniqueId.default)('webchat__basic-transcript__terminator-label');
  var terminatorRef = (0, _react.useRef)();
  var focusedActivityKeyRef = (0, _useValueRef.default)(focusedActivityKey);
  var hideAllTimestamps = groupTimestamp === false;
  var terminatorText = localize('TRANSCRIPT_TERMINATOR_TEXT');
  var transcriptAriaLabel = localize('TRANSCRIPT_ARIA_LABEL_ALT');
  var callbackRef = (0, _react.useCallback)(function (element) {
    if (typeof ref === 'function') {
      ref(element);
    } else {
      ref.current = element;
    }

    rootElementRef.current = element;
  }, [ref, rootElementRef]); // Flatten the tree back into an array with information related to rendering.

  var renderingElements = (0, _react.useMemo)(function () {
    var renderingElements = [];
    var topSideBotNub = (0, _isZeroOrPositive.default)(bubbleNubOffset);
    var topSideUserNub = (0, _isZeroOrPositive.default)(bubbleFromUserNubOffset);
    activityWithRendererTree.forEach(function (entriesWithSameSender) {
      var _entriesWithSameSende = _slicedToArray(entriesWithSameSender, 1),
          _entriesWithSameSende2 = _slicedToArray(_entriesWithSameSende[0], 1),
          firstActivity = _entriesWithSameSende2[0].activity;

      var renderAvatar = createAvatarRenderer({
        activity: firstActivity
      });
      entriesWithSameSender.forEach(function (entriesWithSameSenderAndStatus, indexWithinSenderGroup) {
        var firstInSenderGroup = !indexWithinSenderGroup;
        var lastInSenderGroup = indexWithinSenderGroup === entriesWithSameSender.length - 1;
        entriesWithSameSenderAndStatus.forEach(function (_ref2, indexWithinSenderAndStatusGroup) {
          var _activity$from;

          var activity = _ref2.activity,
              renderActivity = _ref2.renderActivity;
          // We only show the timestamp at the end of the sender group. But we always show the "Send failed, retry" prompt.
          var firstInSenderAndStatusGroup = !indexWithinSenderAndStatusGroup;
          var key = getKeyByActivity(activity);
          var lastInSenderAndStatusGroup = indexWithinSenderAndStatusGroup === entriesWithSameSenderAndStatus.length - 1;
          var renderActivityStatus = createActivityStatusRenderer({
            activity: activity,
            nextVisibleActivity: undefined
          });
          var topSideNub = ((_activity$from = activity.from) === null || _activity$from === void 0 ? void 0 : _activity$from.role) === 'user' ? topSideUserNub : topSideBotNub;
          var showCallout; // Depending on the "showAvatarInGroup" setting, the avatar will render in different positions.

          if (showAvatarInGroup === 'sender') {
            if (topSideNub) {
              showCallout = firstInSenderGroup && firstInSenderAndStatusGroup;
            } else {
              showCallout = lastInSenderGroup && lastInSenderAndStatusGroup;
            }
          } else if (showAvatarInGroup === 'status') {
            if (topSideNub) {
              showCallout = firstInSenderAndStatusGroup;
            } else {
              showCallout = lastInSenderAndStatusGroup;
            }
          } else {
            showCallout = true;
          }

          renderingElements.push({
            activity: activity,
            // After the element is mounted, set it to activityElementsRef.
            callbackRef: function callbackRef(activityElement) {
              activityElement ? activityElementMapRef.current.set(key, activityElement) : activityElementMapRef.current.delete(key);
            },
            // "hideTimestamp" is a render-time parameter for renderActivityStatus().
            // If true, it will hide the timestamp, but it will continue to show the
            // retry prompt. And show the screen reader version of the timestamp.
            hideTimestamp: hideAllTimestamps || indexWithinSenderAndStatusGroup !== entriesWithSameSenderAndStatus.length - 1,
            key: key,
            renderActivity: renderActivity,
            renderActivityStatus: renderActivityStatus,
            renderAvatar: renderAvatar,
            showCallout: showCallout
          });
        });
      });
    });
    return renderingElements;
  }, [activityElementMapRef, activityWithRendererTree, bubbleFromUserNubOffset, bubbleNubOffset, createActivityStatusRenderer, createAvatarRenderer, getKeyByActivity, hideAllTimestamps, showAvatarInGroup]);
  var scrollToBottomScrollTo = (0, _reactScrollToBottom.useScrollTo)();
  var scrollToBottomScrollToEnd = (0, _reactScrollToBottom.useScrollToEnd)();
  var scrollTo = (0, _react.useCallback)(function (position) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref3$behavior = _ref3.behavior,
        behavior = _ref3$behavior === void 0 ? 'auto' : _ref3$behavior;

    if (!position) {
      throw new Error('botframework-webchat: First argument passed to "useScrollTo" must be a ScrollPosition object.');
    }

    var activityId = position.activityID,
        scrollTop = position.scrollTop;

    if (typeof scrollTop !== 'undefined') {
      scrollToBottomScrollTo(scrollTop, {
        behavior: behavior
      });
    } else if (typeof activityId !== 'undefined') {
      var _activityElementMapRe;

      var activityBoundingBoxElement = (_activityElementMapRe = activityElementMapRef.current.get(getKeyByActivityId(activityId))) === null || _activityElementMapRe === void 0 ? void 0 : _activityElementMapRe.querySelector('.webchat__basic-transcript__activity-active-descendant');
      var scrollableElement = rootElementRef.current.querySelector('.webchat__basic-transcript__scrollable');

      if (scrollableElement && activityBoundingBoxElement) {
        // ESLint conflict with TypeScript. The result of getClientRects() is not an Array but DOMRectList, and cannot be destructured.
        // eslint-disable-next-line prefer-destructuring
        var activityBoundingBoxElementClientRect = activityBoundingBoxElement.getClientRects()[0]; // ESLint conflict with TypeScript. The result of getClientRects() is not an Array but DOMRectList, and cannot be destructured.
        // eslint-disable-next-line prefer-destructuring

        var scrollableElementClientRect = scrollableElement.getClientRects()[0]; // If either the activity or the transcript scrollable is not on DOM, we will not scroll the view.

        if (activityBoundingBoxElementClientRect && scrollableElementClientRect) {
          var activityHeight = activityBoundingBoxElementClientRect.height,
              activityY = activityBoundingBoxElementClientRect.y;
          var scrollableHeight = scrollableElementClientRect.height;
          var activityOffsetTop = activityY + scrollableElement.scrollTop;

          var _scrollTop = Math.min(activityOffsetTop, activityOffsetTop - scrollableHeight + activityHeight);

          scrollToBottomScrollTo(_scrollTop, {
            behavior: behavior
          });
        }
      }
    }
  }, [activityElementMapRef, getKeyByActivityId, rootElementRef, scrollToBottomScrollTo]);
  var scrollToEnd = (0, _react.useCallback)(function () {
    return scrollToBottomScrollToEnd({
      behavior: 'smooth'
    });
  }, [scrollToBottomScrollToEnd]);
  var scrollRelative = (0, _react.useCallback)(function (direction) {
    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        displacement = _ref4.displacement;

    var rootElement = rootElementRef.current;

    if (!rootElement) {
      return;
    }

    var scrollable = rootElement.querySelector('.webchat__basic-transcript__scrollable');
    var nextScrollTop;

    if (typeof displacement === 'number') {
      // eslint-disable-next-line no-magic-numbers
      nextScrollTop = scrollable.scrollTop + (direction === 'down' ? 1 : -1) * displacement;
    } else {
      // eslint-disable-next-line no-magic-numbers
      nextScrollTop = scrollable.scrollTop + (direction === 'down' ? 1 : -1) * scrollable.offsetHeight;
    }

    scrollTo({
      scrollTop: Math.max(0, Math.min(scrollable.scrollHeight - scrollable.offsetHeight, nextScrollTop))
    }, {
      behavior: 'smooth'
    });
  }, [rootElementRef, scrollTo]); // Since there could be multiple instances of <BasicTranscript> inside the <Composer>, when the developer calls `scrollXXX`, we need to call it on all instances.
  // We call `useRegisterScrollXXX` to register a callback function, the `useScrollXXX` will multiplex the call into each instance of <BasicTranscript>.

  (0, _useRegisterScrollTo.default)(scrollTo);
  (0, _useRegisterScrollToEnd.default)(scrollToEnd);
  (0, _useRegisterScrollRelative.default)(scrollRelative);
  var markActivityKeyAsRead = useMarkActivityKeyAsRead();
  var dispatchScrollPositionWithActivityId = (0, _useDispatchScrollPosition.default)(); // TODO: [P2] We should use IntersectionObserver to track what activity is in the scrollable.
  //            However, IntersectionObserver is not available on IE11, we need to make a limited polyfill in React style.

  var handleScrollPosition = (0, _react.useCallback)(function (_ref5) {
    var _ref6;

    var scrollTop = _ref5.scrollTop;
    var rootElement = rootElementRef.current;

    if (!rootElement) {
      return;
    }

    var scrollableElement = rootElement.querySelector('.webchat__basic-transcript__scrollable'); // "getClientRects()" is not returning an array, thus, it is not destructurable.
    // eslint-disable-next-line prefer-destructuring

    var scrollableElementClientRect = scrollableElement.getClientRects()[0]; // If the scrollable is not mounted, we cannot measure which activity is in view. Thus, we will not fire any events.

    if (!scrollableElementClientRect) {
      return;
    }

    var scrollableClientBottom = scrollableElementClientRect.bottom; // Find the activity just above scroll view bottom.
    // If the scroll view is already on top, get the first activity.

    var activityElements = Array.from(activityElementMapRef.current.entries());
    var activityKeyJustAboveScrollBottom = (_ref6 = scrollableElement.scrollTop ? activityElements.reverse() // Add subpixel tolerance
    .find(function (_ref7) {
      var _ref8 = _slicedToArray(_ref7, 2),
          element = _ref8[1];

      // "getClientRects()" is not returning an array, thus, it is not destructurable.
      // eslint-disable-next-line prefer-destructuring
      var elementClientRect = element.getClientRects()[0]; // If the activity is not attached to DOM tree, we should not count it as "bottommost visible activity", as it is not visible.

      return elementClientRect && elementClientRect.bottom < scrollableClientBottom + 1;
    }) : activityElements[0]) === null || _ref6 === void 0 ? void 0 : _ref6[0]; // When the end-user slowly scrolling the view down, we will mark activity as read when the message fully appear on the screen.

    activityKeyJustAboveScrollBottom && markActivityKeyAsRead(activityKeyJustAboveScrollBottom);

    if (dispatchScrollPositionWithActivityId) {
      var activity = getActivityByKey(activityKeyJustAboveScrollBottom);
      dispatchScrollPositionWithActivityId(_objectSpread(_objectSpread({}, activity ? {
        activityID: activity.id
      } : {}), {}, {
        scrollTop: scrollTop
      }));
    }
  }, [activityElementMapRef, dispatchScrollPositionWithActivityId, getActivityByKey, markActivityKeyAsRead, rootElementRef]);
  (0, _reactScrollToBottom.useObserveScrollPosition)(handleScrollPosition);
  var handleTranscriptKeyDown = (0, _react.useCallback)(function (event) {
    var target = event.target;
    var fromEndOfTranscriptIndicator = target === terminatorRef.current;
    var fromTranscript = target === event.currentTarget;

    if (!fromEndOfTranscriptIndicator && !fromTranscript) {
      return;
    }

    var handled = true;

    switch (event.key) {
      case 'ArrowDown':
        focusRelativeActivity(fromEndOfTranscriptIndicator ? 0 : 1);
        break;

      case 'ArrowUp':
        // eslint-disable-next-line no-magic-numbers
        focusRelativeActivity(fromEndOfTranscriptIndicator ? 0 : -1);
        break;

      case 'End':
        focusRelativeActivity(Infinity);
        break;

      case 'Enter':
        // This is capturing plain ENTER.
        // When screen reader is not running, or screen reader is running outside of scan mode, the ENTER key will be captured here.
        if (!fromEndOfTranscriptIndicator) {
          var _activityElementMapRe2, _tabbableElements$;

          var body = (_activityElementMapRe2 = activityElementMapRef.current.get(focusedActivityKeyRef.current)) === null || _activityElementMapRe2 === void 0 ? void 0 : _activityElementMapRe2.querySelector('.webchat__basic-transcript__activity-body');
          (_tabbableElements$ = (0, _tabbableElements.default)(body)[0]) === null || _tabbableElements$ === void 0 ? void 0 : _tabbableElements$.focus();
        }

        break;

      case 'Escape':
        focus('sendBoxWithoutKeyboard');
        break;

      case 'Home':
        focusRelativeActivity(-Infinity);
        break;

      default:
        handled = false;
        break;
    }

    if (handled) {
      event.preventDefault(); // If a custom HTML control wants to handle up/down arrow, we will prevent them from listening to this event to prevent bugs due to handling arrow keys twice.

      event.stopPropagation();
    }
  }, [activityElementMapRef, focus, focusedActivityKeyRef, focusRelativeActivity, terminatorRef]);
  var handleTranscriptKeyDownCapture = (0, _react.useCallback)(function (event) {
    var altKey = event.altKey,
        ctrlKey = event.ctrlKey,
        key = event.key,
        metaKey = event.metaKey,
        target = event.target;

    if (altKey || ctrlKey && key !== 'v' || metaKey || !(0, _inputtableKey.default)(key) && key !== 'Backspace') {
      // Ignore if one of the utility key (except SHIFT) is pressed
      // E.g. CTRL-C on a link in one of the message should not jump to chat box
      // E.g. "A" or "Backspace" should jump to chat box
      return;
    } // Send keystrokes to send box if we are focusing on the transcript or terminator.


    if (target === event.currentTarget || target === terminatorRef.current) {
      event.stopPropagation();
      focus('sendBox');
    }
  }, [focus]);
  (0, _useRegisterFocusTranscript.default)((0, _react.useCallback)(function () {
    return focusByActivityKey(undefined);
  }, [focusByActivityKey])); // When the focusing activity has changed, dispatch an event to observers of "useObserveTranscriptFocus".

  var dispatchTranscriptFocusByActivityKey = (0, _useDispatchTranscriptFocusByActivityKey.default)(); // Dispatch a "transcript focus" event based on user selection.
  // We should not dispatch "transcript focus" when a new activity come. Although the selection change, it is not initiated from the user.

  (0, _react.useMemo)(function () {
    return dispatchTranscriptFocusByActivityKey(focusedExplicitly ? focusedActivityKey : undefined);
  }, [dispatchTranscriptFocusByActivityKey, focusedActivityKey, focusedExplicitly]); // When the transcript is being focused on, we should dispatch a "transcriptfocus" event.

  var handleFocus = (0, _react.useCallback)( // We call "focusByActivityKey" with activity key of "true".
  // It means, tries to focus on anything.
  function (_ref9) {
    var currentTarget = _ref9.currentTarget,
        target = _ref9.target;
    return target === currentTarget && focusByActivityKey(true, false);
  }, [focusByActivityKey]); // This is required by IE11.
  // When the user clicks on and empty space (a.k.a. filler) in an empty transcript, IE11 says the focus is on the <div className="filler">,
  // despite the fact there are no "tabIndex" attributes set on the filler.
  // We need to artificially send the focus back to the transcript.

  var handleFocusFiller = (0, _react.useCallback)(function () {
    return focusByActivityKey(undefined);
  }, [focusByActivityKey]); // When focus into the transcript using TAB/SHIFT-TAB, scroll the focused activity into view.

  (0, _useObserveFocusVisible.default)(rootElementRef, (0, _react.useCallback)(function () {
    return focusByActivityKey(undefined);
  }, [focusByActivityKey]));
  return /*#__PURE__*/_react.default.createElement("div", {
    // Although Android TalkBack 12.1 does not support `aria-activedescendant`, when used, it become buggy and will narrate content twice.
    // We are disabling `aria-activedescendant` for Android. See <ActivityRow> for details.
    "aria-activedescendant": _detectBrowser.android ? undefined : activeDescendantId,
    "aria-label": transcriptAriaLabel,
    className: (0, _classnames.default)('webchat__basic-transcript', basicTranscriptStyleSet + '', rootClassName, (className || '') + ''),
    dir: direction,
    onFocus: handleFocus,
    onKeyDown: handleTranscriptKeyDown,
    onKeyDownCapture: handleTranscriptKeyDownCapture,
    ref: callbackRef // "aria-activedescendant" will only works with a number of roles and it must be explicitly set.
    // https://www.w3.org/TR/wai-aria/#aria-activedescendant
    ,
    role: "group" // For up/down arrow key navigation across activities, this component must be included in the tab sequence.
    // Otherwise, "aria-activedescendant" will not be narrated when the user press up/down arrow keys.
    // https://www.w3.org/TR/wai-aria-practices-1.1/#kbd_focus_activedescendant
    ,
    tabIndex: 0
  }, /*#__PURE__*/_react.default.createElement(_LiveRegionTranscript.default, {
    activityElementMapRef: activityElementMapRef
  }), /*#__PURE__*/_react.default.createElement(InternalTranscriptScrollable, {
    onFocusFiller: handleFocusFiller,
    terminatorRef: terminatorRef
  }, renderingElements.map(function (_ref10) {
    var activity = _ref10.activity,
        callbackRef = _ref10.callbackRef,
        hideTimestamp = _ref10.hideTimestamp,
        key = _ref10.key,
        renderActivity = _ref10.renderActivity,
        renderActivityStatus = _ref10.renderActivityStatus,
        renderAvatar = _ref10.renderAvatar,
        showCallout = _ref10.showCallout;
    return /*#__PURE__*/_react.default.createElement(_ActivityRow.default, {
      activity: activity,
      key: key,
      ref: callbackRef
    }, renderActivity({
      hideTimestamp: hideTimestamp,
      renderActivityStatus: renderActivityStatus,
      renderAvatar: renderAvatar,
      showCallout: showCallout
    }));
  })), !!renderingElements.length && /*#__PURE__*/_react.default.createElement(_react.Fragment, null, /*#__PURE__*/_react.default.createElement(_FocusRedirector.default, {
    redirectRef: rootElementRef
  }), /*#__PURE__*/_react.default.createElement("div", {
    "aria-labelledby": terminatorLabelId,
    className: "webchat__basic-transcript__terminator",
    ref: terminatorRef,
    role: "note",
    tabIndex: 0
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "webchat__basic-transcript__terminator-body"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "webchat__basic-transcript__terminator-text",
    id: terminatorLabelId
  }, terminatorText)))), /*#__PURE__*/_react.default.createElement("div", {
    className: "webchat__basic-transcript__focus-indicator"
  }));
});
InternalTranscript.defaultProps = {
  className: ''
};
InternalTranscript.displayName = 'InternalTranscript';
InternalTranscript.propTypes = {
  // PropTypes cannot validate precisely with its TypeScript counterpart.
  // @ts-ignore
  activityElementMapRef: _propTypes.default.shape({
    current: _propTypes.default.instanceOf(Map)
  }).isRequired,
  className: _propTypes.default.string
};

// Separating high-frequency hooks to improve performance.
var InternalTranscriptScrollable = function InternalTranscriptScrollable(_ref11) {
  var children = _ref11.children,
      onFocusFiller = _ref11.onFocusFiller,
      terminatorRef = _ref11.terminatorRef;

  var _useStyleSet3 = (0, _useStyleSet5.default)(),
      _useStyleSet4 = _slicedToArray(_useStyleSet3, 1),
      activitiesStyleSet = _useStyleSet4[0].activities;

  var _useAnimatingToEnd = (0, _reactScrollToBottom.useAnimatingToEnd)(),
      _useAnimatingToEnd2 = _slicedToArray(_useAnimatingToEnd, 1),
      animatingToEnd = _useAnimatingToEnd2[0];

  var _useAtEnd = (0, _reactScrollToBottom.useAtEnd)(),
      _useAtEnd2 = _slicedToArray(_useAtEnd, 1),
      atEnd = _useAtEnd2[0];

  var _useActivityKeysByRea = useActivityKeysByRead(),
      _useActivityKeysByRea2 = _slicedToArray(_useActivityKeysByRea, 2),
      unreadActivityKeys = _useActivityKeysByRea2[1];

  var _useSticky = (0, _reactScrollToBottom.useSticky)(),
      _useSticky2 = _slicedToArray(_useSticky, 1),
      sticky = _useSticky2[0];

  var _useStyleOptions3 = useStyleOptions(),
      _useStyleOptions4 = _slicedToArray(_useStyleOptions3, 1),
      styleOptions = _useStyleOptions4[0];

  var focusByActivityKey = (0, _useFocusByActivityKey.default)();
  var localize = useLocalizer();
  var markActivityKeyAsRead = useMarkActivityKeyAsRead();
  var markAllAsAcknowledged = useMarkAllAsAcknowledged();
  var scrollToEnd = (0, _reactScrollToBottom.useScrollToEnd)();
  var prevSticky = (0, _usePrevious.default)(sticky);
  var transcriptRoleDescription = localize('TRANSCRIPT_ARIA_ROLE_ALT');
  var stickyChangedToTrue = prevSticky !== sticky && sticky; // Acknowledged means either:
  // 1. The user sent a message
  //    - We don't need a condition here. When Web Chat sends the user's message, it will scroll to bottom, and it will trigger condition 2 below.
  // 2. The user scroll to the bottom of the transcript, from a non-bottom scroll position
  //    - If the transcript is already at the bottom, the user needs to scroll up and then go back down
  //    - What happens if we are relaxing "scrolled from a non-bottom scroll position":
  //      1. The condition will become solely "at the bottom of the transcript"
  //      2. Auto-scroll will always scroll the transcript to the bottom
  //      3. Web Chat will always acknowledge all activities as it is at the bottom
  //      4. Acknowledge flag become useless
  //      5. Therefore, even the developer set "pause after 3 activities", if activities are coming in at a slow pace (not batched in a single render)
  //         Web Chat will keep scrolling and not snapped/paused
  // Note: When Web Chat is loaded, there are no activities acknowledged. We need to assume all arriving activities are acknowledged until end-user sends their first activity.
  //       Activities loaded initially could be from conversation history. Without assuming acknowledgement, Web Chat will not scroll initially (as everything is not acknowledged).
  //       It would be better if the chat adapter should let Web Chat know if the activity is loaded from history or not.
  // TODO: [P2] #3670 Move the "conversation history acknowledgement" logic mentioned above to polyfill of chat adapters.
  //       1. Chat adapter should send "acknowledged" as part of "channelData"
  //       2. If "acknowledged" is "undefined", we set it to:
  //          a. true, if there are no egress activities yet
  //          b. Otherwise, false

  (0, _react.useMemo)(function () {
    return stickyChangedToTrue && // TODO: [P2] Both `markActivityKeyAsRead` and `markAllAsAcknowledged` hook are setters of useState.
    //       This means, in a render loop, we will be calling setter and will cause another re-render.
    //       This is not trivial but we should think if there is a way to avoid this.
    markAllAsAcknowledged();
  }, [markAllAsAcknowledged, stickyChangedToTrue]);

  var _useActivityTreeWithR3 = (0, _useActivityTreeWithRenderer.default)({
    flat: true
  }),
      _useActivityTreeWithR4 = _slicedToArray(_useActivityTreeWithR3, 1),
      flattenedActivityTreeWithRenderer = _useActivityTreeWithR4[0];

  var getKeyByActivity = useGetKeyByActivity();
  var renderingActivityKeys = (0, _react.useMemo)(function () {
    return flattenedActivityTreeWithRenderer.map(function (_ref12) {
      var activity = _ref12.activity;
      return getKeyByActivity(activity);
    });
  }, [flattenedActivityTreeWithRenderer, getKeyByActivity]);
  var renderingActivityKeysRef = (0, _useValueRef.default)(renderingActivityKeys); // To prevent flashy button, we are not waiting for another render loop to update the `[readActivityKeys, unreadActivityKeys]` state.
  // Instead, we are building the next one in this `useMemo` call.

  var nextUnreadActivityKeys = (0, _react.useMemo)(function () {
    // This code need to be careful reviewed as it will cause another render. The code should be converging.
    // After we call `markActivityKeyAsRead`, everything will be read and nothing will be unread.
    // That means, in next render, `unreadActivityKeys` will be emptied and the `markActivityKeyAsRead` will not get called again.
    if (sticky && unreadActivityKeys.length) {
      markActivityKeyAsRead(unreadActivityKeys[unreadActivityKeys.length - 1]);
      return [];
    }

    return unreadActivityKeys;
  }, [markActivityKeyAsRead, sticky, unreadActivityKeys]);
  var nextUnreadActivityKeysRef = (0, _useValueRef.default)(nextUnreadActivityKeys); // If we are rendering anything that is unread, we should show the "New messages" button.
  // Not everything in the `unreadActivityKeys` are rendered, say, bot typing indicator.
  // We should not show the "New messages" button for bot typing indicator as it will confuse the user.

  var unread = (0, _react.useMemo)(function () {
    return nextUnreadActivityKeys.some(function (key) {
      return renderingActivityKeys.includes(key);
    });
  }, [renderingActivityKeys, nextUnreadActivityKeys]);
  var handleScrollToEndButtonClick = (0, _react.useCallback)(function () {
    scrollToEnd({
      behavior: 'smooth'
    });
    var renderingActivityKeys = renderingActivityKeysRef.current; // After the "New message" button is clicked, focus on the first unread activity which will be rendered.

    var firstUnreadRenderingActivityKey = nextUnreadActivityKeysRef.current.find(function (key) {
      return renderingActivityKeys.includes(key);
    });

    if (firstUnreadRenderingActivityKey) {
      focusByActivityKey(firstUnreadRenderingActivityKey);
    } else {
      var _terminatorRef$curren;

      // If no unread activity, send the focus to the terminator block.
      (_terminatorRef$curren = terminatorRef.current) === null || _terminatorRef$curren === void 0 ? void 0 : _terminatorRef$curren.focus();
    }
  }, [focusByActivityKey, nextUnreadActivityKeysRef, renderingActivityKeysRef, scrollToEnd, terminatorRef]);
  var renderScrollToEndButton = useCreateScrollToEndButtonRenderer()({
    atEnd: animatingToEnd || atEnd || sticky,
    styleOptions: styleOptions,
    unread: unread
  });
  var hasAnyChild = !!_react.default.Children.count(children);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, renderScrollToEndButton && renderScrollToEndButton({
    onClick: handleScrollToEndButtonClick
  }), hasAnyChild && /*#__PURE__*/_react.default.createElement(_FocusRedirector.default, {
    redirectRef: terminatorRef
  }), /*#__PURE__*/_react.default.createElement(_reactScrollToBottom.Panel, {
    className: "webchat__basic-transcript__scrollable"
  }, /*#__PURE__*/_react.default.createElement("div", {
    "aria-hidden": true,
    className: "webchat__basic-transcript__filler",
    onFocus: onFocusFiller
  }), hasAnyChild && /*#__PURE__*/_react.default.createElement("section", {
    "aria-roledescription": transcriptRoleDescription,
    className: (0, _classnames.default)(activitiesStyleSet + '', 'webchat__basic-transcript__transcript'),
    role: "feed"
  }, children), /*#__PURE__*/_react.default.createElement(_BasicTypingIndicator.default, null)));
};

InternalTranscriptScrollable.propTypes = {
  children: _propTypes.default.any.isRequired,
  onFocusFiller: _propTypes.default.func.isRequired,
  terminatorRef: _propTypes.default.any.isRequired
};

// "scroller" is the auto-scroll limiter, a.k.a. auto scroll snap.
var useScroller = function useScroller(activityElementMapRef) {
  var _useActivityKeys = useActivityKeys(),
      _useActivityKeys2 = _slicedToArray(_useActivityKeys, 1),
      activityKeys = _useActivityKeys2[0];

  var _useLastAcknowledgedA = useLastAcknowledgedActivityKey(),
      _useLastAcknowledgedA2 = _slicedToArray(_useLastAcknowledgedA, 1),
      lastAcknowledgedActivityKey = _useLastAcknowledgedA2[0];

  var _useStyleOptions5 = useStyleOptions(),
      _useStyleOptions6 = _slicedToArray(_useStyleOptions5, 1),
      styleOptions = _useStyleOptions6[0];

  var activityKeysRef = (0, _useValueRef.default)(activityKeys);
  var lastAcknowledgedActivityKeyRef = (0, _useValueRef.default)(lastAcknowledgedActivityKey);
  var styleOptionsRef = (0, _useValueRef.default)(styleOptions);
  return (0, _react.useCallback)(function (_ref13) {
    var offsetHeight = _ref13.offsetHeight,
        scrollTop = _ref13.scrollTop;
    var _styleOptionsRef$curr = styleOptionsRef.current,
        autoScrollSnapOnActivity = _styleOptionsRef$curr.autoScrollSnapOnActivity,
        autoScrollSnapOnActivityOffset = _styleOptionsRef$curr.autoScrollSnapOnActivityOffset,
        autoScrollSnapOnPage = _styleOptionsRef$curr.autoScrollSnapOnPage,
        autoScrollSnapOnPageOffset = _styleOptionsRef$curr.autoScrollSnapOnPageOffset;
    var patchedAutoScrollSnapOnActivity = typeof autoScrollSnapOnActivity === 'number' ? Math.max(0, autoScrollSnapOnActivity) : autoScrollSnapOnActivity ? 1 : 0;
    var patchedAutoScrollSnapOnPage = typeof autoScrollSnapOnPage === 'number' ? Math.max(0, Math.min(1, autoScrollSnapOnPage)) : autoScrollSnapOnPage ? 1 : 0;
    var patchedAutoScrollSnapOnActivityOffset = typeof autoScrollSnapOnActivityOffset === 'number' ? autoScrollSnapOnActivityOffset : 0;
    var patchedAutoScrollSnapOnPageOffset = typeof autoScrollSnapOnPageOffset === 'number' ? autoScrollSnapOnPageOffset : 0;

    if (patchedAutoScrollSnapOnActivity || patchedAutoScrollSnapOnPage) {
      var activityElementMap = activityElementMapRef.current;
      var _activityKeys = activityKeysRef.current;
      var _lastAcknowledgedActivityKey = lastAcknowledgedActivityKeyRef.current;
      var values = [];

      var lastAcknowledgedActivityKeyIndex = _activityKeys.indexOf(_lastAcknowledgedActivityKey);

      if (~lastAcknowledgedActivityKeyIndex) {
        // The activity that we acknowledged could be not rendered, such as post back activity.
        // When calculating scroll snap, we can only base on the first unacknowledged-and-rendering activity.
        var renderingActivityKeys = Array.from(activityElementMap.keys());
        var firstUnacknowledgedActivityElementIndex = -1;

        var _iterator = _createForOfIteratorHelper(_activityKeys.slice(0, lastAcknowledgedActivityKeyIndex + 1).reverse()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var acknowledgedActivityKey = _step.value;
            var index = renderingActivityKeys.indexOf(acknowledgedActivityKey);

            if (~index) {
              if (index !== renderingActivityKeys.length - 1) {
                firstUnacknowledgedActivityElementIndex = index + 1;
              }

              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (~firstUnacknowledgedActivityElementIndex) {
          var activityElements = Array.from(activityElementMap.values());

          if (patchedAutoScrollSnapOnActivity) {
            // Gets the activity element which we should snap to.
            var nthUnacknowledgedActivityElement = activityElements[firstUnacknowledgedActivityElementIndex + patchedAutoScrollSnapOnActivity - 1];

            if (nthUnacknowledgedActivityElement) {
              var nthUnacknowledgedActivityBoundingBoxElement = nthUnacknowledgedActivityElement === null || nthUnacknowledgedActivityElement === void 0 ? void 0 : nthUnacknowledgedActivityElement.querySelector('.webchat__basic-transcript__activity-active-descendant');
              var nthUnacknowledgedActivityOffsetTop = nthUnacknowledgedActivityElement.offsetTop + nthUnacknowledgedActivityBoundingBoxElement.offsetTop;
              values.push(nthUnacknowledgedActivityOffsetTop + nthUnacknowledgedActivityBoundingBoxElement.offsetHeight - offsetHeight - scrollTop + patchedAutoScrollSnapOnActivityOffset);
            }
          }

          if (patchedAutoScrollSnapOnPage) {
            var firstUnacknowledgedActivityElement = activityElements[+firstUnacknowledgedActivityElementIndex];
            var firstUnacknowledgedActivityBoundingBoxElement = firstUnacknowledgedActivityElement.querySelector('.webchat__basic-transcript__activity-active-descendant');
            var firstUnacknowledgedActivityOffsetTop = firstUnacknowledgedActivityElement.offsetTop + firstUnacknowledgedActivityBoundingBoxElement.offsetTop;
            values.push(firstUnacknowledgedActivityOffsetTop - scrollTop - offsetHeight * (1 - patchedAutoScrollSnapOnPage) + patchedAutoScrollSnapOnPageOffset);
          }
        }
      }

      return Math.min.apply(Math, values);
    }

    return Infinity;
  }, [activityElementMapRef, activityKeysRef, lastAcknowledgedActivityKeyRef, styleOptionsRef]);
};

var BasicTranscript = function BasicTranscript(_ref14) {
  var className = _ref14.className;
  var activityElementMapRef = (0, _react.useRef)(new Map());
  var containerRef = (0, _react.useRef)();
  var scroller = useScroller(activityElementMapRef);
  return /*#__PURE__*/_react.default.createElement(_TranscriptFocusComposer.default, {
    containerRef: containerRef
  }, /*#__PURE__*/_react.default.createElement(_reactScrollToBottom.Composer, {
    scroller: scroller
  }, /*#__PURE__*/_react.default.createElement(_KeyboardHelp.default, null), /*#__PURE__*/_react.default.createElement(InternalTranscript, {
    activityElementMapRef: activityElementMapRef,
    className: className,
    ref: containerRef
  })));
};

BasicTranscript.defaultProps = {
  className: ''
};
BasicTranscript.propTypes = {
  className: _propTypes.default.string
};
var _default = BasicTranscript;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1c2VBY3Rpdml0eUtleXMiLCJob29rcyIsInVzZUFjdGl2aXR5S2V5c0J5UmVhZCIsInVzZUNyZWF0ZUFjdGl2aXR5U3RhdHVzUmVuZGVyZXIiLCJ1c2VDcmVhdGVBdmF0YXJSZW5kZXJlciIsInVzZUNyZWF0ZVNjcm9sbFRvRW5kQnV0dG9uUmVuZGVyZXIiLCJ1c2VEaXJlY3Rpb24iLCJ1c2VHZXRBY3Rpdml0eUJ5S2V5IiwidXNlR2V0S2V5QnlBY3Rpdml0eSIsInVzZUdldEtleUJ5QWN0aXZpdHlJZCIsInVzZUxhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleSIsInVzZUxvY2FsaXplciIsInVzZU1hcmtBY3Rpdml0eUtleUFzUmVhZCIsInVzZU1hcmtBbGxBc0Fja25vd2xlZGdlZCIsInVzZVN0eWxlT3B0aW9ucyIsIlJPT1RfU1RZTEUiLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsIm92ZXJmbG93IiwicG9zaXRpb24iLCJmbGV4Iiwib3ZlcmZsb3dYIiwiV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmciLCJsaXN0U3R5bGVUeXBlIiwiSW50ZXJuYWxUcmFuc2NyaXB0IiwiZm9yd2FyZFJlZiIsInJlZiIsImFjdGl2aXR5RWxlbWVudE1hcFJlZiIsImNsYXNzTmFtZSIsInVzZVN0eWxlU2V0IiwiYmFzaWNUcmFuc2NyaXB0U3R5bGVTZXQiLCJiYXNpY1RyYW5zY3JpcHQiLCJidWJibGVGcm9tVXNlck51Yk9mZnNldCIsImJ1YmJsZU51Yk9mZnNldCIsImdyb3VwVGltZXN0YW1wIiwic2hvd0F2YXRhckluR3JvdXAiLCJ1c2VBY3RpdmVEZXNjZW5kYW50SWQiLCJhY3RpdmVEZXNjZW5kYW50SWQiLCJ1c2VBY3Rpdml0eVRyZWVXaXRoUmVuZGVyZXIiLCJhY3Rpdml0eVdpdGhSZW5kZXJlclRyZWUiLCJkaXJlY3Rpb24iLCJ1c2VGb2N1c2VkQWN0aXZpdHlLZXkiLCJmb2N1c2VkQWN0aXZpdHlLZXkiLCJ1c2VGb2N1c2VkRXhwbGljaXRseSIsImZvY3VzZWRFeHBsaWNpdGx5IiwiY3JlYXRlQWN0aXZpdHlTdGF0dXNSZW5kZXJlciIsImNyZWF0ZUF2YXRhclJlbmRlcmVyIiwiZm9jdXMiLCJ1c2VGb2N1cyIsImZvY3VzQnlBY3Rpdml0eUtleSIsInVzZUZvY3VzQnlBY3Rpdml0eUtleSIsImZvY3VzUmVsYXRpdmVBY3Rpdml0eSIsInVzZUZvY3VzUmVsYXRpdmVBY3Rpdml0eSIsImdldEFjdGl2aXR5QnlLZXkiLCJnZXRLZXlCeUFjdGl2aXR5IiwiZ2V0S2V5QnlBY3Rpdml0eUlkIiwibG9jYWxpemUiLCJyb290Q2xhc3NOYW1lIiwidXNlU3R5bGVUb0Vtb3Rpb25PYmplY3QiLCJyb290RWxlbWVudFJlZiIsInVzZVJlZiIsInRlcm1pbmF0b3JMYWJlbElkIiwidXNlVW5pcXVlSWQiLCJ0ZXJtaW5hdG9yUmVmIiwiZm9jdXNlZEFjdGl2aXR5S2V5UmVmIiwidXNlVmFsdWVSZWYiLCJoaWRlQWxsVGltZXN0YW1wcyIsInRlcm1pbmF0b3JUZXh0IiwidHJhbnNjcmlwdEFyaWFMYWJlbCIsImNhbGxiYWNrUmVmIiwidXNlQ2FsbGJhY2siLCJlbGVtZW50IiwiY3VycmVudCIsInJlbmRlcmluZ0VsZW1lbnRzIiwidXNlTWVtbyIsInRvcFNpZGVCb3ROdWIiLCJpc1plcm9PclBvc2l0aXZlIiwidG9wU2lkZVVzZXJOdWIiLCJmb3JFYWNoIiwiZW50cmllc1dpdGhTYW1lU2VuZGVyIiwiZmlyc3RBY3Rpdml0eSIsImFjdGl2aXR5IiwicmVuZGVyQXZhdGFyIiwiZW50cmllc1dpdGhTYW1lU2VuZGVyQW5kU3RhdHVzIiwiaW5kZXhXaXRoaW5TZW5kZXJHcm91cCIsImZpcnN0SW5TZW5kZXJHcm91cCIsImxhc3RJblNlbmRlckdyb3VwIiwibGVuZ3RoIiwiaW5kZXhXaXRoaW5TZW5kZXJBbmRTdGF0dXNHcm91cCIsInJlbmRlckFjdGl2aXR5IiwiZmlyc3RJblNlbmRlckFuZFN0YXR1c0dyb3VwIiwia2V5IiwibGFzdEluU2VuZGVyQW5kU3RhdHVzR3JvdXAiLCJyZW5kZXJBY3Rpdml0eVN0YXR1cyIsIm5leHRWaXNpYmxlQWN0aXZpdHkiLCJ1bmRlZmluZWQiLCJ0b3BTaWRlTnViIiwiZnJvbSIsInJvbGUiLCJzaG93Q2FsbG91dCIsInB1c2giLCJhY3Rpdml0eUVsZW1lbnQiLCJzZXQiLCJkZWxldGUiLCJoaWRlVGltZXN0YW1wIiwic2Nyb2xsVG9Cb3R0b21TY3JvbGxUbyIsInVzZVNjcm9sbFRvIiwic2Nyb2xsVG9Cb3R0b21TY3JvbGxUb0VuZCIsInVzZVNjcm9sbFRvRW5kIiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsIkVycm9yIiwiYWN0aXZpdHlJZCIsImFjdGl2aXR5SUQiLCJzY3JvbGxUb3AiLCJhY3Rpdml0eUJvdW5kaW5nQm94RWxlbWVudCIsImdldCIsInF1ZXJ5U2VsZWN0b3IiLCJzY3JvbGxhYmxlRWxlbWVudCIsImFjdGl2aXR5Qm91bmRpbmdCb3hFbGVtZW50Q2xpZW50UmVjdCIsImdldENsaWVudFJlY3RzIiwic2Nyb2xsYWJsZUVsZW1lbnRDbGllbnRSZWN0IiwiYWN0aXZpdHlIZWlnaHQiLCJoZWlnaHQiLCJhY3Rpdml0eVkiLCJ5Iiwic2Nyb2xsYWJsZUhlaWdodCIsImFjdGl2aXR5T2Zmc2V0VG9wIiwiTWF0aCIsIm1pbiIsInNjcm9sbFRvRW5kIiwic2Nyb2xsUmVsYXRpdmUiLCJkaXNwbGFjZW1lbnQiLCJyb290RWxlbWVudCIsInNjcm9sbGFibGUiLCJuZXh0U2Nyb2xsVG9wIiwib2Zmc2V0SGVpZ2h0IiwibWF4Iiwic2Nyb2xsSGVpZ2h0IiwidXNlUmVnaXN0ZXJTY3JvbGxUbyIsInVzZVJlZ2lzdGVyU2Nyb2xsVG9FbmQiLCJ1c2VSZWdpc3RlclNjcm9sbFJlbGF0aXZlIiwibWFya0FjdGl2aXR5S2V5QXNSZWFkIiwiZGlzcGF0Y2hTY3JvbGxQb3NpdGlvbldpdGhBY3Rpdml0eUlkIiwidXNlRGlzcGF0Y2hTY3JvbGxQb3NpdGlvbiIsImhhbmRsZVNjcm9sbFBvc2l0aW9uIiwic2Nyb2xsYWJsZUNsaWVudEJvdHRvbSIsImJvdHRvbSIsImFjdGl2aXR5RWxlbWVudHMiLCJBcnJheSIsImVudHJpZXMiLCJhY3Rpdml0eUtleUp1c3RBYm92ZVNjcm9sbEJvdHRvbSIsInJldmVyc2UiLCJmaW5kIiwiZWxlbWVudENsaWVudFJlY3QiLCJpZCIsInVzZU9ic2VydmVTY3JvbGxQb3NpdGlvbiIsImhhbmRsZVRyYW5zY3JpcHRLZXlEb3duIiwiZXZlbnQiLCJ0YXJnZXQiLCJmcm9tRW5kT2ZUcmFuc2NyaXB0SW5kaWNhdG9yIiwiZnJvbVRyYW5zY3JpcHQiLCJjdXJyZW50VGFyZ2V0IiwiaGFuZGxlZCIsIkluZmluaXR5IiwiYm9keSIsInRhYmJhYmxlRWxlbWVudHMiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImhhbmRsZVRyYW5zY3JpcHRLZXlEb3duQ2FwdHVyZSIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5IiwiaW5wdXR0YWJsZUtleSIsInVzZVJlZ2lzdGVyRm9jdXNUcmFuc2NyaXB0IiwiZGlzcGF0Y2hUcmFuc2NyaXB0Rm9jdXNCeUFjdGl2aXR5S2V5IiwidXNlRGlzcGF0Y2hUcmFuc2NyaXB0Rm9jdXNCeUFjdGl2aXR5S2V5IiwiaGFuZGxlRm9jdXMiLCJoYW5kbGVGb2N1c0ZpbGxlciIsInVzZU9ic2VydmVGb2N1c1Zpc2libGUiLCJhbmRyb2lkIiwiY2xhc3NOYW1lcyIsIm1hcCIsImRlZmF1bHRQcm9wcyIsImRpc3BsYXlOYW1lIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwic2hhcGUiLCJpbnN0YW5jZU9mIiwiTWFwIiwiaXNSZXF1aXJlZCIsInN0cmluZyIsIkludGVybmFsVHJhbnNjcmlwdFNjcm9sbGFibGUiLCJjaGlsZHJlbiIsIm9uRm9jdXNGaWxsZXIiLCJhY3Rpdml0aWVzU3R5bGVTZXQiLCJhY3Rpdml0aWVzIiwidXNlQW5pbWF0aW5nVG9FbmQiLCJhbmltYXRpbmdUb0VuZCIsInVzZUF0RW5kIiwiYXRFbmQiLCJ1bnJlYWRBY3Rpdml0eUtleXMiLCJ1c2VTdGlja3kiLCJzdGlja3kiLCJzdHlsZU9wdGlvbnMiLCJtYXJrQWxsQXNBY2tub3dsZWRnZWQiLCJwcmV2U3RpY2t5IiwidXNlUHJldmlvdXMiLCJ0cmFuc2NyaXB0Um9sZURlc2NyaXB0aW9uIiwic3RpY2t5Q2hhbmdlZFRvVHJ1ZSIsImZsYXQiLCJmbGF0dGVuZWRBY3Rpdml0eVRyZWVXaXRoUmVuZGVyZXIiLCJyZW5kZXJpbmdBY3Rpdml0eUtleXMiLCJyZW5kZXJpbmdBY3Rpdml0eUtleXNSZWYiLCJuZXh0VW5yZWFkQWN0aXZpdHlLZXlzIiwibmV4dFVucmVhZEFjdGl2aXR5S2V5c1JlZiIsInVucmVhZCIsInNvbWUiLCJpbmNsdWRlcyIsImhhbmRsZVNjcm9sbFRvRW5kQnV0dG9uQ2xpY2siLCJmaXJzdFVucmVhZFJlbmRlcmluZ0FjdGl2aXR5S2V5IiwicmVuZGVyU2Nyb2xsVG9FbmRCdXR0b24iLCJoYXNBbnlDaGlsZCIsIlJlYWN0IiwiQ2hpbGRyZW4iLCJjb3VudCIsIm9uQ2xpY2siLCJhbnkiLCJmdW5jIiwidXNlU2Nyb2xsZXIiLCJhY3Rpdml0eUtleXMiLCJsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXkiLCJhY3Rpdml0eUtleXNSZWYiLCJsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXlSZWYiLCJzdHlsZU9wdGlvbnNSZWYiLCJhdXRvU2Nyb2xsU25hcE9uQWN0aXZpdHkiLCJhdXRvU2Nyb2xsU25hcE9uQWN0aXZpdHlPZmZzZXQiLCJhdXRvU2Nyb2xsU25hcE9uUGFnZSIsImF1dG9TY3JvbGxTbmFwT25QYWdlT2Zmc2V0IiwicGF0Y2hlZEF1dG9TY3JvbGxTbmFwT25BY3Rpdml0eSIsInBhdGNoZWRBdXRvU2Nyb2xsU25hcE9uUGFnZSIsInBhdGNoZWRBdXRvU2Nyb2xsU25hcE9uQWN0aXZpdHlPZmZzZXQiLCJwYXRjaGVkQXV0b1Njcm9sbFNuYXBPblBhZ2VPZmZzZXQiLCJhY3Rpdml0eUVsZW1lbnRNYXAiLCJ2YWx1ZXMiLCJsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXlJbmRleCIsImluZGV4T2YiLCJrZXlzIiwiZmlyc3RVbmFja25vd2xlZGdlZEFjdGl2aXR5RWxlbWVudEluZGV4Iiwic2xpY2UiLCJhY2tub3dsZWRnZWRBY3Rpdml0eUtleSIsImluZGV4IiwibnRoVW5hY2tub3dsZWRnZWRBY3Rpdml0eUVsZW1lbnQiLCJudGhVbmFja25vd2xlZGdlZEFjdGl2aXR5Qm91bmRpbmdCb3hFbGVtZW50IiwibnRoVW5hY2tub3dsZWRnZWRBY3Rpdml0eU9mZnNldFRvcCIsIm9mZnNldFRvcCIsImZpcnN0VW5hY2tub3dsZWRnZWRBY3Rpdml0eUVsZW1lbnQiLCJmaXJzdFVuYWNrbm93bGVkZ2VkQWN0aXZpdHlCb3VuZGluZ0JveEVsZW1lbnQiLCJmaXJzdFVuYWNrbm93bGVkZ2VkQWN0aXZpdHlPZmZzZXRUb3AiLCJCYXNpY1RyYW5zY3JpcHQiLCJjb250YWluZXJSZWYiLCJzY3JvbGxlciJdLCJzb3VyY2VSb290IjoiY29tcG9uZW50Oi8vLyIsInNvdXJjZXMiOlsiLi4vc3JjL0Jhc2ljVHJhbnNjcmlwdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaG9va3MgfSBmcm9tICdib3RmcmFtZXdvcmstd2ViY2hhdC1hcGknO1xuaW1wb3J0IHtcbiAgQ29tcG9zZXIgYXMgUmVhY3RTY3JvbGxUb0JvdHRvbUNvbXBvc2VyLFxuICBQYW5lbCBhcyBSZWFjdFNjcm9sbFRvQm90dG9tUGFuZWwsXG4gIHVzZUFuaW1hdGluZ1RvRW5kLFxuICB1c2VBdEVuZCxcbiAgdXNlT2JzZXJ2ZVNjcm9sbFBvc2l0aW9uLFxuICB1c2VTY3JvbGxUbyxcbiAgdXNlU2Nyb2xsVG9FbmQsXG4gIHVzZVN0aWNreVxufSBmcm9tICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCBGcmFnbWVudCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHR5cGUgeyBBY3Rpdml0eUNvbXBvbmVudEZhY3RvcnkgfSBmcm9tICdib3RmcmFtZXdvcmstd2ViY2hhdC1hcGknO1xuaW1wb3J0IHR5cGUgeyBBY3Rpdml0eUVsZW1lbnRNYXAgfSBmcm9tICcuL1RyYW5zY3JpcHQvdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBGQywgS2V5Ym9hcmRFdmVudEhhbmRsZXIsIE11dGFibGVSZWZPYmplY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0eXBlIHsgV2ViQ2hhdEFjdGl2aXR5IH0gZnJvbSAnYm90ZnJhbWV3b3JrLXdlYmNoYXQtY29yZSc7XG5cbmltcG9ydCB7IGFuZHJvaWQgfSBmcm9tICcuL1V0aWxzL2RldGVjdEJyb3dzZXInO1xuaW1wb3J0IEFjdGl2aXR5Um93IGZyb20gJy4vVHJhbnNjcmlwdC9BY3Rpdml0eVJvdyc7XG5pbXBvcnQgQmFzaWNUeXBpbmdJbmRpY2F0b3IgZnJvbSAnLi9CYXNpY1R5cGluZ0luZGljYXRvcic7XG5pbXBvcnQgRm9jdXNSZWRpcmVjdG9yIGZyb20gJy4vVXRpbHMvRm9jdXNSZWRpcmVjdG9yJztcbmltcG9ydCBpbnB1dHRhYmxlS2V5IGZyb20gJy4vVXRpbHMvVHlwZUZvY3VzU2luay9pbnB1dHRhYmxlS2V5JztcbmltcG9ydCBpc1plcm9PclBvc2l0aXZlIGZyb20gJy4vVXRpbHMvaXNaZXJvT3JQb3NpdGl2ZSc7XG5pbXBvcnQgS2V5Ym9hcmRIZWxwIGZyb20gJy4vVHJhbnNjcmlwdC9LZXlib2FyZEhlbHAnO1xuaW1wb3J0IExpdmVSZWdpb25UcmFuc2NyaXB0IGZyb20gJy4vVHJhbnNjcmlwdC9MaXZlUmVnaW9uVHJhbnNjcmlwdCc7XG4vLyBUT0RPOiBbUDJdICM0MTMzIFJlbmFtZSB0byBcImdldFRhYmJhYmxlRWxlbWVudHNcIi5cbmltcG9ydCB0YWJiYWJsZUVsZW1lbnRzIGZyb20gJy4vVXRpbHMvdGFiYmFibGVFbGVtZW50cyc7XG5pbXBvcnQgVHJhbnNjcmlwdEZvY3VzQ29tcG9zZXIgZnJvbSAnLi9wcm92aWRlcnMvVHJhbnNjcmlwdEZvY3VzL1RyYW5zY3JpcHRGb2N1c0NvbXBvc2VyJztcbmltcG9ydCB1c2VBY3RpdmVEZXNjZW5kYW50SWQgZnJvbSAnLi9wcm92aWRlcnMvVHJhbnNjcmlwdEZvY3VzL3VzZUFjdGl2ZURlc2NlbmRhbnRJZCc7XG5pbXBvcnQgdXNlQWN0aXZpdHlUcmVlV2l0aFJlbmRlcmVyIGZyb20gJy4vcHJvdmlkZXJzL0FjdGl2aXR5VHJlZS91c2VBY3Rpdml0eVRyZWVXaXRoUmVuZGVyZXInO1xuaW1wb3J0IHVzZURpc3BhdGNoU2Nyb2xsUG9zaXRpb24gZnJvbSAnLi9ob29rcy9pbnRlcm5hbC91c2VEaXNwYXRjaFNjcm9sbFBvc2l0aW9uJztcbmltcG9ydCB1c2VEaXNwYXRjaFRyYW5zY3JpcHRGb2N1c0J5QWN0aXZpdHlLZXkgZnJvbSAnLi9ob29rcy9pbnRlcm5hbC91c2VEaXNwYXRjaFRyYW5zY3JpcHRGb2N1c0J5QWN0aXZpdHlLZXknO1xuaW1wb3J0IHVzZUZvY3VzIGZyb20gJy4vaG9va3MvdXNlRm9jdXMnO1xuaW1wb3J0IHVzZUZvY3VzQnlBY3Rpdml0eUtleSBmcm9tICcuL3Byb3ZpZGVycy9UcmFuc2NyaXB0Rm9jdXMvdXNlRm9jdXNCeUFjdGl2aXR5S2V5JztcbmltcG9ydCB1c2VGb2N1c2VkQWN0aXZpdHlLZXkgZnJvbSAnLi9wcm92aWRlcnMvVHJhbnNjcmlwdEZvY3VzL3VzZUZvY3VzZWRBY3Rpdml0eUtleSc7XG5pbXBvcnQgdXNlRm9jdXNlZEV4cGxpY2l0bHkgZnJvbSAnLi9wcm92aWRlcnMvVHJhbnNjcmlwdEZvY3VzL3VzZUZvY3VzZWRFeHBsaWNpdGx5JztcbmltcG9ydCB1c2VGb2N1c1JlbGF0aXZlQWN0aXZpdHkgZnJvbSAnLi9wcm92aWRlcnMvVHJhbnNjcmlwdEZvY3VzL3VzZUZvY3VzUmVsYXRpdmVBY3Rpdml0eSc7XG5pbXBvcnQgdXNlT2JzZXJ2ZUZvY3VzVmlzaWJsZSBmcm9tICcuL2hvb2tzL2ludGVybmFsL3VzZU9ic2VydmVGb2N1c1Zpc2libGUnO1xuaW1wb3J0IHVzZVByZXZpb3VzIGZyb20gJy4vaG9va3MvaW50ZXJuYWwvdXNlUHJldmlvdXMnO1xuaW1wb3J0IHVzZVJlZ2lzdGVyRm9jdXNUcmFuc2NyaXB0IGZyb20gJy4vaG9va3MvaW50ZXJuYWwvdXNlUmVnaXN0ZXJGb2N1c1RyYW5zY3JpcHQnO1xuaW1wb3J0IHVzZVJlZ2lzdGVyU2Nyb2xsUmVsYXRpdmUgZnJvbSAnLi9ob29rcy9pbnRlcm5hbC91c2VSZWdpc3RlclNjcm9sbFJlbGF0aXZlJztcbmltcG9ydCB1c2VSZWdpc3RlclNjcm9sbFRvIGZyb20gJy4vaG9va3MvaW50ZXJuYWwvdXNlUmVnaXN0ZXJTY3JvbGxUbyc7XG5pbXBvcnQgdXNlUmVnaXN0ZXJTY3JvbGxUb0VuZCBmcm9tICcuL2hvb2tzL2ludGVybmFsL3VzZVJlZ2lzdGVyU2Nyb2xsVG9FbmQnO1xuaW1wb3J0IHVzZVN0eWxlU2V0IGZyb20gJy4vaG9va3MvdXNlU3R5bGVTZXQnO1xuaW1wb3J0IHVzZVN0eWxlVG9FbW90aW9uT2JqZWN0IGZyb20gJy4vaG9va3MvaW50ZXJuYWwvdXNlU3R5bGVUb0Vtb3Rpb25PYmplY3QnO1xuaW1wb3J0IHVzZVVuaXF1ZUlkIGZyb20gJy4vaG9va3MvaW50ZXJuYWwvdXNlVW5pcXVlSWQnO1xuaW1wb3J0IHVzZVZhbHVlUmVmIGZyb20gJy4vaG9va3MvaW50ZXJuYWwvdXNlVmFsdWVSZWYnO1xuXG5jb25zdCB7XG4gIHVzZUFjdGl2aXR5S2V5cyxcbiAgdXNlQWN0aXZpdHlLZXlzQnlSZWFkLFxuICB1c2VDcmVhdGVBY3Rpdml0eVN0YXR1c1JlbmRlcmVyLFxuICB1c2VDcmVhdGVBdmF0YXJSZW5kZXJlcixcbiAgdXNlQ3JlYXRlU2Nyb2xsVG9FbmRCdXR0b25SZW5kZXJlcixcbiAgdXNlRGlyZWN0aW9uLFxuICB1c2VHZXRBY3Rpdml0eUJ5S2V5LFxuICB1c2VHZXRLZXlCeUFjdGl2aXR5LFxuICB1c2VHZXRLZXlCeUFjdGl2aXR5SWQsXG4gIHVzZUxhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleSxcbiAgdXNlTG9jYWxpemVyLFxuICB1c2VNYXJrQWN0aXZpdHlLZXlBc1JlYWQsXG4gIHVzZU1hcmtBbGxBc0Fja25vd2xlZGdlZCxcbiAgdXNlU3R5bGVPcHRpb25zXG59ID0gaG9va3M7XG5cbmNvbnN0IFJPT1RfU1RZTEUgPSB7XG4gICcmLndlYmNoYXRfX2Jhc2ljLXRyYW5zY3JpcHQnOiB7XG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAvLyBNYWtlIHN1cmUgdG8gc2V0IFwicG9zaXRpb246IHJlbGF0aXZlXCIgaGVyZSB0byBmb3JtIGFub3RoZXIgc3RhY2tpbmcgY29udGV4dCBmb3IgdGhlIHNjcm9sbC10by1lbmQgYnV0dG9uLlxuICAgIC8vIFN0YWNraW5nIGNvbnRleHQgaGVscCBpc29sYXRpbmcgZWxlbWVudHMgdGhhdCB1c2UgXCJ6LWluZGV4XCIgZnJvbSBnbG9iYWwgcG9sbHV0aW9uLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9DU1NfUG9zaXRpb25pbmcvVW5kZXJzdGFuZGluZ196X2luZGV4L1RoZV9zdGFja2luZ19jb250ZXh0XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG5cbiAgICAnJiAud2ViY2hhdF9fYmFzaWMtdHJhbnNjcmlwdF9fZmlsbGVyJzoge1xuICAgICAgZmxleDogMVxuICAgIH0sXG5cbiAgICAnJiAud2ViY2hhdF9fYmFzaWMtdHJhbnNjcmlwdF9fc2Nyb2xsYWJsZSc6IHtcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcbiAgICAgIFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOiAndG91Y2gnXG4gICAgfSxcblxuICAgICcmIC53ZWJjaGF0X19iYXNpYy10cmFuc2NyaXB0X190cmFuc2NyaXB0Jzoge1xuICAgICAgbGlzdFN0eWxlVHlwZTogJ25vbmUnXG4gICAgfVxuICB9XG59O1xuXG50eXBlIFJlbmRlcmluZ0VsZW1lbnQgPSB7XG4gIGFjdGl2aXR5OiBXZWJDaGF0QWN0aXZpdHk7XG4gIGNhbGxiYWNrUmVmOiAoZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHZvaWQ7XG4gIGhpZGVUaW1lc3RhbXA6IGJvb2xlYW47XG4gIGtleTogc3RyaW5nO1xuICByZW5kZXJBY3Rpdml0eTogRXhjbHVkZTxSZXR1cm5UeXBlPEFjdGl2aXR5Q29tcG9uZW50RmFjdG9yeT4sIGZhbHNlPjtcbiAgcmVuZGVyQWN0aXZpdHlTdGF0dXM6IChwcm9wczogeyBoaWRlVGltZXN0YW1wPzogYm9vbGVhbiB9KSA9PiBSZWFjdE5vZGU7XG4gIHJlbmRlckF2YXRhcjogZmFsc2UgfCAoKCkgPT4gRXhjbHVkZTxSZWFjdE5vZGUsIGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkPik7XG4gIHNob3dDYWxsb3V0OiBib29sZWFuO1xufTtcblxudHlwZSBTY3JvbGxCZWhhdmlvciA9ICdhdXRvJyB8ICdzbW9vdGgnO1xudHlwZSBTY3JvbGxUb09wdGlvbnMgPSB7IGJlaGF2aW9yPzogU2Nyb2xsQmVoYXZpb3IgfTtcbnR5cGUgU2Nyb2xsVG9Qb3NpdGlvbiA9IHsgYWN0aXZpdHlJRD86IHN0cmluZzsgc2Nyb2xsVG9wPzogbnVtYmVyIH07XG5cbnR5cGUgSW50ZXJuYWxUcmFuc2NyaXB0UHJvcHMgPSB7XG4gIGFjdGl2aXR5RWxlbWVudE1hcFJlZjogTXV0YWJsZVJlZk9iamVjdDxBY3Rpdml0eUVsZW1lbnRNYXA+O1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59O1xuXG4vLyBUT0RPOiBbUDFdICM0MTMzIEFkZCB0ZWxlbWV0cnkgZm9yIGNvbXB1dGluZyBob3cgbWFueSByZS1yZW5kZXIgZG9uZSBzbyBmYXIuXG5jb25zdCBJbnRlcm5hbFRyYW5zY3JpcHQgPSBmb3J3YXJkUmVmPEhUTUxEaXZFbGVtZW50LCBJbnRlcm5hbFRyYW5zY3JpcHRQcm9wcz4oXG4gICh7IGFjdGl2aXR5RWxlbWVudE1hcFJlZiwgY2xhc3NOYW1lIH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IFt7IGJhc2ljVHJhbnNjcmlwdDogYmFzaWNUcmFuc2NyaXB0U3R5bGVTZXQgfV0gPSB1c2VTdHlsZVNldCgpO1xuICAgIGNvbnN0IFt7IGJ1YmJsZUZyb21Vc2VyTnViT2Zmc2V0LCBidWJibGVOdWJPZmZzZXQsIGdyb3VwVGltZXN0YW1wLCBzaG93QXZhdGFySW5Hcm91cCB9XSA9IHVzZVN0eWxlT3B0aW9ucygpO1xuICAgIGNvbnN0IFthY3RpdmVEZXNjZW5kYW50SWRdID0gdXNlQWN0aXZlRGVzY2VuZGFudElkKCk7XG4gICAgY29uc3QgW2FjdGl2aXR5V2l0aFJlbmRlcmVyVHJlZV0gPSB1c2VBY3Rpdml0eVRyZWVXaXRoUmVuZGVyZXIoKTtcbiAgICBjb25zdCBbZGlyZWN0aW9uXSA9IHVzZURpcmVjdGlvbigpO1xuICAgIGNvbnN0IFtmb2N1c2VkQWN0aXZpdHlLZXldID0gdXNlRm9jdXNlZEFjdGl2aXR5S2V5KCk7XG4gICAgY29uc3QgW2ZvY3VzZWRFeHBsaWNpdGx5XSA9IHVzZUZvY3VzZWRFeHBsaWNpdGx5KCk7XG4gICAgY29uc3QgY3JlYXRlQWN0aXZpdHlTdGF0dXNSZW5kZXJlciA9IHVzZUNyZWF0ZUFjdGl2aXR5U3RhdHVzUmVuZGVyZXIoKTtcbiAgICBjb25zdCBjcmVhdGVBdmF0YXJSZW5kZXJlciA9IHVzZUNyZWF0ZUF2YXRhclJlbmRlcmVyKCk7XG4gICAgY29uc3QgZm9jdXMgPSB1c2VGb2N1cygpO1xuICAgIGNvbnN0IGZvY3VzQnlBY3Rpdml0eUtleSA9IHVzZUZvY3VzQnlBY3Rpdml0eUtleSgpO1xuICAgIGNvbnN0IGZvY3VzUmVsYXRpdmVBY3Rpdml0eSA9IHVzZUZvY3VzUmVsYXRpdmVBY3Rpdml0eSgpO1xuICAgIGNvbnN0IGdldEFjdGl2aXR5QnlLZXkgPSB1c2VHZXRBY3Rpdml0eUJ5S2V5KCk7XG4gICAgY29uc3QgZ2V0S2V5QnlBY3Rpdml0eSA9IHVzZUdldEtleUJ5QWN0aXZpdHkoKTtcbiAgICBjb25zdCBnZXRLZXlCeUFjdGl2aXR5SWQgPSB1c2VHZXRLZXlCeUFjdGl2aXR5SWQoKTtcbiAgICBjb25zdCBsb2NhbGl6ZSA9IHVzZUxvY2FsaXplcigpO1xuICAgIGNvbnN0IHJvb3RDbGFzc05hbWUgPSB1c2VTdHlsZVRvRW1vdGlvbk9iamVjdCgpKFJPT1RfU1RZTEUpICsgJyc7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnRSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KCk7XG4gICAgY29uc3QgdGVybWluYXRvckxhYmVsSWQgPSB1c2VVbmlxdWVJZCgnd2ViY2hhdF9fYmFzaWMtdHJhbnNjcmlwdF9fdGVybWluYXRvci1sYWJlbCcpO1xuICAgIGNvbnN0IHRlcm1pbmF0b3JSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KCk7XG5cbiAgICBjb25zdCBmb2N1c2VkQWN0aXZpdHlLZXlSZWYgPSB1c2VWYWx1ZVJlZihmb2N1c2VkQWN0aXZpdHlLZXkpO1xuICAgIGNvbnN0IGhpZGVBbGxUaW1lc3RhbXBzID0gZ3JvdXBUaW1lc3RhbXAgPT09IGZhbHNlO1xuICAgIGNvbnN0IHRlcm1pbmF0b3JUZXh0ID0gbG9jYWxpemUoJ1RSQU5TQ1JJUFRfVEVSTUlOQVRPUl9URVhUJyk7XG4gICAgY29uc3QgdHJhbnNjcmlwdEFyaWFMYWJlbCA9IGxvY2FsaXplKCdUUkFOU0NSSVBUX0FSSUFfTEFCRUxfQUxUJyk7XG5cbiAgICBjb25zdCBjYWxsYmFja1JlZiA9IHVzZUNhbGxiYWNrKFxuICAgICAgKGVsZW1lbnQ6IEhUTUxEaXZFbGVtZW50KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVmKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3RFbGVtZW50UmVmLmN1cnJlbnQgPSBlbGVtZW50O1xuICAgICAgfSxcbiAgICAgIFtyZWYsIHJvb3RFbGVtZW50UmVmXVxuICAgICk7XG5cbiAgICAvLyBGbGF0dGVuIHRoZSB0cmVlIGJhY2sgaW50byBhbiBhcnJheSB3aXRoIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gcmVuZGVyaW5nLlxuICAgIGNvbnN0IHJlbmRlcmluZ0VsZW1lbnRzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICBjb25zdCByZW5kZXJpbmdFbGVtZW50czogUmVuZGVyaW5nRWxlbWVudFtdID0gW107XG4gICAgICBjb25zdCB0b3BTaWRlQm90TnViID0gaXNaZXJvT3JQb3NpdGl2ZShidWJibGVOdWJPZmZzZXQpO1xuICAgICAgY29uc3QgdG9wU2lkZVVzZXJOdWIgPSBpc1plcm9PclBvc2l0aXZlKGJ1YmJsZUZyb21Vc2VyTnViT2Zmc2V0KTtcblxuICAgICAgYWN0aXZpdHlXaXRoUmVuZGVyZXJUcmVlLmZvckVhY2goZW50cmllc1dpdGhTYW1lU2VuZGVyID0+IHtcbiAgICAgICAgY29uc3QgW1t7IGFjdGl2aXR5OiBmaXJzdEFjdGl2aXR5IH1dXSA9IGVudHJpZXNXaXRoU2FtZVNlbmRlcjtcbiAgICAgICAgY29uc3QgcmVuZGVyQXZhdGFyID0gY3JlYXRlQXZhdGFyUmVuZGVyZXIoeyBhY3Rpdml0eTogZmlyc3RBY3Rpdml0eSB9KTtcblxuICAgICAgICBlbnRyaWVzV2l0aFNhbWVTZW5kZXIuZm9yRWFjaCgoZW50cmllc1dpdGhTYW1lU2VuZGVyQW5kU3RhdHVzLCBpbmRleFdpdGhpblNlbmRlckdyb3VwKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlyc3RJblNlbmRlckdyb3VwID0gIWluZGV4V2l0aGluU2VuZGVyR3JvdXA7XG4gICAgICAgICAgY29uc3QgbGFzdEluU2VuZGVyR3JvdXAgPSBpbmRleFdpdGhpblNlbmRlckdyb3VwID09PSBlbnRyaWVzV2l0aFNhbWVTZW5kZXIubGVuZ3RoIC0gMTtcblxuICAgICAgICAgIGVudHJpZXNXaXRoU2FtZVNlbmRlckFuZFN0YXR1cy5mb3JFYWNoKCh7IGFjdGl2aXR5LCByZW5kZXJBY3Rpdml0eSB9LCBpbmRleFdpdGhpblNlbmRlckFuZFN0YXR1c0dyb3VwKSA9PiB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IHNob3cgdGhlIHRpbWVzdGFtcCBhdCB0aGUgZW5kIG9mIHRoZSBzZW5kZXIgZ3JvdXAuIEJ1dCB3ZSBhbHdheXMgc2hvdyB0aGUgXCJTZW5kIGZhaWxlZCwgcmV0cnlcIiBwcm9tcHQuXG4gICAgICAgICAgICBjb25zdCBmaXJzdEluU2VuZGVyQW5kU3RhdHVzR3JvdXAgPSAhaW5kZXhXaXRoaW5TZW5kZXJBbmRTdGF0dXNHcm91cDtcbiAgICAgICAgICAgIGNvbnN0IGtleTogc3RyaW5nID0gZ2V0S2V5QnlBY3Rpdml0eShhY3Rpdml0eSk7XG4gICAgICAgICAgICBjb25zdCBsYXN0SW5TZW5kZXJBbmRTdGF0dXNHcm91cCA9XG4gICAgICAgICAgICAgIGluZGV4V2l0aGluU2VuZGVyQW5kU3RhdHVzR3JvdXAgPT09IGVudHJpZXNXaXRoU2FtZVNlbmRlckFuZFN0YXR1cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyQWN0aXZpdHlTdGF0dXMgPSBjcmVhdGVBY3Rpdml0eVN0YXR1c1JlbmRlcmVyKHtcbiAgICAgICAgICAgICAgYWN0aXZpdHksXG4gICAgICAgICAgICAgIG5leHRWaXNpYmxlQWN0aXZpdHk6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0b3BTaWRlTnViID0gYWN0aXZpdHkuZnJvbT8ucm9sZSA9PT0gJ3VzZXInID8gdG9wU2lkZVVzZXJOdWIgOiB0b3BTaWRlQm90TnViO1xuXG4gICAgICAgICAgICBsZXQgc2hvd0NhbGxvdXQ6IGJvb2xlYW47XG5cbiAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgXCJzaG93QXZhdGFySW5Hcm91cFwiIHNldHRpbmcsIHRoZSBhdmF0YXIgd2lsbCByZW5kZXIgaW4gZGlmZmVyZW50IHBvc2l0aW9ucy5cbiAgICAgICAgICAgIGlmIChzaG93QXZhdGFySW5Hcm91cCA9PT0gJ3NlbmRlcicpIHtcbiAgICAgICAgICAgICAgaWYgKHRvcFNpZGVOdWIpIHtcbiAgICAgICAgICAgICAgICBzaG93Q2FsbG91dCA9IGZpcnN0SW5TZW5kZXJHcm91cCAmJiBmaXJzdEluU2VuZGVyQW5kU3RhdHVzR3JvdXA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hvd0NhbGxvdXQgPSBsYXN0SW5TZW5kZXJHcm91cCAmJiBsYXN0SW5TZW5kZXJBbmRTdGF0dXNHcm91cDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaG93QXZhdGFySW5Hcm91cCA9PT0gJ3N0YXR1cycpIHtcbiAgICAgICAgICAgICAgaWYgKHRvcFNpZGVOdWIpIHtcbiAgICAgICAgICAgICAgICBzaG93Q2FsbG91dCA9IGZpcnN0SW5TZW5kZXJBbmRTdGF0dXNHcm91cDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaG93Q2FsbG91dCA9IGxhc3RJblNlbmRlckFuZFN0YXR1c0dyb3VwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzaG93Q2FsbG91dCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcmluZ0VsZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICBhY3Rpdml0eSxcblxuICAgICAgICAgICAgICAvLyBBZnRlciB0aGUgZWxlbWVudCBpcyBtb3VudGVkLCBzZXQgaXQgdG8gYWN0aXZpdHlFbGVtZW50c1JlZi5cbiAgICAgICAgICAgICAgY2FsbGJhY2tSZWY6IGFjdGl2aXR5RWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgYWN0aXZpdHlFbGVtZW50XG4gICAgICAgICAgICAgICAgICA/IGFjdGl2aXR5RWxlbWVudE1hcFJlZi5jdXJyZW50LnNldChrZXksIGFjdGl2aXR5RWxlbWVudClcbiAgICAgICAgICAgICAgICAgIDogYWN0aXZpdHlFbGVtZW50TWFwUmVmLmN1cnJlbnQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgLy8gXCJoaWRlVGltZXN0YW1wXCIgaXMgYSByZW5kZXItdGltZSBwYXJhbWV0ZXIgZm9yIHJlbmRlckFjdGl2aXR5U3RhdHVzKCkuXG4gICAgICAgICAgICAgIC8vIElmIHRydWUsIGl0IHdpbGwgaGlkZSB0aGUgdGltZXN0YW1wLCBidXQgaXQgd2lsbCBjb250aW51ZSB0byBzaG93IHRoZVxuICAgICAgICAgICAgICAvLyByZXRyeSBwcm9tcHQuIEFuZCBzaG93IHRoZSBzY3JlZW4gcmVhZGVyIHZlcnNpb24gb2YgdGhlIHRpbWVzdGFtcC5cbiAgICAgICAgICAgICAgaGlkZVRpbWVzdGFtcDpcbiAgICAgICAgICAgICAgICBoaWRlQWxsVGltZXN0YW1wcyB8fCBpbmRleFdpdGhpblNlbmRlckFuZFN0YXR1c0dyb3VwICE9PSBlbnRyaWVzV2l0aFNhbWVTZW5kZXJBbmRTdGF0dXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICByZW5kZXJBY3Rpdml0eSxcbiAgICAgICAgICAgICAgcmVuZGVyQWN0aXZpdHlTdGF0dXMsXG4gICAgICAgICAgICAgIHJlbmRlckF2YXRhcixcbiAgICAgICAgICAgICAgc2hvd0NhbGxvdXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVuZGVyaW5nRWxlbWVudHM7XG4gICAgfSwgW1xuICAgICAgYWN0aXZpdHlFbGVtZW50TWFwUmVmLFxuICAgICAgYWN0aXZpdHlXaXRoUmVuZGVyZXJUcmVlLFxuICAgICAgYnViYmxlRnJvbVVzZXJOdWJPZmZzZXQsXG4gICAgICBidWJibGVOdWJPZmZzZXQsXG4gICAgICBjcmVhdGVBY3Rpdml0eVN0YXR1c1JlbmRlcmVyLFxuICAgICAgY3JlYXRlQXZhdGFyUmVuZGVyZXIsXG4gICAgICBnZXRLZXlCeUFjdGl2aXR5LFxuICAgICAgaGlkZUFsbFRpbWVzdGFtcHMsXG4gICAgICBzaG93QXZhdGFySW5Hcm91cFxuICAgIF0pO1xuXG4gICAgY29uc3Qgc2Nyb2xsVG9Cb3R0b21TY3JvbGxUbzogKHNjcm9sbFRvcDogbnVtYmVyLCBvcHRpb25zPzogU2Nyb2xsVG9PcHRpb25zKSA9PiB2b2lkID0gdXNlU2Nyb2xsVG8oKTtcbiAgICBjb25zdCBzY3JvbGxUb0JvdHRvbVNjcm9sbFRvRW5kOiAob3B0aW9ucz86IFNjcm9sbFRvT3B0aW9ucykgPT4gdm9pZCA9IHVzZVNjcm9sbFRvRW5kKCk7XG5cbiAgICBjb25zdCBzY3JvbGxUbyA9IHVzZUNhbGxiYWNrKFxuICAgICAgKHBvc2l0aW9uOiBTY3JvbGxUb1Bvc2l0aW9uLCB7IGJlaGF2aW9yID0gJ2F1dG8nIH06IFNjcm9sbFRvT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnYm90ZnJhbWV3b3JrLXdlYmNoYXQ6IEZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBcInVzZVNjcm9sbFRvXCIgbXVzdCBiZSBhIFNjcm9sbFBvc2l0aW9uIG9iamVjdC4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgYWN0aXZpdHlJRDogYWN0aXZpdHlJZCwgc2Nyb2xsVG9wIH0gPSBwb3NpdGlvbjtcblxuICAgICAgICBpZiAodHlwZW9mIHNjcm9sbFRvcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzY3JvbGxUb0JvdHRvbVNjcm9sbFRvKHNjcm9sbFRvcCwgeyBiZWhhdmlvciB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYWN0aXZpdHlJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zdCBhY3Rpdml0eUJvdW5kaW5nQm94RWxlbWVudCA9IGFjdGl2aXR5RWxlbWVudE1hcFJlZi5jdXJyZW50XG4gICAgICAgICAgICAuZ2V0KGdldEtleUJ5QWN0aXZpdHlJZChhY3Rpdml0eUlkKSlcbiAgICAgICAgICAgID8ucXVlcnlTZWxlY3RvcignLndlYmNoYXRfX2Jhc2ljLXRyYW5zY3JpcHRfX2FjdGl2aXR5LWFjdGl2ZS1kZXNjZW5kYW50Jyk7XG5cbiAgICAgICAgICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IHJvb3RFbGVtZW50UmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvcignLndlYmNoYXRfX2Jhc2ljLXRyYW5zY3JpcHRfX3Njcm9sbGFibGUnKTtcblxuICAgICAgICAgIGlmIChzY3JvbGxhYmxlRWxlbWVudCAmJiBhY3Rpdml0eUJvdW5kaW5nQm94RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gRVNMaW50IGNvbmZsaWN0IHdpdGggVHlwZVNjcmlwdC4gVGhlIHJlc3VsdCBvZiBnZXRDbGllbnRSZWN0cygpIGlzIG5vdCBhbiBBcnJheSBidXQgRE9NUmVjdExpc3QsIGFuZCBjYW5ub3QgYmUgZGVzdHJ1Y3R1cmVkLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICBjb25zdCBhY3Rpdml0eUJvdW5kaW5nQm94RWxlbWVudENsaWVudFJlY3QgPSBhY3Rpdml0eUJvdW5kaW5nQm94RWxlbWVudC5nZXRDbGllbnRSZWN0cygpWzBdO1xuXG4gICAgICAgICAgICAvLyBFU0xpbnQgY29uZmxpY3Qgd2l0aCBUeXBlU2NyaXB0LiBUaGUgcmVzdWx0IG9mIGdldENsaWVudFJlY3RzKCkgaXMgbm90IGFuIEFycmF5IGJ1dCBET01SZWN0TGlzdCwgYW5kIGNhbm5vdCBiZSBkZXN0cnVjdHVyZWQuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50Q2xpZW50UmVjdCA9IHNjcm9sbGFibGVFbGVtZW50LmdldENsaWVudFJlY3RzKClbMF07XG5cbiAgICAgICAgICAgIC8vIElmIGVpdGhlciB0aGUgYWN0aXZpdHkgb3IgdGhlIHRyYW5zY3JpcHQgc2Nyb2xsYWJsZSBpcyBub3Qgb24gRE9NLCB3ZSB3aWxsIG5vdCBzY3JvbGwgdGhlIHZpZXcuXG4gICAgICAgICAgICBpZiAoYWN0aXZpdHlCb3VuZGluZ0JveEVsZW1lbnRDbGllbnRSZWN0ICYmIHNjcm9sbGFibGVFbGVtZW50Q2xpZW50UmVjdCkge1xuICAgICAgICAgICAgICBjb25zdCB7IGhlaWdodDogYWN0aXZpdHlIZWlnaHQsIHk6IGFjdGl2aXR5WSB9ID0gYWN0aXZpdHlCb3VuZGluZ0JveEVsZW1lbnRDbGllbnRSZWN0O1xuICAgICAgICAgICAgICBjb25zdCB7IGhlaWdodDogc2Nyb2xsYWJsZUhlaWdodCB9ID0gc2Nyb2xsYWJsZUVsZW1lbnRDbGllbnRSZWN0O1xuICAgICAgICAgICAgICBjb25zdCBhY3Rpdml0eU9mZnNldFRvcCA9IGFjdGl2aXR5WSArIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbFRvcDtcblxuICAgICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBNYXRoLm1pbihhY3Rpdml0eU9mZnNldFRvcCwgYWN0aXZpdHlPZmZzZXRUb3AgLSBzY3JvbGxhYmxlSGVpZ2h0ICsgYWN0aXZpdHlIZWlnaHQpO1xuXG4gICAgICAgICAgICAgIHNjcm9sbFRvQm90dG9tU2Nyb2xsVG8oc2Nyb2xsVG9wLCB7IGJlaGF2aW9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFthY3Rpdml0eUVsZW1lbnRNYXBSZWYsIGdldEtleUJ5QWN0aXZpdHlJZCwgcm9vdEVsZW1lbnRSZWYsIHNjcm9sbFRvQm90dG9tU2Nyb2xsVG9dXG4gICAgKTtcblxuICAgIGNvbnN0IHNjcm9sbFRvRW5kID0gdXNlQ2FsbGJhY2soXG4gICAgICAoKSA9PiBzY3JvbGxUb0JvdHRvbVNjcm9sbFRvRW5kKHsgYmVoYXZpb3I6ICdzbW9vdGgnIH0pLFxuICAgICAgW3Njcm9sbFRvQm90dG9tU2Nyb2xsVG9FbmRdXG4gICAgKTtcblxuICAgIGNvbnN0IHNjcm9sbFJlbGF0aXZlID0gdXNlQ2FsbGJhY2soXG4gICAgICAoZGlyZWN0aW9uOiAnZG93bicgfCAndXAnLCB7IGRpc3BsYWNlbWVudCB9OiB7IGRpc3BsYWNlbWVudD86IG51bWJlciB9ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50OiByb290RWxlbWVudCB9ID0gcm9vdEVsZW1lbnRSZWY7XG5cbiAgICAgICAgaWYgKCFyb290RWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGU6IEhUTUxFbGVtZW50ID0gcm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvcignLndlYmNoYXRfX2Jhc2ljLXRyYW5zY3JpcHRfX3Njcm9sbGFibGUnKTtcbiAgICAgICAgbGV0IG5leHRTY3JvbGxUb3A6IG51bWJlcjtcblxuICAgICAgICBpZiAodHlwZW9mIGRpc3BsYWNlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgICAgIG5leHRTY3JvbGxUb3AgPSBzY3JvbGxhYmxlLnNjcm9sbFRvcCArIChkaXJlY3Rpb24gPT09ICdkb3duJyA/IDEgOiAtMSkgKiBkaXNwbGFjZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgICAgICAgICBuZXh0U2Nyb2xsVG9wID0gc2Nyb2xsYWJsZS5zY3JvbGxUb3AgKyAoZGlyZWN0aW9uID09PSAnZG93bicgPyAxIDogLTEpICogc2Nyb2xsYWJsZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGxUbyhcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzY3JvbGxUb3A6IE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsYWJsZS5vZmZzZXRIZWlnaHQsIG5leHRTY3JvbGxUb3ApKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBiZWhhdmlvcjogJ3Ntb290aCcgfVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIFtyb290RWxlbWVudFJlZiwgc2Nyb2xsVG9dXG4gICAgKTtcblxuICAgIC8vIFNpbmNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGluc3RhbmNlcyBvZiA8QmFzaWNUcmFuc2NyaXB0PiBpbnNpZGUgdGhlIDxDb21wb3Nlcj4sIHdoZW4gdGhlIGRldmVsb3BlciBjYWxscyBgc2Nyb2xsWFhYYCwgd2UgbmVlZCB0byBjYWxsIGl0IG9uIGFsbCBpbnN0YW5jZXMuXG4gICAgLy8gV2UgY2FsbCBgdXNlUmVnaXN0ZXJTY3JvbGxYWFhgIHRvIHJlZ2lzdGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24sIHRoZSBgdXNlU2Nyb2xsWFhYYCB3aWxsIG11bHRpcGxleCB0aGUgY2FsbCBpbnRvIGVhY2ggaW5zdGFuY2Ugb2YgPEJhc2ljVHJhbnNjcmlwdD4uXG4gICAgdXNlUmVnaXN0ZXJTY3JvbGxUbyhzY3JvbGxUbyk7XG4gICAgdXNlUmVnaXN0ZXJTY3JvbGxUb0VuZChzY3JvbGxUb0VuZCk7XG4gICAgdXNlUmVnaXN0ZXJTY3JvbGxSZWxhdGl2ZShzY3JvbGxSZWxhdGl2ZSk7XG5cbiAgICBjb25zdCBtYXJrQWN0aXZpdHlLZXlBc1JlYWQgPSB1c2VNYXJrQWN0aXZpdHlLZXlBc1JlYWQoKTtcblxuICAgIGNvbnN0IGRpc3BhdGNoU2Nyb2xsUG9zaXRpb25XaXRoQWN0aXZpdHlJZDogKHNjcm9sbFBvc2l0aW9uOiBTY3JvbGxUb1Bvc2l0aW9uKSA9PiB2b2lkID1cbiAgICAgIHVzZURpc3BhdGNoU2Nyb2xsUG9zaXRpb24oKTtcblxuICAgIC8vIFRPRE86IFtQMl0gV2Ugc2hvdWxkIHVzZSBJbnRlcnNlY3Rpb25PYnNlcnZlciB0byB0cmFjayB3aGF0IGFjdGl2aXR5IGlzIGluIHRoZSBzY3JvbGxhYmxlLlxuICAgIC8vICAgICAgICAgICAgSG93ZXZlciwgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgbm90IGF2YWlsYWJsZSBvbiBJRTExLCB3ZSBuZWVkIHRvIG1ha2UgYSBsaW1pdGVkIHBvbHlmaWxsIGluIFJlYWN0IHN0eWxlLlxuICAgIGNvbnN0IGhhbmRsZVNjcm9sbFBvc2l0aW9uID0gdXNlQ2FsbGJhY2soXG4gICAgICAoeyBzY3JvbGxUb3AgfTogeyBzY3JvbGxUb3A6IG51bWJlciB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudDogcm9vdEVsZW1lbnQgfSA9IHJvb3RFbGVtZW50UmVmO1xuXG4gICAgICAgIGlmICghcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IHJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy53ZWJjaGF0X19iYXNpYy10cmFuc2NyaXB0X19zY3JvbGxhYmxlJyk7XG5cbiAgICAgICAgLy8gXCJnZXRDbGllbnRSZWN0cygpXCIgaXMgbm90IHJldHVybmluZyBhbiBhcnJheSwgdGh1cywgaXQgaXMgbm90IGRlc3RydWN0dXJhYmxlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZUVsZW1lbnRDbGllbnRSZWN0ID0gc2Nyb2xsYWJsZUVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKVswXTtcblxuICAgICAgICAvLyBJZiB0aGUgc2Nyb2xsYWJsZSBpcyBub3QgbW91bnRlZCwgd2UgY2Fubm90IG1lYXN1cmUgd2hpY2ggYWN0aXZpdHkgaXMgaW4gdmlldy4gVGh1cywgd2Ugd2lsbCBub3QgZmlyZSBhbnkgZXZlbnRzLlxuICAgICAgICBpZiAoIXNjcm9sbGFibGVFbGVtZW50Q2xpZW50UmVjdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgYm90dG9tOiBzY3JvbGxhYmxlQ2xpZW50Qm90dG9tIH0gPSBzY3JvbGxhYmxlRWxlbWVudENsaWVudFJlY3Q7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgYWN0aXZpdHkganVzdCBhYm92ZSBzY3JvbGwgdmlldyBib3R0b20uXG4gICAgICAgIC8vIElmIHRoZSBzY3JvbGwgdmlldyBpcyBhbHJlYWR5IG9uIHRvcCwgZ2V0IHRoZSBmaXJzdCBhY3Rpdml0eS5cbiAgICAgICAgY29uc3QgYWN0aXZpdHlFbGVtZW50cyA9IEFycmF5LmZyb20oYWN0aXZpdHlFbGVtZW50TWFwUmVmLmN1cnJlbnQuZW50cmllcygpKTtcbiAgICAgICAgY29uc3QgYWN0aXZpdHlLZXlKdXN0QWJvdmVTY3JvbGxCb3R0b206IHN0cmluZyB8IHVuZGVmaW5lZCA9IChcbiAgICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgID8gYWN0aXZpdHlFbGVtZW50c1xuICAgICAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAvLyBBZGQgc3VicGl4ZWwgdG9sZXJhbmNlXG4gICAgICAgICAgICAgICAgLmZpbmQoKFssIGVsZW1lbnRdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAvLyBcImdldENsaWVudFJlY3RzKClcIiBpcyBub3QgcmV0dXJuaW5nIGFuIGFycmF5LCB0aHVzLCBpdCBpcyBub3QgZGVzdHJ1Y3R1cmFibGUuXG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudC5nZXRDbGllbnRSZWN0cygpWzBdO1xuXG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYWN0aXZpdHkgaXMgbm90IGF0dGFjaGVkIHRvIERPTSB0cmVlLCB3ZSBzaG91bGQgbm90IGNvdW50IGl0IGFzIFwiYm90dG9tbW9zdCB2aXNpYmxlIGFjdGl2aXR5XCIsIGFzIGl0IGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRDbGllbnRSZWN0ICYmIGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSA8IHNjcm9sbGFibGVDbGllbnRCb3R0b20gKyAxO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGFjdGl2aXR5RWxlbWVudHNbMF1cbiAgICAgICAgKT8uWzBdO1xuXG4gICAgICAgIC8vIFdoZW4gdGhlIGVuZC11c2VyIHNsb3dseSBzY3JvbGxpbmcgdGhlIHZpZXcgZG93biwgd2Ugd2lsbCBtYXJrIGFjdGl2aXR5IGFzIHJlYWQgd2hlbiB0aGUgbWVzc2FnZSBmdWxseSBhcHBlYXIgb24gdGhlIHNjcmVlbi5cbiAgICAgICAgYWN0aXZpdHlLZXlKdXN0QWJvdmVTY3JvbGxCb3R0b20gJiYgbWFya0FjdGl2aXR5S2V5QXNSZWFkKGFjdGl2aXR5S2V5SnVzdEFib3ZlU2Nyb2xsQm90dG9tKTtcblxuICAgICAgICBpZiAoZGlzcGF0Y2hTY3JvbGxQb3NpdGlvbldpdGhBY3Rpdml0eUlkKSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZpdHkgPSBnZXRBY3Rpdml0eUJ5S2V5KGFjdGl2aXR5S2V5SnVzdEFib3ZlU2Nyb2xsQm90dG9tKTtcblxuICAgICAgICAgIGRpc3BhdGNoU2Nyb2xsUG9zaXRpb25XaXRoQWN0aXZpdHlJZCh7IC4uLihhY3Rpdml0eSA/IHsgYWN0aXZpdHlJRDogYWN0aXZpdHkuaWQgfSA6IHt9KSwgc2Nyb2xsVG9wIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICBhY3Rpdml0eUVsZW1lbnRNYXBSZWYsXG4gICAgICAgIGRpc3BhdGNoU2Nyb2xsUG9zaXRpb25XaXRoQWN0aXZpdHlJZCxcbiAgICAgICAgZ2V0QWN0aXZpdHlCeUtleSxcbiAgICAgICAgbWFya0FjdGl2aXR5S2V5QXNSZWFkLFxuICAgICAgICByb290RWxlbWVudFJlZlxuICAgICAgXVxuICAgICk7XG5cbiAgICB1c2VPYnNlcnZlU2Nyb2xsUG9zaXRpb24oaGFuZGxlU2Nyb2xsUG9zaXRpb24pO1xuXG4gICAgY29uc3QgaGFuZGxlVHJhbnNjcmlwdEtleURvd24gPSB1c2VDYWxsYmFjazxLZXlib2FyZEV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4+KFxuICAgICAgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gZXZlbnQ7XG5cbiAgICAgICAgY29uc3QgZnJvbUVuZE9mVHJhbnNjcmlwdEluZGljYXRvciA9IHRhcmdldCA9PT0gdGVybWluYXRvclJlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBmcm9tVHJhbnNjcmlwdCA9IHRhcmdldCA9PT0gZXZlbnQuY3VycmVudFRhcmdldDtcblxuICAgICAgICBpZiAoIWZyb21FbmRPZlRyYW5zY3JpcHRJbmRpY2F0b3IgJiYgIWZyb21UcmFuc2NyaXB0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhhbmRsZWQgPSB0cnVlO1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgIGZvY3VzUmVsYXRpdmVBY3Rpdml0eShmcm9tRW5kT2ZUcmFuc2NyaXB0SW5kaWNhdG9yID8gMCA6IDEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgICAgICAgICBmb2N1c1JlbGF0aXZlQWN0aXZpdHkoZnJvbUVuZE9mVHJhbnNjcmlwdEluZGljYXRvciA/IDAgOiAtMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0VuZCc6XG4gICAgICAgICAgICBmb2N1c1JlbGF0aXZlQWN0aXZpdHkoSW5maW5pdHkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGNhcHR1cmluZyBwbGFpbiBFTlRFUi5cbiAgICAgICAgICAgIC8vIFdoZW4gc2NyZWVuIHJlYWRlciBpcyBub3QgcnVubmluZywgb3Igc2NyZWVuIHJlYWRlciBpcyBydW5uaW5nIG91dHNpZGUgb2Ygc2NhbiBtb2RlLCB0aGUgRU5URVIga2V5IHdpbGwgYmUgY2FwdHVyZWQgaGVyZS5cbiAgICAgICAgICAgIGlmICghZnJvbUVuZE9mVHJhbnNjcmlwdEluZGljYXRvcikge1xuICAgICAgICAgICAgICBjb25zdCBib2R5OiBIVE1MRWxlbWVudCA9IGFjdGl2aXR5RWxlbWVudE1hcFJlZi5jdXJyZW50XG4gICAgICAgICAgICAgICAgLmdldChmb2N1c2VkQWN0aXZpdHlLZXlSZWYuY3VycmVudClcbiAgICAgICAgICAgICAgICA/LnF1ZXJ5U2VsZWN0b3IoJy53ZWJjaGF0X19iYXNpYy10cmFuc2NyaXB0X19hY3Rpdml0eS1ib2R5Jyk7XG5cbiAgICAgICAgICAgICAgdGFiYmFibGVFbGVtZW50cyhib2R5KVswXT8uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgICAgZm9jdXMoJ3NlbmRCb3hXaXRob3V0S2V5Ym9hcmQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICAgICAgICBmb2N1c1JlbGF0aXZlQWN0aXZpdHkoLUluZmluaXR5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgLy8gSWYgYSBjdXN0b20gSFRNTCBjb250cm9sIHdhbnRzIHRvIGhhbmRsZSB1cC9kb3duIGFycm93LCB3ZSB3aWxsIHByZXZlbnQgdGhlbSBmcm9tIGxpc3RlbmluZyB0byB0aGlzIGV2ZW50IHRvIHByZXZlbnQgYnVncyBkdWUgdG8gaGFuZGxpbmcgYXJyb3cga2V5cyB0d2ljZS5cbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFthY3Rpdml0eUVsZW1lbnRNYXBSZWYsIGZvY3VzLCBmb2N1c2VkQWN0aXZpdHlLZXlSZWYsIGZvY3VzUmVsYXRpdmVBY3Rpdml0eSwgdGVybWluYXRvclJlZl1cbiAgICApO1xuXG4gICAgY29uc3QgaGFuZGxlVHJhbnNjcmlwdEtleURvd25DYXB0dXJlID0gdXNlQ2FsbGJhY2s8S2V5Ym9hcmRFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+PihcbiAgICAgIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgeyBhbHRLZXksIGN0cmxLZXksIGtleSwgbWV0YUtleSwgdGFyZ2V0IH0gPSBldmVudDtcblxuICAgICAgICBpZiAoYWx0S2V5IHx8IChjdHJsS2V5ICYmIGtleSAhPT0gJ3YnKSB8fCBtZXRhS2V5IHx8ICghaW5wdXR0YWJsZUtleShrZXkpICYmIGtleSAhPT0gJ0JhY2tzcGFjZScpKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGlmIG9uZSBvZiB0aGUgdXRpbGl0eSBrZXkgKGV4Y2VwdCBTSElGVCkgaXMgcHJlc3NlZFxuICAgICAgICAgIC8vIEUuZy4gQ1RSTC1DIG9uIGEgbGluayBpbiBvbmUgb2YgdGhlIG1lc3NhZ2Ugc2hvdWxkIG5vdCBqdW1wIHRvIGNoYXQgYm94XG4gICAgICAgICAgLy8gRS5nLiBcIkFcIiBvciBcIkJhY2tzcGFjZVwiIHNob3VsZCBqdW1wIHRvIGNoYXQgYm94XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VuZCBrZXlzdHJva2VzIHRvIHNlbmQgYm94IGlmIHdlIGFyZSBmb2N1c2luZyBvbiB0aGUgdHJhbnNjcmlwdCBvciB0ZXJtaW5hdG9yLlxuICAgICAgICBpZiAodGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0IHx8IHRhcmdldCA9PT0gdGVybWluYXRvclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICBmb2N1cygnc2VuZEJveCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgW2ZvY3VzXVxuICAgICk7XG5cbiAgICB1c2VSZWdpc3RlckZvY3VzVHJhbnNjcmlwdCh1c2VDYWxsYmFjaygoKSA9PiBmb2N1c0J5QWN0aXZpdHlLZXkodW5kZWZpbmVkKSwgW2ZvY3VzQnlBY3Rpdml0eUtleV0pKTtcblxuICAgIC8vIFdoZW4gdGhlIGZvY3VzaW5nIGFjdGl2aXR5IGhhcyBjaGFuZ2VkLCBkaXNwYXRjaCBhbiBldmVudCB0byBvYnNlcnZlcnMgb2YgXCJ1c2VPYnNlcnZlVHJhbnNjcmlwdEZvY3VzXCIuXG4gICAgY29uc3QgZGlzcGF0Y2hUcmFuc2NyaXB0Rm9jdXNCeUFjdGl2aXR5S2V5ID0gdXNlRGlzcGF0Y2hUcmFuc2NyaXB0Rm9jdXNCeUFjdGl2aXR5S2V5KCk7XG5cbiAgICAvLyBEaXNwYXRjaCBhIFwidHJhbnNjcmlwdCBmb2N1c1wiIGV2ZW50IGJhc2VkIG9uIHVzZXIgc2VsZWN0aW9uLlxuICAgIC8vIFdlIHNob3VsZCBub3QgZGlzcGF0Y2ggXCJ0cmFuc2NyaXB0IGZvY3VzXCIgd2hlbiBhIG5ldyBhY3Rpdml0eSBjb21lLiBBbHRob3VnaCB0aGUgc2VsZWN0aW9uIGNoYW5nZSwgaXQgaXMgbm90IGluaXRpYXRlZCBmcm9tIHRoZSB1c2VyLlxuICAgIHVzZU1lbW8oXG4gICAgICAoKSA9PiBkaXNwYXRjaFRyYW5zY3JpcHRGb2N1c0J5QWN0aXZpdHlLZXkoZm9jdXNlZEV4cGxpY2l0bHkgPyBmb2N1c2VkQWN0aXZpdHlLZXkgOiB1bmRlZmluZWQpLFxuICAgICAgW2Rpc3BhdGNoVHJhbnNjcmlwdEZvY3VzQnlBY3Rpdml0eUtleSwgZm9jdXNlZEFjdGl2aXR5S2V5LCBmb2N1c2VkRXhwbGljaXRseV1cbiAgICApO1xuXG4gICAgLy8gV2hlbiB0aGUgdHJhbnNjcmlwdCBpcyBiZWluZyBmb2N1c2VkIG9uLCB3ZSBzaG91bGQgZGlzcGF0Y2ggYSBcInRyYW5zY3JpcHRmb2N1c1wiIGV2ZW50LlxuICAgIGNvbnN0IGhhbmRsZUZvY3VzID0gdXNlQ2FsbGJhY2soXG4gICAgICAvLyBXZSBjYWxsIFwiZm9jdXNCeUFjdGl2aXR5S2V5XCIgd2l0aCBhY3Rpdml0eSBrZXkgb2YgXCJ0cnVlXCIuXG4gICAgICAvLyBJdCBtZWFucywgdHJpZXMgdG8gZm9jdXMgb24gYW55dGhpbmcuXG4gICAgICAoeyBjdXJyZW50VGFyZ2V0LCB0YXJnZXQgfSkgPT4gdGFyZ2V0ID09PSBjdXJyZW50VGFyZ2V0ICYmIGZvY3VzQnlBY3Rpdml0eUtleSh0cnVlLCBmYWxzZSksXG4gICAgICBbZm9jdXNCeUFjdGl2aXR5S2V5XVxuICAgICk7XG5cbiAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIGJ5IElFMTEuXG4gICAgLy8gV2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW5kIGVtcHR5IHNwYWNlIChhLmsuYS4gZmlsbGVyKSBpbiBhbiBlbXB0eSB0cmFuc2NyaXB0LCBJRTExIHNheXMgdGhlIGZvY3VzIGlzIG9uIHRoZSA8ZGl2IGNsYXNzTmFtZT1cImZpbGxlclwiPixcbiAgICAvLyBkZXNwaXRlIHRoZSBmYWN0IHRoZXJlIGFyZSBubyBcInRhYkluZGV4XCIgYXR0cmlidXRlcyBzZXQgb24gdGhlIGZpbGxlci5cbiAgICAvLyBXZSBuZWVkIHRvIGFydGlmaWNpYWxseSBzZW5kIHRoZSBmb2N1cyBiYWNrIHRvIHRoZSB0cmFuc2NyaXB0LlxuICAgIGNvbnN0IGhhbmRsZUZvY3VzRmlsbGVyID0gdXNlQ2FsbGJhY2soKCkgPT4gZm9jdXNCeUFjdGl2aXR5S2V5KHVuZGVmaW5lZCksIFtmb2N1c0J5QWN0aXZpdHlLZXldKTtcblxuICAgIC8vIFdoZW4gZm9jdXMgaW50byB0aGUgdHJhbnNjcmlwdCB1c2luZyBUQUIvU0hJRlQtVEFCLCBzY3JvbGwgdGhlIGZvY3VzZWQgYWN0aXZpdHkgaW50byB2aWV3LlxuICAgIHVzZU9ic2VydmVGb2N1c1Zpc2libGUoXG4gICAgICByb290RWxlbWVudFJlZixcbiAgICAgIHVzZUNhbGxiYWNrKCgpID0+IGZvY3VzQnlBY3Rpdml0eUtleSh1bmRlZmluZWQpLCBbZm9jdXNCeUFjdGl2aXR5S2V5XSlcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgLy8gQWx0aG91Z2ggQW5kcm9pZCBUYWxrQmFjayAxMi4xIGRvZXMgbm90IHN1cHBvcnQgYGFyaWEtYWN0aXZlZGVzY2VuZGFudGAsIHdoZW4gdXNlZCwgaXQgYmVjb21lIGJ1Z2d5IGFuZCB3aWxsIG5hcnJhdGUgY29udGVudCB0d2ljZS5cbiAgICAgICAgLy8gV2UgYXJlIGRpc2FibGluZyBgYXJpYS1hY3RpdmVkZXNjZW5kYW50YCBmb3IgQW5kcm9pZC4gU2VlIDxBY3Rpdml0eVJvdz4gZm9yIGRldGFpbHMuXG4gICAgICAgIGFyaWEtYWN0aXZlZGVzY2VuZGFudD17YW5kcm9pZCA/IHVuZGVmaW5lZCA6IGFjdGl2ZURlc2NlbmRhbnRJZH1cbiAgICAgICAgYXJpYS1sYWJlbD17dHJhbnNjcmlwdEFyaWFMYWJlbH1cbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICd3ZWJjaGF0X19iYXNpYy10cmFuc2NyaXB0JyxcbiAgICAgICAgICBiYXNpY1RyYW5zY3JpcHRTdHlsZVNldCArICcnLFxuICAgICAgICAgIHJvb3RDbGFzc05hbWUsXG4gICAgICAgICAgKGNsYXNzTmFtZSB8fCAnJykgKyAnJ1xuICAgICAgICApfVxuICAgICAgICBkaXI9e2RpcmVjdGlvbn1cbiAgICAgICAgb25Gb2N1cz17aGFuZGxlRm9jdXN9XG4gICAgICAgIG9uS2V5RG93bj17aGFuZGxlVHJhbnNjcmlwdEtleURvd259XG4gICAgICAgIG9uS2V5RG93bkNhcHR1cmU9e2hhbmRsZVRyYW5zY3JpcHRLZXlEb3duQ2FwdHVyZX1cbiAgICAgICAgcmVmPXtjYWxsYmFja1JlZn1cbiAgICAgICAgLy8gXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiB3aWxsIG9ubHkgd29ya3Mgd2l0aCBhIG51bWJlciBvZiByb2xlcyBhbmQgaXQgbXVzdCBiZSBleHBsaWNpdGx5IHNldC5cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLyNhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcbiAgICAgICAgcm9sZT1cImdyb3VwXCJcbiAgICAgICAgLy8gRm9yIHVwL2Rvd24gYXJyb3cga2V5IG5hdmlnYXRpb24gYWNyb3NzIGFjdGl2aXRpZXMsIHRoaXMgY29tcG9uZW50IG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIHRhYiBzZXF1ZW5jZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiIHdpbGwgbm90IGJlIG5hcnJhdGVkIHdoZW4gdGhlIHVzZXIgcHJlc3MgdXAvZG93biBhcnJvdyBrZXlzLlxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtcHJhY3RpY2VzLTEuMS8ja2JkX2ZvY3VzX2FjdGl2ZWRlc2NlbmRhbnRcbiAgICAgICAgdGFiSW5kZXg9ezB9XG4gICAgICA+XG4gICAgICAgIDxMaXZlUmVnaW9uVHJhbnNjcmlwdCBhY3Rpdml0eUVsZW1lbnRNYXBSZWY9e2FjdGl2aXR5RWxlbWVudE1hcFJlZn0gLz5cbiAgICAgICAgey8qIFRPRE86IFtQMl0gRml4IEVTTGludCBlcnJvciBgbm8tdXNlLWJlZm9yZS1kZWZpbmVgICovfVxuICAgICAgICB7LyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqL31cbiAgICAgICAgPEludGVybmFsVHJhbnNjcmlwdFNjcm9sbGFibGUgb25Gb2N1c0ZpbGxlcj17aGFuZGxlRm9jdXNGaWxsZXJ9IHRlcm1pbmF0b3JSZWY9e3Rlcm1pbmF0b3JSZWZ9PlxuICAgICAgICAgIHtyZW5kZXJpbmdFbGVtZW50cy5tYXAoXG4gICAgICAgICAgICAoe1xuICAgICAgICAgICAgICBhY3Rpdml0eSxcbiAgICAgICAgICAgICAgY2FsbGJhY2tSZWYsXG4gICAgICAgICAgICAgIGhpZGVUaW1lc3RhbXAsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgcmVuZGVyQWN0aXZpdHksXG4gICAgICAgICAgICAgIHJlbmRlckFjdGl2aXR5U3RhdHVzLFxuICAgICAgICAgICAgICByZW5kZXJBdmF0YXIsXG4gICAgICAgICAgICAgIHNob3dDYWxsb3V0XG4gICAgICAgICAgICB9KSA9PiAoXG4gICAgICAgICAgICAgIDxBY3Rpdml0eVJvdyBhY3Rpdml0eT17YWN0aXZpdHl9IGtleT17a2V5fSByZWY9e2NhbGxiYWNrUmVmfT5cbiAgICAgICAgICAgICAgICB7cmVuZGVyQWN0aXZpdHkoe1xuICAgICAgICAgICAgICAgICAgaGlkZVRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckFjdGl2aXR5U3RhdHVzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyQXZhdGFyLFxuICAgICAgICAgICAgICAgICAgc2hvd0NhbGxvdXRcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgPC9BY3Rpdml0eVJvdz5cbiAgICAgICAgICAgIClcbiAgICAgICAgICApfVxuICAgICAgICA8L0ludGVybmFsVHJhbnNjcmlwdFNjcm9sbGFibGU+XG4gICAgICAgIHshIXJlbmRlcmluZ0VsZW1lbnRzLmxlbmd0aCAmJiAoXG4gICAgICAgICAgPEZyYWdtZW50PlxuICAgICAgICAgICAgPEZvY3VzUmVkaXJlY3RvciByZWRpcmVjdFJlZj17cm9vdEVsZW1lbnRSZWZ9IC8+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGFyaWEtbGFiZWxsZWRieT17dGVybWluYXRvckxhYmVsSWR9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndlYmNoYXRfX2Jhc2ljLXRyYW5zY3JpcHRfX3Rlcm1pbmF0b3JcIlxuICAgICAgICAgICAgICByZWY9e3Rlcm1pbmF0b3JSZWZ9XG4gICAgICAgICAgICAgIHJvbGU9XCJub3RlXCJcbiAgICAgICAgICAgICAgdGFiSW5kZXg9ezB9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2ViY2hhdF9fYmFzaWMtdHJhbnNjcmlwdF9fdGVybWluYXRvci1ib2R5XCI+XG4gICAgICAgICAgICAgICAgey8qIGBpZGAgaXMgcmVxdWlyZWQgZm9yIGBhcmlhLWxhYmVsbGVkYnlgICovfVxuICAgICAgICAgICAgICAgIHsvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZm9yYmlkLWRvbS1wcm9wcyAqL31cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIndlYmNoYXRfX2Jhc2ljLXRyYW5zY3JpcHRfX3Rlcm1pbmF0b3ItdGV4dFwiIGlkPXt0ZXJtaW5hdG9yTGFiZWxJZH0+XG4gICAgICAgICAgICAgICAgICB7dGVybWluYXRvclRleHR9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgICAgKX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3ZWJjaGF0X19iYXNpYy10cmFuc2NyaXB0X19mb2N1cy1pbmRpY2F0b3JcIiAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuKTtcblxuSW50ZXJuYWxUcmFuc2NyaXB0LmRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiAnJ1xufTtcblxuSW50ZXJuYWxUcmFuc2NyaXB0LmRpc3BsYXlOYW1lID0gJ0ludGVybmFsVHJhbnNjcmlwdCc7XG5cbkludGVybmFsVHJhbnNjcmlwdC5wcm9wVHlwZXMgPSB7XG4gIC8vIFByb3BUeXBlcyBjYW5ub3QgdmFsaWRhdGUgcHJlY2lzZWx5IHdpdGggaXRzIFR5cGVTY3JpcHQgY291bnRlcnBhcnQuXG4gIC8vIEB0cy1pZ25vcmVcbiAgYWN0aXZpdHlFbGVtZW50TWFwUmVmOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGN1cnJlbnQ6IFByb3BUeXBlcy5pbnN0YW5jZU9mKE1hcClcbiAgfSkuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG50eXBlIEludGVybmFsVHJhbnNjcmlwdFNjcm9sbGFibGVQcm9wcyA9IHtcbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIG9uRm9jdXNGaWxsZXI6ICgpID0+IHZvaWQ7XG4gIHRlcm1pbmF0b3JSZWY6IE11dGFibGVSZWZPYmplY3Q8SFRNTERpdkVsZW1lbnQ+O1xufTtcblxuLy8gU2VwYXJhdGluZyBoaWdoLWZyZXF1ZW5jeSBob29rcyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuY29uc3QgSW50ZXJuYWxUcmFuc2NyaXB0U2Nyb2xsYWJsZTogRkM8SW50ZXJuYWxUcmFuc2NyaXB0U2Nyb2xsYWJsZVByb3BzPiA9ICh7XG4gIGNoaWxkcmVuLFxuICBvbkZvY3VzRmlsbGVyLFxuICB0ZXJtaW5hdG9yUmVmXG59KSA9PiB7XG4gIGNvbnN0IFt7IGFjdGl2aXRpZXM6IGFjdGl2aXRpZXNTdHlsZVNldCB9XSA9IHVzZVN0eWxlU2V0KCk7XG4gIGNvbnN0IFthbmltYXRpbmdUb0VuZF06IFtib29sZWFuXSA9IHVzZUFuaW1hdGluZ1RvRW5kKCk7XG4gIGNvbnN0IFthdEVuZF06IFtib29sZWFuXSA9IHVzZUF0RW5kKCk7XG4gIGNvbnN0IFssIHVucmVhZEFjdGl2aXR5S2V5c10gPSB1c2VBY3Rpdml0eUtleXNCeVJlYWQoKTtcbiAgY29uc3QgW3N0aWNreV06IFtib29sZWFuXSA9IHVzZVN0aWNreSgpO1xuICBjb25zdCBbc3R5bGVPcHRpb25zXSA9IHVzZVN0eWxlT3B0aW9ucygpO1xuICBjb25zdCBmb2N1c0J5QWN0aXZpdHlLZXkgPSB1c2VGb2N1c0J5QWN0aXZpdHlLZXkoKTtcbiAgY29uc3QgbG9jYWxpemUgPSB1c2VMb2NhbGl6ZXIoKTtcbiAgY29uc3QgbWFya0FjdGl2aXR5S2V5QXNSZWFkID0gdXNlTWFya0FjdGl2aXR5S2V5QXNSZWFkKCk7XG4gIGNvbnN0IG1hcmtBbGxBc0Fja25vd2xlZGdlZCA9IHVzZU1hcmtBbGxBc0Fja25vd2xlZGdlZCgpO1xuICBjb25zdCBzY3JvbGxUb0VuZDogKG9wdGlvbnM/OiBTY3JvbGxUb09wdGlvbnMpID0+IHZvaWQgPSB1c2VTY3JvbGxUb0VuZCgpO1xuXG4gIGNvbnN0IHByZXZTdGlja3kgPSB1c2VQcmV2aW91cyhzdGlja3kpO1xuICBjb25zdCB0cmFuc2NyaXB0Um9sZURlc2NyaXB0aW9uID0gbG9jYWxpemUoJ1RSQU5TQ1JJUFRfQVJJQV9ST0xFX0FMVCcpO1xuXG4gIGNvbnN0IHN0aWNreUNoYW5nZWRUb1RydWUgPSBwcmV2U3RpY2t5ICE9PSBzdGlja3kgJiYgc3RpY2t5O1xuXG4gIC8vIEFja25vd2xlZGdlZCBtZWFucyBlaXRoZXI6XG4gIC8vIDEuIFRoZSB1c2VyIHNlbnQgYSBtZXNzYWdlXG4gIC8vICAgIC0gV2UgZG9uJ3QgbmVlZCBhIGNvbmRpdGlvbiBoZXJlLiBXaGVuIFdlYiBDaGF0IHNlbmRzIHRoZSB1c2VyJ3MgbWVzc2FnZSwgaXQgd2lsbCBzY3JvbGwgdG8gYm90dG9tLCBhbmQgaXQgd2lsbCB0cmlnZ2VyIGNvbmRpdGlvbiAyIGJlbG93LlxuICAvLyAyLiBUaGUgdXNlciBzY3JvbGwgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdHJhbnNjcmlwdCwgZnJvbSBhIG5vbi1ib3R0b20gc2Nyb2xsIHBvc2l0aW9uXG4gIC8vICAgIC0gSWYgdGhlIHRyYW5zY3JpcHQgaXMgYWxyZWFkeSBhdCB0aGUgYm90dG9tLCB0aGUgdXNlciBuZWVkcyB0byBzY3JvbGwgdXAgYW5kIHRoZW4gZ28gYmFjayBkb3duXG4gIC8vICAgIC0gV2hhdCBoYXBwZW5zIGlmIHdlIGFyZSByZWxheGluZyBcInNjcm9sbGVkIGZyb20gYSBub24tYm90dG9tIHNjcm9sbCBwb3NpdGlvblwiOlxuICAvLyAgICAgIDEuIFRoZSBjb25kaXRpb24gd2lsbCBiZWNvbWUgc29sZWx5IFwiYXQgdGhlIGJvdHRvbSBvZiB0aGUgdHJhbnNjcmlwdFwiXG4gIC8vICAgICAgMi4gQXV0by1zY3JvbGwgd2lsbCBhbHdheXMgc2Nyb2xsIHRoZSB0cmFuc2NyaXB0IHRvIHRoZSBib3R0b21cbiAgLy8gICAgICAzLiBXZWIgQ2hhdCB3aWxsIGFsd2F5cyBhY2tub3dsZWRnZSBhbGwgYWN0aXZpdGllcyBhcyBpdCBpcyBhdCB0aGUgYm90dG9tXG4gIC8vICAgICAgNC4gQWNrbm93bGVkZ2UgZmxhZyBiZWNvbWUgdXNlbGVzc1xuICAvLyAgICAgIDUuIFRoZXJlZm9yZSwgZXZlbiB0aGUgZGV2ZWxvcGVyIHNldCBcInBhdXNlIGFmdGVyIDMgYWN0aXZpdGllc1wiLCBpZiBhY3Rpdml0aWVzIGFyZSBjb21pbmcgaW4gYXQgYSBzbG93IHBhY2UgKG5vdCBiYXRjaGVkIGluIGEgc2luZ2xlIHJlbmRlcilcbiAgLy8gICAgICAgICBXZWIgQ2hhdCB3aWxsIGtlZXAgc2Nyb2xsaW5nIGFuZCBub3Qgc25hcHBlZC9wYXVzZWRcblxuICAvLyBOb3RlOiBXaGVuIFdlYiBDaGF0IGlzIGxvYWRlZCwgdGhlcmUgYXJlIG5vIGFjdGl2aXRpZXMgYWNrbm93bGVkZ2VkLiBXZSBuZWVkIHRvIGFzc3VtZSBhbGwgYXJyaXZpbmcgYWN0aXZpdGllcyBhcmUgYWNrbm93bGVkZ2VkIHVudGlsIGVuZC11c2VyIHNlbmRzIHRoZWlyIGZpcnN0IGFjdGl2aXR5LlxuICAvLyAgICAgICBBY3Rpdml0aWVzIGxvYWRlZCBpbml0aWFsbHkgY291bGQgYmUgZnJvbSBjb252ZXJzYXRpb24gaGlzdG9yeS4gV2l0aG91dCBhc3N1bWluZyBhY2tub3dsZWRnZW1lbnQsIFdlYiBDaGF0IHdpbGwgbm90IHNjcm9sbCBpbml0aWFsbHkgKGFzIGV2ZXJ5dGhpbmcgaXMgbm90IGFja25vd2xlZGdlZCkuXG4gIC8vICAgICAgIEl0IHdvdWxkIGJlIGJldHRlciBpZiB0aGUgY2hhdCBhZGFwdGVyIHNob3VsZCBsZXQgV2ViIENoYXQga25vdyBpZiB0aGUgYWN0aXZpdHkgaXMgbG9hZGVkIGZyb20gaGlzdG9yeSBvciBub3QuXG5cbiAgLy8gVE9ETzogW1AyXSAjMzY3MCBNb3ZlIHRoZSBcImNvbnZlcnNhdGlvbiBoaXN0b3J5IGFja25vd2xlZGdlbWVudFwiIGxvZ2ljIG1lbnRpb25lZCBhYm92ZSB0byBwb2x5ZmlsbCBvZiBjaGF0IGFkYXB0ZXJzLlxuICAvLyAgICAgICAxLiBDaGF0IGFkYXB0ZXIgc2hvdWxkIHNlbmQgXCJhY2tub3dsZWRnZWRcIiBhcyBwYXJ0IG9mIFwiY2hhbm5lbERhdGFcIlxuICAvLyAgICAgICAyLiBJZiBcImFja25vd2xlZGdlZFwiIGlzIFwidW5kZWZpbmVkXCIsIHdlIHNldCBpdCB0bzpcbiAgLy8gICAgICAgICAgYS4gdHJ1ZSwgaWYgdGhlcmUgYXJlIG5vIGVncmVzcyBhY3Rpdml0aWVzIHlldFxuICAvLyAgICAgICAgICBiLiBPdGhlcndpc2UsIGZhbHNlXG5cbiAgdXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgc3RpY2t5Q2hhbmdlZFRvVHJ1ZSAmJlxuICAgICAgLy8gVE9ETzogW1AyXSBCb3RoIGBtYXJrQWN0aXZpdHlLZXlBc1JlYWRgIGFuZCBgbWFya0FsbEFzQWNrbm93bGVkZ2VkYCBob29rIGFyZSBzZXR0ZXJzIG9mIHVzZVN0YXRlLlxuICAgICAgLy8gICAgICAgVGhpcyBtZWFucywgaW4gYSByZW5kZXIgbG9vcCwgd2Ugd2lsbCBiZSBjYWxsaW5nIHNldHRlciBhbmQgd2lsbCBjYXVzZSBhbm90aGVyIHJlLXJlbmRlci5cbiAgICAgIC8vICAgICAgIFRoaXMgaXMgbm90IHRyaXZpYWwgYnV0IHdlIHNob3VsZCB0aGluayBpZiB0aGVyZSBpcyBhIHdheSB0byBhdm9pZCB0aGlzLlxuICAgICAgbWFya0FsbEFzQWNrbm93bGVkZ2VkKCksXG4gICAgW21hcmtBbGxBc0Fja25vd2xlZGdlZCwgc3RpY2t5Q2hhbmdlZFRvVHJ1ZV1cbiAgKTtcblxuICBjb25zdCBbZmxhdHRlbmVkQWN0aXZpdHlUcmVlV2l0aFJlbmRlcmVyXSA9IHVzZUFjdGl2aXR5VHJlZVdpdGhSZW5kZXJlcih7IGZsYXQ6IHRydWUgfSk7XG4gIGNvbnN0IGdldEtleUJ5QWN0aXZpdHkgPSB1c2VHZXRLZXlCeUFjdGl2aXR5KCk7XG5cbiAgY29uc3QgcmVuZGVyaW5nQWN0aXZpdHlLZXlzOiBzdHJpbmdbXSA9IHVzZU1lbW88c3RyaW5nW10+KFxuICAgICgpID0+IGZsYXR0ZW5lZEFjdGl2aXR5VHJlZVdpdGhSZW5kZXJlci5tYXAoKHsgYWN0aXZpdHkgfSkgPT4gZ2V0S2V5QnlBY3Rpdml0eShhY3Rpdml0eSkpLFxuICAgIFtmbGF0dGVuZWRBY3Rpdml0eVRyZWVXaXRoUmVuZGVyZXIsIGdldEtleUJ5QWN0aXZpdHldXG4gICk7XG5cbiAgY29uc3QgcmVuZGVyaW5nQWN0aXZpdHlLZXlzUmVmID0gdXNlVmFsdWVSZWYocmVuZGVyaW5nQWN0aXZpdHlLZXlzKTtcblxuICAvLyBUbyBwcmV2ZW50IGZsYXNoeSBidXR0b24sIHdlIGFyZSBub3Qgd2FpdGluZyBmb3IgYW5vdGhlciByZW5kZXIgbG9vcCB0byB1cGRhdGUgdGhlIGBbcmVhZEFjdGl2aXR5S2V5cywgdW5yZWFkQWN0aXZpdHlLZXlzXWAgc3RhdGUuXG4gIC8vIEluc3RlYWQsIHdlIGFyZSBidWlsZGluZyB0aGUgbmV4dCBvbmUgaW4gdGhpcyBgdXNlTWVtb2AgY2FsbC5cbiAgY29uc3QgbmV4dFVucmVhZEFjdGl2aXR5S2V5cyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIC8vIFRoaXMgY29kZSBuZWVkIHRvIGJlIGNhcmVmdWwgcmV2aWV3ZWQgYXMgaXQgd2lsbCBjYXVzZSBhbm90aGVyIHJlbmRlci4gVGhlIGNvZGUgc2hvdWxkIGJlIGNvbnZlcmdpbmcuXG4gICAgLy8gQWZ0ZXIgd2UgY2FsbCBgbWFya0FjdGl2aXR5S2V5QXNSZWFkYCwgZXZlcnl0aGluZyB3aWxsIGJlIHJlYWQgYW5kIG5vdGhpbmcgd2lsbCBiZSB1bnJlYWQuXG4gICAgLy8gVGhhdCBtZWFucywgaW4gbmV4dCByZW5kZXIsIGB1bnJlYWRBY3Rpdml0eUtleXNgIHdpbGwgYmUgZW1wdGllZCBhbmQgdGhlIGBtYXJrQWN0aXZpdHlLZXlBc1JlYWRgIHdpbGwgbm90IGdldCBjYWxsZWQgYWdhaW4uXG4gICAgaWYgKHN0aWNreSAmJiB1bnJlYWRBY3Rpdml0eUtleXMubGVuZ3RoKSB7XG4gICAgICBtYXJrQWN0aXZpdHlLZXlBc1JlYWQodW5yZWFkQWN0aXZpdHlLZXlzW3VucmVhZEFjdGl2aXR5S2V5cy5sZW5ndGggLSAxXSk7XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5yZWFkQWN0aXZpdHlLZXlzO1xuICB9LCBbbWFya0FjdGl2aXR5S2V5QXNSZWFkLCBzdGlja3ksIHVucmVhZEFjdGl2aXR5S2V5c10pO1xuXG4gIGNvbnN0IG5leHRVbnJlYWRBY3Rpdml0eUtleXNSZWYgPSB1c2VWYWx1ZVJlZihuZXh0VW5yZWFkQWN0aXZpdHlLZXlzKTtcblxuICAvLyBJZiB3ZSBhcmUgcmVuZGVyaW5nIGFueXRoaW5nIHRoYXQgaXMgdW5yZWFkLCB3ZSBzaG91bGQgc2hvdyB0aGUgXCJOZXcgbWVzc2FnZXNcIiBidXR0b24uXG4gIC8vIE5vdCBldmVyeXRoaW5nIGluIHRoZSBgdW5yZWFkQWN0aXZpdHlLZXlzYCBhcmUgcmVuZGVyZWQsIHNheSwgYm90IHR5cGluZyBpbmRpY2F0b3IuXG4gIC8vIFdlIHNob3VsZCBub3Qgc2hvdyB0aGUgXCJOZXcgbWVzc2FnZXNcIiBidXR0b24gZm9yIGJvdCB0eXBpbmcgaW5kaWNhdG9yIGFzIGl0IHdpbGwgY29uZnVzZSB0aGUgdXNlci5cbiAgY29uc3QgdW5yZWFkID0gdXNlTWVtbyhcbiAgICAoKSA9PiBuZXh0VW5yZWFkQWN0aXZpdHlLZXlzLnNvbWUoa2V5ID0+IHJlbmRlcmluZ0FjdGl2aXR5S2V5cy5pbmNsdWRlcyhrZXkpKSxcbiAgICBbcmVuZGVyaW5nQWN0aXZpdHlLZXlzLCBuZXh0VW5yZWFkQWN0aXZpdHlLZXlzXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZVNjcm9sbFRvRW5kQnV0dG9uQ2xpY2sgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2Nyb2xsVG9FbmQoeyBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XG5cbiAgICBjb25zdCB7IGN1cnJlbnQ6IHJlbmRlcmluZ0FjdGl2aXR5S2V5cyB9ID0gcmVuZGVyaW5nQWN0aXZpdHlLZXlzUmVmO1xuXG4gICAgLy8gQWZ0ZXIgdGhlIFwiTmV3IG1lc3NhZ2VcIiBidXR0b24gaXMgY2xpY2tlZCwgZm9jdXMgb24gdGhlIGZpcnN0IHVucmVhZCBhY3Rpdml0eSB3aGljaCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgIGNvbnN0IGZpcnN0VW5yZWFkUmVuZGVyaW5nQWN0aXZpdHlLZXkgPSBuZXh0VW5yZWFkQWN0aXZpdHlLZXlzUmVmLmN1cnJlbnQuZmluZChrZXkgPT5cbiAgICAgIHJlbmRlcmluZ0FjdGl2aXR5S2V5cy5pbmNsdWRlcyhrZXkpXG4gICAgKTtcblxuICAgIGlmIChmaXJzdFVucmVhZFJlbmRlcmluZ0FjdGl2aXR5S2V5KSB7XG4gICAgICBmb2N1c0J5QWN0aXZpdHlLZXkoZmlyc3RVbnJlYWRSZW5kZXJpbmdBY3Rpdml0eUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHVucmVhZCBhY3Rpdml0eSwgc2VuZCB0aGUgZm9jdXMgdG8gdGhlIHRlcm1pbmF0b3IgYmxvY2suXG4gICAgICB0ZXJtaW5hdG9yUmVmLmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgfVxuICB9LCBbZm9jdXNCeUFjdGl2aXR5S2V5LCBuZXh0VW5yZWFkQWN0aXZpdHlLZXlzUmVmLCByZW5kZXJpbmdBY3Rpdml0eUtleXNSZWYsIHNjcm9sbFRvRW5kLCB0ZXJtaW5hdG9yUmVmXSk7XG5cbiAgY29uc3QgcmVuZGVyU2Nyb2xsVG9FbmRCdXR0b24gPSB1c2VDcmVhdGVTY3JvbGxUb0VuZEJ1dHRvblJlbmRlcmVyKCkoe1xuICAgIGF0RW5kOiBhbmltYXRpbmdUb0VuZCB8fCBhdEVuZCB8fCBzdGlja3ksXG4gICAgc3R5bGVPcHRpb25zLFxuICAgIHVucmVhZFxuICB9KTtcblxuICBjb25zdCBoYXNBbnlDaGlsZCA9ICEhUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pO1xuXG4gIHJldHVybiAoXG4gICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAge3JlbmRlclNjcm9sbFRvRW5kQnV0dG9uICYmIHJlbmRlclNjcm9sbFRvRW5kQnV0dG9uKHsgb25DbGljazogaGFuZGxlU2Nyb2xsVG9FbmRCdXR0b25DbGljayB9KX1cbiAgICAgIHtoYXNBbnlDaGlsZCAmJiA8Rm9jdXNSZWRpcmVjdG9yIHJlZGlyZWN0UmVmPXt0ZXJtaW5hdG9yUmVmfSAvPn1cbiAgICAgIDxSZWFjdFNjcm9sbFRvQm90dG9tUGFuZWwgY2xhc3NOYW1lPVwid2ViY2hhdF9fYmFzaWMtdHJhbnNjcmlwdF9fc2Nyb2xsYWJsZVwiPlxuICAgICAgICA8ZGl2IGFyaWEtaGlkZGVuPXt0cnVlfSBjbGFzc05hbWU9XCJ3ZWJjaGF0X19iYXNpYy10cmFuc2NyaXB0X19maWxsZXJcIiBvbkZvY3VzPXtvbkZvY3VzRmlsbGVyfSAvPlxuICAgICAgICB7aGFzQW55Q2hpbGQgJiYgKFxuICAgICAgICAgIDxzZWN0aW9uXG4gICAgICAgICAgICBhcmlhLXJvbGVkZXNjcmlwdGlvbj17dHJhbnNjcmlwdFJvbGVEZXNjcmlwdGlvbn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhhY3Rpdml0aWVzU3R5bGVTZXQgKyAnJywgJ3dlYmNoYXRfX2Jhc2ljLXRyYW5zY3JpcHRfX3RyYW5zY3JpcHQnKX1cbiAgICAgICAgICAgIHJvbGU9XCJmZWVkXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICApfVxuICAgICAgICA8QmFzaWNUeXBpbmdJbmRpY2F0b3IgLz5cbiAgICAgIDwvUmVhY3RTY3JvbGxUb0JvdHRvbVBhbmVsPlxuICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICk7XG59O1xuXG5JbnRlcm5hbFRyYW5zY3JpcHRTY3JvbGxhYmxlLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnkuaXNSZXF1aXJlZCxcbiAgb25Gb2N1c0ZpbGxlcjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgdGVybWluYXRvclJlZjogUHJvcFR5cGVzLmFueS5pc1JlcXVpcmVkXG59O1xuXG50eXBlIFNjcm9sbGVyID0gKHsgb2Zmc2V0SGVpZ2h0LCBzY3JvbGxUb3AgfTogeyBvZmZzZXRIZWlnaHQ6IG51bWJlcjsgc2Nyb2xsVG9wOiBudW1iZXIgfSkgPT4gbnVtYmVyO1xuXG4vLyBcInNjcm9sbGVyXCIgaXMgdGhlIGF1dG8tc2Nyb2xsIGxpbWl0ZXIsIGEuay5hLiBhdXRvIHNjcm9sbCBzbmFwLlxuY29uc3QgdXNlU2Nyb2xsZXIgPSAoYWN0aXZpdHlFbGVtZW50TWFwUmVmOiBNdXRhYmxlUmVmT2JqZWN0PEFjdGl2aXR5RWxlbWVudE1hcD4pOiBTY3JvbGxlciA9PiB7XG4gIGNvbnN0IFthY3Rpdml0eUtleXNdID0gdXNlQWN0aXZpdHlLZXlzKCk7XG4gIGNvbnN0IFtsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXldID0gdXNlTGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5KCk7XG4gIGNvbnN0IFtzdHlsZU9wdGlvbnNdID0gdXNlU3R5bGVPcHRpb25zKCk7XG5cbiAgY29uc3QgYWN0aXZpdHlLZXlzUmVmID0gdXNlVmFsdWVSZWYoYWN0aXZpdHlLZXlzKTtcbiAgY29uc3QgbGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5UmVmID0gdXNlVmFsdWVSZWYobGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5KTtcbiAgY29uc3Qgc3R5bGVPcHRpb25zUmVmID0gdXNlVmFsdWVSZWYoc3R5bGVPcHRpb25zKTtcblxuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgKHsgb2Zmc2V0SGVpZ2h0LCBzY3JvbGxUb3AgfSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50OiB7XG4gICAgICAgICAgYXV0b1Njcm9sbFNuYXBPbkFjdGl2aXR5LFxuICAgICAgICAgIGF1dG9TY3JvbGxTbmFwT25BY3Rpdml0eU9mZnNldCxcbiAgICAgICAgICBhdXRvU2Nyb2xsU25hcE9uUGFnZSxcbiAgICAgICAgICBhdXRvU2Nyb2xsU25hcE9uUGFnZU9mZnNldFxuICAgICAgICB9XG4gICAgICB9ID0gc3R5bGVPcHRpb25zUmVmO1xuXG4gICAgICBjb25zdCBwYXRjaGVkQXV0b1Njcm9sbFNuYXBPbkFjdGl2aXR5ID1cbiAgICAgICAgdHlwZW9mIGF1dG9TY3JvbGxTbmFwT25BY3Rpdml0eSA9PT0gJ251bWJlcidcbiAgICAgICAgICA/IE1hdGgubWF4KDAsIGF1dG9TY3JvbGxTbmFwT25BY3Rpdml0eSlcbiAgICAgICAgICA6IGF1dG9TY3JvbGxTbmFwT25BY3Rpdml0eVxuICAgICAgICAgID8gMVxuICAgICAgICAgIDogMDtcbiAgICAgIGNvbnN0IHBhdGNoZWRBdXRvU2Nyb2xsU25hcE9uUGFnZSA9XG4gICAgICAgIHR5cGVvZiBhdXRvU2Nyb2xsU25hcE9uUGFnZSA9PT0gJ251bWJlcidcbiAgICAgICAgICA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGF1dG9TY3JvbGxTbmFwT25QYWdlKSlcbiAgICAgICAgICA6IGF1dG9TY3JvbGxTbmFwT25QYWdlXG4gICAgICAgICAgPyAxXG4gICAgICAgICAgOiAwO1xuICAgICAgY29uc3QgcGF0Y2hlZEF1dG9TY3JvbGxTbmFwT25BY3Rpdml0eU9mZnNldCA9XG4gICAgICAgIHR5cGVvZiBhdXRvU2Nyb2xsU25hcE9uQWN0aXZpdHlPZmZzZXQgPT09ICdudW1iZXInID8gYXV0b1Njcm9sbFNuYXBPbkFjdGl2aXR5T2Zmc2V0IDogMDtcbiAgICAgIGNvbnN0IHBhdGNoZWRBdXRvU2Nyb2xsU25hcE9uUGFnZU9mZnNldCA9XG4gICAgICAgIHR5cGVvZiBhdXRvU2Nyb2xsU25hcE9uUGFnZU9mZnNldCA9PT0gJ251bWJlcicgPyBhdXRvU2Nyb2xsU25hcE9uUGFnZU9mZnNldCA6IDA7XG5cbiAgICAgIGlmIChwYXRjaGVkQXV0b1Njcm9sbFNuYXBPbkFjdGl2aXR5IHx8IHBhdGNoZWRBdXRvU2Nyb2xsU25hcE9uUGFnZSkge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQ6IGFjdGl2aXR5RWxlbWVudE1hcCB9ID0gYWN0aXZpdHlFbGVtZW50TWFwUmVmO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQ6IGFjdGl2aXR5S2V5cyB9ID0gYWN0aXZpdHlLZXlzUmVmO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQ6IGxhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleSB9ID0gbGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5UmVmO1xuICAgICAgICBjb25zdCB2YWx1ZXM6IG51bWJlcltdID0gW107XG5cbiAgICAgICAgY29uc3QgbGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5SW5kZXggPSBhY3Rpdml0eUtleXMuaW5kZXhPZihsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXkpO1xuXG4gICAgICAgIGlmICh+bGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5SW5kZXgpIHtcbiAgICAgICAgICAvLyBUaGUgYWN0aXZpdHkgdGhhdCB3ZSBhY2tub3dsZWRnZWQgY291bGQgYmUgbm90IHJlbmRlcmVkLCBzdWNoIGFzIHBvc3QgYmFjayBhY3Rpdml0eS5cbiAgICAgICAgICAvLyBXaGVuIGNhbGN1bGF0aW5nIHNjcm9sbCBzbmFwLCB3ZSBjYW4gb25seSBiYXNlIG9uIHRoZSBmaXJzdCB1bmFja25vd2xlZGdlZC1hbmQtcmVuZGVyaW5nIGFjdGl2aXR5LlxuICAgICAgICAgIGNvbnN0IHJlbmRlcmluZ0FjdGl2aXR5S2V5cyA9IEFycmF5LmZyb20oYWN0aXZpdHlFbGVtZW50TWFwLmtleXMoKSk7XG4gICAgICAgICAgbGV0IGZpcnN0VW5hY2tub3dsZWRnZWRBY3Rpdml0eUVsZW1lbnRJbmRleCA9IC0xO1xuXG4gICAgICAgICAgZm9yIChjb25zdCBhY2tub3dsZWRnZWRBY3Rpdml0eUtleSBvZiBhY3Rpdml0eUtleXMuc2xpY2UoMCwgbGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5SW5kZXggKyAxKS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmVuZGVyaW5nQWN0aXZpdHlLZXlzLmluZGV4T2YoYWNrbm93bGVkZ2VkQWN0aXZpdHlLZXkpO1xuXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gcmVuZGVyaW5nQWN0aXZpdHlLZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFVuYWNrbm93bGVkZ2VkQWN0aXZpdHlFbGVtZW50SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAofmZpcnN0VW5hY2tub3dsZWRnZWRBY3Rpdml0eUVsZW1lbnRJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZpdHlFbGVtZW50cyA9IEFycmF5LmZyb20oYWN0aXZpdHlFbGVtZW50TWFwLnZhbHVlcygpKTtcblxuICAgICAgICAgICAgaWYgKHBhdGNoZWRBdXRvU2Nyb2xsU25hcE9uQWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgLy8gR2V0cyB0aGUgYWN0aXZpdHkgZWxlbWVudCB3aGljaCB3ZSBzaG91bGQgc25hcCB0by5cbiAgICAgICAgICAgICAgY29uc3QgbnRoVW5hY2tub3dsZWRnZWRBY3Rpdml0eUVsZW1lbnQgPVxuICAgICAgICAgICAgICAgIGFjdGl2aXR5RWxlbWVudHNbZmlyc3RVbmFja25vd2xlZGdlZEFjdGl2aXR5RWxlbWVudEluZGV4ICsgcGF0Y2hlZEF1dG9TY3JvbGxTbmFwT25BY3Rpdml0eSAtIDFdO1xuXG4gICAgICAgICAgICAgIGlmIChudGhVbmFja25vd2xlZGdlZEFjdGl2aXR5RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG50aFVuYWNrbm93bGVkZ2VkQWN0aXZpdHlCb3VuZGluZ0JveEVsZW1lbnQgPSBudGhVbmFja25vd2xlZGdlZEFjdGl2aXR5RWxlbWVudD8ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgICAgICcud2ViY2hhdF9fYmFzaWMtdHJhbnNjcmlwdF9fYWN0aXZpdHktYWN0aXZlLWRlc2NlbmRhbnQnXG4gICAgICAgICAgICAgICAgKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBudGhVbmFja25vd2xlZGdlZEFjdGl2aXR5T2Zmc2V0VG9wID1cbiAgICAgICAgICAgICAgICAgIG50aFVuYWNrbm93bGVkZ2VkQWN0aXZpdHlFbGVtZW50Lm9mZnNldFRvcCArIG50aFVuYWNrbm93bGVkZ2VkQWN0aXZpdHlCb3VuZGluZ0JveEVsZW1lbnQub2Zmc2V0VG9wO1xuXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goXG4gICAgICAgICAgICAgICAgICBudGhVbmFja25vd2xlZGdlZEFjdGl2aXR5T2Zmc2V0VG9wICtcbiAgICAgICAgICAgICAgICAgICAgbnRoVW5hY2tub3dsZWRnZWRBY3Rpdml0eUJvdW5kaW5nQm94RWxlbWVudC5vZmZzZXRIZWlnaHQgLVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRIZWlnaHQgLVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3AgK1xuICAgICAgICAgICAgICAgICAgICBwYXRjaGVkQXV0b1Njcm9sbFNuYXBPbkFjdGl2aXR5T2Zmc2V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGF0Y2hlZEF1dG9TY3JvbGxTbmFwT25QYWdlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0VW5hY2tub3dsZWRnZWRBY3Rpdml0eUVsZW1lbnQgPSBhY3Rpdml0eUVsZW1lbnRzWytmaXJzdFVuYWNrbm93bGVkZ2VkQWN0aXZpdHlFbGVtZW50SW5kZXhdO1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdFVuYWNrbm93bGVkZ2VkQWN0aXZpdHlCb3VuZGluZ0JveEVsZW1lbnQgPSBmaXJzdFVuYWNrbm93bGVkZ2VkQWN0aXZpdHlFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgJy53ZWJjaGF0X19iYXNpYy10cmFuc2NyaXB0X19hY3Rpdml0eS1hY3RpdmUtZGVzY2VuZGFudCdcbiAgICAgICAgICAgICAgKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RVbmFja25vd2xlZGdlZEFjdGl2aXR5T2Zmc2V0VG9wID1cbiAgICAgICAgICAgICAgICBmaXJzdFVuYWNrbm93bGVkZ2VkQWN0aXZpdHlFbGVtZW50Lm9mZnNldFRvcCArIGZpcnN0VW5hY2tub3dsZWRnZWRBY3Rpdml0eUJvdW5kaW5nQm94RWxlbWVudC5vZmZzZXRUb3A7XG5cbiAgICAgICAgICAgICAgdmFsdWVzLnB1c2goXG4gICAgICAgICAgICAgICAgZmlyc3RVbmFja25vd2xlZGdlZEFjdGl2aXR5T2Zmc2V0VG9wIC1cbiAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCAtXG4gICAgICAgICAgICAgICAgICBvZmZzZXRIZWlnaHQgKiAoMSAtIHBhdGNoZWRBdXRvU2Nyb2xsU25hcE9uUGFnZSkgK1xuICAgICAgICAgICAgICAgICAgcGF0Y2hlZEF1dG9TY3JvbGxTbmFwT25QYWdlT2Zmc2V0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKC4uLnZhbHVlcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9LFxuICAgIFthY3Rpdml0eUVsZW1lbnRNYXBSZWYsIGFjdGl2aXR5S2V5c1JlZiwgbGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5UmVmLCBzdHlsZU9wdGlvbnNSZWZdXG4gICk7XG59O1xuXG50eXBlIEJhc2ljVHJhbnNjcmlwdFByb3BzID0ge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59O1xuXG5jb25zdCBCYXNpY1RyYW5zY3JpcHQ6IEZDPEJhc2ljVHJhbnNjcmlwdFByb3BzPiA9ICh7IGNsYXNzTmFtZSB9KSA9PiB7XG4gIGNvbnN0IGFjdGl2aXR5RWxlbWVudE1hcFJlZiA9IHVzZVJlZjxBY3Rpdml0eUVsZW1lbnRNYXA+KG5ldyBNYXAoKSk7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4oKTtcblxuICBjb25zdCBzY3JvbGxlciA9IHVzZVNjcm9sbGVyKGFjdGl2aXR5RWxlbWVudE1hcFJlZik7XG5cbiAgcmV0dXJuIChcbiAgICA8VHJhbnNjcmlwdEZvY3VzQ29tcG9zZXIgY29udGFpbmVyUmVmPXtjb250YWluZXJSZWZ9PlxuICAgICAgPFJlYWN0U2Nyb2xsVG9Cb3R0b21Db21wb3NlciBzY3JvbGxlcj17c2Nyb2xsZXJ9PlxuICAgICAgICA8S2V5Ym9hcmRIZWxwIC8+XG4gICAgICAgIDxJbnRlcm5hbFRyYW5zY3JpcHQgYWN0aXZpdHlFbGVtZW50TWFwUmVmPXthY3Rpdml0eUVsZW1lbnRNYXBSZWZ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSByZWY9e2NvbnRhaW5lclJlZn0gLz5cbiAgICAgIDwvUmVhY3RTY3JvbGxUb0JvdHRvbUNvbXBvc2VyPlxuICAgIDwvVHJhbnNjcmlwdEZvY3VzQ29tcG9zZXI+XG4gICk7XG59O1xuXG5CYXNpY1RyYW5zY3JpcHQuZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWU6ICcnXG59O1xuXG5CYXNpY1RyYW5zY3JpcHQucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2ljVHJhbnNjcmlwdDtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBVUE7O0FBQ0E7O0FBQ0E7O0FBT0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUNFQSxlQURGLEdBZUlDLDZCQWZKLENBQ0VELGVBREY7QUFBQSxJQUVFRSxxQkFGRixHQWVJRCw2QkFmSixDQUVFQyxxQkFGRjtBQUFBLElBR0VDLCtCQUhGLEdBZUlGLDZCQWZKLENBR0VFLCtCQUhGO0FBQUEsSUFJRUMsdUJBSkYsR0FlSUgsNkJBZkosQ0FJRUcsdUJBSkY7QUFBQSxJQUtFQyxrQ0FMRixHQWVJSiw2QkFmSixDQUtFSSxrQ0FMRjtBQUFBLElBTUVDLFlBTkYsR0FlSUwsNkJBZkosQ0FNRUssWUFORjtBQUFB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