"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.connectSendTextBox = void 0;
exports.useTextBoxSubmit = useTextBoxSubmit;
exports.useTextBoxValue = useTextBoxValue;

var _botframeworkWebchatApi = require("botframework-webchat-api");

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _detectBrowser = require("../Utils/detectBrowser");

var _AccessibleInputText = _interopRequireDefault(require("../Utils/AccessibleInputText"));

var _AutoResizeTextArea = _interopRequireDefault(require("./AutoResizeTextArea"));

var _connectToWebChat = _interopRequireDefault(require("../connectToWebChat"));

var _navigableEvent = _interopRequireDefault(require("../Utils/TypeFocusSink/navigableEvent"));

var _useRegisterFocusSendBox = _interopRequireDefault(require("../hooks/internal/useRegisterFocusSendBox"));

var _useReplaceEmoticon = _interopRequireDefault(require("../hooks/internal/useReplaceEmoticon"));

var _useScrollDown = _interopRequireDefault(require("../hooks/useScrollDown"));

var _useScrollUp = _interopRequireDefault(require("../hooks/useScrollUp"));

var _useStyleSet3 = _interopRequireDefault(require("../hooks/useStyleSet"));

var _useStyleToEmotionObject = _interopRequireDefault(require("../hooks/internal/useStyleToEmotionObject"));

var _useSubmit = _interopRequireDefault(require("../providers/internal/SendBox/useSubmit"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useDisabled = _botframeworkWebchatApi.hooks.useDisabled,
    useLocalizer = _botframeworkWebchatApi.hooks.useLocalizer,
    usePonyfill = _botframeworkWebchatApi.hooks.usePonyfill,
    useSendBoxValue = _botframeworkWebchatApi.hooks.useSendBoxValue,
    useStopDictate = _botframeworkWebchatApi.hooks.useStopDictate,
    useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions;
var ROOT_STYLE = {
  '&.webchat__send-box-text-box': {
    display: 'flex',
    '& .webchat__send-box-text-box__input, & .webchat__send-box-text-box__text-area': {
      flex: 1
    }
  }
};

var connectSendTextBox = function connectSendTextBox() {
  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {
    selectors[_key] = arguments[_key];
  }

  return _connectToWebChat.default.apply(void 0, [function (_ref) {
    var disabled = _ref.disabled,
        focusSendBox = _ref.focusSendBox,
        language = _ref.language,
        scrollToEnd = _ref.scrollToEnd,
        sendBoxValue = _ref.sendBoxValue,
        setSendBox = _ref.setSendBox,
        stopDictate = _ref.stopDictate,
        submitSendBox = _ref.submitSendBox;
    return {
      disabled: disabled,
      language: language,
      onChange: function onChange(_ref2) {
        var value = _ref2.target.value;
        setSendBox(value);
        stopDictate();
      },
      onKeyPress: function onKeyPress(event) {
        var key = event.key,
            shiftKey = event.shiftKey;

        if (key === 'Enter' && !shiftKey) {
          event.preventDefault();

          if (sendBoxValue) {
            scrollToEnd();
            submitSendBox();
            focusSendBox();
          }
        }
      },
      onSubmit: function onSubmit(event) {
        event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING
        // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box

        if (sendBoxValue) {
          scrollToEnd();
          submitSendBox();
        }
      },
      value: sendBoxValue
    };
  }].concat(selectors));
};
/**
 * Submits the text box and optionally set the focus after send.
 */


exports.connectSendTextBox = connectSendTextBox;

function useTextBoxSubmit() {
  var submit = (0, _useSubmit.default)();
  return (0, _react.useCallback)(function (setFocus) {
    return submit({
      setFocus: setFocus || undefined
    });
  }, [submit]);
}

function useTextBoxValue() {
  var _useSendBoxValue = useSendBoxValue(),
      _useSendBoxValue2 = _slicedToArray(_useSendBoxValue, 2),
      value = _useSendBoxValue2[0],
      setValue = _useSendBoxValue2[1];

  var replaceEmoticon = (0, _useReplaceEmoticon.default)();
  var stopDictate = useStopDictate();
  var setter = (0, _react.useCallback)(function (nextValue) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      selectionEnd: undefined,
      selectionStart: undefined
    },
        selectionEnd = _ref3.selectionEnd,
        selectionStart = _ref3.selectionStart;

    if (typeof nextValue !== 'string') {
      throw new Error('botframework-webchat: First argument passed to useTextBoxValue() must be a string.');
    } // Currently, we cannot detect whether the change is due to clipboard paste or pressing a key on the keyboard.
    // We should not change to emoji when the user is pasting text.
    // We would assume, for a single character addition, the user must be pressing a key.


    if (nextValue.length === value.length + 1) {
      var _replaceEmoticon = replaceEmoticon({
        selectionEnd: selectionEnd,
        selectionStart: selectionStart,
        value: nextValue
      }),
          nextSelectionEnd = _replaceEmoticon.selectionEnd,
          nextSelectionStart = _replaceEmoticon.selectionStart,
          nextValueWithEmoji = _replaceEmoticon.value;

      selectionEnd = nextSelectionEnd;
      selectionStart = nextSelectionStart;
      nextValue = nextValueWithEmoji;
    }

    setValue(nextValue);
    stopDictate();
    return {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: nextValue
    };
  }, [replaceEmoticon, setValue, stopDictate, value]);
  return [value, setter];
}

var PREVENT_DEFAULT_HANDLER = function PREVENT_DEFAULT_HANDLER(event) {
  return event.preventDefault();
};

var TextBox = function TextBox(_ref4) {
  var className = _ref4.className;

  var _useSendBoxValue3 = useSendBoxValue(),
      _useSendBoxValue4 = _slicedToArray(_useSendBoxValue3, 2),
      setSendBox = _useSendBoxValue4[1];

  var _useStyleSet = (0, _useStyleSet3.default)(),
      _useStyleSet2 = _slicedToArray(_useStyleSet, 1),
      sendBoxTextBoxStyleSet = _useStyleSet2[0].sendBoxTextBox;

  var _useStyleOptions = useStyleOptions(),
      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),
      sendBoxTextWrap = _useStyleOptions2[0].sendBoxTextWrap;

  var _usePonyfill = usePonyfill(),
      _usePonyfill2 = _slicedToArray(_usePonyfill, 1),
      setTimeout = _usePonyfill2[0].setTimeout;

  var _useDisabled = useDisabled(),
      _useDisabled2 = _slicedToArray(_useDisabled, 1),
      disabled = _useDisabled2[0];

  var _useTextBoxValue = useTextBoxValue(),
      _useTextBoxValue2 = _slicedToArray(_useTextBoxValue, 2),
      textBoxValue = _useTextBoxValue2[0],
      setTextBoxValue = _useTextBoxValue2[1];

  var inputElementRef = (0, _react.useRef)();
  var localize = useLocalizer();
  var placeCheckpointOnChangeRef = (0, _react.useRef)(false);
  var prevInputStateRef = (0, _react.useRef)();
  var rootClassName = (0, _useStyleToEmotionObject.default)()(ROOT_STYLE) + '';
  var scrollDown = (0, _useScrollDown.default)();
  var scrollUp = (0, _useScrollUp.default)();
  var submitTextBox = useTextBoxSubmit();
  var undoStackRef = (0, _react.useRef)([]);
  var sendBoxString = localize('TEXT_INPUT_ALT');
  var typeYourMessageString = localize('TEXT_INPUT_PLACEHOLDER');
  var rememberInputState = (0, _react.useCallback)(function () {
    var _inputElementRef$curr = inputElementRef.current,
        selectionEnd = _inputElementRef$curr.selectionEnd,
        selectionStart = _inputElementRef$curr.selectionStart,
        value = _inputElementRef$curr.value;
    prevInputStateRef.current = {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: value
    };
  }, [inputElementRef, prevInputStateRef]); // This is for TypeFocusSink. When the focus in on the script, then starting press "a", without this line, it would cause errors.
  // We call rememberInputState() when "onFocus" event is fired, but since this is from TypeFocusSink, we are not able to receive "onFocus" event before it happen.

  (0, _react.useEffect)(rememberInputState, [rememberInputState]); // This is for moving the selection while setting the send box value.
  // If we only use setSendBox, we will need to wait for the next render cycle to get the value in, before we can set selectionEnd/Start.

  var setSelectionRangeAndValue = (0, _react.useCallback)(function (_ref5) {
    var selectionEnd = _ref5.selectionEnd,
        selectionStart = _ref5.selectionStart,
        value = _ref5.value;

    if (inputElementRef.current) {
      // We need to set the value, before selectionStart/selectionEnd.
      inputElementRef.current.value = value;
      inputElementRef.current.selectionStart = selectionStart;
      inputElementRef.current.selectionEnd = selectionEnd;
    }

    setSendBox(value);
  }, [inputElementRef, setSendBox]);
  var handleChange = (0, _react.useCallback)(function (event) {
    var _event$target = event.target,
        selectionEnd = _event$target.selectionEnd,
        selectionStart = _event$target.selectionStart,
        value = _event$target.value;

    if (placeCheckpointOnChangeRef.current) {
      undoStackRef.current.push(_objectSpread({}, prevInputStateRef.current));
      placeCheckpointOnChangeRef.current = false;
    }

    var nextInputState = setTextBoxValue(value, {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart
    }); // If an emoticon is converted to emoji, place another checkpoint.

    if (nextInputState.value !== value) {
      undoStackRef.current.push({
        selectionEnd: selectionEnd,
        selectionStart: selectionStart,
        value: value
      });
      placeCheckpointOnChangeRef.current = true;
      setSelectionRangeAndValue(nextInputState);
    }
  }, [placeCheckpointOnChangeRef, prevInputStateRef, setSelectionRangeAndValue, setTextBoxValue, undoStackRef]);
  var handleFocus = (0, _react.useCallback)(function () {
    rememberInputState();
    placeCheckpointOnChangeRef.current = true;
  }, [placeCheckpointOnChangeRef, rememberInputState]);
  var handleKeyDown = (0, _react.useCallback)(function (event) {
    var ctrlKey = event.ctrlKey,
        key = event.key,
        metaKey = event.metaKey;

    if ((ctrlKey || metaKey) && (key === 'Z' || key === 'z')) {
      event.preventDefault();
      var poppedInputState = undoStackRef.current.pop();

      if (poppedInputState) {
        prevInputStateRef.current = _objectSpread({}, poppedInputState);
      } else {
        prevInputStateRef.current = {
          selectionEnd: 0,
          selectionStart: 0,
          value: ''
        };
      }

      setSelectionRangeAndValue(prevInputStateRef.current);
    }
  }, [prevInputStateRef, setSelectionRangeAndValue, undoStackRef]);
  var handleKeyPress = (0, _react.useCallback)(function (event) {
    var key = event.key,
        shiftKey = event.shiftKey;

    if (key === 'Enter' && !shiftKey) {
      event.preventDefault(); // If text box is submitted, focus on the send box

      submitTextBox('sendBox'); // After submit, we will clear the undo stack.

      undoStackRef.current = [];
    }
  }, [submitTextBox, undoStackRef]);
  var handleSelect = (0, _react.useCallback)(function (_ref6) {
    var _ref6$currentTarget = _ref6.currentTarget,
        selectionEnd = _ref6$currentTarget.selectionEnd,
        selectionStart = _ref6$currentTarget.selectionStart,
        value = _ref6$currentTarget.value;

    if (value === prevInputStateRef.current.value) {
      // When caret move, we should push to undo stack on change.
      placeCheckpointOnChangeRef.current = true;
    }

    prevInputStateRef.current = {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: value
    };
  }, [placeCheckpointOnChangeRef, prevInputStateRef]);
  var handleSubmit = (0, _react.useCallback)(function (event) {
    event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING
    // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box

    submitTextBox(); // After submit, we will clear the undo stack.

    undoStackRef.current = [];
  }, [submitTextBox, undoStackRef]);
  var handleKeyDownCapture = (0, _react.useCallback)(function (event) {
    var ctrlKey = event.ctrlKey,
        metaKey = event.metaKey,
        shiftKey = event.shiftKey;

    if (ctrlKey || metaKey || shiftKey) {
      return;
    } // Navigable event means the end-user is focusing on an inputtable element, but it is okay to capture the arrow keys.


    if ((0, _navigableEvent.default)(event)) {
      var handled = true;

      switch (event.key) {
        case 'End':
          scrollDown({
            displacement: Infinity
          });
          break;

        case 'Home':
          scrollUp({
            displacement: Infinity
          });
          break;

        case 'PageDown':
          scrollDown();
          break;

        case 'PageUp':
          scrollUp();
          break;

        default:
          handled = false;
          break;
      }

      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }, [scrollDown, scrollUp]);
  var focusCallback = (0, _react.useCallback)(function () {
    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        noKeyboard = _ref7.noKeyboard;

    var current = inputElementRef.current;

    if (current) {
      // The "disable soft keyboard on mobile devices" logic will not work on IE11. It will cause the <input> to become read-only until next focus.
      // Thus, no mobile devices carry IE11 so we don't need to explicitly disable soft keyboard on IE11.
      // See #3757 for repro and details.
      if (noKeyboard && !_detectBrowser.ie11) {
        // To not activate the virtual keyboard while changing focus to an input, we will temporarily set it as read-only and flip it back.
        // https://stackoverflow.com/questions/7610758/prevent-iphone-default-keyboard-when-focusing-an-input/7610923
        var readOnly = current.getAttribute('readonly');
        current.setAttribute('readonly', 'readonly'); // TODO: [P2] We should update this logic to handle quickly-successive `focusCallback`.
        //       If a succeeding `focusCallback` is being called, the `setTimeout` should run immediately.
        //       Or the second `focusCallback` should not set `readonly` to `true`.

        setTimeout(function () {
          var current = inputElementRef.current;

          if (current) {
            current.focus();
            readOnly ? current.setAttribute('readonly', readOnly) : current.removeAttribute('readonly');
          }
        }, 0);
      } else {
        current.focus();
      }
    }
  }, [inputElementRef, setTimeout]);
  (0, _useRegisterFocusSendBox.default)(focusCallback);
  return /*#__PURE__*/_react.default.createElement("form", {
    "aria-disabled": disabled,
    className: (0, _classnames.default)('webchat__send-box-text-box', rootClassName, sendBoxTextBoxStyleSet + '', (className || '') + ''),
    onSubmit: disabled ? PREVENT_DEFAULT_HANDLER : handleSubmit
  }, !sendBoxTextWrap ? /*#__PURE__*/_react.default.createElement(_AccessibleInputText.default, {
    "aria-label": sendBoxString,
    className: "webchat__send-box-text-box__input",
    "data-id": "webchat-sendbox-input",
    disabled: disabled,
    enterKeyHint: "send",
    inputMode: "text",
    onChange: disabled ? undefined : handleChange,
    onFocus: disabled ? undefined : handleFocus,
    onKeyDown: disabled ? undefined : handleKeyDown,
    onKeyDownCapture: disabled ? undefined : handleKeyDownCapture,
    onKeyPress: disabled ? undefined : handleKeyPress,
    onSelect: disabled ? undefined : handleSelect,
    placeholder: typeYourMessageString,
    readOnly: disabled,
    ref: inputElementRef,
    type: "text",
    value: textBoxValue
  }) : /*#__PURE__*/_react.default.createElement(_AutoResizeTextArea.default, {
    "aria-label": sendBoxString,
    className: "webchat__send-box-text-box__text-area",
    "data-id": "webchat-sendbox-input",
    disabled: disabled,
    enterKeyHint: "send",
    inputMode: "text",
    onChange: disabled ? undefined : handleChange,
    onFocus: disabled ? undefined : handleFocus,
    onKeyDown: disabled ? undefined : handleKeyDown,
    onKeyDownCapture: disabled ? undefined : handleKeyDownCapture,
    onKeyPress: disabled ? undefined : handleKeyPress,
    onSelect: disabled ? undefined : handleSelect,
    placeholder: typeYourMessageString,
    readOnly: disabled,
    ref: inputElementRef,
    rows: 1,
    textAreaClassName: "webchat__send-box-text-box__html-text-area",
    value: textBoxValue
  }), disabled && /*#__PURE__*/_react.default.createElement("div", {
    className: "webchat__send-box-text-box__glass"
  }));
};

TextBox.defaultProps = {
  className: ''
};
TextBox.propTypes = {
  className: _propTypes.default.string
};
var _default = TextBox;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJ1c2VEaXNhYmxlZCIsImhvb2tzIiwidXNlTG9jYWxpemVyIiwidXNlUG9ueWZpbGwiLCJ1c2VTZW5kQm94VmFsdWUiLCJ1c2VTdG9wRGljdGF0ZSIsInVzZVN0eWxlT3B0aW9ucyIsIlJPT1RfU1RZTEUiLCJkaXNwbGF5IiwiZmxleCIsImNvbm5lY3RTZW5kVGV4dEJveCIsInNlbGVjdG9ycyIsImNvbm5lY3RUb1dlYkNoYXQiLCJkaXNhYmxlZCIsImZvY3VzU2VuZEJveCIsImxhbmd1YWdlIiwic2Nyb2xsVG9FbmQiLCJzZW5kQm94VmFsdWUiLCJzZXRTZW5kQm94Iiwic3RvcERpY3RhdGUiLCJzdWJtaXRTZW5kQm94Iiwib25DaGFuZ2UiLCJ2YWx1ZSIsInRhcmdldCIsIm9uS2V5UHJlc3MiLCJldmVudCIsImtleSIsInNoaWZ0S2V5IiwicHJldmVudERlZmF1bHQiLCJvblN1Ym1pdCIsInVzZVRleHRCb3hTdWJtaXQiLCJzdWJtaXQiLCJ1c2VTdWJtaXQiLCJ1c2VDYWxsYmFjayIsInNldEZvY3VzIiwidW5kZWZpbmVkIiwidXNlVGV4dEJveFZhbHVlIiwic2V0VmFsdWUiLCJyZXBsYWNlRW1vdGljb24iLCJ1c2VSZXBsYWNlRW1vdGljb24iLCJzZXR0ZXIiLCJuZXh0VmFsdWUiLCJzZWxlY3Rpb25FbmQiLCJzZWxlY3Rpb25TdGFydCIsIkVycm9yIiwibGVuZ3RoIiwibmV4dFNlbGVjdGlvbkVuZCIsIm5leHRTZWxlY3Rpb25TdGFydCIsIm5leHRWYWx1ZVdpdGhFbW9qaSIsIlBSRVZFTlRfREVGQVVMVF9IQU5ETEVSIiwiVGV4dEJveCIsImNsYXNzTmFtZSIsInVzZVN0eWxlU2V0Iiwic2VuZEJveFRleHRCb3hTdHlsZVNldCIsInNlbmRCb3hUZXh0Qm94Iiwic2VuZEJveFRleHRXcmFwIiwic2V0VGltZW91dCIsInRleHRCb3hWYWx1ZSIsInNldFRleHRCb3hWYWx1ZSIsImlucHV0RWxlbWVudFJlZiIsInVzZVJlZiIsImxvY2FsaXplIiwicGxhY2VDaGVja3BvaW50T25DaGFuZ2VSZWYiLCJwcmV2SW5wdXRTdGF0ZVJlZiIsInJvb3RDbGFzc05hbWUiLCJ1c2VTdHlsZVRvRW1vdGlvbk9iamVjdCIsInNjcm9sbERvd24iLCJ1c2VTY3JvbGxEb3duIiwic2Nyb2xsVXAiLCJ1c2VTY3JvbGxVcCIsInN1Ym1pdFRleHRCb3giLCJ1bmRvU3RhY2tSZWYiLCJzZW5kQm94U3RyaW5nIiwidHlwZVlvdXJNZXNzYWdlU3RyaW5nIiwicmVtZW1iZXJJbnB1dFN0YXRlIiwiY3VycmVudCIsInVzZUVmZmVjdCIsInNldFNlbGVjdGlvblJhbmdlQW5kVmFsdWUiLCJoYW5kbGVDaGFuZ2UiLCJwdXNoIiwibmV4dElucHV0U3RhdGUiLCJoYW5kbGVGb2N1cyIsImhhbmRsZUtleURvd24iLCJjdHJsS2V5IiwibWV0YUtleSIsInBvcHBlZElucHV0U3RhdGUiLCJwb3AiLCJoYW5kbGVLZXlQcmVzcyIsImhhbmRsZVNlbGVjdCIsImN1cnJlbnRUYXJnZXQiLCJoYW5kbGVTdWJtaXQiLCJoYW5kbGVLZXlEb3duQ2FwdHVyZSIsIm5hdmlnYWJsZUV2ZW50IiwiaGFuZGxlZCIsImRpc3BsYWNlbWVudCIsIkluZmluaXR5Iiwic3RvcFByb3BhZ2F0aW9uIiwiZm9jdXNDYWxsYmFjayIsIm5vS2V5Ym9hcmQiLCJpZTExIiwicmVhZE9ubHkiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJmb2N1cyIsInJlbW92ZUF0dHJpYnV0ZSIsInVzZVJlZ2lzdGVyRm9jdXNTZW5kQm94IiwiY2xhc3NOYW1lcyIsImRlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsInN0cmluZyJdLCJzb3VyY2VSb290IjoiY29tcG9uZW50Oi8vLyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL1NlbmRCb3gvVGV4dEJveC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaG9va3MgfSBmcm9tICdib3RmcmFtZXdvcmstd2ViY2hhdC1hcGknO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgaWUxMSB9IGZyb20gJy4uL1V0aWxzL2RldGVjdEJyb3dzZXInO1xuaW1wb3J0IEFjY2Vzc2libGVJbnB1dFRleHQgZnJvbSAnLi4vVXRpbHMvQWNjZXNzaWJsZUlucHV0VGV4dCc7XG5pbXBvcnQgQXV0b1Jlc2l6ZVRleHRBcmVhIGZyb20gJy4vQXV0b1Jlc2l6ZVRleHRBcmVhJztcbmltcG9ydCBjb25uZWN0VG9XZWJDaGF0IGZyb20gJy4uL2Nvbm5lY3RUb1dlYkNoYXQnO1xuaW1wb3J0IG5hdmlnYWJsZUV2ZW50IGZyb20gJy4uL1V0aWxzL1R5cGVGb2N1c1NpbmsvbmF2aWdhYmxlRXZlbnQnO1xuaW1wb3J0IHVzZVJlZ2lzdGVyRm9jdXNTZW5kQm94IGZyb20gJy4uL2hvb2tzL2ludGVybmFsL3VzZVJlZ2lzdGVyRm9jdXNTZW5kQm94JztcbmltcG9ydCB1c2VSZXBsYWNlRW1vdGljb24gZnJvbSAnLi4vaG9va3MvaW50ZXJuYWwvdXNlUmVwbGFjZUVtb3RpY29uJztcbmltcG9ydCB1c2VTY3JvbGxEb3duIGZyb20gJy4uL2hvb2tzL3VzZVNjcm9sbERvd24nO1xuaW1wb3J0IHVzZVNjcm9sbFVwIGZyb20gJy4uL2hvb2tzL3VzZVNjcm9sbFVwJztcbmltcG9ydCB1c2VTdHlsZVNldCBmcm9tICcuLi9ob29rcy91c2VTdHlsZVNldCc7XG5pbXBvcnQgdXNlU3R5bGVUb0Vtb3Rpb25PYmplY3QgZnJvbSAnLi4vaG9va3MvaW50ZXJuYWwvdXNlU3R5bGVUb0Vtb3Rpb25PYmplY3QnO1xuaW1wb3J0IHVzZVN1Ym1pdCBmcm9tICcuLi9wcm92aWRlcnMvaW50ZXJuYWwvU2VuZEJveC91c2VTdWJtaXQnO1xuXG5pbXBvcnQgdHlwZSB7IE11dGFibGVSZWZPYmplY3QsIFJlYWN0RXZlbnRIYW5kbGVyIH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCB7IHVzZURpc2FibGVkLCB1c2VMb2NhbGl6ZXIsIHVzZVBvbnlmaWxsLCB1c2VTZW5kQm94VmFsdWUsIHVzZVN0b3BEaWN0YXRlLCB1c2VTdHlsZU9wdGlvbnMgfSA9IGhvb2tzO1xuXG5jb25zdCBST09UX1NUWUxFID0ge1xuICAnJi53ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveCc6IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG5cbiAgICAnJiAud2ViY2hhdF9fc2VuZC1ib3gtdGV4dC1ib3hfX2lucHV0LCAmIC53ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveF9fdGV4dC1hcmVhJzoge1xuICAgICAgZmxleDogMVxuICAgIH1cbiAgfVxufTtcblxuY29uc3QgY29ubmVjdFNlbmRUZXh0Qm94ID0gKC4uLnNlbGVjdG9ycykgPT5cbiAgY29ubmVjdFRvV2ViQ2hhdChcbiAgICAoeyBkaXNhYmxlZCwgZm9jdXNTZW5kQm94LCBsYW5ndWFnZSwgc2Nyb2xsVG9FbmQsIHNlbmRCb3hWYWx1ZSwgc2V0U2VuZEJveCwgc3RvcERpY3RhdGUsIHN1Ym1pdFNlbmRCb3ggfSkgPT4gKHtcbiAgICAgIGRpc2FibGVkLFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBvbkNoYW5nZTogKHsgdGFyZ2V0OiB7IHZhbHVlIH0gfSkgPT4ge1xuICAgICAgICBzZXRTZW5kQm94KHZhbHVlKTtcbiAgICAgICAgc3RvcERpY3RhdGUoKTtcbiAgICAgIH0sXG4gICAgICBvbktleVByZXNzOiBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBzaGlmdEtleSB9ID0gZXZlbnQ7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ0VudGVyJyAmJiAhc2hpZnRLZXkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbmRCb3hWYWx1ZSkge1xuICAgICAgICAgICAgc2Nyb2xsVG9FbmQoKTtcbiAgICAgICAgICAgIHN1Ym1pdFNlbmRCb3goKTtcbiAgICAgICAgICAgIGZvY3VzU2VuZEJveCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uU3VibWl0OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gQ29uc2lkZXIgY2xlYXJpbmcgdGhlIHNlbmQgYm94IG9ubHkgYWZ0ZXIgd2UgcmVjZWl2ZWQgUE9TVF9BQ1RJVklUWV9QRU5ESU5HXG4gICAgICAgIC8vIEUuZy4gaWYgdGhlIGNvbm5lY3Rpb24gaXMgYmFkLCBzZW5kaW5nIHRoZSBtZXNzYWdlIGVzc2VudGlhbGx5IGRvIG5vdGhpbmcgYnV0IGp1c3QgY2xlYXJpbmcgdGhlIHNlbmQgYm94XG5cbiAgICAgICAgaWYgKHNlbmRCb3hWYWx1ZSkge1xuICAgICAgICAgIHNjcm9sbFRvRW5kKCk7XG4gICAgICAgICAgc3VibWl0U2VuZEJveCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmFsdWU6IHNlbmRCb3hWYWx1ZVxuICAgIH0pLFxuICAgIC4uLnNlbGVjdG9yc1xuICApO1xuXG4vKipcbiAqIFN1Ym1pdHMgdGhlIHRleHQgYm94IGFuZCBvcHRpb25hbGx5IHNldCB0aGUgZm9jdXMgYWZ0ZXIgc2VuZC5cbiAqL1xudHlwZSBTdWJtaXRUZXh0Qm94RnVuY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBTdWJtaXRzIHRoZSB0ZXh0IGJveCwgd2l0aG91dCBzZXR0aW5nIHRoZSBmb2N1cyBhZnRlciBzZW5kLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkIG9mIHBhc3NpbmcgYGZhbHNlYCwgeW91IHNob3VsZCBsZWF2ZSB0aGUgYHNldEZvY3VzYCBhcmd1bWVudCBgdW5kZWZpbmVkYC5cbiAgICovXG4gIChzZXRGb2N1czogZmFsc2UpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBTdWJtaXRzIHRoZSB0ZXh0IGJveCBhbmQgb3B0aW9uYWxseSBzZXQgdGhlIGZvY3VzIGFmdGVyIHNlbmQuXG4gICAqL1xuICAoc2V0Rm9jdXM/OiAnc2VuZEJveCcgfCAnc2VuZEJveFdpdGhvdXRLZXlib2FyZCcpOiB2b2lkO1xufTtcblxuZnVuY3Rpb24gdXNlVGV4dEJveFN1Ym1pdCgpOiBTdWJtaXRUZXh0Qm94RnVuY3Rpb24ge1xuICBjb25zdCBzdWJtaXQgPSB1c2VTdWJtaXQoKTtcblxuICByZXR1cm4gdXNlQ2FsbGJhY2s8U3VibWl0VGV4dEJveEZ1bmN0aW9uPihcbiAgICAoc2V0Rm9jdXM/OiBmYWxzZSB8ICdzZW5kQm94JyB8ICdzZW5kQm94V2l0aG91dEtleWJvYXJkJykgPT4gc3VibWl0KHsgc2V0Rm9jdXM6IHNldEZvY3VzIHx8IHVuZGVmaW5lZCB9KSxcbiAgICBbc3VibWl0XVxuICApO1xufVxuXG5mdW5jdGlvbiB1c2VUZXh0Qm94VmFsdWUoKTogW1xuICBzdHJpbmcsXG4gIChcbiAgICB0ZXh0Qm94VmFsdWU6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7IHNlbGVjdGlvbkVuZDogbnVtYmVyOyBzZWxlY3Rpb25TdGFydDogbnVtYmVyIH1cbiAgKSA9PiB7IHNlbGVjdGlvbkVuZDogbnVtYmVyOyBzZWxlY3Rpb25TdGFydDogbnVtYmVyOyB2YWx1ZTogc3RyaW5nIH1cbl0ge1xuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHVzZVNlbmRCb3hWYWx1ZSgpO1xuICBjb25zdCByZXBsYWNlRW1vdGljb24gPSB1c2VSZXBsYWNlRW1vdGljb24oKTtcbiAgY29uc3Qgc3RvcERpY3RhdGUgPSB1c2VTdG9wRGljdGF0ZSgpO1xuXG4gIGNvbnN0IHNldHRlciA9IHVzZUNhbGxiYWNrPFxuICAgIChcbiAgICAgIG5leHRWYWx1ZTogc3RyaW5nLFxuICAgICAgb3B0aW9ucz86IHsgc2VsZWN0aW9uRW5kOiBudW1iZXI7IHNlbGVjdGlvblN0YXJ0OiBudW1iZXIgfVxuICAgICkgPT4ge1xuICAgICAgc2VsZWN0aW9uRW5kOiBudW1iZXI7XG4gICAgICBzZWxlY3Rpb25TdGFydDogbnVtYmVyO1xuICAgICAgdmFsdWU6IHN0cmluZztcbiAgICB9XG4gID4oXG4gICAgKG5leHRWYWx1ZSwgeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0IH0gPSB7IHNlbGVjdGlvbkVuZDogdW5kZWZpbmVkLCBzZWxlY3Rpb25TdGFydDogdW5kZWZpbmVkIH0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGZyYW1ld29yay13ZWJjaGF0OiBGaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gdXNlVGV4dEJveFZhbHVlKCkgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3VycmVudGx5LCB3ZSBjYW5ub3QgZGV0ZWN0IHdoZXRoZXIgdGhlIGNoYW5nZSBpcyBkdWUgdG8gY2xpcGJvYXJkIHBhc3RlIG9yIHByZXNzaW5nIGEga2V5IG9uIHRoZSBrZXlib2FyZC5cbiAgICAgIC8vIFdlIHNob3VsZCBub3QgY2hhbmdlIHRvIGVtb2ppIHdoZW4gdGhlIHVzZXIgaXMgcGFzdGluZyB0ZXh0LlxuICAgICAgLy8gV2Ugd291bGQgYXNzdW1lLCBmb3IgYSBzaW5nbGUgY2hhcmFjdGVyIGFkZGl0aW9uLCB0aGUgdXNlciBtdXN0IGJlIHByZXNzaW5nIGEga2V5LlxuICAgICAgaWYgKG5leHRWYWx1ZS5sZW5ndGggPT09IHZhbHVlLmxlbmd0aCArIDEpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNlbGVjdGlvbkVuZDogbmV4dFNlbGVjdGlvbkVuZCxcbiAgICAgICAgICBzZWxlY3Rpb25TdGFydDogbmV4dFNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIHZhbHVlOiBuZXh0VmFsdWVXaXRoRW1vamlcbiAgICAgICAgfSA9IHJlcGxhY2VFbW90aWNvbih7IHNlbGVjdGlvbkVuZCwgc2VsZWN0aW9uU3RhcnQsIHZhbHVlOiBuZXh0VmFsdWUgfSk7XG5cbiAgICAgICAgc2VsZWN0aW9uRW5kID0gbmV4dFNlbGVjdGlvbkVuZDtcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSBuZXh0U2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIG5leHRWYWx1ZSA9IG5leHRWYWx1ZVdpdGhFbW9qaTtcbiAgICAgIH1cblxuICAgICAgc2V0VmFsdWUobmV4dFZhbHVlKTtcbiAgICAgIHN0b3BEaWN0YXRlKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdGlvbkVuZCxcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIHZhbHVlOiBuZXh0VmFsdWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBbcmVwbGFjZUVtb3RpY29uLCBzZXRWYWx1ZSwgc3RvcERpY3RhdGUsIHZhbHVlXVxuICApO1xuXG4gIHJldHVybiBbdmFsdWUsIHNldHRlcl07XG59XG5cbmNvbnN0IFBSRVZFTlRfREVGQVVMVF9IQU5ETEVSID0gZXZlbnQgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuY29uc3QgVGV4dEJveCA9ICh7IGNsYXNzTmFtZSB9KSA9PiB7XG4gIGNvbnN0IFssIHNldFNlbmRCb3hdID0gdXNlU2VuZEJveFZhbHVlKCk7XG4gIGNvbnN0IFt7IHNlbmRCb3hUZXh0Qm94OiBzZW5kQm94VGV4dEJveFN0eWxlU2V0IH1dID0gdXNlU3R5bGVTZXQoKTtcbiAgY29uc3QgW3sgc2VuZEJveFRleHRXcmFwIH1dID0gdXNlU3R5bGVPcHRpb25zKCk7XG4gIGNvbnN0IFt7IHNldFRpbWVvdXQgfV0gPSB1c2VQb255ZmlsbCgpO1xuICBjb25zdCBbZGlzYWJsZWRdID0gdXNlRGlzYWJsZWQoKTtcbiAgY29uc3QgW3RleHRCb3hWYWx1ZSwgc2V0VGV4dEJveFZhbHVlXSA9IHVzZVRleHRCb3hWYWx1ZSgpO1xuICBjb25zdCBpbnB1dEVsZW1lbnRSZWY6IE11dGFibGVSZWZPYmplY3Q8SFRNTElucHV0RWxlbWVudCAmIEhUTUxUZXh0QXJlYUVsZW1lbnQ+ID0gdXNlUmVmKCk7XG4gIGNvbnN0IGxvY2FsaXplID0gdXNlTG9jYWxpemVyKCk7XG4gIGNvbnN0IHBsYWNlQ2hlY2twb2ludE9uQ2hhbmdlUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcHJldklucHV0U3RhdGVSZWY6IE11dGFibGVSZWZPYmplY3Q8e1xuICAgIHNlbGVjdGlvbkVuZDogbnVtYmVyO1xuICAgIHNlbGVjdGlvblN0YXJ0OiBudW1iZXI7XG4gICAgdmFsdWU6IHN0cmluZztcbiAgfT4gPSB1c2VSZWYoKTtcbiAgY29uc3Qgcm9vdENsYXNzTmFtZSA9IHVzZVN0eWxlVG9FbW90aW9uT2JqZWN0KCkoUk9PVF9TVFlMRSkgKyAnJztcbiAgY29uc3Qgc2Nyb2xsRG93biA9IHVzZVNjcm9sbERvd24oKTtcbiAgY29uc3Qgc2Nyb2xsVXAgPSB1c2VTY3JvbGxVcCgpO1xuICBjb25zdCBzdWJtaXRUZXh0Qm94ID0gdXNlVGV4dEJveFN1Ym1pdCgpO1xuICBjb25zdCB1bmRvU3RhY2tSZWYgPSB1c2VSZWYoW10pO1xuXG4gIGNvbnN0IHNlbmRCb3hTdHJpbmcgPSBsb2NhbGl6ZSgnVEVYVF9JTlBVVF9BTFQnKTtcbiAgY29uc3QgdHlwZVlvdXJNZXNzYWdlU3RyaW5nID0gbG9jYWxpemUoJ1RFWFRfSU5QVVRfUExBQ0VIT0xERVInKTtcblxuICBjb25zdCByZW1lbWJlcklucHV0U3RhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudDogeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZSB9XG4gICAgfSA9IGlucHV0RWxlbWVudFJlZjtcblxuICAgIHByZXZJbnB1dFN0YXRlUmVmLmN1cnJlbnQgPSB7IHNlbGVjdGlvbkVuZCwgc2VsZWN0aW9uU3RhcnQsIHZhbHVlIH07XG4gIH0sIFtpbnB1dEVsZW1lbnRSZWYsIHByZXZJbnB1dFN0YXRlUmVmXSk7XG5cbiAgLy8gVGhpcyBpcyBmb3IgVHlwZUZvY3VzU2luay4gV2hlbiB0aGUgZm9jdXMgaW4gb24gdGhlIHNjcmlwdCwgdGhlbiBzdGFydGluZyBwcmVzcyBcImFcIiwgd2l0aG91dCB0aGlzIGxpbmUsIGl0IHdvdWxkIGNhdXNlIGVycm9ycy5cbiAgLy8gV2UgY2FsbCByZW1lbWJlcklucHV0U3RhdGUoKSB3aGVuIFwib25Gb2N1c1wiIGV2ZW50IGlzIGZpcmVkLCBidXQgc2luY2UgdGhpcyBpcyBmcm9tIFR5cGVGb2N1c1NpbmssIHdlIGFyZSBub3QgYWJsZSB0byByZWNlaXZlIFwib25Gb2N1c1wiIGV2ZW50IGJlZm9yZSBpdCBoYXBwZW4uXG4gIHVzZUVmZmVjdChyZW1lbWJlcklucHV0U3RhdGUsIFtyZW1lbWJlcklucHV0U3RhdGVdKTtcblxuICAvLyBUaGlzIGlzIGZvciBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB3aGlsZSBzZXR0aW5nIHRoZSBzZW5kIGJveCB2YWx1ZS5cbiAgLy8gSWYgd2Ugb25seSB1c2Ugc2V0U2VuZEJveCwgd2Ugd2lsbCBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHJlbmRlciBjeWNsZSB0byBnZXQgdGhlIHZhbHVlIGluLCBiZWZvcmUgd2UgY2FuIHNldCBzZWxlY3Rpb25FbmQvU3RhcnQuXG4gIGNvbnN0IHNldFNlbGVjdGlvblJhbmdlQW5kVmFsdWUgPSB1c2VDYWxsYmFjayhcbiAgICAoeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZSB9KSA9PiB7XG4gICAgICBpZiAoaW5wdXRFbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBzZXQgdGhlIHZhbHVlLCBiZWZvcmUgc2VsZWN0aW9uU3RhcnQvc2VsZWN0aW9uRW5kLlxuICAgICAgICBpbnB1dEVsZW1lbnRSZWYuY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlucHV0RWxlbWVudFJlZi5jdXJyZW50LnNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGlucHV0RWxlbWVudFJlZi5jdXJyZW50LnNlbGVjdGlvbkVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgIH1cblxuICAgICAgc2V0U2VuZEJveCh2YWx1ZSk7XG4gICAgfSxcbiAgICBbaW5wdXRFbGVtZW50UmVmLCBzZXRTZW5kQm94XVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFyZ2V0OiB7IHNlbGVjdGlvbkVuZCwgc2VsZWN0aW9uU3RhcnQsIHZhbHVlIH1cbiAgICAgIH0gPSBldmVudDtcblxuICAgICAgaWYgKHBsYWNlQ2hlY2twb2ludE9uQ2hhbmdlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgdW5kb1N0YWNrUmVmLmN1cnJlbnQucHVzaCh7IC4uLnByZXZJbnB1dFN0YXRlUmVmLmN1cnJlbnQgfSk7XG5cbiAgICAgICAgcGxhY2VDaGVja3BvaW50T25DaGFuZ2VSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXh0SW5wdXRTdGF0ZSA9IHNldFRleHRCb3hWYWx1ZSh2YWx1ZSwgeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0IH0pO1xuXG4gICAgICAvLyBJZiBhbiBlbW90aWNvbiBpcyBjb252ZXJ0ZWQgdG8gZW1vamksIHBsYWNlIGFub3RoZXIgY2hlY2twb2ludC5cbiAgICAgIGlmIChuZXh0SW5wdXRTdGF0ZS52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdW5kb1N0YWNrUmVmLmN1cnJlbnQucHVzaCh7IHNlbGVjdGlvbkVuZCwgc2VsZWN0aW9uU3RhcnQsIHZhbHVlIH0pO1xuXG4gICAgICAgIHBsYWNlQ2hlY2twb2ludE9uQ2hhbmdlUmVmLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgIHNldFNlbGVjdGlvblJhbmdlQW5kVmFsdWUobmV4dElucHV0U3RhdGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3BsYWNlQ2hlY2twb2ludE9uQ2hhbmdlUmVmLCBwcmV2SW5wdXRTdGF0ZVJlZiwgc2V0U2VsZWN0aW9uUmFuZ2VBbmRWYWx1ZSwgc2V0VGV4dEJveFZhbHVlLCB1bmRvU3RhY2tSZWZdXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlRm9jdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmVtZW1iZXJJbnB1dFN0YXRlKCk7XG5cbiAgICBwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSwgW3BsYWNlQ2hlY2twb2ludE9uQ2hhbmdlUmVmLCByZW1lbWJlcklucHV0U3RhdGVdKTtcblxuICBjb25zdCBoYW5kbGVLZXlEb3duID0gdXNlQ2FsbGJhY2soXG4gICAgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgeyBjdHJsS2V5LCBrZXksIG1ldGFLZXkgfSA9IGV2ZW50O1xuXG4gICAgICBpZiAoKGN0cmxLZXkgfHwgbWV0YUtleSkgJiYgKGtleSA9PT0gJ1onIHx8IGtleSA9PT0gJ3onKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGNvbnN0IHBvcHBlZElucHV0U3RhdGUgPSB1bmRvU3RhY2tSZWYuY3VycmVudC5wb3AoKTtcblxuICAgICAgICBpZiAocG9wcGVkSW5wdXRTdGF0ZSkge1xuICAgICAgICAgIHByZXZJbnB1dFN0YXRlUmVmLmN1cnJlbnQgPSB7IC4uLnBvcHBlZElucHV0U3RhdGUgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2SW5wdXRTdGF0ZVJlZi5jdXJyZW50ID0geyBzZWxlY3Rpb25FbmQ6IDAsIHNlbGVjdGlvblN0YXJ0OiAwLCB2YWx1ZTogJycgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFNlbGVjdGlvblJhbmdlQW5kVmFsdWUocHJldklucHV0U3RhdGVSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcHJldklucHV0U3RhdGVSZWYsIHNldFNlbGVjdGlvblJhbmdlQW5kVmFsdWUsIHVuZG9TdGFja1JlZl1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVLZXlQcmVzcyA9IHVzZUNhbGxiYWNrKFxuICAgIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHsga2V5LCBzaGlmdEtleSB9ID0gZXZlbnQ7XG5cbiAgICAgIGlmIChrZXkgPT09ICdFbnRlcicgJiYgIXNoaWZ0S2V5KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gSWYgdGV4dCBib3ggaXMgc3VibWl0dGVkLCBmb2N1cyBvbiB0aGUgc2VuZCBib3hcbiAgICAgICAgc3VibWl0VGV4dEJveCgnc2VuZEJveCcpO1xuXG4gICAgICAgIC8vIEFmdGVyIHN1Ym1pdCwgd2Ugd2lsbCBjbGVhciB0aGUgdW5kbyBzdGFjay5cbiAgICAgICAgdW5kb1N0YWNrUmVmLmN1cnJlbnQgPSBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtzdWJtaXRUZXh0Qm94LCB1bmRvU3RhY2tSZWZdXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlU2VsZWN0ID0gdXNlQ2FsbGJhY2s8UmVhY3RFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQ+PihcbiAgICAoeyBjdXJyZW50VGFyZ2V0OiB7IHNlbGVjdGlvbkVuZCwgc2VsZWN0aW9uU3RhcnQsIHZhbHVlIH0gfSkgPT4ge1xuICAgICAgaWYgKHZhbHVlID09PSBwcmV2SW5wdXRTdGF0ZVJlZi5jdXJyZW50LnZhbHVlKSB7XG4gICAgICAgIC8vIFdoZW4gY2FyZXQgbW92ZSwgd2Ugc2hvdWxkIHB1c2ggdG8gdW5kbyBzdGFjayBvbiBjaGFuZ2UuXG4gICAgICAgIHBsYWNlQ2hlY2twb2ludE9uQ2hhbmdlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBwcmV2SW5wdXRTdGF0ZVJlZi5jdXJyZW50ID0geyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZSB9O1xuICAgIH0sXG4gICAgW3BsYWNlQ2hlY2twb2ludE9uQ2hhbmdlUmVmLCBwcmV2SW5wdXRTdGF0ZVJlZl1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjayhcbiAgICBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAvLyBDb25zaWRlciBjbGVhcmluZyB0aGUgc2VuZCBib3ggb25seSBhZnRlciB3ZSByZWNlaXZlZCBQT1NUX0FDVElWSVRZX1BFTkRJTkdcbiAgICAgIC8vIEUuZy4gaWYgdGhlIGNvbm5lY3Rpb24gaXMgYmFkLCBzZW5kaW5nIHRoZSBtZXNzYWdlIGVzc2VudGlhbGx5IGRvIG5vdGhpbmcgYnV0IGp1c3QgY2xlYXJpbmcgdGhlIHNlbmQgYm94XG4gICAgICBzdWJtaXRUZXh0Qm94KCk7XG5cbiAgICAgIC8vIEFmdGVyIHN1Ym1pdCwgd2Ugd2lsbCBjbGVhciB0aGUgdW5kbyBzdGFjay5cbiAgICAgIHVuZG9TdGFja1JlZi5jdXJyZW50ID0gW107XG4gICAgfSxcbiAgICBbc3VibWl0VGV4dEJveCwgdW5kb1N0YWNrUmVmXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUtleURvd25DYXB0dXJlID0gdXNlQ2FsbGJhY2soXG4gICAgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgeyBjdHJsS2V5LCBtZXRhS2V5LCBzaGlmdEtleSB9ID0gZXZlbnQ7XG5cbiAgICAgIGlmIChjdHJsS2V5IHx8IG1ldGFLZXkgfHwgc2hpZnRLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBOYXZpZ2FibGUgZXZlbnQgbWVhbnMgdGhlIGVuZC11c2VyIGlzIGZvY3VzaW5nIG9uIGFuIGlucHV0dGFibGUgZWxlbWVudCwgYnV0IGl0IGlzIG9rYXkgdG8gY2FwdHVyZSB0aGUgYXJyb3cga2V5cy5cbiAgICAgIGlmIChuYXZpZ2FibGVFdmVudChldmVudCkpIHtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSB0cnVlO1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgY2FzZSAnRW5kJzpcbiAgICAgICAgICAgIHNjcm9sbERvd24oeyBkaXNwbGFjZW1lbnQ6IEluZmluaXR5IH0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgICAgIHNjcm9sbFVwKHsgZGlzcGxhY2VtZW50OiBJbmZpbml0eSB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUGFnZURvd24nOlxuICAgICAgICAgICAgc2Nyb2xsRG93bigpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdQYWdlVXAnOlxuICAgICAgICAgICAgc2Nyb2xsVXAoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbc2Nyb2xsRG93biwgc2Nyb2xsVXBdXG4gICk7XG5cbiAgY29uc3QgZm9jdXNDYWxsYmFjayA9IHVzZUNhbGxiYWNrPChvcHRpb25zPzogeyBub0tleWJvYXJkPzogYm9vbGVhbiB9KSA9PiB2b2lkPihcbiAgICAoeyBub0tleWJvYXJkIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSBpbnB1dEVsZW1lbnRSZWY7XG5cbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIC8vIFRoZSBcImRpc2FibGUgc29mdCBrZXlib2FyZCBvbiBtb2JpbGUgZGV2aWNlc1wiIGxvZ2ljIHdpbGwgbm90IHdvcmsgb24gSUUxMS4gSXQgd2lsbCBjYXVzZSB0aGUgPGlucHV0PiB0byBiZWNvbWUgcmVhZC1vbmx5IHVudGlsIG5leHQgZm9jdXMuXG4gICAgICAgIC8vIFRodXMsIG5vIG1vYmlsZSBkZXZpY2VzIGNhcnJ5IElFMTEgc28gd2UgZG9uJ3QgbmVlZCB0byBleHBsaWNpdGx5IGRpc2FibGUgc29mdCBrZXlib2FyZCBvbiBJRTExLlxuICAgICAgICAvLyBTZWUgIzM3NTcgZm9yIHJlcHJvIGFuZCBkZXRhaWxzLlxuICAgICAgICBpZiAobm9LZXlib2FyZCAmJiAhaWUxMSkge1xuICAgICAgICAgIC8vIFRvIG5vdCBhY3RpdmF0ZSB0aGUgdmlydHVhbCBrZXlib2FyZCB3aGlsZSBjaGFuZ2luZyBmb2N1cyB0byBhbiBpbnB1dCwgd2Ugd2lsbCB0ZW1wb3JhcmlseSBzZXQgaXQgYXMgcmVhZC1vbmx5IGFuZCBmbGlwIGl0IGJhY2suXG4gICAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzYxMDc1OC9wcmV2ZW50LWlwaG9uZS1kZWZhdWx0LWtleWJvYXJkLXdoZW4tZm9jdXNpbmctYW4taW5wdXQvNzYxMDkyM1xuICAgICAgICAgIGNvbnN0IHJlYWRPbmx5ID0gY3VycmVudC5nZXRBdHRyaWJ1dGUoJ3JlYWRvbmx5Jyk7XG5cbiAgICAgICAgICBjdXJyZW50LnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAncmVhZG9ubHknKTtcblxuICAgICAgICAgIC8vIFRPRE86IFtQMl0gV2Ugc2hvdWxkIHVwZGF0ZSB0aGlzIGxvZ2ljIHRvIGhhbmRsZSBxdWlja2x5LXN1Y2Nlc3NpdmUgYGZvY3VzQ2FsbGJhY2tgLlxuICAgICAgICAgIC8vICAgICAgIElmIGEgc3VjY2VlZGluZyBgZm9jdXNDYWxsYmFja2AgaXMgYmVpbmcgY2FsbGVkLCB0aGUgYHNldFRpbWVvdXRgIHNob3VsZCBydW4gaW1tZWRpYXRlbHkuXG4gICAgICAgICAgLy8gICAgICAgT3IgdGhlIHNlY29uZCBgZm9jdXNDYWxsYmFja2Agc2hvdWxkIG5vdCBzZXQgYHJlYWRvbmx5YCB0byBgdHJ1ZWAuXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IGlucHV0RWxlbWVudFJlZjtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgICAgICByZWFkT25seSA/IGN1cnJlbnQuc2V0QXR0cmlidXRlKCdyZWFkb25seScsIHJlYWRPbmx5KSA6IGN1cnJlbnQucmVtb3ZlQXR0cmlidXRlKCdyZWFkb25seScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW2lucHV0RWxlbWVudFJlZiwgc2V0VGltZW91dF1cbiAgKTtcblxuICB1c2VSZWdpc3RlckZvY3VzU2VuZEJveChmb2N1c0NhbGxiYWNrKTtcblxuICByZXR1cm4gKFxuICAgIDxmb3JtXG4gICAgICBhcmlhLWRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhcbiAgICAgICAgJ3dlYmNoYXRfX3NlbmQtYm94LXRleHQtYm94JyxcbiAgICAgICAgcm9vdENsYXNzTmFtZSxcbiAgICAgICAgc2VuZEJveFRleHRCb3hTdHlsZVNldCArICcnLFxuICAgICAgICAoY2xhc3NOYW1lIHx8ICcnKSArICcnXG4gICAgICApfVxuICAgICAgb25TdWJtaXQ9e2Rpc2FibGVkID8gUFJFVkVOVF9ERUZBVUxUX0hBTkRMRVIgOiBoYW5kbGVTdWJtaXR9XG4gICAgPlxuICAgICAgeyFzZW5kQm94VGV4dFdyYXAgPyAoXG4gICAgICAgIDxBY2Nlc3NpYmxlSW5wdXRUZXh0XG4gICAgICAgICAgYXJpYS1sYWJlbD17c2VuZEJveFN0cmluZ31cbiAgICAgICAgICBjbGFzc05hbWU9XCJ3ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveF9faW5wdXRcIlxuICAgICAgICAgIGRhdGEtaWQ9XCJ3ZWJjaGF0LXNlbmRib3gtaW5wdXRcIlxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBlbnRlcktleUhpbnQ9XCJzZW5kXCJcbiAgICAgICAgICBpbnB1dE1vZGU9XCJ0ZXh0XCJcbiAgICAgICAgICBvbkNoYW5nZT17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgb25Gb2N1cz17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVGb2N1c31cbiAgICAgICAgICBvbktleURvd249e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlS2V5RG93bn1cbiAgICAgICAgICBvbktleURvd25DYXB0dXJlPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZUtleURvd25DYXB0dXJlfVxuICAgICAgICAgIG9uS2V5UHJlc3M9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlS2V5UHJlc3N9XG4gICAgICAgICAgb25TZWxlY3Q9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlU2VsZWN0fVxuICAgICAgICAgIHBsYWNlaG9sZGVyPXt0eXBlWW91ck1lc3NhZ2VTdHJpbmd9XG4gICAgICAgICAgcmVhZE9ubHk9e2Rpc2FibGVkfVxuICAgICAgICAgIHJlZj17aW5wdXRFbGVtZW50UmVmfVxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICB2YWx1ZT17dGV4dEJveFZhbHVlfVxuICAgICAgICAvPlxuICAgICAgKSA6IChcbiAgICAgICAgPEF1dG9SZXNpemVUZXh0QXJlYVxuICAgICAgICAgIGFyaWEtbGFiZWw9e3NlbmRCb3hTdHJpbmd9XG4gICAgICAgICAgY2xhc3NOYW1lPVwid2ViY2hhdF9fc2VuZC1ib3gtdGV4dC1ib3hfX3RleHQtYXJlYVwiXG4gICAgICAgICAgZGF0YS1pZD1cIndlYmNoYXQtc2VuZGJveC1pbnB1dFwiXG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGVudGVyS2V5SGludD1cInNlbmRcIlxuICAgICAgICAgIGlucHV0TW9kZT1cInRleHRcIlxuICAgICAgICAgIG9uQ2hhbmdlPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZUNoYW5nZX1cbiAgICAgICAgICBvbkZvY3VzPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZUZvY3VzfVxuICAgICAgICAgIG9uS2V5RG93bj17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVLZXlEb3dufVxuICAgICAgICAgIG9uS2V5RG93bkNhcHR1cmU9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlS2V5RG93bkNhcHR1cmV9XG4gICAgICAgICAgb25LZXlQcmVzcz17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVLZXlQcmVzc31cbiAgICAgICAgICBvblNlbGVjdD17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVTZWxlY3R9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9e3R5cGVZb3VyTWVzc2FnZVN0cmluZ31cbiAgICAgICAgICByZWFkT25seT17ZGlzYWJsZWR9XG4gICAgICAgICAgcmVmPXtpbnB1dEVsZW1lbnRSZWZ9XG4gICAgICAgICAgcm93cz17MX1cbiAgICAgICAgICB0ZXh0QXJlYUNsYXNzTmFtZT1cIndlYmNoYXRfX3NlbmQtYm94LXRleHQtYm94X19odG1sLXRleHQtYXJlYVwiXG4gICAgICAgICAgdmFsdWU9e3RleHRCb3hWYWx1ZX1cbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgICB7ZGlzYWJsZWQgJiYgPGRpdiBjbGFzc05hbWU9XCJ3ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveF9fZ2xhc3NcIiAvPn1cbiAgICA8L2Zvcm0+XG4gICk7XG59O1xuXG5UZXh0Qm94LmRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiAnJ1xufTtcblxuVGV4dEJveC5wcm9wVHlwZXMgPSB7XG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVGV4dEJveDtcblxuZXhwb3J0IHsgY29ubmVjdFNlbmRUZXh0Qm94LCB1c2VUZXh0Qm94U3VibWl0LCB1c2VUZXh0Qm94VmFsdWUgfTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQSxJQUFRQSxXQUFSLEdBQXFHQyw2QkFBckcsQ0FBUUQsV0FBUjtBQUFBLElBQXFCRSxZQUFyQixHQUFxR0QsNkJBQXJHLENBQXFCQyxZQUFyQjtBQUFBLElBQW1DQyxXQUFuQyxHQUFxR0YsNkJBQXJHLENBQW1DRSxXQUFuQztBQUFBLElBQWdEQyxlQUFoRCxHQUFxR0gsNkJBQXJHLENBQWdERyxlQUFoRDtBQUFBLElBQWlFQyxjQUFqRSxHQUFxR0osNkJBQXJHLENBQWlFSSxjQUFqRTtBQUFBLElBQWlGQyxlQUFqRixHQUFxR0wsNkJBQXJHLENBQWlGSyxlQUFqRjtBQUVBLElBQU1DLFVBQVUsR0FBRztFQUNqQixnQ0FBZ0M7SUFDOUJDLE9BQU8sRUFBRSxNQURxQjtJQUc5QixrRkFBa0Y7TUFDaEZDLElBQUksRUFBRTtJQUQwRTtFQUhwRDtBQURmLENBQW5COztBQVVBLElBQU1DLGtCQUFrQixHQUFHLFNBQXJCQSxrQkFBcUI7RUFBQSxrQ0FBSUMsU0FBSjtJQUFJQSxTQUFKO0VBQUE7O0VBQUEsT0FDekJDLHlCQUFBLGdCQUNFO0lBQUEsSUFBR0MsUUFBSCxRQUFHQSxRQUFIO0lBQUEsSUFBYUMsWUFBYixRQUFhQSxZQUFiO0lBQUEsSUFBMkJDLFFBQTNCLFFBQTJCQSxRQUEzQjtJQUFBLElBQXFDQyxXQUFyQyxRQUFxQ0EsV0FBckM7SUFBQSxJQUFrREMsWUFBbEQsUUFBa0RBLFlBQWxEO0lBQUEsSUFBZ0VDLFVBQWhFLFFBQWdFQSxVQUFoRTtJQUFBLElBQTRFQyxXQUE1RSxRQUE0RUEs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