"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _callee;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _effects = require("redux-saga/effects");

var _jwtDecode = _interopRequireDefault(require("jwt-decode"));

var _connect = require("../actions/connect");

var _createPromiseQueue = _interopRequireDefault(require("../createPromiseQueue"));

var _forkPut = _interopRequireDefault(require("./effects/forkPut"));

var _uniqueID = _interopRequireDefault(require("../utils/uniqueID"));

var _updateConnectionStatus = _interopRequireWildcard(require("../actions/updateConnectionStatus"));

var _disconnect = require("../actions/disconnect");

var _reconnect = require("../actions/reconnect");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var _marked = /*#__PURE__*/_regenerator["default"].mark(observeAndPutConnectionStatusUpdate),
    _marked2 = /*#__PURE__*/_regenerator["default"].mark(connectSaga),
    _marked3 = /*#__PURE__*/_regenerator["default"].mark(reconnectSaga),
    _marked4 = /*#__PURE__*/_regenerator["default"].mark(runAsyncEffect),
    _marked5 = /*#__PURE__*/_regenerator["default"].mark(takeDisconnectAsError),
    _marked6 = /*#__PURE__*/_regenerator["default"].mark(_callee);

var CONNECTING = 1;
var ONLINE = 2;
var UNINITIALIZED = 0;

function randomUserID() {
  return "r_".concat((0, _uniqueID["default"])().substring(0, 10));
}

function observeAndPutConnectionStatusUpdate(directLine) {
  var connectionStatusQueue, connectionStatusSubscription, connectionStatus;
  return _regenerator["default"].wrap(function observeAndPutConnectionStatusUpdate$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          connectionStatusQueue = (0, _createPromiseQueue["default"])();
          connectionStatusSubscription = directLine.connectionStatus$.subscribe({
            next: connectionStatusQueue.push
          });
          _context.prev = 2;

        case 3:
          _context.next = 5;
          return (0, _effects.call)(connectionStatusQueue.shift);

        case 5:
          connectionStatus = _context.sent;
          _context.next = 8;
          return (0, _effects.put)((0, _updateConnectionStatus["default"])(connectionStatus));

        case 8:
          _context.next = 3;
          break;

        case 10:
          _context.prev = 10;
          connectionStatusSubscription.unsubscribe();
          return _context.finish(10);

        case 13:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[2,, 10, 13]]);
} // TODO: [P2] We should move this check and rectification to DirectLineJS.


function rectifyUserID(directLine, userIDFromAction) {
  var token = directLine.token;
  var userIDFromToken; // TODO: Add test to make sure "jwt-decode" work as expected.

  try {
    userIDFromToken = ((0, _jwtDecode["default"])(token) || {}).user; // eslint-disable-next-line no-empty
  } catch (err) {}

  var result = {
    fromAction: userIDFromAction,
    fromToken: userIDFromToken
  };

  if (userIDFromToken) {
    if (userIDFromAction && userIDFromAction !== userIDFromToken) {
      console.warn('Web Chat: user ID is both specified in the Direct Line token and passed in, will use the user ID from the token.');
    }

    result["final"] = userIDFromToken;
  } else if (userIDFromAction) {
    if (typeof userIDFromAction !== 'string') {
      console.warn('Web Chat: user ID must be a string.');
      result["final"] = randomUserID();
    } else if (/^dl_/.test(userIDFromAction)) {
      console.warn('Web Chat: user ID prefixed with "dl_" is reserved and must be embedded into the Direct Line token to prevent forgery.');
      result["final"] = randomUserID();
    } else {
      result["final"] = userIDFromAction;
    }
  } else {
    result["final"] = randomUserID();
  }

  return result;
} // We could make this a Promise instead of saga (function generator) to make the code cleaner, if:
// 1. We found a way to cancel Promise
// 2. subscribe() are shared amongst all subscriptions, e.g. turn Observable into events


function connectSaga(directLine) {
  var activitySubscription, unsubscribeActivity, _yield$take, connectionStatus;

  return _regenerator["default"].wrap(function connectSaga$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          // DirectLineJS starts the connection only after the first subscriber for activity$, not connectionStatus$
          activitySubscription = directLine.activity$.subscribe({
            next: function next() {
              return 0;
            }
          });
          unsubscribeActivity = activitySubscription.unsubscribe.bind(activitySubscription);
          _context2.prev = 2;

        case 3:
          _context2.next = 5;
          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);

        case 5:
          _yield$take = _context2.sent;
          connectionStatus = _yield$take.payload.connectionStatus;

          if (!(connectionStatus === ONLINE)) {
            _context2.next = 11;
            break;
          }

          return _context2.abrupt("return", function () {
            unsubscribeActivity();
            directLine.end();
          });

        case 11:
          if (!(connectionStatus !== UNINITIALIZED && connectionStatus !== CONNECTING)) {
            _context2.next = 13;
            break;
          }

          throw new Error("Failed to connect, DirectLineJS returned ".concat(connectionStatus, "."));

        case 13:
          _context2.next = 3;
          break;

        case 15:
          _context2.next = 21;
          break;

        case 17:
          _context2.prev = 17;
          _context2.t0 = _context2["catch"](2);
          // We will unsubscribe if we failed to connect or got cancelled only.
          // We should not unsubscribe in happy case, because DirectLineJS should relying on the subscription to connect/disconnect.
          unsubscribeActivity();
          throw _context2.t0;

        case 21:
          _context2.prev = 21;
          _context2.next = 24;
          return (0, _effects.cancelled)();

        case 24:
          if (!_context2.sent) {
            _context2.next = 26;
            break;
          }

          unsubscribeActivity();

        case 26:
          return _context2.finish(21);

        case 27:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[2, 17, 21, 27]]);
}

function reconnectSaga() {
  var _yield$take2, connectionStatus;

  return _regenerator["default"].wrap(function reconnectSaga$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);

        case 2:
          _yield$take2 = _context3.sent;
          connectionStatus = _yield$take2.payload.connectionStatus;

          if (!(connectionStatus === ONLINE)) {
            _context3.next = 8;
            break;
          }

          return _context3.abrupt("break", 12);

        case 8:
          if (!(connectionStatus !== CONNECTING)) {
            _context3.next = 10;
            break;
          }

          throw new Error("Failed to reconnect. DirectLineJS returned ".concat(connectionStatus, "."));

        case 10:
          _context3.next = 0;
          break;

        case 12:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
} // This is similar to behavior of redux-promise-middleware, but using saga instead of Promise.
// We guarantee PENDING -> FULFILLING -> FULFILLED, or PENDING -> REJECTED. This will help us simplify logic in other part of code.
// Note that after the saga is cancelled, subsequent call to put() will be ignored silently.


function runAsyncEffect(_ref, callEffectFactory) {
  var type, meta, payload, result;
  return _regenerator["default"].wrap(function runAsyncEffect$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          type = _ref.type, meta = _ref.meta, payload = _ref.payload;
          _context4.prev = 1;
          _context4.next = 4;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_PENDING"),
            meta: meta,
            payload: payload
          });

        case 4:
          _context4.next = 6;
          return callEffectFactory();

        case 6:
          result = _context4.sent;
          _context4.next = 9;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_FULFILLING"),
            meta: meta,
            payload: payload
          }, {
            type: "".concat(type, "_FULFILLED"),
            meta: meta,
            payload: payload
          });

        case 9:
          return _context4.abrupt("return", result);

        case 12:
          _context4.prev = 12;
          _context4.t0 = _context4["catch"](1);
          _context4.next = 16;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_REJECTED"),
            error: true,
            meta: meta,
            payload: _context4.t0
          });

        case 16:
          throw _context4.t0;

        case 17:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, null, [[1, 12]]);
}

function takeDisconnectAsError() {
  return _regenerator["default"].wrap(function takeDisconnectAsError$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _effects.take)(_disconnect.DISCONNECT);

        case 2:
          throw new Error('disconnected');

        case 3:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5);
}

function runAsyncEffectUntilDisconnect(baseAction, callEffectFactory) {
  // We cannot use saga cancel() here, because cancelling saga will prohibit us from sending *_REJECTED.
  // Without REJECTED, it impacts our assumptions around PENDING/FULFILLED/REJECTED.
  return runAsyncEffect(baseAction, /*#__PURE__*/_regenerator["default"].mark(function runUntilDisconnect() {
    var _yield$race, result;

    return _regenerator["default"].wrap(function runUntilDisconnect$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return (0, _effects.race)({
              _: takeDisconnectAsError(),
              result: callEffectFactory()
            });

          case 2:
            _yield$race = _context6.sent;
            result = _yield$race.result;
            return _context6.abrupt("return", result);

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, runUntilDisconnect);
  }));
}

function _callee() {
  var _loop;

  return _regenerator["default"].wrap(function _callee$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _loop = /*#__PURE__*/_regenerator["default"].mark(function _loop() {
            var _yield$take3, _yield$take3$payload, directLine, userIDFromAction, username, updateConnectionStatusTask, rectifiedUserID, meta, disconnectMeta, endDirectLine, _yield$race2, _yield$race2$updateCo, _yield$race2$updateCo2, connectionStatus;

            return _regenerator["default"].wrap(function _loop$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return (0, _effects.take)(_connect.CONNECT);

                  case 2:
                    _yield$take3 = _context7.sent;
                    _yield$take3$payload = _yield$take3.payload;
                    directLine = _yield$take3$payload.directLine;
                    userIDFromAction = _yield$take3$payload.userID;
                    username = _yield$take3$payload.username;
                    _context7.next = 9;
                    return (0, _effects.fork)(observeAndPutConnectionStatusUpdate, directLine);

                  case 9:
                    updateConnectionStatusTask = _context7.sent;
                    rectifiedUserID = rectifyUserID(directLine, userIDFromAction); // TODO: [P2] Checks if this attached subtask will get killed if the parent task is complete (peacefully), errored out, or cancelled.

                    meta = {
                      userID: rectifiedUserID["final"],
                      username: username
                    }; // Send user ID to DirectLineJS if it was specified from props of <API.Composer>.
                    // However, DirectLineJS may still prefer the user ID from token if it is burnt into the token.
                    // To prevent DirectLineJS giving false warnings, we will only call setUserId() if it is different than the token.

                    directLine.setUserId && rectifiedUserID.fromToken !== meta.userID && directLine.setUserId(meta.userID);
                    disconnectMeta = void 0; // We will dispatch CONNECT_PENDING, wait for connect completed, errored, or cancelled (thru disconnect).
                    // Then dispatch CONNECT_FULFILLED/CONNECT_REJECTED as needed.

                    _context7.prev = 14;
                    _context7.next = 17;
                    return runAsyncEffectUntilDisconnect({
                      type: _connect.CONNECT,
                      meta: meta,
                      payload: {
                        directLine: directLine
                      }
                    }, function () {
                      return (0, _effects.call)(connectSaga, directLine);
                    });

                  case 17:
                    endDirectLine = _context7.sent;
                    _context7.prev = 18;

                  case 19:
                    _context7.next = 21;
                    return (0, _effects.race)({
                      _: (0, _effects.take)(_disconnect.DISCONNECT),
                      updateConnectionStatusAction: (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS)
                    });

                  case 21:
                    _yield$race2 = _context7.sent;
                    _yield$race2$updateCo = _yield$race2.updateConnectionStatusAction;
                    _yield$race2$updateCo = _yield$race2$updateCo === void 0 ? {} : _yield$race2$updateCo;
                    _yield$race2$updateCo2 = _yield$race2$updateCo.payload;
                    _yield$race2$updateCo2 = _yield$race2$updateCo2 === void 0 ? {} : _yield$race2$updateCo2;
                    connectionStatus = _yield$race2$updateCo2.connectionStatus; // If it is not disconnect action, connectionStatus will not be undefined.

                    if (!(connectionStatus === CONNECTING)) {
                      _context7.next = 32;
                      break;
                    }

                    _context7.next = 30;
                    return runAsyncEffectUntilDisconnect({
                      type: _reconnect.RECONNECT,
                      meta: meta,
                      payload: {
                        directLine: directLine
                      }
                    }, function () {
                      return (0, _effects.call)(reconnectSaga);
                    });

                  case 30:
                    _context7.next = 38;
                    break;

                  case 32:
                    if (!(connectionStatus !== ONLINE)) {
                      _context7.next = 38;
                      break;
                    }

                    if (!(typeof connectionStatus !== 'undefined')) {
                      _context7.next = 37;
                      break;
                    }

                    throw new Error("Connection status changed to ".concat(connectionStatus));

                  case 37:
                    return _context7.abrupt("break", 40);

                  case 38:
                    _context7.next = 19;
                    break;

                  case 40:
                    _context7.prev = 40;
                    endDirectLine();
                    return _context7.finish(40);

                  case 43:
                    _context7.next = 48;
                    break;

                  case 45:
                    _context7.prev = 45;
                    _context7.t0 = _context7["catch"](14);
                    disconnectMeta = {
                      error: _context7.t0
                    };

                  case 48:
                    _context7.prev = 48;
                    _context7.next = 51;
                    return (0, _effects.cancel)(updateConnectionStatusTask);

                  case 51:
                    _context7.next = 53;
                    return (0, _forkPut["default"])({
                      type: _disconnect.DISCONNECT_PENDING,
                      meta: disconnectMeta,
                      payload: {
                        directLine: directLine
                      }
                    }, {
                      type: _disconnect.DISCONNECT_FULFILLED,
                      meta: disconnectMeta,
                      payload: {
                        directLine: directLine
                      }
                    });

                  case 53:
                    return _context7.finish(48);

                  case 54:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _loop, null, [[14, 45, 48, 54], [18,, 40, 43]]);
          });

        case 1:
          return _context8.delegateYield(_loop(), "t0", 2);

        case 2:
          _context8.next = 1;
          break;

        case 4:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked6);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJvYnNlcnZlQW5kUHV0Q29ubmVjdGlvblN0YXR1c1VwZGF0ZSIsImNvbm5lY3RTYWdhIiwicmVjb25uZWN0U2FnYSIsInJ1bkFzeW5jRWZmZWN0IiwidGFrZURpc2Nvbm5lY3RBc0Vycm9yIiwiQ09OTkVDVElORyIsIk9OTElORSIsIlVOSU5JVElBTElaRUQiLCJyYW5kb21Vc2VySUQiLCJ1bmlxdWVJRCIsInN1YnN0cmluZyIsImRpcmVjdExpbmUiLCJjb25uZWN0aW9uU3RhdHVzUXVldWUiLCJjcmVhdGVQcm9taXNlUXVldWUiLCJjb25uZWN0aW9uU3RhdHVzU3Vic2NyaXB0aW9uIiwiY29ubmVjdGlvblN0YXR1cyQiLCJzdWJzY3JpYmUiLCJuZXh0IiwicHVzaCIsImNhbGwiLCJzaGlmdCIsImNvbm5lY3Rpb25TdGF0dXMiLCJwdXQiLCJ1cGRhdGVDb25uZWN0aW9uU3RhdHVzIiwidW5zdWJzY3JpYmUiLCJyZWN0aWZ5VXNlcklEIiwidXNlcklERnJvbUFjdGlvbiIsInRva2VuIiwidXNlcklERnJvbVRva2VuIiwiZGVjb2RlIiwidXNlciIsImVyciIsInJlc3VsdCIsImZyb21BY3Rpb24iLCJmcm9tVG9rZW4iLCJjb25zb2xlIiwid2FybiIsInRlc3QiLCJhY3Rpdml0eVN1YnNjcmlwdGlvbiIsImFjdGl2aXR5JCIsInVuc3Vic2NyaWJlQWN0aXZpdHkiLCJiaW5kIiwidGFrZSIsIlVQREFURV9DT05ORUNUSU9OX1NUQVRVUyIsInBheWxvYWQiLCJlbmQiLCJFcnJvciIsImNhbmNlbGxlZCIsImNhbGxFZmZlY3RGYWN0b3J5IiwidHlwZSIsIm1ldGEiLCJmb3JrUHV0IiwiZXJyb3IiLCJESVNDT05ORUNUIiwicnVuQXN5bmNFZmZlY3RVbnRpbERpc2Nvbm5lY3QiLCJiYXNlQWN0aW9uIiwicnVuVW50aWxEaXNjb25uZWN0IiwicmFjZSIsIl8iLCJDT05ORUNUIiwidXNlcklEIiwidXNlcm5hbWUiLCJmb3JrIiwidXBkYXRlQ29ubmVjdGlvblN0YXR1c1Rhc2siLCJyZWN0aWZpZWRVc2VySUQiLCJzZXRVc2VySWQiLCJkaXNjb25uZWN0TWV0YSIsImVuZERpcmVjdExpbmUiLCJ1cGRhdGVDb25uZWN0aW9uU3RhdHVzQWN0aW9uIiwiUkVDT05ORUNUIiwiY2FuY2VsIiwiRElTQ09OTkVDVF9QRU5ESU5HIiwiRElTQ09OTkVDVF9GVUxGSUxMRUQiXSwic291cmNlUm9vdCI6ImNvcmU6Ly8vIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc2FnYXMvY29ubmVjdFNhZ2EuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLW1hZ2ljLW51bWJlcnM6IFtcImVycm9yXCIsIHsgXCJpZ25vcmVcIjogWzAsIDEwXSB9XSAqL1xuXG5pbXBvcnQgeyBjYWxsLCBjYW5jZWwsIGNhbmNlbGxlZCwgZm9yaywgcHV0LCByYWNlLCB0YWtlIH0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcblxuaW1wb3J0IGRlY29kZSBmcm9tICdqd3QtZGVjb2RlJztcblxuaW1wb3J0IHsgQ09OTkVDVCB9IGZyb20gJy4uL2FjdGlvbnMvY29ubmVjdCc7XG5pbXBvcnQgY3JlYXRlUHJvbWlzZVF1ZXVlIGZyb20gJy4uL2NyZWF0ZVByb21pc2VRdWV1ZSc7XG5pbXBvcnQgZm9ya1B1dCBmcm9tICcuL2VmZmVjdHMvZm9ya1B1dCc7XG5pbXBvcnQgdW5pcXVlSUQgZnJvbSAnLi4vdXRpbHMvdW5pcXVlSUQnO1xuaW1wb3J0IHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXMsIHsgVVBEQVRFX0NPTk5FQ1RJT05fU1RBVFVTIH0gZnJvbSAnLi4vYWN0aW9ucy91cGRhdGVDb25uZWN0aW9uU3RhdHVzJztcblxuaW1wb3J0IHsgRElTQ09OTkVDVCwgRElTQ09OTkVDVF9QRU5ESU5HLCBESVNDT05ORUNUX0ZVTEZJTExFRCB9IGZyb20gJy4uL2FjdGlvbnMvZGlzY29ubmVjdCc7XG5cbmltcG9ydCB7IFJFQ09OTkVDVCB9IGZyb20gJy4uL2FjdGlvbnMvcmVjb25uZWN0JztcblxuY29uc3QgQ09OTkVDVElORyA9IDE7XG5jb25zdCBPTkxJTkUgPSAyO1xuY29uc3QgVU5JTklUSUFMSVpFRCA9IDA7XG5cbmZ1bmN0aW9uIHJhbmRvbVVzZXJJRCgpIHtcbiAgcmV0dXJuIGByXyR7dW5pcXVlSUQoKS5zdWJzdHJpbmcoMCwgMTApfWA7XG59XG5cbmZ1bmN0aW9uKiBvYnNlcnZlQW5kUHV0Q29ubmVjdGlvblN0YXR1c1VwZGF0ZShkaXJlY3RMaW5lKSB7XG4gIGNvbnN0IGNvbm5lY3Rpb25TdGF0dXNRdWV1ZSA9IGNyZWF0ZVByb21pc2VRdWV1ZSgpO1xuICBjb25zdCBjb25uZWN0aW9uU3RhdHVzU3Vic2NyaXB0aW9uID0gZGlyZWN0TGluZS5jb25uZWN0aW9uU3RhdHVzJC5zdWJzY3JpYmUoeyBuZXh0OiBjb25uZWN0aW9uU3RhdHVzUXVldWUucHVzaCB9KTtcblxuICB0cnkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0dXMgPSB5aWVsZCBjYWxsKGNvbm5lY3Rpb25TdGF0dXNRdWV1ZS5zaGlmdCk7XG5cbiAgICAgIHlpZWxkIHB1dCh1cGRhdGVDb25uZWN0aW9uU3RhdHVzKGNvbm5lY3Rpb25TdGF0dXMpKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgY29ubmVjdGlvblN0YXR1c1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG5cbi8vIFRPRE86IFtQMl0gV2Ugc2hvdWxkIG1vdmUgdGhpcyBjaGVjayBhbmQgcmVjdGlmaWNhdGlvbiB0byBEaXJlY3RMaW5lSlMuXG5mdW5jdGlvbiByZWN0aWZ5VXNlcklEKGRpcmVjdExpbmUsIHVzZXJJREZyb21BY3Rpb24pIHtcbiAgY29uc3QgeyB0b2tlbiB9ID0gZGlyZWN0TGluZTtcblxuICBsZXQgdXNlcklERnJvbVRva2VuO1xuXG4gIC8vIFRPRE86IEFkZCB0ZXN0IHRvIG1ha2Ugc3VyZSBcImp3dC1kZWNvZGVcIiB3b3JrIGFzIGV4cGVjdGVkLlxuICB0cnkge1xuICAgIHVzZXJJREZyb21Ub2tlbiA9IChkZWNvZGUodG9rZW4pIHx8IHt9KS51c2VyO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGZyb21BY3Rpb246IHVzZXJJREZyb21BY3Rpb24sXG4gICAgZnJvbVRva2VuOiB1c2VySURGcm9tVG9rZW5cbiAgfTtcblxuICBpZiAodXNlcklERnJvbVRva2VuKSB7XG4gICAgaWYgKHVzZXJJREZyb21BY3Rpb24gJiYgdXNlcklERnJvbUFjdGlvbiAhPT0gdXNlcklERnJvbVRva2VuKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdXZWIgQ2hhdDogdXNlciBJRCBpcyBib3RoIHNwZWNpZmllZCBpbiB0aGUgRGlyZWN0IExpbmUgdG9rZW4gYW5kIHBhc3NlZCBpbiwgd2lsbCB1c2UgdGhlIHVzZXIgSUQgZnJvbSB0aGUgdG9rZW4uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXN1bHQuZmluYWwgPSB1c2VySURGcm9tVG9rZW47XG4gIH0gZWxzZSBpZiAodXNlcklERnJvbUFjdGlvbikge1xuICAgIGlmICh0eXBlb2YgdXNlcklERnJvbUFjdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnNvbGUud2FybignV2ViIENoYXQ6IHVzZXIgSUQgbXVzdCBiZSBhIHN0cmluZy4nKTtcblxuICAgICAgcmVzdWx0LmZpbmFsID0gcmFuZG9tVXNlcklEKCk7XG4gICAgfSBlbHNlIGlmICgvXmRsXy91LnRlc3QodXNlcklERnJvbUFjdGlvbikpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1dlYiBDaGF0OiB1c2VyIElEIHByZWZpeGVkIHdpdGggXCJkbF9cIiBpcyByZXNlcnZlZCBhbmQgbXVzdCBiZSBlbWJlZGRlZCBpbnRvIHRoZSBEaXJlY3QgTGluZSB0b2tlbiB0byBwcmV2ZW50IGZvcmdlcnkuJ1xuICAgICAgKTtcblxuICAgICAgcmVzdWx0LmZpbmFsID0gcmFuZG9tVXNlcklEKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5maW5hbCA9IHVzZXJJREZyb21BY3Rpb247XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5maW5hbCA9IHJhbmRvbVVzZXJJRCgpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gV2UgY291bGQgbWFrZSB0aGlzIGEgUHJvbWlzZSBpbnN0ZWFkIG9mIHNhZ2EgKGZ1bmN0aW9uIGdlbmVyYXRvcikgdG8gbWFrZSB0aGUgY29kZSBjbGVhbmVyLCBpZjpcbi8vIDEuIFdlIGZvdW5kIGEgd2F5IHRvIGNhbmNlbCBQcm9taXNlXG4vLyAyLiBzdWJzY3JpYmUoKSBhcmUgc2hhcmVkIGFtb25nc3QgYWxsIHN1YnNjcmlwdGlvbnMsIGUuZy4gdHVybiBPYnNlcnZhYmxlIGludG8gZXZlbnRzXG5mdW5jdGlvbiogY29ubmVjdFNhZ2EoZGlyZWN0TGluZSkge1xuICAvLyBEaXJlY3RMaW5lSlMgc3RhcnRzIHRoZSBjb25uZWN0aW9uIG9ubHkgYWZ0ZXIgdGhlIGZpcnN0IHN1YnNjcmliZXIgZm9yIGFjdGl2aXR5JCwgbm90IGNvbm5lY3Rpb25TdGF0dXMkXG4gIGNvbnN0IGFjdGl2aXR5U3Vic2NyaXB0aW9uID0gZGlyZWN0TGluZS5hY3Rpdml0eSQuc3Vic2NyaWJlKHsgbmV4dDogKCkgPT4gMCB9KTtcbiAgY29uc3QgdW5zdWJzY3JpYmVBY3Rpdml0eSA9IGFjdGl2aXR5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlLmJpbmQoYWN0aXZpdHlTdWJzY3JpcHRpb24pO1xuXG4gIHRyeSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXlsb2FkOiB7IGNvbm5lY3Rpb25TdGF0dXMgfVxuICAgICAgfSA9IHlpZWxkIHRha2UoVVBEQVRFX0NPTk5FQ1RJT05fU1RBVFVTKTtcblxuICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0dXMgPT09IE9OTElORSkge1xuICAgICAgICAvLyBUT0RPOiBbUDJdIERpcmVjdExpbmVKUyBzaG91bGQga2lsbCB0aGUgY29ubmVjdGlvbiB3aGVuIHdlIHVuc3Vic2NyaWJlXG4gICAgICAgIC8vICAgICAgIEJ1dCBjdXJyZW50bHkgaW4gdjMsIERpcmVjdExpbmVKUyBkb2VzIG5vdCBoYXZlIHRoaXMgZnVuY3Rpb25hbGl0eVxuICAgICAgICAvLyAgICAgICBUaHVzLCB3ZSBuZWVkIHRvIGNhbGwgXCJlbmQoKVwiIGV4cGxpY2l0bHlcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlQWN0aXZpdHkoKTtcbiAgICAgICAgICBkaXJlY3RMaW5lLmVuZCgpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdHVzICE9PSBVTklOSVRJQUxJWkVEICYmIGNvbm5lY3Rpb25TdGF0dXMgIT09IENPTk5FQ1RJTkcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29ubmVjdCwgRGlyZWN0TGluZUpTIHJldHVybmVkICR7Y29ubmVjdGlvblN0YXR1c30uYCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBXZSB3aWxsIHVuc3Vic2NyaWJlIGlmIHdlIGZhaWxlZCB0byBjb25uZWN0IG9yIGdvdCBjYW5jZWxsZWQgb25seS5cbiAgICAvLyBXZSBzaG91bGQgbm90IHVuc3Vic2NyaWJlIGluIGhhcHB5IGNhc2UsIGJlY2F1c2UgRGlyZWN0TGluZUpTIHNob3VsZCByZWx5aW5nIG9uIHRoZSBzdWJzY3JpcHRpb24gdG8gY29ubmVjdC9kaXNjb25uZWN0LlxuICAgIHVuc3Vic2NyaWJlQWN0aXZpdHkoKTtcblxuICAgIHRocm93IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoeWllbGQgY2FuY2VsbGVkKCkpIHtcbiAgICAgIHVuc3Vic2NyaWJlQWN0aXZpdHkoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24qIHJlY29ubmVjdFNhZ2EoKSB7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXlsb2FkOiB7IGNvbm5lY3Rpb25TdGF0dXMgfVxuICAgIH0gPSB5aWVsZCB0YWtlKFVQREFURV9DT05ORUNUSU9OX1NUQVRVUyk7XG5cbiAgICBpZiAoY29ubmVjdGlvblN0YXR1cyA9PT0gT05MSU5FKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0dXMgIT09IENPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlY29ubmVjdC4gRGlyZWN0TGluZUpTIHJldHVybmVkICR7Y29ubmVjdGlvblN0YXR1c30uYCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgc2ltaWxhciB0byBiZWhhdmlvciBvZiByZWR1eC1wcm9taXNlLW1pZGRsZXdhcmUsIGJ1dCB1c2luZyBzYWdhIGluc3RlYWQgb2YgUHJvbWlzZS5cbi8vIFdlIGd1YXJhbnRlZSBQRU5ESU5HIC0+IEZVTEZJTExJTkcgLT4gRlVMRklMTEVELCBvciBQRU5ESU5HIC0+IFJFSkVDVEVELiBUaGlzIHdpbGwgaGVscCB1cyBzaW1wbGlmeSBsb2dpYyBpbiBvdGhlciBwYXJ0IG9mIGNvZGUuXG4vLyBOb3RlIHRoYXQgYWZ0ZXIgdGhlIHNhZ2EgaXMgY2FuY2VsbGVkLCBzdWJzZXF1ZW50IGNhbGwgdG8gcHV0KCkgd2lsbCBiZSBpZ25vcmVkIHNpbGVudGx5LlxuZnVuY3Rpb24qIHJ1bkFzeW5jRWZmZWN0KHsgdHlwZSwgbWV0YSwgcGF5bG9hZCB9LCBjYWxsRWZmZWN0RmFjdG9yeSkge1xuICB0cnkge1xuICAgIHlpZWxkIGZvcmtQdXQoeyB0eXBlOiBgJHt0eXBlfV9QRU5ESU5HYCwgbWV0YSwgcGF5bG9hZCB9KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGNhbGxFZmZlY3RGYWN0b3J5KCk7XG5cbiAgICB5aWVsZCBmb3JrUHV0KHsgdHlwZTogYCR7dHlwZX1fRlVMRklMTElOR2AsIG1ldGEsIHBheWxvYWQgfSwgeyB0eXBlOiBgJHt0eXBlfV9GVUxGSUxMRURgLCBtZXRhLCBwYXlsb2FkIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAocGF5bG9hZCkge1xuICAgIHlpZWxkIGZvcmtQdXQoeyB0eXBlOiBgJHt0eXBlfV9SRUpFQ1RFRGAsIGVycm9yOiB0cnVlLCBtZXRhLCBwYXlsb2FkIH0pO1xuXG4gICAgdGhyb3cgcGF5bG9hZDtcbiAgfVxufVxuXG5mdW5jdGlvbiogdGFrZURpc2Nvbm5lY3RBc0Vycm9yKCkge1xuICB5aWVsZCB0YWtlKERJU0NPTk5FQ1QpO1xuXG4gIHRocm93IG5ldyBFcnJvcignZGlzY29ubmVjdGVkJyk7XG59XG5cbmZ1bmN0aW9uIHJ1bkFzeW5jRWZmZWN0VW50aWxEaXNjb25uZWN0KGJhc2VBY3Rpb24sIGNhbGxFZmZlY3RGYWN0b3J5KSB7XG4gIC8vIFdlIGNhbm5vdCB1c2Ugc2FnYSBjYW5jZWwoKSBoZXJlLCBiZWNhdXNlIGNhbmNlbGxpbmcgc2FnYSB3aWxsIHByb2hpYml0IHVzIGZyb20gc2VuZGluZyAqX1JFSkVDVEVELlxuICAvLyBXaXRob3V0IFJFSkVDVEVELCBpdCBpbXBhY3RzIG91ciBhc3N1bXB0aW9ucyBhcm91bmQgUEVORElORy9GVUxGSUxMRUQvUkVKRUNURUQuXG4gIHJldHVybiBydW5Bc3luY0VmZmVjdChiYXNlQWN0aW9uLCBmdW5jdGlvbiogcnVuVW50aWxEaXNjb25uZWN0KCkge1xuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSB5aWVsZCByYWNlKHtcbiAgICAgIF86IHRha2VEaXNjb25uZWN0QXNFcnJvcigpLFxuICAgICAgcmVzdWx0OiBjYWxsRWZmZWN0RmFjdG9yeSgpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24qICgpIHtcbiAgZm9yICg7Oykge1xuICAgIGNvbnN0IHtcbiAgICAgIHBheWxvYWQ6IHsgZGlyZWN0TGluZSwgdXNlcklEOiB1c2VySURGcm9tQWN0aW9uLCB1c2VybmFtZSB9XG4gICAgfSA9IHlpZWxkIHRha2UoQ09OTkVDVCk7XG5cbiAgICBjb25zdCB1cGRhdGVDb25uZWN0aW9uU3RhdHVzVGFzayA9IHlpZWxkIGZvcmsob2JzZXJ2ZUFuZFB1dENvbm5lY3Rpb25TdGF0dXNVcGRhdGUsIGRpcmVjdExpbmUpO1xuICAgIGNvbnN0IHJlY3RpZmllZFVzZXJJRCA9IHJlY3RpZnlVc2VySUQoZGlyZWN0TGluZSwgdXNlcklERnJvbUFjdGlvbik7XG5cbiAgICAvLyBUT0RPOiBbUDJdIENoZWNrcyBpZiB0aGlzIGF0dGFjaGVkIHN1YnRhc2sgd2lsbCBnZXQga2lsbGVkIGlmIHRoZSBwYXJlbnQgdGFzayBpcyBjb21wbGV0ZSAocGVhY2VmdWxseSksIGVycm9yZWQgb3V0LCBvciBjYW5jZWxsZWQuXG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgIHVzZXJJRDogcmVjdGlmaWVkVXNlcklELmZpbmFsLFxuICAgICAgdXNlcm5hbWVcbiAgICB9O1xuXG4gICAgLy8gU2VuZCB1c2VyIElEIHRvIERpcmVjdExpbmVKUyBpZiBpdCB3YXMgc3BlY2lmaWVkIGZyb20gcHJvcHMgb2YgPEFQSS5Db21wb3Nlcj4uXG4gICAgLy8gSG93ZXZlciwgRGlyZWN0TGluZUpTIG1heSBzdGlsbCBwcmVmZXIgdGhlIHVzZXIgSUQgZnJvbSB0b2tlbiBpZiBpdCBpcyBidXJudCBpbnRvIHRoZSB0b2tlbi5cbiAgICAvLyBUbyBwcmV2ZW50IERpcmVjdExpbmVKUyBnaXZpbmcgZmFsc2Ugd2FybmluZ3MsIHdlIHdpbGwgb25seSBjYWxsIHNldFVzZXJJZCgpIGlmIGl0IGlzIGRpZmZlcmVudCB0aGFuIHRoZSB0b2tlbi5cbiAgICBkaXJlY3RMaW5lLnNldFVzZXJJZCAmJiByZWN0aWZpZWRVc2VySUQuZnJvbVRva2VuICE9PSBtZXRhLnVzZXJJRCAmJiBkaXJlY3RMaW5lLnNldFVzZXJJZChtZXRhLnVzZXJJRCk7XG5cbiAgICBsZXQgZGlzY29ubmVjdE1ldGE7XG5cbiAgICAvLyBXZSB3aWxsIGRpc3BhdGNoIENPTk5FQ1RfUEVORElORywgd2FpdCBmb3IgY29ubmVjdCBjb21wbGV0ZWQsIGVycm9yZWQsIG9yIGNhbmNlbGxlZCAodGhydSBkaXNjb25uZWN0KS5cbiAgICAvLyBUaGVuIGRpc3BhdGNoIENPTk5FQ1RfRlVMRklMTEVEL0NPTk5FQ1RfUkVKRUNURUQgYXMgbmVlZGVkLlxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmREaXJlY3RMaW5lID0geWllbGQgcnVuQXN5bmNFZmZlY3RVbnRpbERpc2Nvbm5lY3QoXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBDT05ORUNULFxuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgcGF5bG9hZDogeyBkaXJlY3RMaW5lIH1cbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gY2FsbChjb25uZWN0U2FnYSwgZGlyZWN0TGluZSlcbiAgICAgICk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAvLyBXZSBhcmUgd2FpdGluZyBmb3IgY29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlIG9yIGRpc2Nvbm5lY3QgYWN0aW9uLlxuICAgICAgICAgIGNvbnN0IHsgdXBkYXRlQ29ubmVjdGlvblN0YXR1c0FjdGlvbjogeyBwYXlsb2FkOiB7IGNvbm5lY3Rpb25TdGF0dXMgfSA9IHt9IH0gPSB7fSB9ID0geWllbGQgcmFjZSh7XG4gICAgICAgICAgICBfOiB0YWtlKERJU0NPTk5FQ1QpLFxuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvblN0YXR1c0FjdGlvbjogdGFrZShVUERBVEVfQ09OTkVDVElPTl9TVEFUVVMpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBJZiBpdCBpcyBub3QgZGlzY29ubmVjdCBhY3Rpb24sIGNvbm5lY3Rpb25TdGF0dXMgd2lsbCBub3QgYmUgdW5kZWZpbmVkLlxuICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhdHVzID09PSBDT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAvLyBJZiBEaXJlY3RMaW5lSlMgY2hhbmdlZCBjb25uZWN0aW9uU3RhdHVzIHRvIENPTk5FQ1RJTkcsIHdlIHdpbGwgdHJlYXQgaXQgYXMgcmVjb25uZWN0IHN0YXR1cy5cbiAgICAgICAgICAgIHlpZWxkIHJ1bkFzeW5jRWZmZWN0VW50aWxEaXNjb25uZWN0KFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogUkVDT05ORUNULFxuICAgICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogeyBkaXJlY3RMaW5lIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKCkgPT4gY2FsbChyZWNvbm5lY3RTYWdhKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0dXMgIT09IE9OTElORSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0aW9uU3RhdHVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGtpbGwgdGhlIGNvbm5lY3Rpb24gYmVjYXVzZSBEaXJlY3RMaW5lSlMgd2FudCB0byBjbG9zZSBpdC5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIHN0YXR1cyBjaGFuZ2VkIHRvICR7Y29ubmVjdGlvblN0YXR1c31gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFNvbWVvbmUgZGlzcGF0Y2hlZCBkaXNjb25uZWN0IGFjdGlvbi5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBlbmREaXJlY3RMaW5lKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRpc2Nvbm5lY3RNZXRhID0geyBlcnJvciB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB5aWVsZCBjYW5jZWwodXBkYXRlQ29ubmVjdGlvblN0YXR1c1Rhc2spO1xuXG4gICAgICAvLyBFdmVuIGlmIHRoZSBjb25uZWN0aW9uIGlzIGludGVycnVwdGVkLCB3ZSB3aWxsIHN0aWxsIGVtaXQgRElTQ09OTkVDVF9QRU5ESU5HLlxuICAgICAgLy8gVGhpcyB3aWxsIG1ha2VzIGhhbmRsaW5nIGxvZ2ljIGVhc2llci4gSWYgQ09OTkVDVF9GVUxGSUxMRUQsIHdlIGd1YXJhbnRlZSBESVNDT05ORUNUX1BFTkRJTkcuXG4gICAgICB5aWVsZCBmb3JrUHV0KFxuICAgICAgICB7IHR5cGU6IERJU0NPTk5FQ1RfUEVORElORywgbWV0YTogZGlzY29ubmVjdE1ldGEsIHBheWxvYWQ6IHsgZGlyZWN0TGluZSB9IH0sXG4gICAgICAgIHsgdHlwZTogRElTQ09OTkVDVF9GVUxGSUxMRUQsIG1ldGE6IGRpc2Nvbm5lY3RNZXRhLCBwYXlsb2FkOiB7IGRpcmVjdExpbmUgfSB9XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRUE7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozt3REFVVUEsbUM7eURBZ0VBQyxXO3lEQXFDQUMsYTt5REFpQkFDLGM7eURBZ0JBQyxxQjs7O0FBOUlWLElBQU1DLFVBQVUsR0FBRyxDQUFuQjtBQUNBLElBQU1DLE1BQU0sR0FBRyxDQUFmO0FBQ0EsSUFBTUMsYUFBYSxHQUFHLENBQXRCOztBQUVBLFNBQVNDLFlBQVQsR0FBd0I7RUFDdEIsbUJBQVksSUFBQUMsb0JBQUEsSUFBV0MsU0FBWCxDQUFxQixDQUFyQixFQUF3QixFQUF4QixDQUFaO0FBQ0Q7O0FBRUQsU0FBVVYsbUNBQVYsQ0FBOENXLFVBQTlDO0VBQUE7RUFBQTtJQUFBO01BQUE7UUFBQTtVQUNRQyxxQkFEUixHQUNnQyxJQUFBQyw4QkFBQSxHQURoQztVQUVRQyw0QkFGUixHQUV1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