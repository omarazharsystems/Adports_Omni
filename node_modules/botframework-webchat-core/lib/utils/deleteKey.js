"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = deleteKey;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _isForbiddenPropertyName = _interopRequireDefault(require("./isForbiddenPropertyName"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function deleteKey(map) {
  if (!map) {
    return map;
  }

  var nextMap = _objectSpread({}, map);

  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];

    if (typeof key !== 'string' || !(0, _isForbiddenPropertyName["default"])(key)) {
      // Mitigation through denylisting.
      // eslint-disable-next-line security/detect-object-injection
      delete nextMap[key];
    }
  }

  return nextMap;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWxldGVLZXkiLCJtYXAiLCJuZXh0TWFwIiwia2V5cyIsImtleSIsImlzRm9yYmlkZGVuUHJvcGVydHlOYW1lIl0sInNvdXJjZVJvb3QiOiJjb3JlOi8vLyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL2RlbGV0ZUtleS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaXNGb3JiaWRkZW5Qcm9wZXJ0eU5hbWUgZnJvbSAnLi9pc0ZvcmJpZGRlblByb3BlcnR5TmFtZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlbGV0ZUtleTxUTWFwLCBUS2V5IGV4dGVuZHMga2V5b2YgVE1hcD4obWFwOiBUTWFwLCAuLi5rZXlzOiBUS2V5W10pOiBPbWl0PFRNYXAsIFRLZXk+IHtcbiAgaWYgKCFtYXApIHtcbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgY29uc3QgbmV4dE1hcCA9IHsgLi4ubWFwIH07XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhaXNGb3JiaWRkZW5Qcm9wZXJ0eU5hbWUoa2V5KSkge1xuICAgICAgLy8gTWl0aWdhdGlvbiB0aHJvdWdoIGRlbnlsaXN0aW5nLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1vYmplY3QtaW5qZWN0aW9uXG4gICAgICBkZWxldGUgbmV4dE1hcFtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0TWFwO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7Ozs7QUFFZSxTQUFTQSxTQUFULENBQWtEQyxHQUFsRCxFQUFnRztFQUM3RyxJQUFJLENBQUNBLEdBQUwsRUFBVTtJQUNSLE9BQU9BLEdBQVA7RUFDRDs7RUFFRCxJQUFNQyxPQUFPLHFCQUFRRCxHQUFSLENBQWI7O0VBTDZHLGtDQUFoQ0UsSUFBZ0M7SUFBaENBLElBQWdDO0VBQUE7O0VBTzdHLHlCQUFrQkEsSUFBbEIsMkJBQXdCO0lBQW5CLElBQU1DLEdBQUcsWUFBVDs7SUFDSCxJQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFmLElBQTJCLENBQUMsSUFBQUMsbUNBQUEsRUFBd0JELEdBQXhCLENBQWhDLEVBQThEO01BQzVEO01BQ0E7TUFDQSxPQUFPRixPQUFPLENBQUNFLEdBQUQsQ0FBZDtJQUNEO0VBQ0Y7O0VBRUQsT0FBT0YsT0FBUDtBQUNEIn0=