"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _hooks = require("../../hooks");

var _usePrevious = _interopRequireDefault(require("../../hooks/internal/usePrevious"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var ActivitySendStatusTelemetryComposer = function ActivitySendStatusTelemetryComposer() {
  var _useSendStatusByActiv = (0, _hooks.useSendStatusByActivityKey)(),
      _useSendStatusByActiv2 = _slicedToArray(_useSendStatusByActiv, 1),
      activityToSendStatusMap = _useSendStatusByActiv2[0];

  var prevActivityToSendStatusMap = (0, _usePrevious.default)(activityToSendStatusMap);
  var getActivityByKey = (0, _hooks.useGetActivityByKey)();
  var trackEvent = (0, _hooks.useTrackEvent)();

  if (prevActivityToSendStatusMap) {
    var _iterator = _createForOfIteratorHelper(activityToSendStatusMap.keys()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var key = _step.value;
        var status = activityToSendStatusMap.get(key);
        var prevStatus = prevActivityToSendStatusMap.get(key); // `status` is falsy if it is not an outgoing activity.
        // `prevStatus` is undefined or a valid status, if it is undefined, it is newly added
        // This telemetry data point only emit changes in outgoing activities.

        if (status && status !== prevStatus) {
          var _activity$attachments;

          var activity = getActivityByKey(key);
          var clientActivityID = activity === null || activity === void 0 ? void 0 : activity.channelData.clientActivityID;
          var type = activity === null || activity === void 0 ? void 0 : activity.type;

          var telemetryPayload = _objectSpread(_objectSpread({
            hasAttachment: (activity === null || activity === void 0 ? void 0 : activity.type) === 'message' && ((_activity$attachments = activity.attachments) === null || _activity$attachments === void 0 ? void 0 : _activity$attachments.length) > 0 ? 'true' : 'false',
            key: key,
            status: status
          }, clientActivityID ? {
            clientActivityID: clientActivityID
          } : {}), type ? {
            type: type
          } : {}); // Only add prevStatus if it is NOT null/undefined


          if (prevStatus) {
            telemetryPayload.prevStatus = prevStatus;
          }

          trackEvent('send-status:change', telemetryPayload);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return null;
};

var _default = ActivitySendStatusTelemetryComposer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJBY3Rpdml0eVNlbmRTdGF0dXNUZWxlbWV0cnlDb21wb3NlciIsInVzZVNlbmRTdGF0dXNCeUFjdGl2aXR5S2V5IiwiYWN0aXZpdHlUb1NlbmRTdGF0dXNNYXAiLCJwcmV2QWN0aXZpdHlUb1NlbmRTdGF0dXNNYXAiLCJ1c2VQcmV2aW91cyIsImdldEFjdGl2aXR5QnlLZXkiLCJ1c2VHZXRBY3Rpdml0eUJ5S2V5IiwidHJhY2tFdmVudCIsInVzZVRyYWNrRXZlbnQiLCJrZXlzIiwia2V5Iiwic3RhdHVzIiwiZ2V0IiwicHJldlN0YXR1cyIsImFjdGl2aXR5IiwiY2xpZW50QWN0aXZpdHlJRCIsImNoYW5uZWxEYXRhIiwidHlwZSIsInRlbGVtZXRyeVBheWxvYWQiLCJoYXNBdHRhY2htZW50IiwiYXR0YWNobWVudHMiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6ImNvbXBvbmVudDovLy8iLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcm92aWRlcnMvQWN0aXZpdHlTZW5kU3RhdHVzVGVsZW1ldHJ5L0FjdGl2aXR5U2VuZFN0YXR1c1RlbGVtZXRyeUNvbXBvc2VyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VHZXRBY3Rpdml0eUJ5S2V5LCB1c2VTZW5kU3RhdHVzQnlBY3Rpdml0eUtleSwgdXNlVHJhY2tFdmVudCB9IGZyb20gJy4uLy4uL2hvb2tzJztcclxuXHJcbmltcG9ydCB1c2VQcmV2aW91cyBmcm9tICcuLi8uLi9ob29rcy9pbnRlcm5hbC91c2VQcmV2aW91cyc7XHJcblxyXG50eXBlIFRlbGVtZXRyeVNlbmRTdGF0dXNDaGFuZ2VQYXlsb2FkID0ge1xyXG4gIGNsaWVudEFjdGl2aXR5SUQ/OiBzdHJpbmc7XHJcbiAgaGFzQXR0YWNobWVudD86ICd0cnVlJyB8ICdmYWxzZSc7XHJcbiAga2V5OiBzdHJpbmc7XHJcbiAgcHJldlN0YXR1cz86ICdzZW5kaW5nJyB8ICdzZW5kIGZhaWxlZCcgfCAnc2VudCc7XHJcbiAgc3RhdHVzOiAnc2VuZGluZycgfCAnc2VuZCBmYWlsZWQnIHwgJ3NlbnQnO1xyXG4gIHR5cGU/OiBzdHJpbmc7XHJcbn07XHJcblxyXG5jb25zdCBBY3Rpdml0eVNlbmRTdGF0dXNUZWxlbWV0cnlDb21wb3NlciA9ICgpID0+IHtcclxuICBjb25zdCBbYWN0aXZpdHlUb1NlbmRTdGF0dXNNYXBdID0gdXNlU2VuZFN0YXR1c0J5QWN0aXZpdHlLZXkoKTtcclxuICBjb25zdCBwcmV2QWN0aXZpdHlUb1NlbmRTdGF0dXNNYXAgPSB1c2VQcmV2aW91cyhhY3Rpdml0eVRvU2VuZFN0YXR1c01hcCk7XHJcbiAgY29uc3QgZ2V0QWN0aXZpdHlCeUtleSA9IHVzZUdldEFjdGl2aXR5QnlLZXkoKTtcclxuICBjb25zdCB0cmFja0V2ZW50ID0gdXNlVHJhY2tFdmVudCgpO1xyXG5cclxuICBpZiAocHJldkFjdGl2aXR5VG9TZW5kU3RhdHVzTWFwKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhY3Rpdml0eVRvU2VuZFN0YXR1c01hcC5rZXlzKCkpIHtcclxuICAgICAgY29uc3Qgc3RhdHVzID0gYWN0aXZpdHlUb1NlbmRTdGF0dXNNYXAuZ2V0KGtleSk7XHJcbiAgICAgIGNvbnN0IHByZXZTdGF0dXMgPSBwcmV2QWN0aXZpdHlUb1NlbmRTdGF0dXNNYXAuZ2V0KGtleSk7XHJcblxyXG4gICAgICAvLyBgc3RhdHVzYCBpcyBmYWxzeSBpZiBpdCBpcyBub3QgYW4gb3V0Z29pbmcgYWN0aXZpdHkuXHJcbiAgICAgIC8vIGBwcmV2U3RhdHVzYCBpcyB1bmRlZmluZWQgb3IgYSB2YWxpZCBzdGF0dXMsIGlmIGl0IGlzIHVuZGVmaW5lZCwgaXQgaXMgbmV3bHkgYWRkZWRcclxuICAgICAgLy8gVGhpcyB0ZWxlbWV0cnkgZGF0YSBwb2ludCBvbmx5IGVtaXQgY2hhbmdlcyBpbiBvdXRnb2luZyBhY3Rpdml0aWVzLlxyXG4gICAgICBpZiAoc3RhdHVzICYmIHN0YXR1cyAhPT0gcHJldlN0YXR1cykge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2aXR5ID0gZ2V0QWN0aXZpdHlCeUtleShrZXkpO1xyXG4gICAgICAgIGNvbnN0IGNsaWVudEFjdGl2aXR5SUQgPSBhY3Rpdml0eT8uY2hhbm5lbERhdGEuY2xpZW50QWN0aXZpdHlJRDtcclxuICAgICAgICBjb25zdCB0eXBlID0gYWN0aXZpdHk/LnR5cGU7XHJcblxyXG4gICAgICAgIGNvbnN0IHRlbGVtZXRyeVBheWxvYWQ6IFRlbGVtZXRyeVNlbmRTdGF0dXNDaGFuZ2VQYXlsb2FkID0ge1xyXG4gICAgICAgICAgaGFzQXR0YWNobWVudDogYWN0aXZpdHk/LnR5cGUgPT09ICdtZXNzYWdlJyAmJiBhY3Rpdml0eS5hdHRhY2htZW50cz8ubGVuZ3RoID4gMCA/ICd0cnVlJyA6ICdmYWxzZScsXHJcbiAgICAgICAgICBrZXksXHJcbiAgICAgICAgICBzdGF0dXMsXHJcbiAgICAgICAgICAuLi4oY2xpZW50QWN0aXZpdHlJRCA/IHsgY2xpZW50QWN0aXZpdHlJRCB9IDoge30pLFxyXG4gICAgICAgICAgLi4uKHR5cGUgPyB7IHR5cGUgfSA6IHt9KVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIE9ubHkgYWRkIHByZXZTdGF0dXMgaWYgaXQgaXMgTk9UIG51bGwvdW5kZWZpbmVkXHJcbiAgICAgICAgaWYgKHByZXZTdGF0dXMpIHtcclxuICAgICAgICAgIHRlbGVtZXRyeVBheWxvYWQucHJldlN0YXR1cyA9IHByZXZTdGF0dXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cmFja0V2ZW50KCdzZW5kLXN0YXR1czpjaGFuZ2UnLCB0ZWxlbWV0cnlQYXlsb2FkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBY3Rpdml0eVNlbmRTdGF0dXNUZWxlbWV0cnlDb21wb3NlcjtcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVdBLElBQU1BLG1DQUFtQyxHQUFHLFNBQXRDQSxtQ0FBc0MsR0FBTTtFQUNoRCw0QkFBa0MsSUFBQUMsaUNBQUEsR0FBbEM7RUFBQTtFQUFBLElBQU9DLHVCQUFQOztFQUNBLElBQU1DLDJCQUEyQixHQUFHLElBQUFDLG9CQUFBLEVBQVlGLHVCQUFaLENBQXBDO0VBQ0EsSUFBTUcsZ0JBQWdCLEdBQUcsSUFBQUMsMEJBQUEsR0FBekI7RUFDQSxJQUFNQyxVQUFVLEdBQUcsSUFBQUMsb0JBQUEsR0FBbkI7O0VBRUEsSUFBSUwsMkJBQUosRUFBaUM7SUFBQSwyQ0FDYkQsdUJBQXVCLENBQUNPLElBQXhCLEVBRGE7SUFBQTs7SUFBQTtNQUMvQixvREFBa0Q7UUFBQSxJQUF2Q0MsR0FBdUM7UUFDaEQsSUFBTUMsTUFBTSxHQUFHVCx1QkFBdUIsQ0FBQ1UsR0FBeEIsQ0FBNEJGLEdBQTVCLENBQWY7UUFDQSxJQUFNRyxVQUFVLEdBQUdWLDJCQUEyQixDQUFDUyxHQUE1QixDQUFnQ0YsR0FBaEMsQ0FBbkIsQ0FGZ0QsQ0FJaEQ7UUFDQTtRQUNBOztRQUNBLElBQUlDLE1BQU0sSUFBSUEsTUFBTSxLQUFLRSxVQUF6QixFQUFxQztVQUFBOztVQUNuQyxJQUFNQyxRQUFRLEdBQUdULGdCQUFnQixDQUFDSyxHQUFELENBQWpDO1VBQ0EsSUFBTUssZ0JBQWdCLEdBQUdELFFBQUgsYUFBR0EsUUFBSCx1QkFBR0EsUUFBUSxDQUFFRSxXQUFWLENBQXNCRCxnQkFBL0M7VUFDQSxJQUFNRSxJQUFJLEdBQUdILFFBQUgsYUFBR0EsUUFBSCx1QkFBR0EsUUFBUSxDQUFFRyxJQUF2Qjs7VUFFQSxJQUFNQyxnQkFBa0Q7WUFDdERDLGFBQWEsRUFBRSxDQUFBTCxRQUFRLFNBQVIsSUFBQUEsUUFBUSxXQUFSLFlBQUFBLFFBQVEsQ0FBRUcsSUFBVixNQUFtQixTQUFuQixJQUFnQywwQkFBQUgsUUFBUSxDQUFDTSxXQUFULGdGQUFzQkMsTUFBdEIsSUFBK0IsQ0FBL0QsR0FBbUUsTUFBbkUsR0FBNEUsT0FEckM7WUFFdERYLEdBQUcsRUFBSEEsR0FGc0Q7WUFHdERDLE1BQU0sRUFBTkE7VUFIc0QsR0FJbERJLGdCQUFnQixHQUFHO1lBQUVBLGdCQUFnQixFQUFoQkE7VUFBRixDQUFILEdBQTBCLEVBSlEsR0FLbERFLElBQUksR0FBRztZQUFFQSxJQUFJLEVBQUpBO1VBQUYsQ0FBSCxHQUFjLEVBTGdDLENBQXhELENBTG1DLENBYW5DOzs7VUFDQSxJQUFJSixVQUFKLEVBQWdCO1lBQ2RLLGdCQUFnQixDQUFDTCxVQUFqQixHQUE4QkEsVUFBOUI7VUFDRDs7VUFFRE4sVUFBVSxDQUFDLG9CQUFELEVBQXVCVyxnQkFBdkIsQ0FBVjtRQUNEO01BQ0Y7SUE1QjhCO01BQUE7SUFBQTtNQUFBO0lBQUE7RUE2QmhDOztFQUVELE9BQU8sSUFBUDtBQUNELENBdENEOztlQXdDZWxCLG1DIn0=