"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _SendStatus = require("../../types/internal/SendStatus");

var _Context = _interopRequireDefault(require("./private/Context"));

var _freezeArray = _interopRequireDefault(require("../../utils/freezeArray"));

var _isMapEqual = _interopRequireDefault(require("./private/isMapEqual"));

var _useActivities3 = _interopRequireDefault(require("../../hooks/useActivities"));

var _useForceRender = _interopRequireDefault(require("../../hooks/internal/useForceRender"));

var _useGetKeyByActivity = _interopRequireDefault(require("../ActivityKeyer/useGetKeyByActivity"));

var _useGetSendTimeoutForActivity = _interopRequireDefault(require("../../hooks/useGetSendTimeoutForActivity"));

var _usePonyfill3 = _interopRequireDefault(require("../../hooks/usePonyfill"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// Magic numbers for `expiryByActivityKey`.
var EXPIRY_SEND_FAILED = -Infinity;
var EXPIRY_SENT = Infinity;

var ActivitySendStatusComposer = function ActivitySendStatusComposer(_ref) {
  var children = _ref.children;

  var _useActivities = (0, _useActivities3.default)(),
      _useActivities2 = _slicedToArray(_useActivities, 1),
      activities = _useActivities2[0];

  var _usePonyfill = (0, _usePonyfill3.default)(),
      _usePonyfill2 = _slicedToArray(_usePonyfill, 1),
      _usePonyfill2$ = _usePonyfill2[0],
      clearTimeout = _usePonyfill2$.clearTimeout,
      Date = _usePonyfill2$.Date,
      setTimeout = _usePonyfill2$.setTimeout;

  var forceRender = (0, _useForceRender.default)();
  var getKeyByActivity = (0, _useGetKeyByActivity.default)();
  var getSendTimeoutForActivity = (0, _useGetSendTimeoutForActivity.default)();
  var sendStatusByActivityKeyRef = (0, _react.useRef)(Object.freeze(new Map()));
  /**
   * Map of outgoing activities and their respective expiry.
   *
   * The key is the activity key.
   *
   * The value is:
   *
   * - `Infinity` if the activity is already sent (and will never expire), otherwise;
   * - `-Infinity` if the activity failed to send (a.k.a. already expired), otherwise;
   * - An epoch time of when the activity will be expired.
   */

  var expiryByActivityKey = (0, _react.useMemo)( // We could build a `useMemoMap()` hook to memoize mapper function more efficiently.
  function () {
    return Object.freeze(activities.reduce(function (expiryByActivityKey, activity) {
      if (activity.from.role === 'user') {
        var key = getKeyByActivity(activity);

        if (key) {
          var _activity$channelData = activity.channelData,
              state = _activity$channelData.state,
              sendStatus = _activity$channelData['webchat:send-status']; // `channelData.state` is being deprecated in favor of `channelData['webchat:send-status']`.
          // Please refer to #4362 for details. Remove on or after 2024-07-31.

          var rectifiedSendStatus = sendStatus || (state === _SendStatus.SENT ? _SendStatus.SENT : _SendStatus.SENDING);

          if (rectifiedSendStatus === _SendStatus.SENT) {
            expiryByActivityKey.set(key, EXPIRY_SENT);
          } else if (rectifiedSendStatus === _SendStatus.SEND_FAILED) {
            expiryByActivityKey.set(key, EXPIRY_SEND_FAILED);
          } else {
            var expiry = +new Date(activity.localTimestamp) + getSendTimeoutForActivity({
              activity: activity
            });
            expiry && expiryByActivityKey.set(key, expiry);
          }
        }
      }

      return expiryByActivityKey;
    }, new Map()));
  }, [activities, Date, getKeyByActivity, getSendTimeoutForActivity]);
  /** Map of outgoing activities and their respective send status. */

  var nextSendStatusByActivityKey = new Map();
  var now = Date.now(); // Turns the expiry (epoch time) into `SendStatus`, which is based on current clock.

  var _iterator = _createForOfIteratorHelper(expiryByActivityKey),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
          key = _step$value[0],
          expiry = _step$value[1];

      nextSendStatusByActivityKey.set(key, expiry === EXPIRY_SENT ? _SendStatus.SENT : now >= expiry ? _SendStatus.SEND_FAILED : _SendStatus.SENDING);
    } // Only memoize the new result if it has changed.

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (!(0, _isMapEqual.default)(sendStatusByActivityKeyRef.current, nextSendStatusByActivityKey)) {
    sendStatusByActivityKeyRef.current = Object.freeze(nextSendStatusByActivityKey);
  } // Gets/realizes the `current` from `ref` because we need to use it for `deps` array in hooks for memoization.


  var sendStatusByActivityKey = sendStatusByActivityKeyRef.current;
  var sendStatusByActivityKeyState = (0, _react.useMemo)(function () {
    return (0, _freezeArray.default)([sendStatusByActivityKey]);
  }, [sendStatusByActivityKey]);
  var context = (0, _react.useMemo)(function () {
    return {
      sendStatusByActivityKeyState: sendStatusByActivityKeyState
    };
  }, [sendStatusByActivityKeyState]); // Finds the closest expiry. This is the time we should recompute `sendStatusByActivityKey`.

  var nextExpiry = Array.from(expiryByActivityKey.values()) // Ignores activities which are already marked as `"send failed"`, because the magic number its `-Infinity`.
  // We don't need to recompute them because `"send failed"` cannot change back to `"sending"` without modifying `activities` or `styleOptions`.
  .reduce(function (nextExpiry, expiry) {
    // Finds the next closest expiry, exclude those that already expired.
    if (expiry > now && expiry < nextExpiry) {
      return expiry;
    }

    return nextExpiry;
  }, Infinity); // When the activity with closest expiry expire, recomputes everything so the `sendStatusByActivityKey` will be updated.

  (0, _react.useEffect)(function () {
    if (nextExpiry) {
      var timeout = setTimeout(forceRender, nextExpiry - Date.now());
      return function () {
        return clearTimeout(timeout);
      };
    }
  }, [clearTimeout, Date, forceRender, nextExpiry, setTimeout]);
  return /*#__PURE__*/_react.default.createElement(_Context.default.Provider, {
    value: context
  }, children);
};

var _default = ActivitySendStatusComposer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJFWFBJUllfU0VORF9GQUlMRUQiLCJJbmZpbml0eSIsIkVYUElSWV9TRU5UIiwiQWN0aXZpdHlTZW5kU3RhdHVzQ29tcG9zZXIiLCJjaGlsZHJlbiIsInVzZUFjdGl2aXRpZXMiLCJhY3Rpdml0aWVzIiwidXNlUG9ueWZpbGwiLCJjbGVhclRpbWVvdXQiLCJEYXRlIiwic2V0VGltZW91dCIsImZvcmNlUmVuZGVyIiwidXNlRm9yY2VSZW5kZXIiLCJnZXRLZXlCeUFjdGl2aXR5IiwidXNlR2V0S2V5QnlBY3Rpdml0eSIsImdldFNlbmRUaW1lb3V0Rm9yQWN0aXZpdHkiLCJ1c2VHZXRTZW5kVGltZW91dEZvckFjdGl2aXR5Iiwic2VuZFN0YXR1c0J5QWN0aXZpdHlLZXlSZWYiLCJ1c2VSZWYiLCJPYmplY3QiLCJmcmVlemUiLCJNYXAiLCJleHBpcnlCeUFjdGl2aXR5S2V5IiwidXNlTWVtbyIsInJlZHVjZSIsImFjdGl2aXR5IiwiZnJvbSIsInJvbGUiLCJrZXkiLCJjaGFubmVsRGF0YSIsInN0YXRlIiwic2VuZFN0YXR1cyIsInJlY3RpZmllZFNlbmRTdGF0dXMiLCJTRU5UIiwiU0VORElORyIsInNldCIsIlNFTkRfRkFJTEVEIiwiZXhwaXJ5IiwibG9jYWxUaW1lc3RhbXAiLCJuZXh0U2VuZFN0YXR1c0J5QWN0aXZpdHlLZXkiLCJub3ciLCJpc01hcEVxdWFsIiwiY3VycmVudCIsInNlbmRTdGF0dXNCeUFjdGl2aXR5S2V5Iiwic2VuZFN0YXR1c0J5QWN0aXZpdHlLZXlTdGF0ZSIsImZyZWV6ZUFycmF5IiwiY29udGV4dCIsIm5leHRFeHBpcnkiLCJBcnJheSIsInZhbHVlcyIsInVzZUVmZmVjdCIsInRpbWVvdXQiXSwic291cmNlUm9vdCI6ImNvbXBvbmVudDovLy8iLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcm92aWRlcnMvQWN0aXZpdHlTZW5kU3RhdHVzL0FjdGl2aXR5U2VuZFN0YXR1c0NvbXBvc2VyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFNFTkRJTkcsIFNFTkRfRkFJTEVELCBTRU5UIH0gZnJvbSAnLi4vLi4vdHlwZXMvaW50ZXJuYWwvU2VuZFN0YXR1cyc7XG5pbXBvcnQgQWN0aXZpdHlTZW5kU3RhdHVzQ29udGV4dCBmcm9tICcuL3ByaXZhdGUvQ29udGV4dCc7XG5pbXBvcnQgZnJlZXplQXJyYXkgZnJvbSAnLi4vLi4vdXRpbHMvZnJlZXplQXJyYXknO1xuaW1wb3J0IGlzTWFwRXF1YWwgZnJvbSAnLi9wcml2YXRlL2lzTWFwRXF1YWwnO1xuaW1wb3J0IHVzZUFjdGl2aXRpZXMgZnJvbSAnLi4vLi4vaG9va3MvdXNlQWN0aXZpdGllcyc7XG5pbXBvcnQgdXNlRm9yY2VSZW5kZXIgZnJvbSAnLi4vLi4vaG9va3MvaW50ZXJuYWwvdXNlRm9yY2VSZW5kZXInO1xuaW1wb3J0IHVzZUdldEtleUJ5QWN0aXZpdHkgZnJvbSAnLi4vQWN0aXZpdHlLZXllci91c2VHZXRLZXlCeUFjdGl2aXR5JztcbmltcG9ydCB1c2VHZXRTZW5kVGltZW91dEZvckFjdGl2aXR5IGZyb20gJy4uLy4uL2hvb2tzL3VzZUdldFNlbmRUaW1lb3V0Rm9yQWN0aXZpdHknO1xuaW1wb3J0IHVzZVBvbnlmaWxsIGZyb20gJy4uLy4uL2hvb2tzL3VzZVBvbnlmaWxsJztcblxuaW1wb3J0IHR5cGUgeyBBY3Rpdml0eVNlbmRTdGF0dXNDb250ZXh0VHlwZSB9IGZyb20gJy4vcHJpdmF0ZS9Db250ZXh0JztcbmltcG9ydCB0eXBlIHsgRkMsIFByb3BzV2l0aENoaWxkcmVuIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHR5cGUgeyBTZW5kU3RhdHVzIH0gZnJvbSAnLi4vLi4vdHlwZXMvaW50ZXJuYWwvU2VuZFN0YXR1cyc7XG5cbi8vIE1hZ2ljIG51bWJlcnMgZm9yIGBleHBpcnlCeUFjdGl2aXR5S2V5YC5cbmNvbnN0IEVYUElSWV9TRU5EX0ZBSUxFRCA9IC1JbmZpbml0eTtcbmNvbnN0IEVYUElSWV9TRU5UID0gSW5maW5pdHk7XG5cbmNvbnN0IEFjdGl2aXR5U2VuZFN0YXR1c0NvbXBvc2VyOiBGQzxQcm9wc1dpdGhDaGlsZHJlbjx7fT4+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbYWN0aXZpdGllc10gPSB1c2VBY3Rpdml0aWVzKCk7XG4gIGNvbnN0IFt7IGNsZWFyVGltZW91dCwgRGF0ZSwgc2V0VGltZW91dCB9XSA9IHVzZVBvbnlmaWxsKCk7XG4gIGNvbnN0IGZvcmNlUmVuZGVyID0gdXNlRm9yY2VSZW5kZXIoKTtcbiAgY29uc3QgZ2V0S2V5QnlBY3Rpdml0eSA9IHVzZUdldEtleUJ5QWN0aXZpdHkoKTtcbiAgY29uc3QgZ2V0U2VuZFRpbWVvdXRGb3JBY3Rpdml0eSA9IHVzZUdldFNlbmRUaW1lb3V0Rm9yQWN0aXZpdHkoKTtcbiAgY29uc3Qgc2VuZFN0YXR1c0J5QWN0aXZpdHlLZXlSZWYgPSB1c2VSZWY8UmVhZG9ubHlNYXA8c3RyaW5nLCBTZW5kU3RhdHVzPj4oT2JqZWN0LmZyZWV6ZShuZXcgTWFwKCkpKTtcblxuICAvKipcbiAgICogTWFwIG9mIG91dGdvaW5nIGFjdGl2aXRpZXMgYW5kIHRoZWlyIHJlc3BlY3RpdmUgZXhwaXJ5LlxuICAgKlxuICAgKiBUaGUga2V5IGlzIHRoZSBhY3Rpdml0eSBrZXkuXG4gICAqXG4gICAqIFRoZSB2YWx1ZSBpczpcbiAgICpcbiAgICogLSBgSW5maW5pdHlgIGlmIHRoZSBhY3Rpdml0eSBpcyBhbHJlYWR5IHNlbnQgKGFuZCB3aWxsIG5ldmVyIGV4cGlyZSksIG90aGVyd2lzZTtcbiAgICogLSBgLUluZmluaXR5YCBpZiB0aGUgYWN0aXZpdHkgZmFpbGVkIHRvIHNlbmQgKGEuay5hLiBhbHJlYWR5IGV4cGlyZWQpLCBvdGhlcndpc2U7XG4gICAqIC0gQW4gZXBvY2ggdGltZSBvZiB3aGVuIHRoZSBhY3Rpdml0eSB3aWxsIGJlIGV4cGlyZWQuXG4gICAqL1xuICBjb25zdCBleHBpcnlCeUFjdGl2aXR5S2V5ID0gdXNlTWVtbzxSZWFkb25seU1hcDxzdHJpbmcsIG51bWJlcj4+KFxuICAgIC8vIFdlIGNvdWxkIGJ1aWxkIGEgYHVzZU1lbW9NYXAoKWAgaG9vayB0byBtZW1vaXplIG1hcHBlciBmdW5jdGlvbiBtb3JlIGVmZmljaWVudGx5LlxuICAgICgpID0+XG4gICAgICBPYmplY3QuZnJlZXplKFxuICAgICAgICBhY3Rpdml0aWVzLnJlZHVjZTxNYXA8c3RyaW5nLCBudW1iZXI+PigoZXhwaXJ5QnlBY3Rpdml0eUtleSwgYWN0aXZpdHkpID0+IHtcbiAgICAgICAgICBpZiAoYWN0aXZpdHkuZnJvbS5yb2xlID09PSAndXNlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldEtleUJ5QWN0aXZpdHkoYWN0aXZpdHkpO1xuXG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBjaGFubmVsRGF0YTogeyBzdGF0ZSwgJ3dlYmNoYXQ6c2VuZC1zdGF0dXMnOiBzZW5kU3RhdHVzIH1cbiAgICAgICAgICAgICAgfSA9IGFjdGl2aXR5O1xuXG4gICAgICAgICAgICAgIC8vIGBjaGFubmVsRGF0YS5zdGF0ZWAgaXMgYmVpbmcgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBgY2hhbm5lbERhdGFbJ3dlYmNoYXQ6c2VuZC1zdGF0dXMnXWAuXG4gICAgICAgICAgICAgIC8vIFBsZWFzZSByZWZlciB0byAjNDM2MiBmb3IgZGV0YWlscy4gUmVtb3ZlIG9uIG9yIGFmdGVyIDIwMjQtMDctMzEuXG4gICAgICAgICAgICAgIGNvbnN0IHJlY3RpZmllZFNlbmRTdGF0dXMgPSBzZW5kU3RhdHVzIHx8IChzdGF0ZSA9PT0gU0VOVCA/IFNFTlQgOiBTRU5ESU5HKTtcblxuICAgICAgICAgICAgICBpZiAocmVjdGlmaWVkU2VuZFN0YXR1cyA9PT0gU0VOVCkge1xuICAgICAgICAgICAgICAgIGV4cGlyeUJ5QWN0aXZpdHlLZXkuc2V0KGtleSwgRVhQSVJZX1NFTlQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlY3RpZmllZFNlbmRTdGF0dXMgPT09IFNFTkRfRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgZXhwaXJ5QnlBY3Rpdml0eUtleS5zZXQoa2V5LCBFWFBJUllfU0VORF9GQUlMRUQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGlyeSA9ICtuZXcgRGF0ZShhY3Rpdml0eS5sb2NhbFRpbWVzdGFtcCkgKyBnZXRTZW5kVGltZW91dEZvckFjdGl2aXR5KHsgYWN0aXZpdHkgfSk7XG5cbiAgICAgICAgICAgICAgICBleHBpcnkgJiYgZXhwaXJ5QnlBY3Rpdml0eUtleS5zZXQoa2V5LCBleHBpcnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGV4cGlyeUJ5QWN0aXZpdHlLZXk7XG4gICAgICAgIH0sIG5ldyBNYXAoKSlcbiAgICAgICksXG4gICAgW2FjdGl2aXRpZXMsIERhdGUsIGdldEtleUJ5QWN0aXZpdHksIGdldFNlbmRUaW1lb3V0Rm9yQWN0aXZpdHldXG4gICk7XG5cbiAgLyoqIE1hcCBvZiBvdXRnb2luZyBhY3Rpdml0aWVzIGFuZCB0aGVpciByZXNwZWN0aXZlIHNlbmQgc3RhdHVzLiAqL1xuICBjb25zdCBuZXh0U2VuZFN0YXR1c0J5QWN0aXZpdHlLZXkgPSBuZXcgTWFwPHN0cmluZywgU2VuZFN0YXR1cz4oKTtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAvLyBUdXJucyB0aGUgZXhwaXJ5IChlcG9jaCB0aW1lKSBpbnRvIGBTZW5kU3RhdHVzYCwgd2hpY2ggaXMgYmFzZWQgb24gY3VycmVudCBjbG9jay5cbiAgZm9yIChjb25zdCBba2V5LCBleHBpcnldIG9mIGV4cGlyeUJ5QWN0aXZpdHlLZXkpIHtcbiAgICBuZXh0U2VuZFN0YXR1c0J5QWN0aXZpdHlLZXkuc2V0KGtleSwgZXhwaXJ5ID09PSBFWFBJUllfU0VOVCA/IFNFTlQgOiBub3cgPj0gZXhwaXJ5ID8gU0VORF9GQUlMRUQgOiBTRU5ESU5HKTtcbiAgfVxuXG4gIC8vIE9ubHkgbWVtb2l6ZSB0aGUgbmV3IHJlc3VsdCBpZiBpdCBoYXMgY2hhbmdlZC5cbiAgaWYgKCFpc01hcEVxdWFsKHNlbmRTdGF0dXNCeUFjdGl2aXR5S2V5UmVmLmN1cnJlbnQsIG5leHRTZW5kU3RhdHVzQnlBY3Rpdml0eUtleSkpIHtcbiAgICBzZW5kU3RhdHVzQnlBY3Rpdml0eUtleVJlZi5jdXJyZW50ID0gT2JqZWN0LmZyZWV6ZShuZXh0U2VuZFN0YXR1c0J5QWN0aXZpdHlLZXkpO1xuICB9XG5cbiAgLy8gR2V0cy9yZWFsaXplcyB0aGUgYGN1cnJlbnRgIGZyb20gYHJlZmAgYmVjYXVzZSB3ZSBuZWVkIHRvIHVzZSBpdCBmb3IgYGRlcHNgIGFycmF5IGluIGhvb2tzIGZvciBtZW1vaXphdGlvbi5cbiAgY29uc3QgeyBjdXJyZW50OiBzZW5kU3RhdHVzQnlBY3Rpdml0eUtleSB9ID0gc2VuZFN0YXR1c0J5QWN0aXZpdHlLZXlSZWY7XG5cbiAgY29uc3Qgc2VuZFN0YXR1c0J5QWN0aXZpdHlLZXlTdGF0ZSA9IHVzZU1lbW88cmVhZG9ubHkgW1JlYWRvbmx5TWFwPHN0cmluZywgU2VuZFN0YXR1cz5dPihcbiAgICAoKSA9PiBmcmVlemVBcnJheShbc2VuZFN0YXR1c0J5QWN0aXZpdHlLZXldKSxcbiAgICBbc2VuZFN0YXR1c0J5QWN0aXZpdHlLZXldXG4gICk7XG5cbiAgY29uc3QgY29udGV4dCA9IHVzZU1lbW88QWN0aXZpdHlTZW5kU3RhdHVzQ29udGV4dFR5cGU+KFxuICAgICgpID0+ICh7IHNlbmRTdGF0dXNCeUFjdGl2aXR5S2V5U3RhdGUgfSksXG4gICAgW3NlbmRTdGF0dXNCeUFjdGl2aXR5S2V5U3RhdGVdXG4gICk7XG5cbiAgLy8gRmluZHMgdGhlIGNsb3Nlc3QgZXhwaXJ5LiBUaGlzIGlzIHRoZSB0aW1lIHdlIHNob3VsZCByZWNvbXB1dGUgYHNlbmRTdGF0dXNCeUFjdGl2aXR5S2V5YC5cbiAgY29uc3QgbmV4dEV4cGlyeSA9IEFycmF5LmZyb20oZXhwaXJ5QnlBY3Rpdml0eUtleS52YWx1ZXMoKSlcbiAgICAvLyBJZ25vcmVzIGFjdGl2aXRpZXMgd2hpY2ggYXJlIGFscmVhZHkgbWFya2VkIGFzIGBcInNlbmQgZmFpbGVkXCJgLCBiZWNhdXNlIHRoZSBtYWdpYyBudW1iZXIgaXRzIGAtSW5maW5pdHlgLlxuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVjb21wdXRlIHRoZW0gYmVjYXVzZSBgXCJzZW5kIGZhaWxlZFwiYCBjYW5ub3QgY2hhbmdlIGJhY2sgdG8gYFwic2VuZGluZ1wiYCB3aXRob3V0IG1vZGlmeWluZyBgYWN0aXZpdGllc2Agb3IgYHN0eWxlT3B0aW9uc2AuXG4gICAgLnJlZHVjZSgobmV4dEV4cGlyeSwgZXhwaXJ5KSA9PiB7XG4gICAgICAvLyBGaW5kcyB0aGUgbmV4dCBjbG9zZXN0IGV4cGlyeSwgZXhjbHVkZSB0aG9zZSB0aGF0IGFscmVhZHkgZXhwaXJlZC5cbiAgICAgIGlmIChleHBpcnkgPiBub3cgJiYgZXhwaXJ5IDwgbmV4dEV4cGlyeSkge1xuICAgICAgICByZXR1cm4gZXhwaXJ5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dEV4cGlyeTtcbiAgICB9LCBJbmZpbml0eSk7XG5cbiAgLy8gV2hlbiB0aGUgYWN0aXZpdHkgd2l0aCBjbG9zZXN0IGV4cGlyeSBleHBpcmUsIHJlY29tcHV0ZXMgZXZlcnl0aGluZyBzbyB0aGUgYHNlbmRTdGF0dXNCeUFjdGl2aXR5S2V5YCB3aWxsIGJlIHVwZGF0ZWQuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG5leHRFeHBpcnkpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZvcmNlUmVuZGVyLCBuZXh0RXhwaXJ5IC0gRGF0ZS5ub3coKSk7XG5cbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICB9LCBbY2xlYXJUaW1lb3V0LCBEYXRlLCBmb3JjZVJlbmRlciwgbmV4dEV4cGlyeSwgc2V0VGltZW91dF0pO1xuXG4gIHJldHVybiA8QWN0aXZpdHlTZW5kU3RhdHVzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dH0+e2NoaWxkcmVufTwvQWN0aXZpdHlTZW5kU3RhdHVzQ29udGV4dC5Qcm92aWRlcj47XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBY3Rpdml0eVNlbmRTdGF0dXNDb21wb3NlcjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNQTtBQUNBLElBQU1BLGtCQUFrQixHQUFHLENBQUNDLFFBQTVCO0FBQ0EsSUFBTUMsV0FBVyxHQUFHRCxRQUFwQjs7QUFFQSxJQUFNRSwwQkFBcUQsR0FBRyxTQUF4REEsMEJBQXdELE9BQWtCO0VBQUEsSUFBZkMsUUFBZSxRQUFmQSxRQUFlOztFQUM5RSxxQkFBcUIsSUFBQUMsdUJBQUEsR0FBckI7RUFBQTtFQUFBLElBQU9DLFVBQVA7O0VBQ0EsbUJBQTZDLElBQUFDLHFCQUFBLEdBQTdDO0VBQUE7RUFBQTtFQUFBLElBQVNDLFlBQVQsa0JBQVNBLFlBQVQ7RUFBQSxJQUF1QkMsSUFBdkIsa0JBQXVCQSxJQUF2QjtFQUFBLElBQTZCQyxVQUE3QixrQkFBNkJBLFVBQTdCOztFQUNBLElBQU1DLFdBQVcsR0FBRyxJQUFBQyx1QkFBQSxHQUFwQjtFQUNBLElBQU1DLGdCQUFnQixHQUFHLElBQUFDLDRCQUFBLEdBQXpCO0VBQ0EsSUFBTUMseUJBQXlCLEdBQUcsSUFBQUMscUNBQUEsR0FBbEM7RUFDQSxJQUFNQywwQkFBMEIsR0FBRyxJQUFBQyxhQUFBLEVBQXdDQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxJQUFJQyxHQUFKLEVBQWQsQ0FBeEMsQ0FBbkM7RUFFQTtBQUNGO0FBQ0E7QUFDQTtBQUNB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