"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _Context = _interopRequireDefault(require("./private/Context"));

var _findLastIndex = _interopRequireDefault(require("../../utils/findLastIndex"));

var _useActivities3 = _interopRequireDefault(require("../../hooks/useActivities"));

var _useActivityKeys3 = _interopRequireDefault(require("../ActivityKeyer/useActivityKeys"));

var _usePrevious = _interopRequireDefault(require("../../hooks/internal/usePrevious"));

var _useValueRef = _interopRequireDefault(require("../../hooks/internal/useValueRef"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function findClosestActivityKeyIfNotExists(activityKey, keys, prevKeys) {
  if (keys.includes(activityKey)) {
    return activityKey;
  } else if (!prevKeys || !activityKey) {
    // Initially, when the transcript was empty, there should be nothing read.
    return;
  } // If the last activity key is no longer in this activities (say, deleted), we try to find the closest one.


  var prevIndex = prevKeys.indexOf(activityKey);

  if (~prevIndex) {
    // List out all previously activity keys, find the closest one that is in the new transcript.
    var acknowledgedActivityKeys = prevKeys.slice(0, prevIndex).reverse();

    var _iterator = _createForOfIteratorHelper(acknowledgedActivityKeys),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var prevAcknowledgedActivityKey = _step.value;

        if (keys.includes(prevAcknowledgedActivityKey)) {
          return prevAcknowledgedActivityKey;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } // If nothing is found, return `undefined`.

}

var ActivityAcknowledgementComposer = function ActivityAcknowledgementComposer(_ref) {
  var children = _ref.children;

  var _useActivities = (0, _useActivities3.default)(),
      _useActivities2 = _slicedToArray(_useActivities, 1),
      activities = _useActivities2[0];

  var _useActivityKeys = (0, _useActivityKeys3.default)(),
      _useActivityKeys2 = _slicedToArray(_useActivityKeys, 1),
      allActivityKeys = _useActivityKeys2[0];

  var _useState = (0, _react.useState)(),
      _useState2 = _slicedToArray(_useState, 2),
      rawLastAcknowledgedActivityKey = _useState2[0],
      setRawLastAcknowledgedActivityKey = _useState2[1];

  var _useState3 = (0, _react.useState)(),
      _useState4 = _slicedToArray(_useState3, 2),
      rawLastReadActivityKey = _useState4[0],
      setRawLastReadActivityKey = _useState4[1];

  var allActivityKeysRef = (0, _useValueRef.default)(allActivityKeys);
  var prevAllActivityKeys = (0, _usePrevious.default)(allActivityKeys);
  var lastOutgoingActivityKeyIndex = (0, _react.useMemo)(function () {
    return (0, _findLastIndex.default)(activities, function (activity) {
      var _activity$from;

      return ((_activity$from = activity.from) === null || _activity$from === void 0 ? void 0 : _activity$from.role) === 'user';
    });
  }, [activities]); // Make sure when we return "lastReadActivityKey" exists in the current transcript.

  var lastReadActivityKey = (0, _react.useMemo)(function () {
    rawLastReadActivityKey && !~prevAllActivityKeys.includes(rawLastReadActivityKey) && console.warn("botframework-webchat internal assertion: \"rawLastReadActivityKey\" of value ".concat(rawLastReadActivityKey, " should be in the \"prevAllActivityKeys\" array."));
    return findClosestActivityKeyIfNotExists(rawLastReadActivityKey, allActivityKeys, prevAllActivityKeys);
  }, [allActivityKeys, prevAllActivityKeys, rawLastReadActivityKey]);
  var lastReadActivityKeyRef = (0, _useValueRef.default)(lastReadActivityKey); // Make sure when we return "lastAcknowledgedActivityKey" exists in the current transcript.

  var lastAcknowledgedActivityKey = (0, _react.useMemo)(function () {
    rawLastAcknowledgedActivityKey && !~prevAllActivityKeys.includes(rawLastAcknowledgedActivityKey) && console.warn("botframework-webchat internal assertion: \"rawLastAcknowledgedActivityKey\" of value ".concat(rawLastAcknowledgedActivityKey, " should be in the \"prevAllActivityKeys\" array."));
    var lastAcknowledgedActivityKey = findClosestActivityKeyIfNotExists(rawLastAcknowledgedActivityKey, allActivityKeys, prevAllActivityKeys); // TODO: [P2] Since Direct Line may send history and does not have read receipt.
    //            Thus, if we don't assume everything is acknowledged initially, while displaying the history,
    //            the transcript would soon stop scrolling.
    //            Thus, before the first outgoing activity is detected, we need to assume everything is acknowledged.

    return allActivityKeys[Math.max(allActivityKeys.indexOf(lastAcknowledgedActivityKey), lastOutgoingActivityKeyIndex)] || allActivityKeys[allActivityKeys.length - 1];
  }, [allActivityKeys, lastOutgoingActivityKeyIndex, prevAllActivityKeys, rawLastAcknowledgedActivityKey]);
  var activityAcknowledgements = (0, _react.useMemo)(function () {
    var activityAcknowledgements = new Map();
    var lastAcknowledgedIndex = allActivityKeys.indexOf(lastAcknowledgedActivityKey);
    var lastReadIndex = allActivityKeys.indexOf(lastReadActivityKey);
    allActivityKeys.forEach(function (activityKey, index) {
      activityAcknowledgements.set(activityKey, {
        acknowledged: index <= lastAcknowledgedIndex,
        read: index <= lastReadIndex
      });
    });
    return Object.freeze(activityAcknowledgements);
  }, [allActivityKeys, lastAcknowledgedActivityKey, lastReadActivityKey]);
  var activityAcknowledgementsRef = (0, _useValueRef.default)(activityAcknowledgements);
  var getHasAcknowledgedByActivityKey = (0, _react.useCallback)(function (activityKey) {
    var _activityAcknowledgem;

    return (_activityAcknowledgem = activityAcknowledgementsRef.current.get(activityKey)) === null || _activityAcknowledgem === void 0 ? void 0 : _activityAcknowledgem.acknowledged;
  }, [activityAcknowledgementsRef]); // TODO: [P2] Memoize with `useMemoWithPrevious` for better memoization of arrays.

  var activityKeysByReadState = (0, _react.useMemo)(function () {
    var index = allActivityKeys.indexOf(lastReadActivityKey);
    return Object.freeze([Object.freeze(allActivityKeys.slice(0, index + 1)), Object.freeze(allActivityKeys.slice(index + 1))]);
  }, [allActivityKeys, lastReadActivityKey]);
  var markAllAsAcknowledged = (0, _react.useCallback)(function () {
    var allActivityKeys = allActivityKeysRef.current;
    setRawLastAcknowledgedActivityKey(allActivityKeys[allActivityKeys.length - 1]);
  }, [allActivityKeysRef, setRawLastAcknowledgedActivityKey]);
  var markActivityKeyAsRead = (0, _react.useCallback)(function (activityKey) {
    var allActivityKeys = allActivityKeysRef.current;
    var index = allActivityKeys.indexOf(activityKey);

    if (!~index) {
      return console.warn("botframework-webchat: Cannot mark activity with key ".concat(activityKey, " as read because it is not in the transcript."));
    }

    index > allActivityKeys.indexOf(lastReadActivityKeyRef.current) && setRawLastReadActivityKey(activityKey);
  }, [allActivityKeysRef, lastReadActivityKeyRef, setRawLastReadActivityKey]);

  if (activityKeysByReadState[0].length + activityKeysByReadState[1].length !== allActivityKeys.length) {
    console.warn('botframework-webchat internal: Sum of count of read and unread activity keys MUST equals to total number of activity keys.');
  }

  var contextValue = (0, _react.useMemo)(function () {
    return {
      activityKeysByReadState: activityKeysByReadState,
      getHasAcknowledgedByActivityKey: getHasAcknowledgedByActivityKey,
      lastAcknowledgedActivityKeyState: Object.freeze([lastAcknowledgedActivityKey]),
      lastReadActivityKeyState: Object.freeze([lastReadActivityKey]),
      markActivityKeyAsRead: markActivityKeyAsRead,
      markAllAsAcknowledged: markAllAsAcknowledged
    };
  }, [activityKeysByReadState, getHasAcknowledgedByActivityKey, lastAcknowledgedActivityKey, lastReadActivityKey, markActivityKeyAsRead, markAllAsAcknowledged]);
  return /*#__PURE__*/_react.default.createElement(_Context.default.Provider, {
    value: contextValue
  }, children);
};

var _default = ActivityAcknowledgementComposer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJmaW5kQ2xvc2VzdEFjdGl2aXR5S2V5SWZOb3RFeGlzdHMiLCJhY3Rpdml0eUtleSIsImtleXMiLCJwcmV2S2V5cyIsImluY2x1ZGVzIiwicHJldkluZGV4IiwiaW5kZXhPZiIsImFja25vd2xlZGdlZEFjdGl2aXR5S2V5cyIsInNsaWNlIiwicmV2ZXJzZSIsInByZXZBY2tub3dsZWRnZWRBY3Rpdml0eUtleSIsIkFjdGl2aXR5QWNrbm93bGVkZ2VtZW50Q29tcG9zZXIiLCJjaGlsZHJlbiIsInVzZUFjdGl2aXRpZXMiLCJhY3Rpdml0aWVzIiwidXNlQWN0aXZpdHlLZXlzIiwiYWxsQWN0aXZpdHlLZXlzIiwidXNlU3RhdGUiLCJyYXdMYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXkiLCJzZXRSYXdMYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXkiLCJyYXdMYXN0UmVhZEFjdGl2aXR5S2V5Iiwic2V0UmF3TGFzdFJlYWRBY3Rpdml0eUtleSIsImFsbEFjdGl2aXR5S2V5c1JlZiIsInVzZVZhbHVlUmVmIiwicHJldkFsbEFjdGl2aXR5S2V5cyIsInVzZVByZXZpb3VzIiwibGFzdE91dGdvaW5nQWN0aXZpdHlLZXlJbmRleCIsInVzZU1lbW8iLCJmaW5kTGFzdEluZGV4IiwiYWN0aXZpdHkiLCJmcm9tIiwicm9sZSIsImxhc3RSZWFkQWN0aXZpdHlLZXkiLCJjb25zb2xlIiwid2FybiIsImxhc3RSZWFkQWN0aXZpdHlLZXlSZWYiLCJsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXkiLCJNYXRoIiwibWF4IiwibGVuZ3RoIiwiYWN0aXZpdHlBY2tub3dsZWRnZW1lbnRzIiwiTWFwIiwibGFzdEFja25vd2xlZGdlZEluZGV4IiwibGFzdFJlYWRJbmRleCIsImZvckVhY2giLCJpbmRleCIsInNldCIsImFja25vd2xlZGdlZCIsInJlYWQiLCJPYmplY3QiLCJmcmVlemUiLCJhY3Rpdml0eUFja25vd2xlZGdlbWVudHNSZWYiLCJnZXRIYXNBY2tub3dsZWRnZWRCeUFjdGl2aXR5S2V5IiwidXNlQ2FsbGJhY2siLCJjdXJyZW50IiwiZ2V0IiwiYWN0aXZpdHlLZXlzQnlSZWFkU3RhdGUiLCJtYXJrQWxsQXNBY2tub3dsZWRnZWQiLCJtYXJrQWN0aXZpdHlLZXlBc1JlYWQiLCJjb250ZXh0VmFsdWUiLCJsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXlTdGF0ZSIsImxhc3RSZWFkQWN0aXZpdHlLZXlTdGF0ZSJdLCJzb3VyY2VSb290IjoiY29tcG9uZW50Oi8vLyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3Byb3ZpZGVycy9BY3Rpdml0eUFja25vd2xlZGdlbWVudC9BY3Rpdml0eUFja25vd2xlZGdlbWVudENvbXBvc2VyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgdHlwZSB7IEZDLCBQcm9wc1dpdGhDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IEFjdGl2aXR5QWNrbm93bGVkZ2VtZW50Q29udGV4dCwgeyBBY3Rpdml0eUFja25vd2xlZGdlbWVudENvbnRleHRUeXBlIH0gZnJvbSAnLi9wcml2YXRlL0NvbnRleHQnO1xuaW1wb3J0IGZpbmRMYXN0SW5kZXggZnJvbSAnLi4vLi4vdXRpbHMvZmluZExhc3RJbmRleCc7XG5pbXBvcnQgdXNlQWN0aXZpdGllcyBmcm9tICcuLi8uLi9ob29rcy91c2VBY3Rpdml0aWVzJztcbmltcG9ydCB1c2VBY3Rpdml0eUtleXMgZnJvbSAnLi4vQWN0aXZpdHlLZXllci91c2VBY3Rpdml0eUtleXMnO1xuaW1wb3J0IHVzZVByZXZpb3VzIGZyb20gJy4uLy4uL2hvb2tzL2ludGVybmFsL3VzZVByZXZpb3VzJztcbmltcG9ydCB1c2VWYWx1ZVJlZiBmcm9tICcuLi8uLi9ob29rcy9pbnRlcm5hbC91c2VWYWx1ZVJlZic7XG5cbmltcG9ydCB0eXBlIHsgQWN0aXZpdHlBY2tub3dsZWRnZW1lbnQgfSBmcm9tICcuL3ByaXZhdGUvdHlwZXMnO1xuXG50eXBlIEFjdGl2aXR5QWNrbm93bGVkZ2VtZW50Q29tcG9zZXJQcm9wcyA9IFByb3BzV2l0aENoaWxkcmVuPHt9PjtcblxuZnVuY3Rpb24gZmluZENsb3Nlc3RBY3Rpdml0eUtleUlmTm90RXhpc3RzKFxuICBhY3Rpdml0eUtleTogc3RyaW5nLFxuICBrZXlzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgcHJldktleXM6IHJlYWRvbmx5IHN0cmluZ1tdXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoa2V5cy5pbmNsdWRlcyhhY3Rpdml0eUtleSkpIHtcbiAgICByZXR1cm4gYWN0aXZpdHlLZXk7XG4gIH0gZWxzZSBpZiAoIXByZXZLZXlzIHx8ICFhY3Rpdml0eUtleSkge1xuICAgIC8vIEluaXRpYWxseSwgd2hlbiB0aGUgdHJhbnNjcmlwdCB3YXMgZW1wdHksIHRoZXJlIHNob3VsZCBiZSBub3RoaW5nIHJlYWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgdGhlIGxhc3QgYWN0aXZpdHkga2V5IGlzIG5vIGxvbmdlciBpbiB0aGlzIGFjdGl2aXRpZXMgKHNheSwgZGVsZXRlZCksIHdlIHRyeSB0byBmaW5kIHRoZSBjbG9zZXN0IG9uZS5cbiAgY29uc3QgcHJldkluZGV4ID0gcHJldktleXMuaW5kZXhPZihhY3Rpdml0eUtleSk7XG5cbiAgaWYgKH5wcmV2SW5kZXgpIHtcbiAgICAvLyBMaXN0IG91dCBhbGwgcHJldmlvdXNseSBhY3Rpdml0eSBrZXlzLCBmaW5kIHRoZSBjbG9zZXN0IG9uZSB0aGF0IGlzIGluIHRoZSBuZXcgdHJhbnNjcmlwdC5cbiAgICBjb25zdCBhY2tub3dsZWRnZWRBY3Rpdml0eUtleXMgPSBwcmV2S2V5cy5zbGljZSgwLCBwcmV2SW5kZXgpLnJldmVyc2UoKTtcblxuICAgIGZvciAoY29uc3QgcHJldkFja25vd2xlZGdlZEFjdGl2aXR5S2V5IG9mIGFja25vd2xlZGdlZEFjdGl2aXR5S2V5cykge1xuICAgICAgaWYgKGtleXMuaW5jbHVkZXMocHJldkFja25vd2xlZGdlZEFjdGl2aXR5S2V5KSkge1xuICAgICAgICByZXR1cm4gcHJldkFja25vd2xlZGdlZEFjdGl2aXR5S2V5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5vdGhpbmcgaXMgZm91bmQsIHJldHVybiBgdW5kZWZpbmVkYC5cbn1cblxuY29uc3QgQWN0aXZpdHlBY2tub3dsZWRnZW1lbnRDb21wb3NlcjogRkM8QWN0aXZpdHlBY2tub3dsZWRnZW1lbnRDb21wb3NlclByb3BzPiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW2FjdGl2aXRpZXNdID0gdXNlQWN0aXZpdGllcygpO1xuICBjb25zdCBbYWxsQWN0aXZpdHlLZXlzXSA9IHVzZUFjdGl2aXR5S2V5cygpO1xuICBjb25zdCBbcmF3TGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5LCBzZXRSYXdMYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXldID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPigpO1xuICBjb25zdCBbcmF3TGFzdFJlYWRBY3Rpdml0eUtleSwgc2V0UmF3TGFzdFJlYWRBY3Rpdml0eUtleV0gPSB1c2VTdGF0ZTxzdHJpbmcgfCB1bmRlZmluZWQ+KCk7XG5cbiAgY29uc3QgYWxsQWN0aXZpdHlLZXlzUmVmID0gdXNlVmFsdWVSZWYoYWxsQWN0aXZpdHlLZXlzKTtcbiAgY29uc3QgcHJldkFsbEFjdGl2aXR5S2V5cyA9IHVzZVByZXZpb3VzKGFsbEFjdGl2aXR5S2V5cyk7XG5cbiAgY29uc3QgbGFzdE91dGdvaW5nQWN0aXZpdHlLZXlJbmRleCA9IHVzZU1lbW8oXG4gICAgKCkgPT4gZmluZExhc3RJbmRleChhY3Rpdml0aWVzLCBhY3Rpdml0eSA9PiBhY3Rpdml0eS5mcm9tPy5yb2xlID09PSAndXNlcicpLFxuICAgIFthY3Rpdml0aWVzXVxuICApO1xuXG4gIC8vIE1ha2Ugc3VyZSB3aGVuIHdlIHJldHVybiBcImxhc3RSZWFkQWN0aXZpdHlLZXlcIiBleGlzdHMgaW4gdGhlIGN1cnJlbnQgdHJhbnNjcmlwdC5cbiAgY29uc3QgbGFzdFJlYWRBY3Rpdml0eUtleSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJhd0xhc3RSZWFkQWN0aXZpdHlLZXkgJiZcbiAgICAgICF+cHJldkFsbEFjdGl2aXR5S2V5cy5pbmNsdWRlcyhyYXdMYXN0UmVhZEFjdGl2aXR5S2V5KSAmJlxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgYm90ZnJhbWV3b3JrLXdlYmNoYXQgaW50ZXJuYWwgYXNzZXJ0aW9uOiBcInJhd0xhc3RSZWFkQWN0aXZpdHlLZXlcIiBvZiB2YWx1ZSAke3Jhd0xhc3RSZWFkQWN0aXZpdHlLZXl9IHNob3VsZCBiZSBpbiB0aGUgXCJwcmV2QWxsQWN0aXZpdHlLZXlzXCIgYXJyYXkuYFxuICAgICAgKTtcblxuICAgIHJldHVybiBmaW5kQ2xvc2VzdEFjdGl2aXR5S2V5SWZOb3RFeGlzdHMocmF3TGFzdFJlYWRBY3Rpdml0eUtleSwgYWxsQWN0aXZpdHlLZXlzLCBwcmV2QWxsQWN0aXZpdHlLZXlzKTtcbiAgfSwgW2FsbEFjdGl2aXR5S2V5cywgcHJldkFsbEFjdGl2aXR5S2V5cywgcmF3TGFzdFJlYWRBY3Rpdml0eUtleV0pO1xuXG4gIGNvbnN0IGxhc3RSZWFkQWN0aXZpdHlLZXlSZWYgPSB1c2VWYWx1ZVJlZihsYXN0UmVhZEFjdGl2aXR5S2V5KTtcblxuICAvLyBNYWtlIHN1cmUgd2hlbiB3ZSByZXR1cm4gXCJsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXlcIiBleGlzdHMgaW4gdGhlIGN1cnJlbnQgdHJhbnNjcmlwdC5cbiAgY29uc3QgbGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmF3TGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5ICYmXG4gICAgICAhfnByZXZBbGxBY3Rpdml0eUtleXMuaW5jbHVkZXMocmF3TGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5KSAmJlxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgYm90ZnJhbWV3b3JrLXdlYmNoYXQgaW50ZXJuYWwgYXNzZXJ0aW9uOiBcInJhd0xhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleVwiIG9mIHZhbHVlICR7cmF3TGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5fSBzaG91bGQgYmUgaW4gdGhlIFwicHJldkFsbEFjdGl2aXR5S2V5c1wiIGFycmF5LmBcbiAgICAgICk7XG5cbiAgICBjb25zdCBsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXkgPSBmaW5kQ2xvc2VzdEFjdGl2aXR5S2V5SWZOb3RFeGlzdHMoXG4gICAgICByYXdMYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXksXG4gICAgICBhbGxBY3Rpdml0eUtleXMsXG4gICAgICBwcmV2QWxsQWN0aXZpdHlLZXlzXG4gICAgKTtcblxuICAgIC8vIFRPRE86IFtQMl0gU2luY2UgRGlyZWN0IExpbmUgbWF5IHNlbmQgaGlzdG9yeSBhbmQgZG9lcyBub3QgaGF2ZSByZWFkIHJlY2VpcHQuXG4gICAgLy8gICAgICAgICAgICBUaHVzLCBpZiB3ZSBkb24ndCBhc3N1bWUgZXZlcnl0aGluZyBpcyBhY2tub3dsZWRnZWQgaW5pdGlhbGx5LCB3aGlsZSBkaXNwbGF5aW5nIHRoZSBoaXN0b3J5LFxuICAgIC8vICAgICAgICAgICAgdGhlIHRyYW5zY3JpcHQgd291bGQgc29vbiBzdG9wIHNjcm9sbGluZy5cbiAgICAvLyAgICAgICAgICAgIFRodXMsIGJlZm9yZSB0aGUgZmlyc3Qgb3V0Z29pbmcgYWN0aXZpdHkgaXMgZGV0ZWN0ZWQsIHdlIG5lZWQgdG8gYXNzdW1lIGV2ZXJ5dGhpbmcgaXMgYWNrbm93bGVkZ2VkLlxuICAgIHJldHVybiAoXG4gICAgICBhbGxBY3Rpdml0eUtleXNbTWF0aC5tYXgoYWxsQWN0aXZpdHlLZXlzLmluZGV4T2YobGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5KSwgbGFzdE91dGdvaW5nQWN0aXZpdHlLZXlJbmRleCldIHx8XG4gICAgICBhbGxBY3Rpdml0eUtleXNbYWxsQWN0aXZpdHlLZXlzLmxlbmd0aCAtIDFdXG4gICAgKTtcbiAgfSwgW2FsbEFjdGl2aXR5S2V5cywgbGFzdE91dGdvaW5nQWN0aXZpdHlLZXlJbmRleCwgcHJldkFsbEFjdGl2aXR5S2V5cywgcmF3TGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5XSk7XG5cbiAgY29uc3QgYWN0aXZpdHlBY2tub3dsZWRnZW1lbnRzID0gdXNlTWVtbzxSZWFkb25seTxNYXA8c3RyaW5nLCBBY3Rpdml0eUFja25vd2xlZGdlbWVudD4+PigoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZpdHlBY2tub3dsZWRnZW1lbnRzID0gbmV3IE1hcDxzdHJpbmcsIEFjdGl2aXR5QWNrbm93bGVkZ2VtZW50PigpO1xuICAgIGNvbnN0IGxhc3RBY2tub3dsZWRnZWRJbmRleCA9IGFsbEFjdGl2aXR5S2V5cy5pbmRleE9mKGxhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleSk7XG4gICAgY29uc3QgbGFzdFJlYWRJbmRleCA9IGFsbEFjdGl2aXR5S2V5cy5pbmRleE9mKGxhc3RSZWFkQWN0aXZpdHlLZXkpO1xuXG4gICAgYWxsQWN0aXZpdHlLZXlzLmZvckVhY2goKGFjdGl2aXR5S2V5LCBpbmRleCkgPT4ge1xuICAgICAgYWN0aXZpdHlBY2tub3dsZWRnZW1lbnRzLnNldChhY3Rpdml0eUtleSwge1xuICAgICAgICBhY2tub3dsZWRnZWQ6IGluZGV4IDw9IGxhc3RBY2tub3dsZWRnZWRJbmRleCxcbiAgICAgICAgcmVhZDogaW5kZXggPD0gbGFzdFJlYWRJbmRleFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShhY3Rpdml0eUFja25vd2xlZGdlbWVudHMpO1xuICB9LCBbYWxsQWN0aXZpdHlLZXlzLCBsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXksIGxhc3RSZWFkQWN0aXZpdHlLZXldKTtcblxuICBjb25zdCBhY3Rpdml0eUFja25vd2xlZGdlbWVudHNSZWYgPSB1c2VWYWx1ZVJlZihhY3Rpdml0eUFja25vd2xlZGdlbWVudHMpO1xuXG4gIGNvbnN0IGdldEhhc0Fja25vd2xlZGdlZEJ5QWN0aXZpdHlLZXkgPSB1c2VDYWxsYmFjazwoYWN0aXZpdHlLZXk6IHN0cmluZykgPT4gYm9vbGVhbj4oXG4gICAgKGFjdGl2aXR5S2V5OiBzdHJpbmcpID0+IGFjdGl2aXR5QWNrbm93bGVkZ2VtZW50c1JlZi5jdXJyZW50LmdldChhY3Rpdml0eUtleSk/LmFja25vd2xlZGdlZCxcbiAgICBbYWN0aXZpdHlBY2tub3dsZWRnZW1lbnRzUmVmXVxuICApO1xuXG4gIC8vIFRPRE86IFtQMl0gTWVtb2l6ZSB3aXRoIGB1c2VNZW1vV2l0aFByZXZpb3VzYCBmb3IgYmV0dGVyIG1lbW9pemF0aW9uIG9mIGFycmF5cy5cbiAgY29uc3QgYWN0aXZpdHlLZXlzQnlSZWFkU3RhdGUgPSB1c2VNZW1vPHJlYWRvbmx5IFtyZWFkb25seSBzdHJpbmdbXSwgcmVhZG9ubHkgc3RyaW5nW11dPigoKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBhbGxBY3Rpdml0eUtleXMuaW5kZXhPZihsYXN0UmVhZEFjdGl2aXR5S2V5KTtcblxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKFtcbiAgICAgIE9iamVjdC5mcmVlemUoYWxsQWN0aXZpdHlLZXlzLnNsaWNlKDAsIGluZGV4ICsgMSkpLFxuICAgICAgT2JqZWN0LmZyZWV6ZShhbGxBY3Rpdml0eUtleXMuc2xpY2UoaW5kZXggKyAxKSlcbiAgICBdKSBhcyByZWFkb25seSBbcmVhZG9ubHkgc3RyaW5nW10sIHJlYWRvbmx5IHN0cmluZ1tdXTtcbiAgfSwgW2FsbEFjdGl2aXR5S2V5cywgbGFzdFJlYWRBY3Rpdml0eUtleV0pO1xuXG4gIGNvbnN0IG1hcmtBbGxBc0Fja25vd2xlZGdlZCA9IHVzZUNhbGxiYWNrKCgpOiB2b2lkID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQ6IGFsbEFjdGl2aXR5S2V5cyB9ID0gYWxsQWN0aXZpdHlLZXlzUmVmO1xuXG4gICAgc2V0UmF3TGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5KGFsbEFjdGl2aXR5S2V5c1thbGxBY3Rpdml0eUtleXMubGVuZ3RoIC0gMV0pO1xuICB9LCBbYWxsQWN0aXZpdHlLZXlzUmVmLCBzZXRSYXdMYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXldKTtcblxuICBjb25zdCBtYXJrQWN0aXZpdHlLZXlBc1JlYWQgPSB1c2VDYWxsYmFjayhcbiAgICAoYWN0aXZpdHlLZXk6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgeyBjdXJyZW50OiBhbGxBY3Rpdml0eUtleXMgfSA9IGFsbEFjdGl2aXR5S2V5c1JlZjtcbiAgICAgIGNvbnN0IGluZGV4ID0gYWxsQWN0aXZpdHlLZXlzLmluZGV4T2YoYWN0aXZpdHlLZXkpO1xuXG4gICAgICBpZiAoIX5pbmRleCkge1xuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFxuICAgICAgICAgIGBib3RmcmFtZXdvcmstd2ViY2hhdDogQ2Fubm90IG1hcmsgYWN0aXZpdHkgd2l0aCBrZXkgJHthY3Rpdml0eUtleX0gYXMgcmVhZCBiZWNhdXNlIGl0IGlzIG5vdCBpbiB0aGUgdHJhbnNjcmlwdC5gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGluZGV4ID4gYWxsQWN0aXZpdHlLZXlzLmluZGV4T2YobGFzdFJlYWRBY3Rpdml0eUtleVJlZi5jdXJyZW50KSAmJiBzZXRSYXdMYXN0UmVhZEFjdGl2aXR5S2V5KGFjdGl2aXR5S2V5KTtcbiAgICB9LFxuICAgIFthbGxBY3Rpdml0eUtleXNSZWYsIGxhc3RSZWFkQWN0aXZpdHlLZXlSZWYsIHNldFJhd0xhc3RSZWFkQWN0aXZpdHlLZXldXG4gICk7XG5cbiAgaWYgKGFjdGl2aXR5S2V5c0J5UmVhZFN0YXRlWzBdLmxlbmd0aCArIGFjdGl2aXR5S2V5c0J5UmVhZFN0YXRlWzFdLmxlbmd0aCAhPT0gYWxsQWN0aXZpdHlLZXlzLmxlbmd0aCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdib3RmcmFtZXdvcmstd2ViY2hhdCBpbnRlcm5hbDogU3VtIG9mIGNvdW50IG9mIHJlYWQgYW5kIHVucmVhZCBhY3Rpdml0eSBrZXlzIE1VU1QgZXF1YWxzIHRvIHRvdGFsIG51bWJlciBvZiBhY3Rpdml0eSBrZXlzLidcbiAgICApO1xuICB9XG5cbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbzxBY3Rpdml0eUFja25vd2xlZGdlbWVudENvbnRleHRUeXBlPihcbiAgICAoKSA9PiAoe1xuICAgICAgYWN0aXZpdHlLZXlzQnlSZWFkU3RhdGUsXG4gICAgICBnZXRIYXNBY2tub3dsZWRnZWRCeUFjdGl2aXR5S2V5LFxuICAgICAgbGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5U3RhdGU6IE9iamVjdC5mcmVlemUoW2xhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleV0pIGFzIHJlYWRvbmx5IFtzdHJpbmddLFxuICAgICAgbGFzdFJlYWRBY3Rpdml0eUtleVN0YXRlOiBPYmplY3QuZnJlZXplKFtsYXN0UmVhZEFjdGl2aXR5S2V5XSkgYXMgcmVhZG9ubHkgW3N0cmluZ10sXG4gICAgICBtYXJrQWN0aXZpdHlLZXlBc1JlYWQsXG4gICAgICBtYXJrQWxsQXNBY2tub3dsZWRnZWRcbiAgICB9KSxcbiAgICBbXG4gICAgICBhY3Rpdml0eUtleXNCeVJlYWRTdGF0ZSxcbiAgICAgIGdldEhhc0Fja25vd2xlZGdlZEJ5QWN0aXZpdHlLZXksXG4gICAgICBsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXksXG4gICAgICBsYXN0UmVhZEFjdGl2aXR5S2V5LFxuICAgICAgbWFya0FjdGl2aXR5S2V5QXNSZWFkLFxuICAgICAgbWFya0FsbEFzQWNrbm93bGVkZ2VkXG4gICAgXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPEFjdGl2aXR5QWNrbm93bGVkZ2VtZW50Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT57Y2hpbGRyZW59PC9BY3Rpdml0eUFja25vd2xlZGdlbWVudENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBY3Rpdml0eUFja25vd2xlZGdlbWVudENvbXBvc2VyO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFJQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1BLFNBQVNBLGlDQUFULENBQ0VDLFdBREYsRUFFRUMsSUFGRixFQUdFQyxRQUhGLEVBSXNCO0VBQ3BCLElBQUlELElBQUksQ0FBQ0UsUUFBTCxDQUFjSCxXQUFkLENBQUosRUFBZ0M7SUFDOUIsT0FBT0EsV0FBUDtFQUNELENBRkQsTUFFTyxJQUFJLENBQUNFLFFBQUQsSUFBYSxDQUFDRixXQUFsQixFQUErQjtJQUNwQztJQUNBO0VBQ0QsQ0FObUIsQ0FRcEI7OztFQUNBLElBQU1JLFNBQVMsR0FBR0YsUUFBUSxDQUFDRyxPQUFULENBQWlCTCxXQUFqQixDQUFsQjs7RUFFQSxJQUFJLENBQUNJLFNBQUwsRUFBZ0I7SUFDZDtJQUNBLElBQU1FLHdCQUF3QixHQUFHSixRQUFRLENBQUNLLEtBQVQsQ0FBZSxDQUFmLEVBQWtCSCxTQUFsQixFQUE2QkksT0FBN0IsRUFBakM7O0lBRmMsMkNBSTRCRix3QkFKNUI7SUFBQTs7SUFBQTtNQUlkLG9EQUFvRTtRQUFBLElBQXpERywyQkFBeUQ7O1FBQ2xFLElBQUlSLElBQUksQ0FBQ0UsUUFBTCxDQUFjTSwyQkFBZCxDQUFKLEVBQWdEO1VBQzlDLE9BQU9BLDJCQUFQO1FBQ0Q7TUFDRjtJQVJhO01BQUE7SUFBQTtNQUFBO0lBQUE7RUFTZixDQXBCbUIsQ0FzQnBCOztBQUNEOztBQUVELElBQU1DLCtCQUF5RSxHQUFHLFNBQTVFQSwrQkFBNEUsT0FBa0I7RUFBQSxJQUFmQyxRQUFlLFFBQWZBLFFBQWU7O0VBQ2xHLHFCQUFxQixJQUFBQyx1QkFBQSxHQUFyQjtFQUFBO0VBQUEsSUFBT0MsVUFBUDs7RUFDQSx1QkFBMEIsSUFBQUMseUJBQUEsR0FBMUI7RUFBQTtFQUFB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