"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _Constants = _interopRequireDefault(require("../Common/Constants"));

var _sleep = _interopRequireDefault(require("./sleep"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Custom handler for HTTP calls with Axios. Handler allows to retry HTTP calls if failed.
 *
 * @param axios Axios instance.
 * @param axiosRetryOptions Options for axios retry.
 */
var axiosRetry = function axiosRetry(axios, axiosRetryOptions) {
  // eslint-disable-line @typescript-eslint/explicit-module-boundary-types
  var retryInterval = 1000; // 1 second interval between retries
  // Default values

  if (axiosRetryOptions.retryOn429 === undefined || axiosRetryOptions.retryOn429 === null) {
    axiosRetryOptions.retryOn429 = true;
  }

  var retries = axiosRetryOptions.retries,
      headerOverwrites = axiosRetryOptions.headerOverwrites;
  var currentTry = 1; // Executed as soon as after 1st try
  // Method to intercepts responses within range of 2xx

  var onSuccess = undefined; // define default behaviour for 429 retries in case the handler was not included by the caller.

  if (!axiosRetryOptions.shouldRetry) {
    axiosRetryOptions.shouldRetry = function (response) {
      if (response && response.status && response.status === _Constants["default"].tooManyRequestsStatusCode && axiosRetryOptions.retryOn429 === false) {
        return false;
      }

      return true;
    };
  } // Method to intercepts responses outside range of 2xx


  var onError = function onError(error) {
    var config = error.config,
        response = error.response; // If we have no information of the request to retry

    if (!config) {
      return Promise.reject(error);
    } // Evaluates if execution should stop according to the conditions defined in the handler


    if (axiosRetryOptions.shouldRetry && !axiosRetryOptions.shouldRetry(response)) {
      return Promise.reject(error);
    } // Retry request if below threshold


    var shouldRetry = currentTry < retries;

    if (shouldRetry) {
      currentTry++;

      if (headerOverwrites && response !== null && response !== void 0 && response.headers) {
        var _iterator = _createForOfIteratorHelper(headerOverwrites),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var headerName = _step.value;
            var responseHeader = response === null || response === void 0 ? void 0 : response.headers[headerName.toLocaleLowerCase()];

            if (responseHeader) {
              // eslint-disable-next-line security/detect-object-injection
              config.headers[headerName] = responseHeader;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return new Promise(function (resolve) {
        return (0, _sleep["default"])(retryInterval).then(function () {
          return resolve(axios(config));
        });
      });
    }

    return Promise.reject(error);
  };

  axios.interceptors.response.use(onSuccess, onError); // Intercept response before returning
};

var _default = axiosRetry;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9VdGlscy9heGlvc1JldHJ5LnRzIl0sIm5hbWVzIjpbImF4aW9zUmV0cnkiLCJheGlvcyIsImF4aW9zUmV0cnlPcHRpb25zIiwicmV0cnlJbnRlcnZhbCIsInJldHJ5T240MjkiLCJ1bmRlZmluZWQiLCJyZXRyaWVzIiwiaGVhZGVyT3ZlcndyaXRlcyIsImN1cnJlbnRUcnkiLCJvblN1Y2Nlc3MiLCJzaG91bGRSZXRyeSIsInJlc3BvbnNlIiwic3RhdHVzIiwiQ29uc3RhbnRzIiwidG9vTWFueVJlcXVlc3RzU3RhdHVzQ29kZSIsIm9uRXJyb3IiLCJlcnJvciIsImNvbmZpZyIsIlByb21pc2UiLCJyZWplY3QiLCJoZWFkZXJzIiwiaGVhZGVyTmFtZSIsInJlc3BvbnNlSGVhZGVyIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJyZXNvbHZlIiwidGhlbiIsImludGVyY2VwdG9ycyIsInVzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUEsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBQ0MsS0FBRCxFQUF1QkMsaUJBQXZCLEVBQWlFO0FBQUU7QUFDcEYsTUFBTUMsYUFBYSxHQUFHLElBQXRCLENBRGtGLENBQ3REO0FBRTVCOztBQUNBLE1BQUlELGlCQUFpQixDQUFDRSxVQUFsQixLQUFpQ0MsU0FBakMsSUFBOENILGlCQUFpQixDQUFDRSxVQUFsQixLQUFpQyxJQUFuRixFQUF5RjtBQUN2RkYsSUFBQUEsaUJBQWlCLENBQUNFLFVBQWxCLEdBQStCLElBQS9CO0FBQ0Q7O0FBRUQsTUFBUUUsT0FBUixHQUFzQ0osaUJBQXRDLENBQVFJLE9BQVI7QUFBQSxNQUFpQkMsZ0JBQWpCLEdBQXNDTCxpQkFBdEMsQ0FBaUJLLGdCQUFqQjtBQUVBLE1BQUlDLFVBQVUsR0FBRyxDQUFqQixDQVZrRixDQVU5RDtBQUVwQjs7QUFDQSxNQUFNQyxTQUFTLEdBQUdKLFNBQWxCLENBYmtGLENBZWxGOztBQUNBLE1BQUksQ0FBQ0gsaUJBQWlCLENBQUNRLFdBQXZCLEVBQW9DO0FBQ2xDUixJQUFBQSxpQkFBaUIsQ0FBQ1EsV0FBbEIsR0FBZ0MsVUFBQ0MsUUFBRCxFQUFjO0FBQzVDLFVBQUlBLFFBQVEsSUFBSUEsUUFBUSxDQUFDQyxNQUFyQixJQUErQkQsUUFBUSxDQUFDQyxNQUFULEtBQW9CQyxzQkFBVUMseUJBQTdELElBQTBGWixpQkFBaUIsQ0FBQ0UsVUFBbEIsS0FBaUMsS0FBL0gsRUFBc0k7QUFDcEksZUFBTyxLQUFQO0FBQ0Q7O0FBQ0QsYUFBTyxJQUFQO0FBQ0QsS0FMRDtBQU1ELEdBdkJpRixDQXlCbEY7OztBQUNBLE1BQU1XLE9BQU8sR0FBRyxTQUFWQSxPQUFVLENBQUNDLEtBQUQsRUFBdUI7QUFFckMsUUFBUUMsTUFBUixHQUE2QkQsS0FBN0IsQ0FBUUMsTUFBUjtBQUFBLFFBQWdCTixRQUFoQixHQUE2QkssS0FBN0IsQ0FBZ0JMLFFBQWhCLENBRnFDLENBR3JDOztBQUNBLFFBQUksQ0FBQ00sTUFBTCxFQUFhO0FBQ1gsYUFBT0MsT0FBTyxDQUFDQyxNQUFSLENBQWVILEtBQWYsQ0FBUDtBQUNELEtBTm9DLENBUXJDOzs7QUFDQSxRQUFJZCxpQkFBaUIsQ0FBQ1EsV0FBbEIsSUFBaUMsQ0FBQ1IsaUJBQWlCLENBQUNRLFdBQWxCLENBQThCQyxRQUE5QixDQUF0QyxFQUErRTtBQUM3RSxhQUFPTyxPQUFPLENBQUNDLE1BQVIsQ0FBZUgsS0FBZixDQUFQO0FBQ0QsS0FYb0MsQ0FZckM7OztBQUNBLFFBQU1OLFdBQVcsR0FBR0YsVUFBVSxHQUFHRixPQUFqQzs7QUFFQSxRQUFJSSxXQUFKLEVBQWlCO0FBQ2ZGLE1BQUFBLFVBQVU7O0FBRVYsVUFBSUQsZ0JBQWdCLElBQUlJLFFBQUosYUFBSUEsUUFBSixlQUFJQSxRQUFRLENBQUVTLE9BQWxDLEVBQTJDO0FBQUEsbURBQ2hCYixnQkFEZ0I7QUFBQTs7QUFBQTtBQUN6Qyw4REFBMkM7QUFBQSxnQkFBaENjLFVBQWdDO0FBQ3pDLGdCQUFNQyxjQUFjLEdBQUdYLFFBQUgsYUFBR0EsUUFBSCx1QkFBR0EsUUFBUSxDQUFFUyxPQUFWLENBQWtCQyxVQUFVLENBQUNFLGlCQUFYLEVBQWxCLENBQXZCOztBQUNBLGdCQUFJRCxjQUFKLEVBQW9CO0FBQ2xCO0FBQ0FMLGNBQUFBLE1BQU0sQ0FBQ0csT0FBUCxDQUFlQyxVQUFmLElBQTZCQyxjQUE3QjtBQUNEO0FBQ0Y7QUFQd0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVExQzs7QUFFRCxhQUFPLElBQUlKLE9BQUosQ0FBWSxVQUFDTSxPQUFEO0FBQUEsZUFBYSx1QkFBTXJCLGFBQU4sRUFBc0NzQixJQUF0QyxDQUEyQztBQUFBLGlCQUFNRCxPQUFPLENBQUN2QixLQUFLLENBQUNnQixNQUFELENBQU4sQ0FBYjtBQUFBLFNBQTNDLENBQWI7QUFBQSxPQUFaLENBQVA7QUFDRDs7QUFDRCxXQUFPQyxPQUFPLENBQUNDLE1BQVIsQ0FBZUgsS0FBZixDQUFQO0FBQ0QsR0EvQkQ7O0FBaUNBZixFQUFBQSxLQUFLLENBQUN5QixZQUFOLENBQW1CZixRQUFuQixDQUE0QmdCLEdBQTVCLENBQWdDbEIsU0FBaEMsRUFBMkNNLE9BQTNDLEVBM0RrRixDQTJEN0I7QUFDdEQsQ0E1REQ7O2VBNkRlZixVIiwic291cmNlUm9vdCI6Im9jc2RrOi8vLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF4aW9zSW5zdGFuY2UsIEF4aW9zRXJyb3IgfSBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCBDb25zdGFudHMgZnJvbSBcIi4uL0NvbW1vbi9Db25zdGFudHNcIjtcbmltcG9ydCBJQXhpb3NSZXRyeU9wdGlvbnMgZnJvbSBcIi4uL0ludGVyZmFjZXMvSUF4aW9zUmV0cnlPcHRpb25zXCI7XG5pbXBvcnQgc2xlZXAgZnJvbSBcIi4vc2xlZXBcIjtcblxuLyoqXG4gKiBDdXN0b20gaGFuZGxlciBmb3IgSFRUUCBjYWxscyB3aXRoIEF4aW9zLiBIYW5kbGVyIGFsbG93cyB0byByZXRyeSBIVFRQIGNhbGxzIGlmIGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0gYXhpb3MgQXhpb3MgaW5zdGFuY2UuXG4gKiBAcGFyYW0gYXhpb3NSZXRyeU9wdGlvbnMgT3B0aW9ucyBmb3IgYXhpb3MgcmV0cnkuXG4gKi9cbmNvbnN0IGF4aW9zUmV0cnkgPSAoYXhpb3M6IEF4aW9zSW5zdGFuY2UsIGF4aW9zUmV0cnlPcHRpb25zOiBJQXhpb3NSZXRyeU9wdGlvbnMpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSAxMDAwOyAvLyAxIHNlY29uZCBpbnRlcnZhbCBiZXR3ZWVuIHJldHJpZXNcblxuICAvLyBEZWZhdWx0IHZhbHVlc1xuICBpZiAoYXhpb3NSZXRyeU9wdGlvbnMucmV0cnlPbjQyOSA9PT0gdW5kZWZpbmVkIHx8IGF4aW9zUmV0cnlPcHRpb25zLnJldHJ5T240MjkgPT09IG51bGwpIHtcbiAgICBheGlvc1JldHJ5T3B0aW9ucy5yZXRyeU9uNDI5ID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHsgcmV0cmllcywgaGVhZGVyT3ZlcndyaXRlcyB9ID0gYXhpb3NSZXRyeU9wdGlvbnM7XG5cbiAgbGV0IGN1cnJlbnRUcnkgPSAxOyAvLyBFeGVjdXRlZCBhcyBzb29uIGFzIGFmdGVyIDFzdCB0cnlcblxuICAvLyBNZXRob2QgdG8gaW50ZXJjZXB0cyByZXNwb25zZXMgd2l0aGluIHJhbmdlIG9mIDJ4eFxuICBjb25zdCBvblN1Y2Nlc3MgPSB1bmRlZmluZWQ7XG5cbiAgLy8gZGVmaW5lIGRlZmF1bHQgYmVoYXZpb3VyIGZvciA0MjkgcmV0cmllcyBpbiBjYXNlIHRoZSBoYW5kbGVyIHdhcyBub3QgaW5jbHVkZWQgYnkgdGhlIGNhbGxlci5cbiAgaWYgKCFheGlvc1JldHJ5T3B0aW9ucy5zaG91bGRSZXRyeSkge1xuICAgIGF4aW9zUmV0cnlPcHRpb25zLnNob3VsZFJldHJ5ID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cyA9PT0gQ29uc3RhbnRzLnRvb01hbnlSZXF1ZXN0c1N0YXR1c0NvZGUgJiYgYXhpb3NSZXRyeU9wdGlvbnMucmV0cnlPbjQyOSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gTWV0aG9kIHRvIGludGVyY2VwdHMgcmVzcG9uc2VzIG91dHNpZGUgcmFuZ2Ugb2YgMnh4XG4gIGNvbnN0IG9uRXJyb3IgPSAoZXJyb3I6IEF4aW9zRXJyb3IpID0+IHtcblxuICAgIGNvbnN0IHsgY29uZmlnLCByZXNwb25zZSB9ID0gZXJyb3I7XG4gICAgLy8gSWYgd2UgaGF2ZSBubyBpbmZvcm1hdGlvbiBvZiB0aGUgcmVxdWVzdCB0byByZXRyeVxuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIEV2YWx1YXRlcyBpZiBleGVjdXRpb24gc2hvdWxkIHN0b3AgYWNjb3JkaW5nIHRvIHRoZSBjb25kaXRpb25zIGRlZmluZWQgaW4gdGhlIGhhbmRsZXJcbiAgICBpZiAoYXhpb3NSZXRyeU9wdGlvbnMuc2hvdWxkUmV0cnkgJiYgIWF4aW9zUmV0cnlPcHRpb25zLnNob3VsZFJldHJ5KHJlc3BvbnNlKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgLy8gUmV0cnkgcmVxdWVzdCBpZiBiZWxvdyB0aHJlc2hvbGRcbiAgICBjb25zdCBzaG91bGRSZXRyeSA9IGN1cnJlbnRUcnkgPCByZXRyaWVzO1xuXG4gICAgaWYgKHNob3VsZFJldHJ5KSB7XG4gICAgICBjdXJyZW50VHJ5Kys7XG5cbiAgICAgIGlmIChoZWFkZXJPdmVyd3JpdGVzICYmIHJlc3BvbnNlPy5oZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyTmFtZSBvZiBoZWFkZXJPdmVyd3JpdGVzKSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXIgPSByZXNwb25zZT8uaGVhZGVyc1toZWFkZXJOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCldO1xuICAgICAgICAgIGlmIChyZXNwb25zZUhlYWRlcikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1vYmplY3QtaW5qZWN0aW9uXG4gICAgICAgICAgICBjb25maWcuaGVhZGVyc1toZWFkZXJOYW1lXSA9IHJlc3BvbnNlSGVhZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNsZWVwKHJldHJ5SW50ZXJ2YWwgYXMgbnVtYmVyIHwgMTAwMCkudGhlbigoKSA9PiByZXNvbHZlKGF4aW9zKGNvbmZpZykpKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH07XG5cbiAgYXhpb3MuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShvblN1Y2Nlc3MsIG9uRXJyb3IpOyAvLyBJbnRlcmNlcHQgcmVzcG9uc2UgYmVmb3JlIHJldHVybmluZ1xufTtcbmV4cG9ydCBkZWZhdWx0IGF4aW9zUmV0cnk7Il19