"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setPreChatAndInitiateChat = exports.prepareStartChat = exports.initStartChat = exports.checkIfConversationStillValid = void 0;
var _TelemetryConstants = require("../../../common/telemetry/TelemetryConstants");
var _Constants = require("../../../common/Constants");
var _utils = require("../../../common/utils");
var _authHelper = require("./authHelper");
var _ActivityStreamHandler = require("./ActivityStreamHandler");
var _omnichannelChatComponents = require("@microsoft/omnichannel-chat-components");
var _ConversationState = require("../../../contexts/common/ConversationState");
var _LiveChatWidgetActionType = require("../../../contexts/common/LiveChatWidgetActionType");
var _NotificationHandler = require("../../webchatcontainerstateful/webchatcontroller/notification/NotificationHandler");
var _NotificationScenarios = require("../../webchatcontainerstateful/webchatcontroller/enums/NotificationScenarios");
var _TelemetryHelper = require("../../../common/telemetry/TelemetryHelper");
var _TelemetryManager = require("../../../common/telemetry/TelemetryManager");
var _createAdapter = require("./createAdapter");
var _newMessageEventHandler = require("../../../plugins/newMessageEventHandler");
var _reconnectChatHelper = require("./reconnectChatHelper");
var _setPostChatContextAndLoadSurvey = require("./setPostChatContextAndLoadSurvey");
var _updateSessionDataForTelemetry = require("./updateSessionDataForTelemetry");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let optionalParams = {};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let widgetInstanceId;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let popoutWidgetInstanceId;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const prepareStartChat = async (props, chatSDK, state, dispatch, setAdapter) => {
  optionalParams = {}; //Resetting to ensure no stale values
  widgetInstanceId = (0, _utils.getWidgetCacheIdfromProps)(props);

  // reconnect > chat from cache
  await (0, _reconnectChatHelper.handleChatReconnect)(chatSDK, props, dispatch, setAdapter, initStartChat, state);
  // If chat reconnect has kicked in chat state will become Active or Reconnect. So just exit, else go next
  if (state.appStates.conversationState === _ConversationState.ConversationState.Active || state.appStates.conversationState === _ConversationState.ConversationState.ReconnectChat) {
    return;
  }

  // Check if there is any active popout chats in cache
  if (await canStartPopoutChat(props)) {
    return;
  }

  // Can connect to existing chat session
  if (await canConnectToExistingChat(props, chatSDK, state, dispatch, setAdapter)) {
    return;
  }

  // Setting Proactive chat settings
  const isProactiveChat = state.appStates.conversationState === _ConversationState.ConversationState.ProactiveChat;
  const isPreChatEnabledInProactiveChat = state.appStates.proactiveChatStates.proactiveChatEnablePrechat;

  //Setting PreChat and intiate chat
  await setPreChatAndInitiateChat(chatSDK, dispatch, setAdapter, isProactiveChat, isPreChatEnabledInProactiveChat, undefined, props);
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.prepareStartChat = prepareStartChat;
const setPreChatAndInitiateChat = async (chatSDK, dispatch, setAdapter, isProactiveChat, proactiveChatEnablePrechatState, state, props) => {
  var _props$controlProps;
  //Handle reconnect scenario

  // Getting prechat Survey Context
  const parseToJson = false;
  const preChatSurveyResponse = await chatSDK.getPreChatSurvey(parseToJson);
  const showPrechat = isProactiveChat ? preChatSurveyResponse && proactiveChatEnablePrechatState : preChatSurveyResponse && !(props !== null && props !== void 0 && (_props$controlProps = props.controlProps) !== null && _props$controlProps !== void 0 && _props$controlProps.hidePreChatSurveyPane);
  if (showPrechat) {
    dispatch({
      type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_PRE_CHAT_SURVEY_RESPONSE,
      payload: preChatSurveyResponse
    });
    dispatch({
      type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_CONVERSATION_STATE,
      payload: _ConversationState.ConversationState.Prechat
    });
    return;
  }

  //Initiate start chat
  dispatch({
    type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_CONVERSATION_STATE,
    payload: _ConversationState.ConversationState.Loading
  });
  const optionalParams = {
    isProactiveChat
  };
  await initStartChat(chatSDK, dispatch, setAdapter, state, props, optionalParams);
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.setPreChatAndInitiateChat = setPreChatAndInitiateChat;
const initStartChat = async (chatSDK, dispatch, setAdapter, state, props, params, persistedState) => {
  var _props$controlProps2;
  let isStartChatSuccessful = false;
  const chatConfig = props === null || props === void 0 ? void 0 : props.chatConfig;
  const getAuthToken = props === null || props === void 0 ? void 0 : props.getAuthToken;
  const hideErrorUIPane = props === null || props === void 0 ? void 0 : (_props$controlProps2 = props.controlProps) === null || _props$controlProps2 === void 0 ? void 0 : _props$controlProps2.hideErrorUIPane;
  try {
    var _newAdapter$activity$, _TelemetryTimers$Widg2;
    //Start widget load timer
    _TelemetryManager.TelemetryTimers.WidgetLoadTimer = (0, _utils.createTimer)();
    _TelemetryHelper.TelemetryHelper.logLoadingEvent(_TelemetryConstants.LogLevel.INFO, {
      Event: _TelemetryConstants.TelemetryEvent.WidgetLoadStarted,
      Description: "Widget loading started"
    });
    const authClientFunction = (0, _authHelper.getAuthClientFunction)(chatConfig);
    if (getAuthToken && authClientFunction) {
      // set auth token to chat sdk before start chat
      const authSuccess = await (0, _authHelper.handleAuthentication)(chatSDK, chatConfig, getAuthToken);
      if (!authSuccess) {
        // Replacing with error ui
        throw new Error("Authentication was not successful");
      }
    }

    //Check if chat retrieved from cache
    if (persistedState || params !== null && params !== void 0 && params.liveChatContext) {
      var _persistedState$domai, _persistedState$domai2, _persistedState$domai3, _persistedState$domai4, _persistedState$domai5;
      _omnichannelChatComponents.BroadcastService.postMessage({
        eventName: _TelemetryConstants.BroadcastEvent.ChatRetrievedFromCache,
        payload: {
          chatId: persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai = persistedState.domainStates) === null || _persistedState$domai === void 0 ? void 0 : (_persistedState$domai2 = _persistedState$domai.liveChatContext) === null || _persistedState$domai2 === void 0 ? void 0 : (_persistedState$domai3 = _persistedState$domai2.chatToken) === null || _persistedState$domai3 === void 0 ? void 0 : _persistedState$domai3.chatId,
          requestId: persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai4 = persistedState.domainStates) === null || _persistedState$domai4 === void 0 ? void 0 : (_persistedState$domai5 = _persistedState$domai4.liveChatContext) === null || _persistedState$domai5 === void 0 ? void 0 : _persistedState$domai5.requestId
        }
      });
    }
    try {
      var _window$Microsoft, _window$Microsoft$Dyn, _window$Microsoft$Dyn2, _window$Microsoft$Dyn3;
      // Set custom context params
      await setCustomContextParams(state, props);
      const defaultOptionalParams = {
        sendDefaultInitContext: true,
        isProactiveChat: !!(params !== null && params !== void 0 && params.isProactiveChat),
        portalContactId: (_window$Microsoft = window.Microsoft) === null || _window$Microsoft === void 0 ? void 0 : (_window$Microsoft$Dyn = _window$Microsoft.Dynamic365) === null || _window$Microsoft$Dyn === void 0 ? void 0 : (_window$Microsoft$Dyn2 = _window$Microsoft$Dyn.Portal) === null || _window$Microsoft$Dyn2 === void 0 ? void 0 : (_window$Microsoft$Dyn3 = _window$Microsoft$Dyn2.User) === null || _window$Microsoft$Dyn3 === void 0 ? void 0 : _window$Microsoft$Dyn3.contactId
      };
      const startChatOptionalParams = Object.assign({}, params, optionalParams, defaultOptionalParams);
      await chatSDK.startChat(startChatOptionalParams);
      isStartChatSuccessful = true;
    } catch (error) {
      (0, _utils.checkContactIdError)(error);
      _TelemetryHelper.TelemetryHelper.logSDKEvent(_TelemetryConstants.LogLevel.ERROR, {
        Event: _TelemetryConstants.TelemetryEvent.StartChatMethodException,
        ExceptionDetails: {
          exception: `Failed to setup startChat: ${error}`
        }
      });
      isStartChatSuccessful = false;
      throw error;
    }

    // New adapter creation
    const newAdapter = await (0, _createAdapter.createAdapter)(chatSDK);
    setAdapter(newAdapter);
    const chatToken = await chatSDK.getChatToken();
    dispatch({
      type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_CHAT_TOKEN,
      payload: chatToken
    });
    newAdapter === null || newAdapter === void 0 ? void 0 : (_newAdapter$activity$ = newAdapter.activity$) === null || _newAdapter$activity$ === void 0 ? void 0 : _newAdapter$activity$.subscribe((0, _newMessageEventHandler.createOnNewAdapterActivityHandler)(chatToken === null || chatToken === void 0 ? void 0 : chatToken.chatId, chatToken === null || chatToken === void 0 ? void 0 : chatToken.visitorId));

    // Set app state to Active
    if (isStartChatSuccessful) {
      _ActivityStreamHandler.ActivityStreamHandler.uncork();
      // Update start chat failure app state if chat loads successfully
      dispatch({
        type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_START_CHAT_FAILING,
        payload: false
      });
      dispatch({
        type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_CONVERSATION_STATE,
        payload: _ConversationState.ConversationState.Active
      });
    }
    if (persistedState) {
      var _TelemetryTimers$Widg;
      dispatch({
        type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_WIDGET_STATE,
        payload: persistedState
      });
      _TelemetryHelper.TelemetryHelper.logLoadingEvent(_TelemetryConstants.LogLevel.INFO, {
        Event: _TelemetryConstants.TelemetryEvent.WidgetLoadComplete,
        Description: "Widget load complete. Persisted state retrieved",
        ElapsedTimeInMilliseconds: _TelemetryManager.TelemetryTimers === null || _TelemetryManager.TelemetryTimers === void 0 ? void 0 : (_TelemetryTimers$Widg = _TelemetryManager.TelemetryTimers.WidgetLoadTimer) === null || _TelemetryTimers$Widg === void 0 ? void 0 : _TelemetryTimers$Widg.milliSecondsElapsed
      });
      await (0, _setPostChatContextAndLoadSurvey.setPostChatContextAndLoadSurvey)(chatSDK, dispatch, true);
      return;
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const liveChatContext = await (chatSDK === null || chatSDK === void 0 ? void 0 : chatSDK.getCurrentLiveChatContext());
    dispatch({
      type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_LIVE_CHAT_CONTEXT,
      payload: liveChatContext
    });
    _TelemetryHelper.TelemetryHelper.logLoadingEvent(_TelemetryConstants.LogLevel.INFO, {
      Event: _TelemetryConstants.TelemetryEvent.WidgetLoadComplete,
      Description: "Widget load complete",
      ElapsedTimeInMilliseconds: _TelemetryManager.TelemetryTimers === null || _TelemetryManager.TelemetryTimers === void 0 ? void 0 : (_TelemetryTimers$Widg2 = _TelemetryManager.TelemetryTimers.WidgetLoadTimer) === null || _TelemetryTimers$Widg2 === void 0 ? void 0 : _TelemetryTimers$Widg2.milliSecondsElapsed
    });

    // Set post chat context in state
    // Commenting this for now as post chat context is fetched during end chat
    await (0, _setPostChatContextAndLoadSurvey.setPostChatContextAndLoadSurvey)(chatSDK, dispatch);

    // Updating chat session detail for telemetry
    await (0, _updateSessionDataForTelemetry.updateSessionDataForTelemetry)(chatSDK, dispatch);
  } catch (ex) {
    var _TelemetryTimers$Widg4;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (ex.message === _Constants.ChatSDKError.WidgetUseOutsideOperatingHour) {
      var _TelemetryTimers$Widg3;
      dispatch({
        type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_OUTSIDE_OPERATING_HOURS,
        payload: true
      });
      dispatch({
        type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_CONVERSATION_STATE,
        payload: _ConversationState.ConversationState.OutOfOffice
      });
      _TelemetryHelper.TelemetryHelper.logLoadingEvent(_TelemetryConstants.LogLevel.INFO, {
        Event: _TelemetryConstants.TelemetryEvent.WidgetLoadComplete,
        Description: "Widget load complete. Widget is OOOH.",
        ElapsedTimeInMilliseconds: _TelemetryManager.TelemetryTimers === null || _TelemetryManager.TelemetryTimers === void 0 ? void 0 : (_TelemetryTimers$Widg3 = _TelemetryManager.TelemetryTimers.WidgetLoadTimer) === null || _TelemetryTimers$Widg3 === void 0 ? void 0 : _TelemetryTimers$Widg3.milliSecondsElapsed
      });
      return;
    }
    _TelemetryHelper.TelemetryHelper.logLoadingEvent(_TelemetryConstants.LogLevel.ERROR, {
      Event: _TelemetryConstants.TelemetryEvent.WidgetLoadFailed,
      ExceptionDetails: {
        Exception: `Widget load Failed: ${ex}`
      },
      ElapsedTimeInMilliseconds: _TelemetryManager.TelemetryTimers === null || _TelemetryManager.TelemetryTimers === void 0 ? void 0 : (_TelemetryTimers$Widg4 = _TelemetryManager.TelemetryTimers.WidgetLoadTimer) === null || _TelemetryTimers$Widg4 === void 0 ? void 0 : _TelemetryTimers$Widg4.milliSecondsElapsed
    });
    _NotificationHandler.NotificationHandler.notifyError(_NotificationScenarios.NotificationScenarios.Connection, "Start Chat Failed: " + ex);
    dispatch({
      type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_START_CHAT_FAILING,
      payload: true
    });
    if (!hideErrorUIPane) {
      // Set app state to failing start chat if hideErrorUI is not turned on
      _TelemetryHelper.TelemetryHelper.logLoadingEvent(_TelemetryConstants.LogLevel.INFO, {
        Event: _TelemetryConstants.TelemetryEvent.ErrorUIPaneLoaded,
        Description: "Error UI Pane Loaded"
      });
    }
    // Show the loading pane in other cases for failure, this will help for both hideStartChatButton case
    dispatch({
      type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_CONVERSATION_STATE,
      payload: _ConversationState.ConversationState.Loading
    });

    // If sessionInit was successful but LCW startchat failed due to some reason e.g adapter didn't load
    // we need to directly endChat to avoid leaving ghost chats in OC, not disturbing any other UI state 
    if (isStartChatSuccessful === true) {
      await forceEndChat(chatSDK);
    }
  } finally {
    optionalParams = {};
    widgetInstanceId = "";
  }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.initStartChat = initStartChat;
const forceEndChat = async chatSDK => {
  _TelemetryHelper.TelemetryHelper.logLoadingEvent(_TelemetryConstants.LogLevel.ERROR, {
    Event: _TelemetryConstants.TelemetryEvent.WidgetLoadFailed,
    ExceptionDetails: {
      Exception: "SessionInit was successful, but widget load failed."
    }
  });
  chatSDK === null || chatSDK === void 0 ? void 0 : chatSDK.endChat();
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const canConnectToExistingChat = async (props, chatSDK, state, dispatch, setAdapter) => {
  var _state$appStates, _persistedState$domai6, _persistedState$appSt;
  // By pass this function in case of popout chat
  if ((state === null || state === void 0 ? void 0 : (_state$appStates = state.appStates) === null || _state$appStates === void 0 ? void 0 : _state$appStates.hideStartChatButton) === true) {
    return false;
  }
  const persistedState = (0, _utils.getStateFromCache)((0, _utils.getWidgetCacheIdfromProps)(props));

  //Connect to only active chat session
  if (persistedState && !(0, _utils.isUndefinedOrEmpty)(persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai6 = persistedState.domainStates) === null || _persistedState$domai6 === void 0 ? void 0 : _persistedState$domai6.liveChatContext) && (persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$appSt = persistedState.appStates) === null || _persistedState$appSt === void 0 ? void 0 : _persistedState$appSt.conversationState) === _ConversationState.ConversationState.Active) {
    var _persistedState$domai7;
    dispatch({
      type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_CONVERSATION_STATE,
      payload: _ConversationState.ConversationState.Loading
    });
    const optionalParams = {
      liveChatContext: persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai7 = persistedState.domainStates) === null || _persistedState$domai7 === void 0 ? void 0 : _persistedState$domai7.liveChatContext
    };
    await initStartChat(chatSDK, dispatch, setAdapter, state, props, optionalParams, persistedState);
    return true;
  }
  return false;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const setCustomContextParams = async (state, props) => {
  var _props$chatConfig, _props$chatConfig$Liv, _state$domainStates, _persistedState$domai8;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const isAuthenticatedChat = props !== null && props !== void 0 && (_props$chatConfig = props.chatConfig) !== null && _props$chatConfig !== void 0 && (_props$chatConfig$Liv = _props$chatConfig.LiveChatConfigAuthSettings) !== null && _props$chatConfig$Liv !== void 0 && _props$chatConfig$Liv.msdyn_javascriptclientfunction ? true : false;
  //Should not set custom context for auth chat
  if (isAuthenticatedChat) {
    return;
  }
  if (state !== null && state !== void 0 && (_state$domainStates = state.domainStates) !== null && _state$domainStates !== void 0 && _state$domainStates.customContext) {
    var _state$domainStates2;
    optionalParams = Object.assign({}, optionalParams, {
      customContext: JSON.parse(JSON.stringify(state === null || state === void 0 ? void 0 : (_state$domainStates2 = state.domainStates) === null || _state$domainStates2 === void 0 ? void 0 : _state$domainStates2.customContext))
    });
    return;
  }
  if ((0, _utils.isNullOrEmptyString)(widgetInstanceId)) {
    widgetInstanceId = (0, _utils.getWidgetCacheIdfromProps)(props);
  }
  // Add custom context only for unauthenticated chat
  const persistedState = (0, _utils.getStateFromCache)(widgetInstanceId);
  const customContextLocal = (persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai8 = persistedState.domainStates) === null || _persistedState$domai8 === void 0 ? void 0 : _persistedState$domai8.customContext) ?? (props === null || props === void 0 ? void 0 : props.initialCustomContext);
  if (customContextLocal) {
    _TelemetryHelper.TelemetryHelper.logLoadingEvent(_TelemetryConstants.LogLevel.INFO, {
      Event: _TelemetryConstants.TelemetryEvent.SettingCustomContext,
      Description: "Setting custom context for unauthenticated chat"
    });
    optionalParams = Object.assign({}, optionalParams, {
      customContext: JSON.parse(JSON.stringify(customContextLocal))
    });
  } else {
    const customContextFromParent = await getInitContextParamsForPopout();
    if (!(0, _utils.isUndefinedOrEmpty)(customContextFromParent === null || customContextFromParent === void 0 ? void 0 : customContextFromParent.contextVariables)) {
      optionalParams = Object.assign({}, optionalParams, {
        customContext: JSON.parse(JSON.stringify(customContextFromParent.contextVariables))
      });
    }
  }
};
const canStartPopoutChat = async props => {
  if (props.allowSdkChatSupport === false) {
    return false;
  }
  popoutWidgetInstanceId = (0, _utils.getWidgetCacheIdfromProps)(props, true);
  if (!(0, _utils.isNullOrEmptyString)(popoutWidgetInstanceId)) {
    var _persistedState$domai9, _persistedState$appSt2;
    const persistedState = (0, _utils.getStateFromCache)(popoutWidgetInstanceId);
    if (persistedState && !(0, _utils.isUndefinedOrEmpty)(persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai9 = persistedState.domainStates) === null || _persistedState$domai9 === void 0 ? void 0 : _persistedState$domai9.liveChatContext) && (persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$appSt2 = persistedState.appStates) === null || _persistedState$appSt2 === void 0 ? void 0 : _persistedState$appSt2.conversationState) === _ConversationState.ConversationState.Active) {
      // Initiate popout chat
      _omnichannelChatComponents.BroadcastService.postMessage({
        eventName: _TelemetryConstants.BroadcastEvent.InitiateStartChatInPopoutMode
      });
      return true;
    }
  }
  return false;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const checkIfConversationStillValid = async (chatSDK, dispatch, state) => {
  var _state$domainStates3, _state$domainStates3$;
  const requestIdFromCache = (_state$domainStates3 = state.domainStates) === null || _state$domainStates3 === void 0 ? void 0 : (_state$domainStates3$ = _state$domainStates3.liveChatContext) === null || _state$domainStates3$ === void 0 ? void 0 : _state$domainStates3$.requestId;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let conversationDetails = undefined;

  //Preserve current requestId
  const currentRequestId = chatSDK.requestId ?? "";
  dispatch({
    type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_INITIAL_CHAT_SDK_REQUEST_ID,
    payload: currentRequestId
  });
  try {
    chatSDK.requestId = requestIdFromCache;
    conversationDetails = await (0, _utils.getConversationDetailsCall)(chatSDK);
    if (Object.keys(conversationDetails).length === 0) {
      chatSDK.requestId = currentRequestId;
      return false;
    }
    if (conversationDetails.state === _Constants.LiveWorkItemState.Closed || conversationDetails.state === _Constants.LiveWorkItemState.WrapUp) {
      dispatch({
        type: _LiveChatWidgetActionType.LiveChatWidgetActionType.SET_LIVE_CHAT_CONTEXT,
        payload: undefined
      });
      chatSDK.requestId = currentRequestId;
      return false;
    }
    return true;
  } catch (erorr) {
    _TelemetryHelper.TelemetryHelper.logActionEvent(_TelemetryConstants.LogLevel.ERROR, {
      Event: _TelemetryConstants.TelemetryEvent.GetConversationDetailsException,
      ExceptionDetails: {
        exception: `Conversation is not valid: ${erorr}`
      }
    });
    chatSDK.requestId = currentRequestId;
    return false;
  }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
exports.checkIfConversationStillValid = checkIfConversationStillValid;
const getInitContextParamsForPopout = async () => {
  return window.opener ? await getInitContextParamForPopoutFromOuterScope(window.opener) : null;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getInitContextParamForPopoutFromOuterScope = async scope => {
  let payload;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let waitPromiseResolve;
  const waitPromise = new Promise((res, rej) => {
    waitPromiseResolve = res;
    setTimeout(() => rej("Failed to find method in outer scope"), 5000);
  }).catch(rej => console.warn(rej));
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const getInitContextParamsFromParent = e => {
    if (e.data && e.data.messageName == _Constants.Constants.InitContextParamsResponse) {
      payload = e.data.payload;
      waitPromiseResolve();
    }
  };
  window.addEventListener("message", getInitContextParamsFromParent, false);
  scope.postMessage({
    messageName: _Constants.Constants.InitContextParamsRequest
  }, "*");
  await waitPromise;
  window.removeEventListener("message", getInitContextParamsFromParent, false);
  return payload;
};