"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMarkdown = void 0;
var _Constants = require("../../../common/Constants");
var _markdownIt = _interopRequireDefault(require("markdown-it"));
var _markdownItForInline = _interopRequireDefault(require("markdown-it-for-inline"));
var _slackMarkdownIt = _interopRequireDefault(require("slack-markdown-it"));
var _defaultMarkdownLocalizedTexts = require("../../webchatcontainerstateful/common/defaultProps/defaultMarkdownLocalizedTexts");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const createMarkdown = (disableMarkdownMessageFormatting, disableNewLineMarkdownSupport) => {
  let markdown;
  if (!disableMarkdownMessageFormatting) {
    markdown = new _markdownIt.default(_Constants.Constants.Default, {
      html: true,
      linkify: true,
      breaks: !disableNewLineMarkdownSupport
    });
    markdown.use(_slackMarkdownIt.default);
  } else {
    markdown = new _markdownIt.default(_Constants.Constants.Zero, {
      html: true,
      linkify: true,
      breaks: !disableNewLineMarkdownSupport
    });
    markdown.enable(["entity",
    // Rule to process html entity - &#123;, &#xAF;, &quot;
    "linkify",
    // Rule to replace link-like texts with link nodes
    "html_block",
    // Rule to process html blocks and paragraphs
    "html_inline",
    // Rule to process html tags
    "newline" // Rule to proceess '\n'
    ]);
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  markdown.use(_markdownItForInline.default, "url_new_win", "link_open", function (tokens, idx, env) {
    const targetAttrIndex = tokens[idx].attrIndex(_Constants.Constants.Target);
    // Put a transparent pixel instead of the "open in new window" icon, so developers can easily modify the icon in CSS.
    const TRANSPARENT_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    if (~targetAttrIndex) {
      tokens[idx].attrs[targetAttrIndex][1] = _Constants.Constants.Blank;
    } else {
      tokens[idx].attrPush([_Constants.Constants.Target, _Constants.Constants.Blank]);
    }
    const relAttrIndex = tokens[idx].attrIndex(_Constants.Constants.TargetRelationship);
    if (~relAttrIndex) {
      tokens[idx].attrs[relAttrIndex][1] = _Constants.Constants.TargetRelationshipAttributes;
    } else {
      tokens[idx].attrPush([_Constants.Constants.TargetRelationship, _Constants.Constants.TargetRelationshipAttributes]);
      if (!disableMarkdownMessageFormatting) {
        tokens[idx].attrPush([_Constants.Constants.Title, _defaultMarkdownLocalizedTexts.defaultMarkdownLocalizedTexts.MARKDOWN_EXTERNAL_LINK_ALT]);
        // eslint-disable-next-line quotes
        const iconTokens = markdown.parseInline(`![${_defaultMarkdownLocalizedTexts.defaultMarkdownLocalizedTexts.MARKDOWN_EXTERNAL_LINK_ALT}](${TRANSPARENT_GIF})`, env)[0].children;
        if (iconTokens && iconTokens.length > 0) {
          iconTokens[0].attrJoin("class", _Constants.Constants.OpenLinkIconCssClass);
          tokens.splice(idx + 2, 0, ...iconTokens);
        }
      }
    }
  });
  return markdown;
};
exports.createMarkdown = createMarkdown;