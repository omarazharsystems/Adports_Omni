var _this = this;
import { AriaTelemetryConstants, ChatSDKError, Constants, HtmlAttributeNames, LocaleConstants } from "./Constants";
import { BroadcastEvent, LogLevel, TelemetryEvent } from "./telemetry/TelemetryConstants";
import { BroadcastService } from "@microsoft/omnichannel-chat-components";
import { DataStoreManager } from "./contextDataStore/DataStoreManager";
import { KeyCodes } from "./KeyCodes";
import { Md5 } from "md5-typescript";
import { TelemetryHelper } from "./telemetry/TelemetryHelper";
const getElementBySelector = selector => {
  let element;
  if (typeof selector === "string") {
    element = document.querySelector(selector);
  } else {
    element = selector;
  }
  return element;
};

// The purpose of this function is:
// - to make elements not focusable, when confirmation pane or email transcript pane are showing,
// - to set their initial tab indices back after confirmation pane or email transcript pane are closed
// Otherwise, the user will be able to click on the screen and tab through different buttons or other elements, even though
// these dialogs are showing
export const setTabIndices = (elements, tabIndexMap, shouldBeFocusable) => {
  if (elements) {
    if (shouldBeFocusable) {
      for (let index = 0; index < elements.length; index++) {
        if (tabIndexMap.has(elements[index].id)) {
          elements[index].tabIndex = tabIndexMap.get(elements[index].id);
        }
      }
      tabIndexMap.clear();
    } else {
      for (let index = 0; index < elements.length; index++) {
        tabIndexMap.set(elements[index].id, elements[index].tabIndex);
        elements[index].tabIndex = -1;
      }
    }
  }
};
export const findParentFocusableElementsWithoutChildContainer = elementId => {
  const childContainer = document.getElementById(elementId);
  if (!childContainer) {
    return null;
  }
  const parentContainer = childContainer.parentElement;
  if (!parentContainer) {
    return null;
  }
  const parentFocusableElements = findAllFocusableElement(parentContainer);
  if (!parentFocusableElements) {
    return null;
  }
  for (let index = 0; index < parentFocusableElements.length; index++) {
    if (childContainer.contains(parentFocusableElements[index])) {
      parentFocusableElements.splice(index, 1);
      index--;
    }
  }
  return parentFocusableElements;
};
export const findAllFocusableElement = parent => {
  const container = getElementBySelector(parent);
  if (container !== null) {
    return Array.prototype.slice.call(container.querySelectorAll("a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]"));
  }
  return null;
};
export const preventFocusToMoveOutOfElement = elementId => {
  const container = document.getElementById(elementId);
  if (!container) {
    return;
  }
  const focusableElements = findAllFocusableElement(container);
  if (!focusableElements) {
    return;
  }
  const firstFocusableElement = focusableElements[0];
  const lastFocusableElement = focusableElements[focusableElements.length - 1];
  firstFocusableElement.onkeydown = e => {
    if (e.shiftKey && e.key === KeyCodes.TAB) {
      e.preventDefault();
      lastFocusableElement === null || lastFocusableElement === void 0 ? void 0 : lastFocusableElement.focus();
    }
  };
  lastFocusableElement.onkeydown = e => {
    if (!e.shiftKey && e.key === KeyCodes.TAB) {
      e.preventDefault();
      firstFocusableElement === null || firstFocusableElement === void 0 ? void 0 : firstFocusableElement.focus();
    }
  };
};
export const setFocusOnSendBox = () => {
  const sendBoxSelector = "textarea[data-id=\"webchat-sendbox-input\"]";
  setFocusOnElement(sendBoxSelector);
};
export const setFocusOnElement = selector => {
  const element = getElementBySelector(selector);
  element === null || element === void 0 ? void 0 : element.focus();
};
export const escapeHtml = inputString => {
  const entityMap = {
    "<": "&lt;",
    ">": "&gt;",
    "\"": "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
  };
  return String(inputString).replace(/[<>"'/]/g, s => {
    return entityMap[s];
  });
};
export const getIconText = text => {
  if (text) {
    const initials = text.split(/\s/).reduce((response, word) => response += word.slice(0, 1), "");
    if (initials.length > 1) {
      return initials.substring(0, 2).toUpperCase();
    } else {
      return text.substring(0, 2).toUpperCase();
    }
  }
  return "";
};
export const getLocaleDirection = localeLCID => {
  return LocaleConstants.RTL_LOCALES.indexOf(localeLCID) === -1 ? "ltr" : "rtl";
};
export const changeLanguageCodeFormatForWebChat = languageCode => {
  return languageCode.slice(0, -2) + languageCode.slice(-2).toUpperCase();
};
export const getTimestampHourMinute = timestampStr => {
  let yearFormat;
  let monthDayFormat;
  const hourFormat = "numeric";
  const minuteFormat = "2-digit";
  const date = new Date(timestampStr);
  const now = new Date();
  if (isNaN(date.getTime())) {
    return "";
  }
  if (date.getFullYear() !== now.getFullYear()) {
    yearFormat = "numeric";
    monthDayFormat = "2-digit";
  }
  if (date.getMonth() !== now.getMonth() || date.getDate() !== now.getDate()) {
    monthDayFormat = "2-digit";
  }
  return date.toLocaleTimeString(navigator.language, {
    year: yearFormat,
    month: monthDayFormat,
    day: monthDayFormat,
    hour: hourFormat,
    minute: minuteFormat
  });
};
export const parseAdaptiveCardPayload = (payload, requiredFieldMissingMessage) => {
  if (payload && payload !== "{}") {
    try {
      const parsedPayload = JSON.parse(payload.replace("*", "&#42;"));
      const body = parsedPayload.body;
      if (body) {
        //Parse ID field into available options and add required error messages
        for (const fields of body) {
          if (fields.id && fields.id.includes(":")) {
            const parsedId = JSON.parse(fields.id);
            fields.id = parsedId.Id;
            fields.isRequired = parsedId.IsRequired ?? false;
            if (fields.isRequired) {
              fields.errorMessage = requiredFieldMissingMessage.replace("{0}", parsedId.Name ?? "");
            }
          }
        }
      }
      return JSON.stringify(parsedPayload);
    } catch (ex) {
      throw new Error(`Adaptive card pase error: ${ex}`);
    }
  }
  return payload;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const extractPreChatSurveyResponseValues = (preChatSurvey, values) => {
  if (preChatSurvey && preChatSurvey !== "{}" && values) {
    try {
      const parsedSurvey = JSON.parse(preChatSurvey);
      const body = parsedSurvey.body;
      const type = {
        "Type": Constants.InputSubmit
      };
      const computedValues = [];
      for (const val of values) {
        const index = val.index;
        const Id = body[index].id;
        computedValues[Id] = val.value;
      }
      const finalPayload = {
        ...type,
        ...computedValues
      };
      return finalPayload;
    } catch (ex) {
      throw new Error(`PreChatSurvey Response parse error: ${ex}`);
    }
  }
  return {};
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const isNullOrUndefined = obj => {
  return obj === null || obj === undefined;
};
export const isNullOrEmptyString = s => {
  return isNullOrUndefined(s) || s === "";
};
export const newGuid = () => {
  //RFC 4122 canonical representation Version-4 xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx where x is any hexadecimal digit and y is one of 8, 9, A, or B
  const guidPattern = Constants.GuidPattern;
  let newGuid = "";
  for (let i = 0; i < guidPattern.length; i++) {
    const randomString = Math.floor(Math.random() * Date.now());
    switch (guidPattern[i]) {
      case "x":
        newGuid += randomString.toString(16).substring(0, 4);
        break;
      //get 4 digit
      case "m":
        newGuid += randomString.toString(16).substring(0, 3);
        break;
      //Get 3 digit
      case "y":
        newGuid += (randomString & 0x3 | 0x8).toString(16);
        break;
      // To get only one of 8, 9, A, or B
      default:
        newGuid += guidPattern[i];
      //Default "-" and "4"
    }
  }

  return newGuid;
};
export const createTimer = () => {
  const timeStart = new Date().getTime();
  return {
    get milliSecondsElapsed() {
      const ms = new Date().getTime() - timeStart;
      return ms;
    }
  };
};

// Returns the domain of the org
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const getDomain = hostValue => {
  for (let i = 0; i < AriaTelemetryConstants.lcwEUDomainNames.length; i++) {
    if (hostValue.endsWith(AriaTelemetryConstants.lcwEUDomainNames[i])) {
      return AriaTelemetryConstants.EU;
    }
  }
  return AriaTelemetryConstants.Public;
};
export const getWidgetCacheId = function (orgId, widgetId, widgetInstanceId) {
  let popoutChat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (popoutChat) {
    widgetInstanceId = widgetInstanceId + Constants.PopoutCacheSuffix;
  }
  const widgetCacheId = `${widgetInstanceId}_${orgId}_${widgetId}`;
  return Md5.init(widgetCacheId);
};
export const getWidgetEndChatEventName = (orgId, widgetId, widgetInstanceId) => {
  if (!isNullOrEmptyString(widgetInstanceId)) {
    return `${BroadcastEvent.ChatEnded}_${widgetInstanceId}_${orgId}_${widgetId}`;
  }
  return `${BroadcastEvent.ChatEnded}_${orgId}_${widgetId}`;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const getStateFromCache = widgetCacheId => {
  // Getting updated state from cache
  try {
    if (DataStoreManager.clientDataStore) {
      var _DataStoreManager$cli;
      const widgetStateEventName = widgetCacheId;
      const widgetStateFromCache = (_DataStoreManager$cli = DataStoreManager.clientDataStore) === null || _DataStoreManager$cli === void 0 ? void 0 : _DataStoreManager$cli.getData(widgetStateEventName);
      const persistedState = widgetStateFromCache ? JSON.parse(widgetStateFromCache) : undefined;
      return persistedState;
    } else {
      return null;
    }
  } catch (error) {
    console.log(error);
    return null;
  }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const isUndefinedOrEmpty = object => {
  if (object) {
    if (Object.keys(object).length === 0) {
      return true;
    }
    return false;
  } else {
    return true;
  }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const addDelayInMs = ms => {
  return new Promise(resolve => setTimeout(resolve, ms));
};
export const getBroadcastChannelName = (widgetId, widgetInstanceId) => {
  return widgetInstanceId && !isNullOrEmptyString(widgetInstanceId) ? `${widgetInstanceId}_${widgetId}` : widgetId;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const getWidgetCacheIdfromProps = function (props) {
  var _props$chatSDK, _props$chatSDK$omnich, _props$chatSDK2, _props$chatSDK2$omnic, _props$controlProps, _props$controlProps2;
  let popoutChat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  const orgId = props === null || props === void 0 ? void 0 : (_props$chatSDK = props.chatSDK) === null || _props$chatSDK === void 0 ? void 0 : (_props$chatSDK$omnich = _props$chatSDK.omnichannelConfig) === null || _props$chatSDK$omnich === void 0 ? void 0 : _props$chatSDK$omnich.orgId;
  const widgetId = props === null || props === void 0 ? void 0 : (_props$chatSDK2 = props.chatSDK) === null || _props$chatSDK2 === void 0 ? void 0 : (_props$chatSDK2$omnic = _props$chatSDK2.omnichannelConfig) === null || _props$chatSDK2$omnic === void 0 ? void 0 : _props$chatSDK2$omnic.widgetId;
  let widgetInstanceId = (props === null || props === void 0 ? void 0 : (_props$controlProps = props.controlProps) === null || _props$controlProps === void 0 ? void 0 : _props$controlProps.widgetInstanceId) ?? "";
  if (props.useSessionStorage) {
    widgetInstanceId = widgetInstanceId + Constants.SessionCacheSuffix;
  }
  if (props !== null && props !== void 0 && (_props$controlProps2 = props.controlProps) !== null && _props$controlProps2 !== void 0 && _props$controlProps2.hideStartChatButton || popoutChat === true) {
    popoutChat = true;
  }
  const widgetCacheId = getWidgetCacheId(orgId, widgetId, widgetInstanceId, popoutChat);
  return widgetCacheId;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const debounceLeading = function (fn) {
  let ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;
  let timeoutId;
  return function () {
    // eslint-disable-line @typescript-eslint/no-explicit-any

    if (!timeoutId) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      fn.apply(_this, args);
    }
    timeoutId = setTimeout(() => {
      timeoutId = null;
    }, ms);
  };
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const getConversationDetailsCall = async chatSDK => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let conversationDetails = undefined;
  try {
    TelemetryHelper.logSDKEvent(LogLevel.INFO, {
      Event: TelemetryEvent.GetConversationDetailsCallStarted,
      Description: "Conversation details call started"
    });
    conversationDetails = await chatSDK.getConversationDetails();
  } catch (error) {
    checkContactIdError(error);
    TelemetryHelper.logSDKEvent(LogLevel.ERROR, {
      Event: TelemetryEvent.GetConversationDetailsCallFailed,
      ExceptionDetails: {
        exception: `Get Conversation Details Call Failed : ${error}`
      }
    });
  }
  return conversationDetails;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const checkContactIdError = e => {
  if ((e === null || e === void 0 ? void 0 : e.message) === ChatSDKError.AuthContactIdNotFoundFailure) {
    const contactIdNotFoundErrorEvent = {
      eventName: BroadcastEvent.ContactIdNotFound,
      payload: {
        error: e
      }
    };
    BroadcastService.postMessage(contactIdNotFoundErrorEvent);
  }
};
export const createFileAndDownload = (fileName, blobData, mimeType) => {
  const aElement = document.createElement("a");
  const blob = new Blob([blobData], {
    type: mimeType
  });
  const objectUrl = URL.createObjectURL(blob);
  aElement.setAttribute(HtmlAttributeNames.href, objectUrl);
  aElement.setAttribute(HtmlAttributeNames.download, fileName);
  aElement.setAttribute(HtmlAttributeNames.ariaHidden, "true");
  aElement.style.display = "none";
  document.body.appendChild(aElement);
  aElement.click();
  document.body.removeChild(aElement);
};