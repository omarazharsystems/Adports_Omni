function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
import { BroadcastEvent, LogLevel, TelemetryEvent } from "../../../common/telemetry/TelemetryConstants";
import { BroadcastService, BroadcastServiceInitialize, decodeComponentString } from "@microsoft/omnichannel-chat-components";
import { Components } from "botframework-webchat";
import { ConfirmationState, Constants, ConversationEndEntity, E2VVOptions, LiveWorkItemState, StorageType } from "../../../common/Constants";
import { Stack } from "@fluentui/react";
import React, { useEffect, useRef, useState } from "react";
import { checkIfConversationStillValid, initStartChat, prepareStartChat, setPreChatAndInitiateChat } from "../common/startChat";
import { createTimer, getBroadcastChannelName, getConversationDetailsCall, getLocaleDirection, getStateFromCache, getWidgetCacheIdfromProps, getWidgetEndChatEventName, isNullOrEmptyString, isUndefinedOrEmpty, newGuid } from "../../../common/utils";
import { defaultClientDataStoreProvider, isCookieAllowed } from "../../../common/storage/default/defaultClientDataStoreProvider";
import { endChat, prepareEndChat } from "../common/endChat";
import { handleChatReconnect, isPersistentEnabled, isReconnectEnabled } from "../common/reconnectChatHelper";
import { shouldShowCallingContainer, shouldShowChatButton, shouldShowConfirmationPane, shouldShowEmailTranscriptPane, shouldShowHeader, shouldShowLoadingPane, shouldShowOutOfOfficeHoursPane, shouldShowPostChatLoadingPane, shouldShowPostChatSurveyPane, shouldShowPreChatSurveyPane, shouldShowProactiveChatPane, shouldShowReconnectChatPane, shouldShowWebChatContainer } from "../../../controller/componentController";
import { ActivityStreamHandler } from "../common/ActivityStreamHandler";
import CallingContainerStateful from "../../callingcontainerstateful/CallingContainerStateful";
import ChatButtonStateful from "../../chatbuttonstateful/ChatButtonStateful";
import ConfirmationPaneStateful from "../../confirmationpanestateful/ConfirmationPaneStateful";
import { ConversationState } from "../../../contexts/common/ConversationState";
import { DataStoreManager } from "../../../common/contextDataStore/DataStoreManager";
import DraggableChatWidget from "../../draggable/DraggableChatWidget";
import { ElementType } from "@microsoft/omnichannel-chat-components";
import EmailTranscriptPaneStateful from "../../emailtranscriptpanestateful/EmailTranscriptPaneStateful";
import HeaderStateful from "../../headerstateful/HeaderStateful";
import { LiveChatWidgetActionType } from "../../../contexts/common/LiveChatWidgetActionType";
import LoadingPaneStateful from "../../loadingpanestateful/LoadingPaneStateful";
import OutOfOfficeHoursPaneStateful from "../../ooohpanestateful/OOOHPaneStateful";
import PostChatLoadingPaneStateful from "../../postchatloadingpanestateful/PostChatLoadingPaneStateful";
import PostChatSurveyPaneStateful from "../../postchatsurveypanestateful/PostChatSurveyPaneStateful";
import PreChatSurveyPaneStateful from "../../prechatsurveypanestateful/PreChatSurveyPaneStateful";
import ProactiveChatPaneStateful from "../../proactivechatpanestateful/ProactiveChatPaneStateful";
import ReconnectChatPaneStateful from "../../reconnectchatpanestateful/ReconnectChatPaneStateful";
import { TelemetryHelper } from "../../../common/telemetry/TelemetryHelper";
import { TelemetryTimers } from "../../../common/telemetry/TelemetryManager";
import WebChatContainerStateful from "../../webchatcontainerstateful/WebChatContainerStateful";
import createDownloadTranscriptProps from "../common/createDownloadTranscriptProps";
import { createFooter } from "../common/createFooter";
import { createInternetConnectionChangeHandler } from "../common/createInternetConnectionChangeHandler";
import { defaultScrollBarProps } from "../common/defaultProps/defaultScrollBarProps";
import { defaultWebChatContainerStatefulProps } from "../../webchatcontainerstateful/common/defaultProps/defaultWebChatContainerStatefulProps";
import { disposeTelemetryLoggers } from "../common/disposeTelemetryLoggers";
import { getGeneralStylesForButton } from "../common/getGeneralStylesForButton";
import { handleChatDisconnect } from "../common/chatDisconnectHelper";
import { initCallingSdk } from "../common/initCallingSdk";
import { initConfirmationPropsComposer } from "../common/initConfirmationPropsComposer";
import { initWebChatComposer } from "../common/initWebChatComposer";
import { registerBroadcastServiceForStorage } from "../../../common/storage/default/defaultCacheManager";
import { registerTelemetryLoggers } from "../common/registerTelemetryLoggers";
import { setPostChatContextAndLoadSurvey } from "../common/setPostChatContextAndLoadSurvey";
import { startProactiveChat } from "../common/startProactiveChat";
import useChatAdapterStore from "../../../hooks/useChatAdapterStore";
import useChatContextStore from "../../../hooks/useChatContextStore";
import useChatSDKStore from "../../../hooks/useChatSDKStore";
export const LiveChatWidgetStateful = props => {
  var _props$webChatContain, _props$styleProps, _chatSDK$omnichannelC, _props$controlProps, _props$controlProps2, _state$appStates7, _props$webChatContain5, _state$appStates14, _props$webChatContain6, _props$controlProps11, _props$draggableChatW, _props$draggableChatW2, _props$draggableChatW3, _props$draggableChatW4, _props$draggableChatW5, _livechatProps$webCha, _livechatProps$styleP, _livechatProps$contro, _livechatProps$contro2, _livechatProps$compon, _livechatProps$contro3, _livechatProps$compon2, _livechatProps$contro4, _livechatProps$compon3, _livechatProps$contro5, _livechatProps$compon4, _livechatProps$contro6, _livechatProps$compon5, _livechatProps$contro7, _livechatProps$compon6, _livechatProps$contro8, _livechatProps$compon7, _livechatProps$contro9, _livechatProps$contro10, _livechatProps$compon8, _livechatProps$contro11, _livechatProps$compon9, _livechatProps$contro12, _livechatProps$compon10, _livechatProps$compon11, _livechatProps$compon12;
  const [state, dispatch] = useChatContextStore();
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const [adapter, setAdapter] = useChatAdapterStore();
  const [webChatStyles, setWebChatStyles] = useState({
    ...defaultWebChatContainerStatefulProps.webChatStyles,
    ...((_props$webChatContain = props.webChatContainerProps) === null || _props$webChatContain === void 0 ? void 0 : _props$webChatContain.webChatStyles)
  });
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const chatSDK = useChatSDKStore();
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const [voiceVideoCallingSDK, setVoiceVideoCallingSDK] = useState(undefined);
  const {
    Composer
  } = Components;
  const canStartProactiveChat = useRef(true);

  // Process general styles
  const generalStyles = {
    root: Object.assign({}, getGeneralStylesForButton(state), (_props$styleProps = props.styleProps) === null || _props$styleProps === void 0 ? void 0 : _props$styleProps.generalStyles)
  };

  //Scrollbar styles
  const scrollbarProps = Object.assign({}, defaultScrollBarProps, props === null || props === void 0 ? void 0 : props.scrollBarProps);
  const broadcastServiceChannelName = getBroadcastChannelName(chatSDK === null || chatSDK === void 0 ? void 0 : (_chatSDK$omnichannelC = chatSDK.omnichannelConfig) === null || _chatSDK$omnichannelC === void 0 ? void 0 : _chatSDK$omnichannelC.widgetId, ((_props$controlProps = props.controlProps) === null || _props$controlProps === void 0 ? void 0 : _props$controlProps.widgetInstanceId) ?? "");
  BroadcastServiceInitialize(broadcastServiceChannelName);
  TelemetryTimers.LcwLoadToChatButtonTimer = createTimer();
  const widgetElementId = ((_props$controlProps2 = props.controlProps) === null || _props$controlProps2 === void 0 ? void 0 : _props$controlProps2.id) || "oc-lcw";
  const currentMessageCountRef = useRef(0);
  let widgetStateEventId = "";
  const lastLWICheckTimeRef = useRef(0);
  let optionalParams;
  let activeCachedChatExist = false;
  const uwid = useRef(""); // its an uniqueid per chatr instance

  const setOptionalParams = () => {
    var _state$appStates, _state$domainStates, _state$appStates3;
    if (!isUndefinedOrEmpty((_state$appStates = state.appStates) === null || _state$appStates === void 0 ? void 0 : _state$appStates.reconnectId)) {
      var _state$appStates2;
      activeCachedChatExist = true;
      optionalParams = {
        reconnectId: state === null || state === void 0 ? void 0 : (_state$appStates2 = state.appStates) === null || _state$appStates2 === void 0 ? void 0 : _state$appStates2.reconnectId
      };
    } else if (!isUndefinedOrEmpty(state === null || state === void 0 ? void 0 : (_state$domainStates = state.domainStates) === null || _state$domainStates === void 0 ? void 0 : _state$domainStates.liveChatContext) && (state === null || state === void 0 ? void 0 : (_state$appStates3 = state.appStates) === null || _state$appStates3 === void 0 ? void 0 : _state$appStates3.conversationState) === ConversationState.Active) {
      var _state$domainStates2;
      activeCachedChatExist = true;
      optionalParams = {
        liveChatContext: state === null || state === void 0 ? void 0 : (_state$domainStates2 = state.domainStates) === null || _state$domainStates2 === void 0 ? void 0 : _state$domainStates2.liveChatContext
      };
    } else {
      activeCachedChatExist = false;
      optionalParams = {};
    }
  };

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const startChat = async (props, localState) => {
    const isReconnectTriggered = async () => {
      if (isReconnectEnabled(props.chatConfig) === true && !isPersistentEnabled(props.chatConfig)) {
        const noValidReconnectId = await handleChatReconnect(chatSDK, props, dispatch, setAdapter, initStartChat, state);
        // If chat reconnect has kicked in chat state will become Active or Reconnect. So just exit, else go next
        if (!noValidReconnectId && (state.appStates.conversationState === ConversationState.Active || state.appStates.conversationState === ConversationState.ReconnectChat)) {
          return true;
        }
      }
      return false;
    };
    let isChatValid = false;
    //Start a chat from cache/reconnectid
    if (activeCachedChatExist === true) {
      dispatch({
        type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
        payload: ConversationState.Loading
      });
      if (localState) {
        localState.appStates.conversationState = ConversationState.Loading;
      }

      //Check if conversation state is not in wrapup or closed state
      isChatValid = await checkIfConversationStillValid(chatSDK, dispatch, state);
      if (isChatValid === true) {
        const reconnectTriggered = await isReconnectTriggered();
        if (!reconnectTriggered) {
          await initStartChat(chatSDK, dispatch, setAdapter, state, props, optionalParams);
        }
        return;
      }
    }
    if (isChatValid === false) {
      if (localState) {
        // adding the reconnect logic for the case when customer tries to reconnect from a new browser or InPrivate browser
        const reconnectTriggered = await isReconnectTriggered();
        if (!reconnectTriggered) {
          await setPreChatAndInitiateChat(chatSDK, dispatch, setAdapter, undefined, undefined, localState, props);
        }
        return;
      } else {
        var _state$appStates4;
        // To avoid showing blank screen in popout
        if ((state === null || state === void 0 ? void 0 : (_state$appStates4 = state.appStates) === null || _state$appStates4 === void 0 ? void 0 : _state$appStates4.hideStartChatButton) === false) {
          dispatch({
            type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
            payload: ConversationState.Closed
          });
          return;
        }
        dispatch({
          type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
          payload: ConversationState.Loading
        });
      }
    }
  };

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const setupClientDataStore = () => {
    // Add default localStorage support for widget
    const widgetCacheId = getWidgetCacheIdfromProps(props);
    if (props.contextDataStore === undefined) {
      var _props$controlProps3;
      const cacheTtlInMins = (props === null || props === void 0 ? void 0 : (_props$controlProps3 = props.controlProps) === null || _props$controlProps3 === void 0 ? void 0 : _props$controlProps3.cacheTtlInMins) ?? Constants.CacheTtlInMinutes;
      const storageType = (props === null || props === void 0 ? void 0 : props.useSessionStorage) === true ? StorageType.sessionStorage : StorageType.localStorage;
      DataStoreManager.clientDataStore = defaultClientDataStoreProvider(cacheTtlInMins, storageType);
      registerBroadcastServiceForStorage(widgetCacheId, cacheTtlInMins, storageType);
    } else {
      DataStoreManager.clientDataStore = props.contextDataStore;
    }
  };
  useEffect(() => {
    var _props$controlProps4, _props$controlProps5, _props$controlProps6, _props$chatConfig, _props$chatConfig$Liv, _props$controlProps8, _props$chatConfig2, _props$chatConfig2$Ch, _state$appStates5;
    state.domainStates.confirmationPaneConfirmedOptionClicked = false;
    state.domainStates.confirmationState = ConfirmationState.NotSet;
    setupClientDataStore();
    registerTelemetryLoggers(props, dispatch);
    createInternetConnectionChangeHandler();
    uwid.current = newGuid();
    dispatch({
      type: LiveChatWidgetActionType.SET_WIDGET_ELEMENT_ID,
      payload: widgetElementId
    });
    dispatch({
      type: LiveChatWidgetActionType.SET_START_CHAT_BUTTON_DISPLAY,
      payload: ((_props$controlProps4 = props.controlProps) === null || _props$controlProps4 === void 0 ? void 0 : _props$controlProps4.hideStartChatButton) || false
    });
    dispatch({
      type: LiveChatWidgetActionType.SET_E2VV_ENABLED,
      payload: false
    });
    if ((_props$controlProps5 = props.controlProps) !== null && _props$controlProps5 !== void 0 && _props$controlProps5.widgetInstanceId && !isNullOrEmptyString((_props$controlProps6 = props.controlProps) === null || _props$controlProps6 === void 0 ? void 0 : _props$controlProps6.widgetInstanceId)) {
      var _props$controlProps7;
      dispatch({
        type: LiveChatWidgetActionType.SET_WIDGET_INSTANCE_ID,
        payload: (_props$controlProps7 = props.controlProps) === null || _props$controlProps7 === void 0 ? void 0 : _props$controlProps7.widgetInstanceId
      });
    }
    if (((_props$chatConfig = props.chatConfig) === null || _props$chatConfig === void 0 ? void 0 : (_props$chatConfig$Liv = _props$chatConfig.LiveWSAndLiveChatEngJoin) === null || _props$chatConfig$Liv === void 0 ? void 0 : _props$chatConfig$Liv.msdyn_callingoptions) !== E2VVOptions.NoCalling) {
      initCallingSdk(chatSDK, setVoiceVideoCallingSDK).then(sdkCreated => {
        sdkCreated && dispatch({
          type: LiveChatWidgetActionType.SET_E2VV_ENABLED,
          payload: true
        });
      });
    }
    if (props.initialCustomContext) {
      dispatch({
        type: LiveChatWidgetActionType.SET_CUSTOM_CONTEXT,
        payload: props.initialCustomContext
      });
    }

    // Initialize global dir
    const globalDir = ((_props$controlProps8 = props.controlProps) === null || _props$controlProps8 === void 0 ? void 0 : _props$controlProps8.dir) ?? getLocaleDirection((_props$chatConfig2 = props.chatConfig) === null || _props$chatConfig2 === void 0 ? void 0 : (_props$chatConfig2$Ch = _props$chatConfig2.ChatWidgetLanguage) === null || _props$chatConfig2$Ch === void 0 ? void 0 : _props$chatConfig2$Ch.msdyn_localeid);
    dispatch({
      type: LiveChatWidgetActionType.SET_GLOBAL_DIR,
      payload: globalDir
    });
    setOptionalParams();

    // Unauth chat
    if ((state === null || state === void 0 ? void 0 : (_state$appStates5 = state.appStates) === null || _state$appStates5 === void 0 ? void 0 : _state$appStates5.hideStartChatButton) === false) {
      startChat(props);
    }
  }, []);

  // useEffect for when skip chat button rendering
  useEffect(() => {
    var _state$appStates6;
    if ((state === null || state === void 0 ? void 0 : (_state$appStates6 = state.appStates) === null || _state$appStates6 === void 0 ? void 0 : _state$appStates6.hideStartChatButton) === true) {
      var _props$chatConfig3, _props$chatConfig3$Li;
      //handle OOH pane
      if ((props === null || props === void 0 ? void 0 : (_props$chatConfig3 = props.chatConfig) === null || _props$chatConfig3 === void 0 ? void 0 : (_props$chatConfig3$Li = _props$chatConfig3.LiveWSAndLiveChatEngJoin) === null || _props$chatConfig3$Li === void 0 ? void 0 : _props$chatConfig3$Li.OutOfOperatingHours.toLowerCase()) === "true") {
        dispatch({
          type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
          payload: ConversationState.OutOfOffice
        });
        return;
      }
      BroadcastService.postMessage({
        eventName: BroadcastEvent.ChatInitiated
      });
      //Pass the state to avoid getting stale state
      startChat(props, state);
    }
  }, [state === null || state === void 0 ? void 0 : (_state$appStates7 = state.appStates) === null || _state$appStates7 === void 0 ? void 0 : _state$appStates7.hideStartChatButton]);

  // useEffect for custom context
  useEffect(() => {
    var _chatSDK$omnichannelC2, _chatSDK$omnichannelC3, _props$controlProps10;
    // Add the custom context on receiving the SetCustomContext event
    BroadcastService.getMessageByEventName(BroadcastEvent.SetCustomContext).subscribe(msg => {
      TelemetryHelper.logActionEvent(LogLevel.INFO, {
        Event: TelemetryEvent.CustomContextReceived,
        Description: "CustomContext received."
      });
      dispatch({
        type: LiveChatWidgetActionType.SET_CUSTOM_CONTEXT,
        payload: msg === null || msg === void 0 ? void 0 : msg.payload
      });
    });
    BroadcastService.getMessageByEventName(BroadcastEvent.StartProactiveChat).subscribe(msg => {
      TelemetryHelper.logActionEvent(LogLevel.INFO, {
        Event: TelemetryEvent.StartProactiveChatEventReceived,
        Description: "Start proactive chat event received."
      });
      if (canStartProactiveChat.current === true) {
        var _msg$payload, _msg$payload2, _msg$payload3;
        startProactiveChat(dispatch, msg === null || msg === void 0 ? void 0 : (_msg$payload = msg.payload) === null || _msg$payload === void 0 ? void 0 : _msg$payload.notificationConfig, msg === null || msg === void 0 ? void 0 : (_msg$payload2 = msg.payload) === null || _msg$payload2 === void 0 ? void 0 : _msg$payload2.enablePreChat, msg === null || msg === void 0 ? void 0 : (_msg$payload3 = msg.payload) === null || _msg$payload3 === void 0 ? void 0 : _msg$payload3.inNewWindow);
      } else {
        TelemetryHelper.logActionEvent(LogLevel.INFO, {
          Event: TelemetryEvent.ChatAlreadyTriggered,
          Description: "Start proactive chat method called, when chat was already triggered."
        });
      }
    });

    // Toggle chat visibility
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    BroadcastService.getMessageByEventName(BroadcastEvent.HideChatVisibilityChangeEvent).subscribe(async event => {
      var _event$payload;
      if ((event === null || event === void 0 ? void 0 : (_event$payload = event.payload) === null || _event$payload === void 0 ? void 0 : _event$payload.isChatHidden) !== undefined) {
        var _props$controlProps9;
        if ((_props$controlProps9 = props.controlProps) !== null && _props$controlProps9 !== void 0 && _props$controlProps9.hideStartChatButton) {
          var _event$payload2;
          dispatch({
            type: LiveChatWidgetActionType.SET_MINIMIZED,
            payload: event === null || event === void 0 ? void 0 : (_event$payload2 = event.payload) === null || _event$payload2 === void 0 ? void 0 : _event$payload2.isChatHidden
          });
        }
        const dateNow = Date.now();
        if (dateNow - lastLWICheckTimeRef.current > Constants.LWICheckOnVisibilityTimeout) {
          const conversationDetails = await getConversationDetailsCall(chatSDK);
          lastLWICheckTimeRef.current = dateNow;
          if ((conversationDetails === null || conversationDetails === void 0 ? void 0 : conversationDetails.state) === LiveWorkItemState.WrapUp || (conversationDetails === null || conversationDetails === void 0 ? void 0 : conversationDetails.state) === LiveWorkItemState.Closed) {
            dispatch({
              type: LiveChatWidgetActionType.SET_CHAT_DISCONNECT_EVENT_RECEIVED,
              payload: true
            });
            TelemetryHelper.logActionEvent(LogLevel.INFO, {
              Event: TelemetryEvent.ChatDisconnectThreadEventReceived,
              Description: "Chat disconnected due to timeout, left or removed."
            });
          }
        }
      }
    });

    // Start chat from SDK Event
    BroadcastService.getMessageByEventName(BroadcastEvent.StartChat).subscribe(() => {
      TelemetryHelper.logActionEvent(LogLevel.INFO, {
        Event: TelemetryEvent.StartChatEventRecevied,
        Description: "Start chat event received."
      });

      // DataStoreManager.clientDataStore?.swtichToSessionStorage(true);
      const persistedState = getStateFromCache(getWidgetCacheIdfromProps(props));

      // Chat not found in cache - scenario: explicitly clearing cache and calling startChat SDK method
      if (persistedState === undefined) {
        BroadcastService.postMessage({
          eventName: BroadcastEvent.ChatInitiated
        });
        prepareStartChat(props, chatSDK, state, dispatch, setAdapter);
        return;
      }

      // Chat exist in cache
      if (persistedState) {
        var _persistedState$appSt, _persistedState$appSt2, _persistedState$appSt3, _persistedState$appSt4;
        // Only initiate new chat if widget state in cache in one of the followings
        if (((_persistedState$appSt = persistedState.appStates) === null || _persistedState$appSt === void 0 ? void 0 : _persistedState$appSt.conversationState) === ConversationState.Closed || ((_persistedState$appSt2 = persistedState.appStates) === null || _persistedState$appSt2 === void 0 ? void 0 : _persistedState$appSt2.conversationState) === ConversationState.InActive || ((_persistedState$appSt3 = persistedState.appStates) === null || _persistedState$appSt3 === void 0 ? void 0 : _persistedState$appSt3.conversationState) === ConversationState.Postchat) {
          BroadcastService.postMessage({
            eventName: BroadcastEvent.ChatInitiated
          });
          prepareStartChat(props, chatSDK, state, dispatch, setAdapter);
          return;
        }

        // If minimized, maximize the chat
        if ((persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$appSt4 = persistedState.appStates) === null || _persistedState$appSt4 === void 0 ? void 0 : _persistedState$appSt4.isMinimized) === true) {
          var _persistedState$domai, _persistedState$domai2, _persistedState$domai3, _persistedState$domai4;
          dispatch({
            type: LiveChatWidgetActionType.SET_MINIMIZED,
            payload: false
          });
          BroadcastService.postMessage({
            eventName: BroadcastEvent.MaximizeChat,
            payload: {
              height: persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai = persistedState.domainStates) === null || _persistedState$domai === void 0 ? void 0 : (_persistedState$domai2 = _persistedState$domai.widgetSize) === null || _persistedState$domai2 === void 0 ? void 0 : _persistedState$domai2.height,
              width: persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai3 = persistedState.domainStates) === null || _persistedState$domai3 === void 0 ? void 0 : (_persistedState$domai4 = _persistedState$domai3.widgetSize) === null || _persistedState$domai4 === void 0 ? void 0 : _persistedState$domai4.width
            }
          });
        }
      }
    });

    // End chat
    BroadcastService.getMessageByEventName(BroadcastEvent.InitiateEndChat).subscribe(async () => {
      // This is to ensure to get latest state from cache in multitab
      const persistedState = getStateFromCache(getWidgetCacheIdfromProps(props));
      if (persistedState && persistedState.appStates.conversationState === ConversationState.Active) {
        dispatch({
          type: LiveChatWidgetActionType.SET_CONVERSATION_ENDED_BY,
          payload: ConversationEndEntity.Customer
        });
      } else {
        const skipEndChatSDK = true;
        const skipCloseChat = false;
        endChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, skipEndChatSDK, skipCloseChat);
      }
      BroadcastService.postMessage({
        eventName: BroadcastEvent.CloseChat
      });
    });

    // End chat on browser unload
    BroadcastService.getMessageByEventName(BroadcastEvent.InitiateEndChatOnBrowserUnload).subscribe(() => {
      initiateEndChatOnBrowserUnload();
    });

    // Listen to end chat event from other tabs
    const endChatEventName = getWidgetEndChatEventName(chatSDK === null || chatSDK === void 0 ? void 0 : (_chatSDK$omnichannelC2 = chatSDK.omnichannelConfig) === null || _chatSDK$omnichannelC2 === void 0 ? void 0 : _chatSDK$omnichannelC2.orgId, chatSDK === null || chatSDK === void 0 ? void 0 : (_chatSDK$omnichannelC3 = chatSDK.omnichannelConfig) === null || _chatSDK$omnichannelC3 === void 0 ? void 0 : _chatSDK$omnichannelC3.widgetId, ((_props$controlProps10 = props.controlProps) === null || _props$controlProps10 === void 0 ? void 0 : _props$controlProps10.widgetInstanceId) ?? "");
    BroadcastService.getMessageByEventName(endChatEventName).subscribe(msg => {
      console.log("Receiving end chat event", JSON.stringify(msg.payload));
      if (msg.payload !== uwid.current) {
        endChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, true, false, false);
        return;
      }
    });

    //Listen to WidgetSize, used for minimize to maximize
    BroadcastService.getMessageByEventName("WidgetSize").subscribe(msg => {
      dispatch({
        type: LiveChatWidgetActionType.SET_WIDGET_SIZE,
        payload: msg === null || msg === void 0 ? void 0 : msg.payload
      });
    });

    // Reset state variables
    BroadcastService.getMessageByEventName(BroadcastEvent.RaiseErrorEvent).subscribe(() => {
      dispatch({
        type: LiveChatWidgetActionType.SET_LIVE_CHAT_CONFIG,
        payload: undefined
      });
      dispatch({
        type: LiveChatWidgetActionType.SET_CUSTOM_CONTEXT,
        payload: undefined
      });
      dispatch({
        type: LiveChatWidgetActionType.SET_CHAT_TOKEN,
        payload: undefined
      });
      dispatch({
        type: LiveChatWidgetActionType.SET_LIVE_CHAT_CONTEXT,
        payload: undefined
      });
    });

    // Check for TPC and log in telemetry if blocked
    isCookieAllowed();
    return () => {
      disposeTelemetryLoggers();
    };
  }, []);
  useEffect(() => {
    // On new message
    if (state.appStates.conversationState === ConversationState.Active) {
      chatSDK === null || chatSDK === void 0 ? void 0 : chatSDK.onNewMessage(() => {
        // Track the message count
        currentMessageCountRef.current++;
        dispatch({
          type: LiveChatWidgetActionType.SET_UNREAD_MESSAGE_COUNT,
          payload: currentMessageCountRef.current + 1
        });

        // New message notification
        BroadcastService.postMessage({
          eventName: BroadcastEvent.NewMessageNotification
        });
      });
    }
    if (state.appStates.conversationState === ConversationState.InActive) {
      var _props$webChatContain2, _props$webChatContain3;
      if ((props === null || props === void 0 ? void 0 : (_props$webChatContain2 = props.webChatContainerProps) === null || _props$webChatContain2 === void 0 ? void 0 : (_props$webChatContain3 = _props$webChatContain2.renderingMiddlewareProps) === null || _props$webChatContain3 === void 0 ? void 0 : _props$webChatContain3.hideSendboxOnConversationEnd) !== false) {
        setWebChatStyles(styles => {
          return {
            ...styles,
            hideSendBox: true
          };
        });
      }
    }
  }, [state.appStates.conversationState]);
  useEffect(() => {
    canStartProactiveChat.current = state.appStates.conversationState === ConversationState.Closed && !state.appStates.proactiveChatStates.proactiveChatInNewWindow;
  }, [state.appStates.conversationState, state.appStates.proactiveChatStates.proactiveChatInNewWindow]);

  // Reset the UnreadMessageCount when minimized is toggled and broadcast it.
  useEffect(() => {
    if (state.appStates.isMinimized) {
      ActivityStreamHandler.cork();
    } else {
      setTimeout(() => ActivityStreamHandler.uncork(), 500);
    }
    currentMessageCountRef.current = -1;
    dispatch({
      type: LiveChatWidgetActionType.SET_UNREAD_MESSAGE_COUNT,
      payload: 0
    });
    const customEvent = {
      elementType: ElementType.Custom,
      eventName: BroadcastEvent.UnreadMessageCount,
      payload: 0
    };
    BroadcastService.postMessage(customEvent);
  }, [state.appStates.isMinimized]);

  // Broadcast the UnreadMessageCount state on any change.
  useEffect(() => {
    if (state.appStates.isMinimized === true && state.appStates.unreadMessageCount > 0) {
      const customEvent = {
        elementType: ElementType.Custom,
        eventName: BroadcastEvent.UnreadMessageCount,
        payload: `${state.appStates.unreadMessageCount}`
      };
      BroadcastService.postMessage(customEvent);
    }
  }, [state.appStates.unreadMessageCount]);
  useEffect(() => {
    var _props$webChatContain4;
    setWebChatStyles({
      ...webChatStyles,
      ...((_props$webChatContain4 = props.webChatContainerProps) === null || _props$webChatContain4 === void 0 ? void 0 : _props$webChatContain4.webChatStyles)
    });
  }, [(_props$webChatContain5 = props.webChatContainerProps) === null || _props$webChatContain5 === void 0 ? void 0 : _props$webChatContain5.webChatStyles]);
  useEffect(() => {
    //Confirmation pane dismissing through OK option, so proceed with end chat
    if (state.domainStates.confirmationState === ConfirmationState.Ok) {
      dispatch({
        type: LiveChatWidgetActionType.SET_CONVERSATION_ENDED_BY,
        payload: ConversationEndEntity.Customer
      });
    }
  }, [state.domainStates.confirmationState]);
  useEffect(() => {
    var _state$appStates8, _state$appStates9, _state$appStates10, _state$appStates11, _state$appStates12, _state$appStates13;
    // Do not process anything during initialization
    if ((state === null || state === void 0 ? void 0 : (_state$appStates8 = state.appStates) === null || _state$appStates8 === void 0 ? void 0 : _state$appStates8.conversationEndedBy) === ConversationEndEntity.NotSet) {
      return;
    }

    // If start chat failed, and C2 is trying to close chat widget
    if (state !== null && state !== void 0 && (_state$appStates9 = state.appStates) !== null && _state$appStates9 !== void 0 && _state$appStates9.startChatFailed || (state === null || state === void 0 ? void 0 : (_state$appStates10 = state.appStates) === null || _state$appStates10 === void 0 ? void 0 : _state$appStates10.conversationState) === ConversationState.Postchat) {
      endChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, true, false, true, uwid.current);
      return;
    }

    // Scenario -> Chat was InActive and closing the chat (Refresh scenario on post chat)
    if ((state === null || state === void 0 ? void 0 : (_state$appStates11 = state.appStates) === null || _state$appStates11 === void 0 ? void 0 : _state$appStates11.conversationState) === ConversationState.InActive) {
      endChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, false, false, true, uwid.current);
      return;
    }
    if ((state === null || state === void 0 ? void 0 : (_state$appStates12 = state.appStates) === null || _state$appStates12 === void 0 ? void 0 : _state$appStates12.conversationEndedBy) === ConversationEndEntity.Agent || (state === null || state === void 0 ? void 0 : (_state$appStates13 = state.appStates) === null || _state$appStates13 === void 0 ? void 0 : _state$appStates13.conversationEndedBy) === ConversationEndEntity.Bot) {
      dispatch({
        type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
        payload: ConversationState.InActive
      });
    }

    // All other cases
    prepareEndChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, uwid.current);
  }, [state === null || state === void 0 ? void 0 : (_state$appStates14 = state.appStates) === null || _state$appStates14 === void 0 ? void 0 : _state$appStates14.conversationEndedBy]);

  // Publish chat widget state
  useEffect(() => {
    // Only activate these windows events when conversation state is active and chat widget is in popout mode
    // Ghost chat scenarios
    /* COMMENTING THIS CODE FOR PARITY WITH OLD LCW
    if (state.appStates.conversationState === ConversationState.Active &&
        props.controlProps?.hideStartChatButton === true) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
          window.onbeforeunload = function () {
            const prompt = Constants.BrowserUnloadConfirmationMessage;
            return prompt;
        };
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        window.onunload = function () {
            initiateEndChatOnBrowserUnload();
        };
    }*/

    widgetStateEventId = getWidgetCacheIdfromProps(props);
    const chatWidgetStateChangeEvent = {
      eventName: widgetStateEventId,
      payload: {
        ...state
      }
    };
    BroadcastService.postMessage(chatWidgetStateChangeEvent);
  }, [state]);

  // Handle Chat disconnect cases
  useEffect(() => {
    if (state.appStates.chatDisconnectEventReceived) {
      handleChatDisconnect(props, state, setWebChatStyles);
    }
  }, [state.appStates.chatDisconnectEventReceived]);
  const initiateEndChatOnBrowserUnload = () => {
    var _DataStoreManager$cli;
    TelemetryHelper.logActionEvent(LogLevel.INFO, {
      Event: TelemetryEvent.BrowserUnloadEventStarted,
      Description: "Browser unload event received."
    });
    endChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, false, false, false);
    // Clean local storage
    (_DataStoreManager$cli = DataStoreManager.clientDataStore) === null || _DataStoreManager$cli === void 0 ? void 0 : _DataStoreManager$cli.removeData(widgetStateEventId);

    //Dispose calling instance
    if (voiceVideoCallingSDK) {
      voiceVideoCallingSDK === null || voiceVideoCallingSDK === void 0 ? void 0 : voiceVideoCallingSDK.close();
    }
    //Message for clearing window[popouTab]
    BroadcastService.postMessage({
      eventName: BroadcastEvent.ClosePopoutWindow
    });
  };
  const webChatProps = initWebChatComposer(props, state, dispatch, chatSDK);
  const setPostChatContextRelay = () => setPostChatContextAndLoadSurvey(chatSDK, dispatch);
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const endChatRelay = (adapter, skipEndChatSDK, skipCloseChat, postMessageToOtherTab) => endChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, skipEndChatSDK, skipCloseChat, postMessageToOtherTab, uwid.current);
  const prepareStartChatRelay = () => prepareStartChat(props, chatSDK, state, dispatch, setAdapter);
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const initStartChatRelay = (optionalParams, persistedState) => initStartChat(chatSDK, dispatch, setAdapter, state, props, optionalParams, persistedState);
  const confirmationPaneProps = initConfirmationPropsComposer(props);
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const prepareEndChatRelay = () => prepareEndChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, uwid.current);
  const downloadTranscriptProps = createDownloadTranscriptProps(props.downloadTranscriptProps, {
    ...(defaultWebChatContainerStatefulProps === null || defaultWebChatContainerStatefulProps === void 0 ? void 0 : defaultWebChatContainerStatefulProps.webChatStyles),
    ...((_props$webChatContain6 = props.webChatContainerProps) === null || _props$webChatContain6 === void 0 ? void 0 : _props$webChatContain6.webChatStyles)
  }, props.webChatContainerProps);
  const livechatProps = {
    ...props,
    downloadTranscriptProps
  };
  const chatWidgetDraggableConfig = {
    elementId: widgetElementId,
    channel: ((_props$controlProps11 = props.controlProps) === null || _props$controlProps11 === void 0 ? void 0 : _props$controlProps11.widgetInstanceId) ?? "lcw",
    disabled: ((_props$draggableChatW = props.draggableChatWidgetProps) === null || _props$draggableChatW === void 0 ? void 0 : _props$draggableChatW.disabled) === true ?? false // Draggable by default, unless explicitly disabled
  };

  // Disable receiving IDraggableEvent in current window
  if (((_props$draggableChatW2 = props.draggableChatWidgetProps) === null || _props$draggableChatW2 === void 0 ? void 0 : _props$draggableChatW2.disabled) === false && (_props$draggableChatW3 = props.draggableChatWidgetProps) !== null && _props$draggableChatW3 !== void 0 && _props$draggableChatW3.targetIframe) {
    chatWidgetDraggableConfig.disabled = true;
  }
  const headerDraggableConfig = {
    draggableEventChannel: chatWidgetDraggableConfig.channel ?? "lcw",
    draggableEventEmitterTargetWindow: (_props$draggableChatW4 = props.draggableChatWidgetProps) !== null && _props$draggableChatW4 !== void 0 && _props$draggableChatW4.targetIframe ? window.parent : window,
    draggable: ((_props$draggableChatW5 = props.draggableChatWidgetProps) === null || _props$draggableChatW5 === void 0 ? void 0 : _props$draggableChatW5.disabled) !== true // Draggable by default, unless explicitly disabled
  };

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("style", null, `
            ::-webkit-scrollbar {
                width: ${scrollbarProps.width};
            }

            ::-webkit-scrollbar-track {
                background: ${scrollbarProps.trackBackgroundColor};
            }

            ::-webkit-scrollbar-thumb {
                background: ${scrollbarProps.thumbBackgroundColor};
                border-radius: ${scrollbarProps.thumbBorderRadius};
            }

            ::-webkit-scrollbar-thumb:hover {
                background: ${scrollbarProps.thumbHoverColor};
            }
            `), /*#__PURE__*/React.createElement(DraggableChatWidget, chatWidgetDraggableConfig, /*#__PURE__*/React.createElement(Composer, _extends({}, webChatProps, {
    styleOptions: webChatStyles,
    directLine: ((_livechatProps$webCha = livechatProps.webChatContainerProps) === null || _livechatProps$webCha === void 0 ? void 0 : _livechatProps$webCha.directLine) ?? adapter ?? defaultWebChatContainerStatefulProps.directLine
  }), /*#__PURE__*/React.createElement(Stack, {
    id: widgetElementId,
    styles: generalStyles,
    className: (_livechatProps$styleP = livechatProps.styleProps) === null || _livechatProps$styleP === void 0 ? void 0 : _livechatProps$styleP.className
  }, !((_livechatProps$contro = livechatProps.controlProps) !== null && _livechatProps$contro !== void 0 && _livechatProps$contro.hideChatButton) && !((_livechatProps$contro2 = livechatProps.controlProps) !== null && _livechatProps$contro2 !== void 0 && _livechatProps$contro2.hideStartChatButton) && shouldShowChatButton(state) && (decodeComponentString((_livechatProps$compon = livechatProps.componentOverrides) === null || _livechatProps$compon === void 0 ? void 0 : _livechatProps$compon.chatButton) || /*#__PURE__*/React.createElement(ChatButtonStateful, {
    buttonProps: livechatProps.chatButtonProps,
    outOfOfficeButtonProps: livechatProps.outOfOfficeChatButtonProps,
    startChat: prepareStartChatRelay
  })), !((_livechatProps$contro3 = livechatProps.controlProps) !== null && _livechatProps$contro3 !== void 0 && _livechatProps$contro3.hideProactiveChatPane) && shouldShowProactiveChatPane(state) && (decodeComponentString((_livechatProps$compon2 = livechatProps.componentOverrides) === null || _livechatProps$compon2 === void 0 ? void 0 : _livechatProps$compon2.proactiveChatPane) || /*#__PURE__*/React.createElement(ProactiveChatPaneStateful, {
    proactiveChatProps: livechatProps.proactiveChatPaneProps,
    startChat: prepareStartChatRelay
  })), !((_livechatProps$contro4 = livechatProps.controlProps) !== null && _livechatProps$contro4 !== void 0 && _livechatProps$contro4.hideHeader) && shouldShowHeader(state) && (decodeComponentString((_livechatProps$compon3 = livechatProps.componentOverrides) === null || _livechatProps$compon3 === void 0 ? void 0 : _livechatProps$compon3.header) || /*#__PURE__*/React.createElement(HeaderStateful, _extends({
    headerProps: livechatProps.headerProps,
    outOfOfficeHeaderProps: livechatProps.outOfOfficeHeaderProps,
    endChat: endChatRelay
  }, headerDraggableConfig))), !((_livechatProps$contro5 = livechatProps.controlProps) !== null && _livechatProps$contro5 !== void 0 && _livechatProps$contro5.hideLoadingPane) && shouldShowLoadingPane(state) && (decodeComponentString((_livechatProps$compon4 = livechatProps.componentOverrides) === null || _livechatProps$compon4 === void 0 ? void 0 : _livechatProps$compon4.loadingPane) || /*#__PURE__*/React.createElement(LoadingPaneStateful, {
    loadingPaneProps: livechatProps.loadingPaneProps,
    startChatErrorPaneProps: livechatProps.startChatErrorPaneProps
  })), !((_livechatProps$contro6 = livechatProps.controlProps) !== null && _livechatProps$contro6 !== void 0 && _livechatProps$contro6.hideOutOfOfficeHoursPane) && shouldShowOutOfOfficeHoursPane(state) && (decodeComponentString((_livechatProps$compon5 = livechatProps.componentOverrides) === null || _livechatProps$compon5 === void 0 ? void 0 : _livechatProps$compon5.outOfOfficeHoursPane) || /*#__PURE__*/React.createElement(OutOfOfficeHoursPaneStateful, livechatProps.outOfOfficeHoursPaneProps)), !((_livechatProps$contro7 = livechatProps.controlProps) !== null && _livechatProps$contro7 !== void 0 && _livechatProps$contro7.hideReconnectChatPane) && shouldShowReconnectChatPane(state) && (decodeComponentString((_livechatProps$compon6 = livechatProps.componentOverrides) === null || _livechatProps$compon6 === void 0 ? void 0 : _livechatProps$compon6.reconnectChatPane) || /*#__PURE__*/React.createElement(ReconnectChatPaneStateful, {
    reconnectChatProps: livechatProps.reconnectChatPaneProps,
    initStartChat: initStartChatRelay
  })), !((_livechatProps$contro8 = livechatProps.controlProps) !== null && _livechatProps$contro8 !== void 0 && _livechatProps$contro8.hidePreChatSurveyPane) && shouldShowPreChatSurveyPane(state) && (decodeComponentString((_livechatProps$compon7 = livechatProps.componentOverrides) === null || _livechatProps$compon7 === void 0 ? void 0 : _livechatProps$compon7.preChatSurveyPane) || /*#__PURE__*/React.createElement(PreChatSurveyPaneStateful, {
    surveyProps: livechatProps.preChatSurveyPaneProps,
    initStartChat: initStartChatRelay
  })), !((_livechatProps$contro9 = livechatProps.controlProps) !== null && _livechatProps$contro9 !== void 0 && _livechatProps$contro9.hideCallingContainer) && shouldShowCallingContainer(state) && /*#__PURE__*/React.createElement(CallingContainerStateful, _extends({
    voiceVideoCallingSdk: voiceVideoCallingSDK
  }, livechatProps.callingContainerProps)), !((_livechatProps$contro10 = livechatProps.controlProps) !== null && _livechatProps$contro10 !== void 0 && _livechatProps$contro10.hideWebChatContainer) && shouldShowWebChatContainer(state) && (decodeComponentString((_livechatProps$compon8 = livechatProps.componentOverrides) === null || _livechatProps$compon8 === void 0 ? void 0 : _livechatProps$compon8.webChatContainer) || /*#__PURE__*/React.createElement(WebChatContainerStateful, livechatProps)), !((_livechatProps$contro11 = livechatProps.controlProps) !== null && _livechatProps$contro11 !== void 0 && _livechatProps$contro11.hideConfirmationPane) && shouldShowConfirmationPane(state) && (decodeComponentString((_livechatProps$compon9 = livechatProps.componentOverrides) === null || _livechatProps$compon9 === void 0 ? void 0 : _livechatProps$compon9.confirmationPane) || /*#__PURE__*/React.createElement(ConfirmationPaneStateful, _extends({}, confirmationPaneProps, {
    setPostChatContext: setPostChatContextRelay,
    prepareEndChat: prepareEndChatRelay
  }))), !((_livechatProps$contro12 = livechatProps.controlProps) !== null && _livechatProps$contro12 !== void 0 && _livechatProps$contro12.hidePostChatLoadingPane) && shouldShowPostChatLoadingPane(state) && (decodeComponentString((_livechatProps$compon10 = livechatProps.componentOverrides) === null || _livechatProps$compon10 === void 0 ? void 0 : _livechatProps$compon10.postChatLoadingPane) || /*#__PURE__*/React.createElement(PostChatLoadingPaneStateful, livechatProps.postChatLoadingPaneProps)), shouldShowPostChatSurveyPane(state) && (decodeComponentString((_livechatProps$compon11 = livechatProps.componentOverrides) === null || _livechatProps$compon11 === void 0 ? void 0 : _livechatProps$compon11.postChatSurveyPane) || /*#__PURE__*/React.createElement(PostChatSurveyPaneStateful, _extends({}, livechatProps.postChatSurveyPaneProps, livechatProps.chatSDK))), createFooter(livechatProps, state), shouldShowEmailTranscriptPane(state) && (decodeComponentString((_livechatProps$compon12 = livechatProps.componentOverrides) === null || _livechatProps$compon12 === void 0 ? void 0 : _livechatProps$compon12.emailTranscriptPane) || /*#__PURE__*/React.createElement(EmailTranscriptPaneStateful, livechatProps.emailTranscriptPane))))));
};
export default LiveChatWidgetStateful;