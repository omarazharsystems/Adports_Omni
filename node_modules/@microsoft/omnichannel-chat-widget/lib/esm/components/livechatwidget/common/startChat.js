import { BroadcastEvent, LogLevel, TelemetryEvent } from "../../../common/telemetry/TelemetryConstants";
import { ChatSDKError, Constants, LiveWorkItemState } from "../../../common/Constants";
import { checkContactIdError, createTimer, getConversationDetailsCall, getStateFromCache, getWidgetCacheIdfromProps, isNullOrEmptyString, isUndefinedOrEmpty } from "../../../common/utils";
import { getAuthClientFunction, handleAuthentication } from "./authHelper";
import { ActivityStreamHandler } from "./ActivityStreamHandler";
import { BroadcastService } from "@microsoft/omnichannel-chat-components";
import { ConversationState } from "../../../contexts/common/ConversationState";
import { LiveChatWidgetActionType } from "../../../contexts/common/LiveChatWidgetActionType";
import { NotificationHandler } from "../../webchatcontainerstateful/webchatcontroller/notification/NotificationHandler";
import { NotificationScenarios } from "../../webchatcontainerstateful/webchatcontroller/enums/NotificationScenarios";
import { TelemetryHelper } from "../../../common/telemetry/TelemetryHelper";
import { TelemetryTimers } from "../../../common/telemetry/TelemetryManager";
import { createAdapter } from "./createAdapter";
import { createOnNewAdapterActivityHandler } from "../../../plugins/newMessageEventHandler";
import { handleChatReconnect } from "./reconnectChatHelper";
import { setPostChatContextAndLoadSurvey } from "./setPostChatContextAndLoadSurvey";
import { updateSessionDataForTelemetry } from "./updateSessionDataForTelemetry";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
let optionalParams = {};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let widgetInstanceId;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let popoutWidgetInstanceId;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const prepareStartChat = async (props, chatSDK, state, dispatch, setAdapter) => {
  optionalParams = {}; //Resetting to ensure no stale values
  widgetInstanceId = getWidgetCacheIdfromProps(props);

  // reconnect > chat from cache
  await handleChatReconnect(chatSDK, props, dispatch, setAdapter, initStartChat, state);
  // If chat reconnect has kicked in chat state will become Active or Reconnect. So just exit, else go next
  if (state.appStates.conversationState === ConversationState.Active || state.appStates.conversationState === ConversationState.ReconnectChat) {
    return;
  }

  // Check if there is any active popout chats in cache
  if (await canStartPopoutChat(props)) {
    return;
  }

  // Can connect to existing chat session
  if (await canConnectToExistingChat(props, chatSDK, state, dispatch, setAdapter)) {
    return;
  }

  // Setting Proactive chat settings
  const isProactiveChat = state.appStates.conversationState === ConversationState.ProactiveChat;
  const isPreChatEnabledInProactiveChat = state.appStates.proactiveChatStates.proactiveChatEnablePrechat;

  //Setting PreChat and intiate chat
  await setPreChatAndInitiateChat(chatSDK, dispatch, setAdapter, isProactiveChat, isPreChatEnabledInProactiveChat, undefined, props);
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const setPreChatAndInitiateChat = async (chatSDK, dispatch, setAdapter, isProactiveChat, proactiveChatEnablePrechatState, state, props) => {
  var _props$controlProps;
  //Handle reconnect scenario

  // Getting prechat Survey Context
  const parseToJson = false;
  const preChatSurveyResponse = await chatSDK.getPreChatSurvey(parseToJson);
  const showPrechat = isProactiveChat ? preChatSurveyResponse && proactiveChatEnablePrechatState : preChatSurveyResponse && !(props !== null && props !== void 0 && (_props$controlProps = props.controlProps) !== null && _props$controlProps !== void 0 && _props$controlProps.hidePreChatSurveyPane);
  if (showPrechat) {
    dispatch({
      type: LiveChatWidgetActionType.SET_PRE_CHAT_SURVEY_RESPONSE,
      payload: preChatSurveyResponse
    });
    dispatch({
      type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
      payload: ConversationState.Prechat
    });
    return;
  }

  //Initiate start chat
  dispatch({
    type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
    payload: ConversationState.Loading
  });
  const optionalParams = {
    isProactiveChat
  };
  await initStartChat(chatSDK, dispatch, setAdapter, state, props, optionalParams);
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const initStartChat = async (chatSDK, dispatch, setAdapter, state, props, params, persistedState) => {
  var _props$controlProps2;
  let isStartChatSuccessful = false;
  const chatConfig = props === null || props === void 0 ? void 0 : props.chatConfig;
  const getAuthToken = props === null || props === void 0 ? void 0 : props.getAuthToken;
  const hideErrorUIPane = props === null || props === void 0 ? void 0 : (_props$controlProps2 = props.controlProps) === null || _props$controlProps2 === void 0 ? void 0 : _props$controlProps2.hideErrorUIPane;
  try {
    var _newAdapter$activity$, _TelemetryTimers$Widg2;
    //Start widget load timer
    TelemetryTimers.WidgetLoadTimer = createTimer();
    TelemetryHelper.logLoadingEvent(LogLevel.INFO, {
      Event: TelemetryEvent.WidgetLoadStarted,
      Description: "Widget loading started"
    });
    const authClientFunction = getAuthClientFunction(chatConfig);
    if (getAuthToken && authClientFunction) {
      // set auth token to chat sdk before start chat
      const authSuccess = await handleAuthentication(chatSDK, chatConfig, getAuthToken);
      if (!authSuccess) {
        // Replacing with error ui
        throw new Error("Authentication was not successful");
      }
    }

    //Check if chat retrieved from cache
    if (persistedState || params !== null && params !== void 0 && params.liveChatContext) {
      var _persistedState$domai, _persistedState$domai2, _persistedState$domai3, _persistedState$domai4, _persistedState$domai5;
      BroadcastService.postMessage({
        eventName: BroadcastEvent.ChatRetrievedFromCache,
        payload: {
          chatId: persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai = persistedState.domainStates) === null || _persistedState$domai === void 0 ? void 0 : (_persistedState$domai2 = _persistedState$domai.liveChatContext) === null || _persistedState$domai2 === void 0 ? void 0 : (_persistedState$domai3 = _persistedState$domai2.chatToken) === null || _persistedState$domai3 === void 0 ? void 0 : _persistedState$domai3.chatId,
          requestId: persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai4 = persistedState.domainStates) === null || _persistedState$domai4 === void 0 ? void 0 : (_persistedState$domai5 = _persistedState$domai4.liveChatContext) === null || _persistedState$domai5 === void 0 ? void 0 : _persistedState$domai5.requestId
        }
      });
    }
    try {
      var _window$Microsoft, _window$Microsoft$Dyn, _window$Microsoft$Dyn2, _window$Microsoft$Dyn3;
      // Set custom context params
      await setCustomContextParams(state, props);
      const defaultOptionalParams = {
        sendDefaultInitContext: true,
        isProactiveChat: !!(params !== null && params !== void 0 && params.isProactiveChat),
        portalContactId: (_window$Microsoft = window.Microsoft) === null || _window$Microsoft === void 0 ? void 0 : (_window$Microsoft$Dyn = _window$Microsoft.Dynamic365) === null || _window$Microsoft$Dyn === void 0 ? void 0 : (_window$Microsoft$Dyn2 = _window$Microsoft$Dyn.Portal) === null || _window$Microsoft$Dyn2 === void 0 ? void 0 : (_window$Microsoft$Dyn3 = _window$Microsoft$Dyn2.User) === null || _window$Microsoft$Dyn3 === void 0 ? void 0 : _window$Microsoft$Dyn3.contactId
      };
      const startChatOptionalParams = Object.assign({}, params, optionalParams, defaultOptionalParams);
      await chatSDK.startChat(startChatOptionalParams);
      isStartChatSuccessful = true;
    } catch (error) {
      checkContactIdError(error);
      TelemetryHelper.logSDKEvent(LogLevel.ERROR, {
        Event: TelemetryEvent.StartChatMethodException,
        ExceptionDetails: {
          exception: `Failed to setup startChat: ${error}`
        }
      });
      isStartChatSuccessful = false;
      throw error;
    }

    // New adapter creation
    const newAdapter = await createAdapter(chatSDK);
    setAdapter(newAdapter);
    const chatToken = await chatSDK.getChatToken();
    dispatch({
      type: LiveChatWidgetActionType.SET_CHAT_TOKEN,
      payload: chatToken
    });
    newAdapter === null || newAdapter === void 0 ? void 0 : (_newAdapter$activity$ = newAdapter.activity$) === null || _newAdapter$activity$ === void 0 ? void 0 : _newAdapter$activity$.subscribe(createOnNewAdapterActivityHandler(chatToken === null || chatToken === void 0 ? void 0 : chatToken.chatId, chatToken === null || chatToken === void 0 ? void 0 : chatToken.visitorId));

    // Set app state to Active
    if (isStartChatSuccessful) {
      ActivityStreamHandler.uncork();
      // Update start chat failure app state if chat loads successfully
      dispatch({
        type: LiveChatWidgetActionType.SET_START_CHAT_FAILING,
        payload: false
      });
      dispatch({
        type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
        payload: ConversationState.Active
      });
    }
    if (persistedState) {
      var _TelemetryTimers$Widg;
      dispatch({
        type: LiveChatWidgetActionType.SET_WIDGET_STATE,
        payload: persistedState
      });
      TelemetryHelper.logLoadingEvent(LogLevel.INFO, {
        Event: TelemetryEvent.WidgetLoadComplete,
        Description: "Widget load complete. Persisted state retrieved",
        ElapsedTimeInMilliseconds: TelemetryTimers === null || TelemetryTimers === void 0 ? void 0 : (_TelemetryTimers$Widg = TelemetryTimers.WidgetLoadTimer) === null || _TelemetryTimers$Widg === void 0 ? void 0 : _TelemetryTimers$Widg.milliSecondsElapsed
      });
      await setPostChatContextAndLoadSurvey(chatSDK, dispatch, true);
      return;
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const liveChatContext = await (chatSDK === null || chatSDK === void 0 ? void 0 : chatSDK.getCurrentLiveChatContext());
    dispatch({
      type: LiveChatWidgetActionType.SET_LIVE_CHAT_CONTEXT,
      payload: liveChatContext
    });
    TelemetryHelper.logLoadingEvent(LogLevel.INFO, {
      Event: TelemetryEvent.WidgetLoadComplete,
      Description: "Widget load complete",
      ElapsedTimeInMilliseconds: TelemetryTimers === null || TelemetryTimers === void 0 ? void 0 : (_TelemetryTimers$Widg2 = TelemetryTimers.WidgetLoadTimer) === null || _TelemetryTimers$Widg2 === void 0 ? void 0 : _TelemetryTimers$Widg2.milliSecondsElapsed
    });

    // Set post chat context in state
    // Commenting this for now as post chat context is fetched during end chat
    await setPostChatContextAndLoadSurvey(chatSDK, dispatch);

    // Updating chat session detail for telemetry
    await updateSessionDataForTelemetry(chatSDK, dispatch);
  } catch (ex) {
    var _TelemetryTimers$Widg4;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (ex.message === ChatSDKError.WidgetUseOutsideOperatingHour) {
      var _TelemetryTimers$Widg3;
      dispatch({
        type: LiveChatWidgetActionType.SET_OUTSIDE_OPERATING_HOURS,
        payload: true
      });
      dispatch({
        type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
        payload: ConversationState.OutOfOffice
      });
      TelemetryHelper.logLoadingEvent(LogLevel.INFO, {
        Event: TelemetryEvent.WidgetLoadComplete,
        Description: "Widget load complete. Widget is OOOH.",
        ElapsedTimeInMilliseconds: TelemetryTimers === null || TelemetryTimers === void 0 ? void 0 : (_TelemetryTimers$Widg3 = TelemetryTimers.WidgetLoadTimer) === null || _TelemetryTimers$Widg3 === void 0 ? void 0 : _TelemetryTimers$Widg3.milliSecondsElapsed
      });
      return;
    }
    TelemetryHelper.logLoadingEvent(LogLevel.ERROR, {
      Event: TelemetryEvent.WidgetLoadFailed,
      ExceptionDetails: {
        Exception: `Widget load Failed: ${ex}`
      },
      ElapsedTimeInMilliseconds: TelemetryTimers === null || TelemetryTimers === void 0 ? void 0 : (_TelemetryTimers$Widg4 = TelemetryTimers.WidgetLoadTimer) === null || _TelemetryTimers$Widg4 === void 0 ? void 0 : _TelemetryTimers$Widg4.milliSecondsElapsed
    });
    NotificationHandler.notifyError(NotificationScenarios.Connection, "Start Chat Failed: " + ex);
    dispatch({
      type: LiveChatWidgetActionType.SET_START_CHAT_FAILING,
      payload: true
    });
    if (!hideErrorUIPane) {
      // Set app state to failing start chat if hideErrorUI is not turned on
      TelemetryHelper.logLoadingEvent(LogLevel.INFO, {
        Event: TelemetryEvent.ErrorUIPaneLoaded,
        Description: "Error UI Pane Loaded"
      });
    }
    // Show the loading pane in other cases for failure, this will help for both hideStartChatButton case
    dispatch({
      type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
      payload: ConversationState.Loading
    });

    // If sessionInit was successful but LCW startchat failed due to some reason e.g adapter didn't load
    // we need to directly endChat to avoid leaving ghost chats in OC, not disturbing any other UI state 
    if (isStartChatSuccessful === true) {
      await forceEndChat(chatSDK);
    }
  } finally {
    optionalParams = {};
    widgetInstanceId = "";
  }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const forceEndChat = async chatSDK => {
  TelemetryHelper.logLoadingEvent(LogLevel.ERROR, {
    Event: TelemetryEvent.WidgetLoadFailed,
    ExceptionDetails: {
      Exception: "SessionInit was successful, but widget load failed."
    }
  });
  chatSDK === null || chatSDK === void 0 ? void 0 : chatSDK.endChat();
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const canConnectToExistingChat = async (props, chatSDK, state, dispatch, setAdapter) => {
  var _state$appStates, _persistedState$domai6, _persistedState$appSt;
  // By pass this function in case of popout chat
  if ((state === null || state === void 0 ? void 0 : (_state$appStates = state.appStates) === null || _state$appStates === void 0 ? void 0 : _state$appStates.hideStartChatButton) === true) {
    return false;
  }
  const persistedState = getStateFromCache(getWidgetCacheIdfromProps(props));

  //Connect to only active chat session
  if (persistedState && !isUndefinedOrEmpty(persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai6 = persistedState.domainStates) === null || _persistedState$domai6 === void 0 ? void 0 : _persistedState$domai6.liveChatContext) && (persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$appSt = persistedState.appStates) === null || _persistedState$appSt === void 0 ? void 0 : _persistedState$appSt.conversationState) === ConversationState.Active) {
    var _persistedState$domai7;
    dispatch({
      type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
      payload: ConversationState.Loading
    });
    const optionalParams = {
      liveChatContext: persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai7 = persistedState.domainStates) === null || _persistedState$domai7 === void 0 ? void 0 : _persistedState$domai7.liveChatContext
    };
    await initStartChat(chatSDK, dispatch, setAdapter, state, props, optionalParams, persistedState);
    return true;
  }
  return false;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const setCustomContextParams = async (state, props) => {
  var _props$chatConfig, _props$chatConfig$Liv, _state$domainStates, _persistedState$domai8;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const isAuthenticatedChat = props !== null && props !== void 0 && (_props$chatConfig = props.chatConfig) !== null && _props$chatConfig !== void 0 && (_props$chatConfig$Liv = _props$chatConfig.LiveChatConfigAuthSettings) !== null && _props$chatConfig$Liv !== void 0 && _props$chatConfig$Liv.msdyn_javascriptclientfunction ? true : false;
  //Should not set custom context for auth chat
  if (isAuthenticatedChat) {
    return;
  }
  if (state !== null && state !== void 0 && (_state$domainStates = state.domainStates) !== null && _state$domainStates !== void 0 && _state$domainStates.customContext) {
    var _state$domainStates2;
    optionalParams = Object.assign({}, optionalParams, {
      customContext: JSON.parse(JSON.stringify(state === null || state === void 0 ? void 0 : (_state$domainStates2 = state.domainStates) === null || _state$domainStates2 === void 0 ? void 0 : _state$domainStates2.customContext))
    });
    return;
  }
  if (isNullOrEmptyString(widgetInstanceId)) {
    widgetInstanceId = getWidgetCacheIdfromProps(props);
  }
  // Add custom context only for unauthenticated chat
  const persistedState = getStateFromCache(widgetInstanceId);
  const customContextLocal = (persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai8 = persistedState.domainStates) === null || _persistedState$domai8 === void 0 ? void 0 : _persistedState$domai8.customContext) ?? (props === null || props === void 0 ? void 0 : props.initialCustomContext);
  if (customContextLocal) {
    TelemetryHelper.logLoadingEvent(LogLevel.INFO, {
      Event: TelemetryEvent.SettingCustomContext,
      Description: "Setting custom context for unauthenticated chat"
    });
    optionalParams = Object.assign({}, optionalParams, {
      customContext: JSON.parse(JSON.stringify(customContextLocal))
    });
  } else {
    const customContextFromParent = await getInitContextParamsForPopout();
    if (!isUndefinedOrEmpty(customContextFromParent === null || customContextFromParent === void 0 ? void 0 : customContextFromParent.contextVariables)) {
      optionalParams = Object.assign({}, optionalParams, {
        customContext: JSON.parse(JSON.stringify(customContextFromParent.contextVariables))
      });
    }
  }
};
const canStartPopoutChat = async props => {
  if (props.allowSdkChatSupport === false) {
    return false;
  }
  popoutWidgetInstanceId = getWidgetCacheIdfromProps(props, true);
  if (!isNullOrEmptyString(popoutWidgetInstanceId)) {
    var _persistedState$domai9, _persistedState$appSt2;
    const persistedState = getStateFromCache(popoutWidgetInstanceId);
    if (persistedState && !isUndefinedOrEmpty(persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$domai9 = persistedState.domainStates) === null || _persistedState$domai9 === void 0 ? void 0 : _persistedState$domai9.liveChatContext) && (persistedState === null || persistedState === void 0 ? void 0 : (_persistedState$appSt2 = persistedState.appStates) === null || _persistedState$appSt2 === void 0 ? void 0 : _persistedState$appSt2.conversationState) === ConversationState.Active) {
      // Initiate popout chat
      BroadcastService.postMessage({
        eventName: BroadcastEvent.InitiateStartChatInPopoutMode
      });
      return true;
    }
  }
  return false;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const checkIfConversationStillValid = async (chatSDK, dispatch, state) => {
  var _state$domainStates3, _state$domainStates3$;
  const requestIdFromCache = (_state$domainStates3 = state.domainStates) === null || _state$domainStates3 === void 0 ? void 0 : (_state$domainStates3$ = _state$domainStates3.liveChatContext) === null || _state$domainStates3$ === void 0 ? void 0 : _state$domainStates3$.requestId;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let conversationDetails = undefined;

  //Preserve current requestId
  const currentRequestId = chatSDK.requestId ?? "";
  dispatch({
    type: LiveChatWidgetActionType.SET_INITIAL_CHAT_SDK_REQUEST_ID,
    payload: currentRequestId
  });
  try {
    chatSDK.requestId = requestIdFromCache;
    conversationDetails = await getConversationDetailsCall(chatSDK);
    if (Object.keys(conversationDetails).length === 0) {
      chatSDK.requestId = currentRequestId;
      return false;
    }
    if (conversationDetails.state === LiveWorkItemState.Closed || conversationDetails.state === LiveWorkItemState.WrapUp) {
      dispatch({
        type: LiveChatWidgetActionType.SET_LIVE_CHAT_CONTEXT,
        payload: undefined
      });
      chatSDK.requestId = currentRequestId;
      return false;
    }
    return true;
  } catch (erorr) {
    TelemetryHelper.logActionEvent(LogLevel.ERROR, {
      Event: TelemetryEvent.GetConversationDetailsException,
      ExceptionDetails: {
        exception: `Conversation is not valid: ${erorr}`
      }
    });
    chatSDK.requestId = currentRequestId;
    return false;
  }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getInitContextParamsForPopout = async () => {
  return window.opener ? await getInitContextParamForPopoutFromOuterScope(window.opener) : null;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getInitContextParamForPopoutFromOuterScope = async scope => {
  let payload;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let waitPromiseResolve;
  const waitPromise = new Promise((res, rej) => {
    waitPromiseResolve = res;
    setTimeout(() => rej("Failed to find method in outer scope"), 5000);
  }).catch(rej => console.warn(rej));
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const getInitContextParamsFromParent = e => {
    if (e.data && e.data.messageName == Constants.InitContextParamsResponse) {
      payload = e.data.payload;
      waitPromiseResolve();
    }
  };
  window.addEventListener("message", getInitContextParamsFromParent, false);
  scope.postMessage({
    messageName: Constants.InitContextParamsRequest
  }, "*");
  await waitPromise;
  window.removeEventListener("message", getInitContextParamsFromParent, false);
  return payload;
};
export { prepareStartChat, initStartChat, setPreChatAndInitiateChat, checkIfConversationStillValid };