import { ConfirmationState, Constants, ConversationEndEntity } from "../../../common/Constants";
import { LogLevel, TelemetryEvent } from "../../../common/telemetry/TelemetryConstants";
import { getAuthClientFunction, handleAuthentication } from "./authHelper";
import { getConversationDetailsCall, getWidgetEndChatEventName, isNullOrEmptyString } from "../../../common/utils";
import { getPostChatContext, initiatePostChat } from "./renderSurveyHelpers";
import { BroadcastService } from "@microsoft/omnichannel-chat-components";
import { ConversationState } from "../../../contexts/common/ConversationState";
import { LiveChatWidgetActionType } from "../../../contexts/common/LiveChatWidgetActionType";
import { TelemetryHelper } from "../../../common/telemetry/TelemetryHelper";
import { WebChatStoreLoader } from "../../webchatcontainerstateful/webchatcontroller/WebChatStoreLoader";
import { defaultWebChatContainerStatefulProps } from "../../webchatcontainerstateful/common/defaultProps/defaultWebChatContainerStatefulProps";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const prepareEndChat = async (props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, uwid) => {
  try {
    var _conversationDetails$, _state$domainStates, _state$domainStates2;
    const conversationDetails = await getConversationDetailsCall(chatSDK);

    // Use Case : When post chat is not configured
    if ((conversationDetails === null || conversationDetails === void 0 ? void 0 : (_conversationDetails$ = conversationDetails.canRenderPostChat) === null || _conversationDetails$ === void 0 ? void 0 : _conversationDetails$.toLowerCase()) === Constants.false) {
      var _state$appStates;
      // If ended by customer, just close chat
      if ((state === null || state === void 0 ? void 0 : (_state$appStates = state.appStates) === null || _state$appStates === void 0 ? void 0 : _state$appStates.conversationEndedBy) === ConversationEndEntity.Customer) {
        await endChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, false, false, true, uwid);
      }
      //Use Case: If ended by Agent, stay chat in InActive state
      return;
    }

    // Use Case : Can render post chat scenarios
    await getPostChatContext(chatSDK, state, dispatch);

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const postchatContext = state === null || state === void 0 ? void 0 : (_state$domainStates = state.domainStates) === null || _state$domainStates === void 0 ? void 0 : _state$domainStates.postChatContext;
    if (postchatContext === undefined) {
      var _state$appStates2;
      // For Customer intiated conversations, just close chat widget
      if ((state === null || state === void 0 ? void 0 : (_state$appStates2 = state.appStates) === null || _state$appStates2 === void 0 ? void 0 : _state$appStates2.conversationEndedBy) === ConversationEndEntity.Customer) {
        await endChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, false, false, true, uwid);
        return;
      }

      //For agent initiated end chat, allow to download transcript
      dispatch({
        type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
        payload: ConversationState.InActive
      });
      return;
    }
    endChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, false, true, true, uwid);

    // Initiate post chat render
    if (state !== null && state !== void 0 && (_state$domainStates2 = state.domainStates) !== null && _state$domainStates2 !== void 0 && _state$domainStates2.postChatContext) {
      await initiatePostChat(props, conversationDetails, state, dispatch, postchatContext);
      return;
    }
  } catch (error) {
    var _props$controlProps;
    TelemetryHelper.logActionEvent(LogLevel.ERROR, {
      Event: TelemetryEvent.EndChatFailed,
      ExceptionDetails: {
        exception: JSON.stringify(error)
      }
    });

    //Close chat widget for any failure in embedded to allow to show start chat button
    if (((_props$controlProps = props.controlProps) === null || _props$controlProps === void 0 ? void 0 : _props$controlProps.hideStartChatButton) === false) {
      await endChat(props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, false, false, true, uwid);
    }
  } finally {
    //Chat token clean up
    await chatTokenCleanUp(dispatch);
  }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const endChat = async function (props, chatSDK, state, dispatch, setAdapter, setWebChatStyles, adapter, skipEndChatSDK, skipCloseChat, postMessageToOtherTab) {
  let uwid = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : "";
  if (!skipEndChatSDK && chatSDK.conversation) {
    try {
      TelemetryHelper.logSDKEvent(LogLevel.INFO, {
        Event: TelemetryEvent.EndChatSDKCall
      });
      //Get auth token again if chat continued for longer time, otherwise gets 401 error
      await handleAuthenticationIfEnabled(props, chatSDK);
      await (chatSDK === null || chatSDK === void 0 ? void 0 : chatSDK.endChat());
    } catch (ex) {
      TelemetryHelper.logSDKEvent(LogLevel.ERROR, {
        Event: TelemetryEvent.EndChatSDKCallFailed,
        ExceptionDetails: {
          exception: ex
        }
      });
      postMessageToOtherTab = false;
    } finally {
      await endChatStateCleanUp(dispatch);
    }
  }
  if (!skipCloseChat) {
    try {
      var _props$webChatContain;
      adapter === null || adapter === void 0 ? void 0 : adapter.end();
      setAdapter(undefined);
      setWebChatStyles({
        ...defaultWebChatContainerStatefulProps.webChatStyles,
        ...((_props$webChatContain = props.webChatContainerProps) === null || _props$webChatContain === void 0 ? void 0 : _props$webChatContain.webChatStyles)
      });
      WebChatStoreLoader.store = null;
      closeChatStateCleanUp(dispatch);
      TelemetryHelper.logActionEvent(LogLevel.INFO, {
        Event: TelemetryEvent.CloseChatCall,
        Description: "Chat was closed succesfully"
      });
    } catch (error) {
      TelemetryHelper.logActionEvent(LogLevel.ERROR, {
        Event: TelemetryEvent.CloseChatMethodException,
        ExceptionDetails: {
          exception: `Failed to endChat: ${error}`
        }
      });
    } finally {
      dispatch({
        type: LiveChatWidgetActionType.SET_UNREAD_MESSAGE_COUNT,
        payload: 0
      });
      // Always allow to close the chat for embedded mode irrespective of end chat errors
      closeChatWidget(dispatch, props, state);
    }
  }
  if (postMessageToOtherTab && !isNullOrEmptyString(uwid)) {
    const endChatEventName = await getEndChatEventName(chatSDK, props);
    BroadcastService.postMessage({
      eventName: endChatEventName,
      payload: uwid
    });
  }
};
const endChatStateCleanUp = async dispatch => {
  // Need to clear these states immediately when chat ended from OC.
  dispatch({
    type: LiveChatWidgetActionType.SET_LIVE_CHAT_CONTEXT,
    payload: undefined
  });
  dispatch({
    type: LiveChatWidgetActionType.SET_RECONNECT_ID,
    payload: undefined
  });
  dispatch({
    type: LiveChatWidgetActionType.SET_CHAT_DISCONNECT_EVENT_RECEIVED,
    payload: false
  });
};
const closeChatStateCleanUp = async dispatch => {
  dispatch({
    type: LiveChatWidgetActionType.SET_CHAT_TOKEN,
    payload: undefined
  });
  // dispatch({ type: LiveChatWidgetActionType.SET_CONVERSATION_STATE, payload: ConversationState.Closed });
  dispatch({
    type: LiveChatWidgetActionType.SET_RECONNECT_ID,
    payload: undefined
  });
  dispatch({
    type: LiveChatWidgetActionType.SET_AUDIO_NOTIFICATION,
    payload: null
  });
  dispatch({
    type: LiveChatWidgetActionType.SET_CONVERSATION_ENDED_BY,
    payload: ConversationEndEntity.NotSet
  });
  dispatch({
    type: LiveChatWidgetActionType.SET_CONFIRMATION_STATE,
    payload: ConfirmationState.NotSet
  });
  dispatch({
    type: LiveChatWidgetActionType.SET_START_CHAT_FAILING,
    payload: false
  });
  dispatch({
    type: LiveChatWidgetActionType.SET_PROACTIVE_CHAT_PARAMS,
    payload: {
      proactiveChatBodyTitle: "",
      proactiveChatEnablePrechat: false,
      proactiveChatInNewWindow: false
    }
  });
};
const closeChatWidget = (dispatch, props, state) => {
  var _state$appStates3;
  if (state !== null && state !== void 0 && (_state$appStates3 = state.appStates) !== null && _state$appStates3 !== void 0 && _state$appStates3.hideStartChatButton) {
    var _props$controlProps2, _props$controlProps3;
    // Only close chat if header is enabled for popout
    // TODO : This condition needs to be removed eventually when the filler UX is ready for popout, removing this condition would show a blank screen for OOB Widget
    if ((props === null || props === void 0 ? void 0 : (_props$controlProps2 = props.controlProps) === null || _props$controlProps2 === void 0 ? void 0 : _props$controlProps2.hideHeader) === undefined || (props === null || props === void 0 ? void 0 : (_props$controlProps3 = props.controlProps) === null || _props$controlProps3 === void 0 ? void 0 : _props$controlProps3.hideHeader) === false) {
      dispatch({
        type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
        payload: ConversationState.Closed
      });
    }
    return;
  }

  // Embedded chat
  dispatch({
    type: LiveChatWidgetActionType.SET_CONVERSATION_STATE,
    payload: ConversationState.Closed
  });
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const handleAuthenticationIfEnabled = async (props, chatSDK) => {
  //Unable to end chat if token has expired
  if (props.getAuthToken) {
    const authClientFunction = getAuthClientFunction(props.chatConfig);
    if (props.getAuthToken && authClientFunction) {
      // set auth token to chat sdk before end chat
      const authSuccess = await handleAuthentication(chatSDK, props.chatConfig, props.getAuthToken);
      if (!authSuccess) {
        TelemetryHelper.logActionEvent(LogLevel.ERROR, {
          Event: TelemetryEvent.GetAuthTokenFailed,
          ExceptionDetails: {
            exception: "Unable to get auth token during end chat"
          }
        });
        throw new Error("handleAuthenticationIfEnabled:Failed to get authentication token");
      }
    }
  }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const chatTokenCleanUp = async dispatch => {
  //Just do cleanup here
  dispatch({
    type: LiveChatWidgetActionType.SET_CHAT_TOKEN,
    payload: undefined
  });
  dispatch({
    type: LiveChatWidgetActionType.SET_LIVE_CHAT_CONTEXT,
    payload: undefined
  });
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getEndChatEventName = async (chatSDK, props) => {
  var _chatSDK$omnichannelC, _chatSDK$omnichannelC2, _props$controlProps4;
  return getWidgetEndChatEventName(chatSDK === null || chatSDK === void 0 ? void 0 : (_chatSDK$omnichannelC = chatSDK.omnichannelConfig) === null || _chatSDK$omnichannelC === void 0 ? void 0 : _chatSDK$omnichannelC.orgId, chatSDK === null || chatSDK === void 0 ? void 0 : (_chatSDK$omnichannelC2 = chatSDK.omnichannelConfig) === null || _chatSDK$omnichannelC2 === void 0 ? void 0 : _chatSDK$omnichannelC2.widgetId, (props === null || props === void 0 ? void 0 : (_props$controlProps4 = props.controlProps) === null || _props$controlProps4 === void 0 ? void 0 : _props$controlProps4.widgetInstanceId) ?? "");
};
export { prepareEndChat, endChat };