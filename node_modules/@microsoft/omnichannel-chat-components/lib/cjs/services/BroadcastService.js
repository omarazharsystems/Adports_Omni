"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BroadcastServiceInitialize = exports.BroadcastService = void 0;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _broadcastChannel = require("broadcast-channel");

const newMessage = new _rxjs.Subject(); // eslint-disable-next-line @typescript-eslint/no-explicit-any

const broadcastServicePubList = {}; // eslint-disable-next-line @typescript-eslint/no-explicit-any

const broadcastServiceSubList = {}; // eslint-disable-next-line @typescript-eslint/no-explicit-any

let pubChannel; // eslint-disable-next-line @typescript-eslint/no-explicit-any

let subChannel;

const BroadcastServiceInitialize = channelName => {
  if (broadcastServicePubList[channelName]) {
    pubChannel = broadcastServicePubList[channelName];
  } else {
    const newPubChannel = new _broadcastChannel.BroadcastChannel(channelName);
    broadcastServicePubList[channelName] = newPubChannel;
    pubChannel = newPubChannel;
  }

  if (broadcastServiceSubList[channelName]) {
    subChannel = broadcastServiceSubList[channelName];
  } else {
    const newSubChannel = new _broadcastChannel.BroadcastChannel(channelName);
    broadcastServiceSubList[channelName] = newSubChannel;
    subChannel = newSubChannel;
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  subChannel.onmessage = message => {
    newMessage.next(message);
  };
};

exports.BroadcastServiceInitialize = BroadcastServiceInitialize;
const BroadcastService = {
  //broadcast a message
  postMessage: message => {
    /**
     * Omit copying methods to prevent 'DataCloneError' in older browsers when passing an object with functions
     * This exception occurs when an object can't be clone with the 'structured clone algorithm' (used by postMessage)
     */
    pubChannel.postMessage(JSON.parse(JSON.stringify(message)));
  },
  getMessage: message => {
    return newMessage.pipe((0, _operators.filter)(msg => msg.elementId == message.elementId && msg.elementType == message.elementType && msg.eventName == message.eventName));
  },
  getMessageByEventName: eventName => {
    return newMessage.pipe((0, _operators.filter)(message => message.eventName === eventName));
  },
  getAnyMessage: () => {
    return newMessage;
  },
  disposeChannel: () => {
    pubChannel.close();
    subChannel.close();
  }
};
exports.BroadcastService = BroadcastService;