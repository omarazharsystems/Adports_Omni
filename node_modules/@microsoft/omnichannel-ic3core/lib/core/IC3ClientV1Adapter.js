"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable security/detect-object-injection */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var Constants_1 = require("../common/Constants");
var HttpHeaders_1 = require("../http/HttpHeaders");
var HttpRequestType_1 = require("../http/HttpRequestType");
var IC3ClientAdapter_1 = require("./IC3ClientAdapter");
var IC3Initializer_1 = require("../core/IC3Initializer");
var IC3TelemetryEvent_1 = require("../logging/IC3TelemetryEvent");
var HttpClient_1 = require("../http/HttpClient");
var LogLevel_1 = require("../logging/LogLevel");
var ProtocoleType_1 = require("../interfaces/ProtocoleType");
var RequestHelper_1 = require("../http/RequestHelper");
var ResourceType_1 = require("../model/ResourceType");
var ServiceEndpointHelper_1 = require("../common/ServiceEndpointHelper");
var Util_1 = require("../common/Util");
var Utilities_1 = require("../common/Utilities");
var IC3ClientV1Adapter = /** @class */ (function (_super) {
    __extends(IC3ClientV1Adapter, _super);
    function IC3ClientV1Adapter(id, hostType) {
        var _this = _super.call(this, id) || this;
        _this.debug && console.debug("IC3Core/Constructor");
        _this.protocolType = ProtocoleType_1.default.IC3V1SDK;
        _this.hostType = hostType;
        _this.ic3Initializer = new IC3Initializer_1.default();
        return _this;
    }
    IC3ClientV1Adapter.prototype.startPolling = function () {
        _super.prototype.startPolling.call(this);
    };
    IC3ClientV1Adapter.prototype.stopPolling = function () {
        _super.prototype.stopPolling.call(this);
    };
    IC3ClientV1Adapter.prototype.setup = function (setupParams) {
        return _super.prototype.setup.call(this, setupParams);
    };
    IC3ClientV1Adapter.prototype.initialize = function (sessionInfo) {
        var _this = this;
        return _super.prototype.initialize.call(this, sessionInfo)
            .then(function () {
            var initializeOperation = function () {
                var _a;
                return (_a = _this.ic3Initializer) === null || _a === void 0 ? void 0 : _a.setup(_this.logger).then(function () { return _this.setSkypeTokenCookie(); }).then(function () { var _a; return (_a = _this.ic3Initializer) === null || _a === void 0 ? void 0 : _a.setIc3Info(_this.ic3Info); }).then(function () { var _a; return (_a = _this.ic3Initializer) === null || _a === void 0 ? void 0 : _a.initializeIC3(_this.handlePollData.bind(_this)); }).then(function (ic3Info) { _this.ic3Info = ic3Info; });
            };
            return initializeOperation();
        });
    };
    IC3ClientV1Adapter.prototype.update = function (sessionInfo) {
        var _this = this;
        return _super.prototype.update.call(this, sessionInfo)
            .then(function () {
            var updateOperation = function () {
                var ic3Info = {
                    RegionGtms: sessionInfo.regionGtms,
                    SkypeToken: sessionInfo.token,
                    visitor: sessionInfo.visitor
                };
                return _this.updateToken(ic3Info);
            };
            return updateOperation();
        });
    };
    IC3ClientV1Adapter.prototype.dispose = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                (_a = this.ic3Initializer) === null || _a === void 0 ? void 0 : _a.stopPolling();
                this.heartBeatTimer && clearInterval(this.heartBeatTimer);
                Promise.resolve();
                return [2 /*return*/];
            });
        });
    };
    IC3ClientV1Adapter.prototype.joinConversation = function (conversationId, sendHeartBeat) {
        var _this = this;
        var timer = Utilities_1.default.timer();
        return _super.prototype.joinConversation.call(this, conversationId, sendHeartBeat).then(function (conversation) {
            return _this.getThreadRequest(conversation.id).then(function (thread) {
                _this.internalConversationsData[conversation.id] = {
                    id: conversationId,
                    members: thread.members
                };
                return conversation;
            }).catch(function (ex) {
                var elapsedTimeInMilliseconds = timer.milliSecondsElapsed;
                _this.logger && _this.logger.log(LogLevel_1.default.WARN, IC3TelemetryEvent_1.default.JoinConversationV1GetThreadRequestFailed, {
                    Description: "Unable to retrieve thread: " + ex,
                    ElapsedTimeInMilliseconds: elapsedTimeInMilliseconds,
                    EndpointUrl: _this.EndpointUrl, EndpointId: _this.ic3Info.endpointId
                });
                _this.internalConversationsData[conversation.id] = {
                    id: conversationId,
                    members: []
                };
                return conversation;
            });
        });
    };
    IC3ClientV1Adapter.prototype.sendMessage = function (conversation, message) {
        return _super.prototype.sendMessage.call(this, conversation, message);
    };
    IC3ClientV1Adapter.prototype.sendFileMessage = function (conversation, fileMetadata, message) {
        return _super.prototype.sendFileMessage.call(this, conversation, fileMetadata, message);
    };
    IC3ClientV1Adapter.prototype.getMessages = function (conversation) {
        return _super.prototype.getMessages.call(this, conversation);
    };
    IC3ClientV1Adapter.prototype.registerOnNewMessage = function (conversation, callback) {
        return _super.prototype.registerOnNewMessage.call(this, conversation, callback);
    };
    IC3ClientV1Adapter.prototype.registerOnThreadUpdate = function (conversation, callback) {
        return _super.prototype.registerOnThreadUpdate.call(this, conversation, callback);
    };
    IC3ClientV1Adapter.prototype.disconnectFromConversation = function (conversation) {
        return _super.prototype.disconnectFromConversation.call(this, conversation);
    };
    IC3ClientV1Adapter.prototype.setSkypeTokenCookie = function () {
        var url = this.ic3Info.RegionGtms.ams.concat(Constants_1.default.skypeTokenAuthURL);
        var headers = RequestHelper_1.default.getDefaultBaseIC3Headers();
        headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeForm;
        var skypeTokenData = Constants_1.default.skypeTokenConstantForData + this.ic3Info.SkypeToken;
        var requestParameters = {
            data: skypeTokenData,
            enableExponentialBackoff: true,
            useXHRWithCredentials: true,
            headers: headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: false,
            shouldResetOnFailure: false,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.POST,
            url: url
        };
        return HttpClient_1.HttpClient.MakeRequest(requestParameters);
    };
    IC3ClientV1Adapter.prototype.getThreadRequest = function (conversationId) {
        var url = ServiceEndpointHelper_1.default.getThreadUrl(conversationId, this.ic3Info.RegionGtms);
        var headers = RequestHelper_1.default.getDefaultBaseIC3Headers();
        headers[HttpHeaders_1.default.RegistrationTokenHeader] = this.ic3Info.RegistrationToken;
        var requestParameters = {
            enableExponentialBackoff: true,
            headers: headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: true,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.GET,
            url: url
        };
        return HttpClient_1.HttpClient.MakeRequest(requestParameters);
    };
    IC3ClientV1Adapter.prototype.newMessageReceived = function (conversation, message, resourceType) {
        _super.prototype.onNewMessage.call(this, conversation, message, resourceType);
    };
    IC3ClientV1Adapter.prototype.newThreadUpdate = function (conversation, message) {
        _super.prototype.onThreadUpdate.call(this, conversation, message);
    };
    IC3ClientV1Adapter.prototype.handleNewMessageEvent = function (eventMessage) {
        var conversationId;
        if (eventMessage.resource && eventMessage.resource.conversationid) {
            conversationId = eventMessage.resource.conversationid;
        }
        else if (eventMessage.resource.conversationLink) {
            conversationId = Util_1.default.getConversationIdFromUrl(eventMessage.resource.conversationLink);
        }
        else {
            conversationId = Util_1.default.getConversationIdFromUrl(eventMessage.resourceLink);
        }
        var conversationIndex = this.conversations.findIndex(function (conv) { return conv.id === conversationId; });
        var interestedConversation = this.conversations[conversationIndex];
        this.newMessageReceived(interestedConversation, eventMessage.resource, eventMessage.resourceType);
    };
    IC3ClientV1Adapter.prototype.handleConversationUpdateEvent = function (eventMessage) {
        if (eventMessage.resourceType === ResourceType_1.default.ConversationUpdate) {
            // handle conversation update
        }
    };
    IC3ClientV1Adapter.prototype.handleThreadUpdate = function (eventMessage) {
        if (eventMessage.resourceType !== ResourceType_1.default.ThreadUpdate) {
            return;
        }
        var conversationId;
        if (eventMessage.resource && eventMessage.resource.id) {
            conversationId = eventMessage.resource.id;
        }
        else if (eventMessage.resource.messages) {
            conversationId = Util_1.default.getConversationIdFromUrl(eventMessage.resource.messages);
        }
        else {
            conversationId = Util_1.default.getConversationIdFromUrl(eventMessage.resourceLink);
        }
        var conversationIndex = this.conversations.findIndex(function (conv) { return conv.id === conversationId; });
        var interestedConversation = this.conversations[conversationIndex];
        this.newThreadUpdate(interestedConversation, eventMessage.resource);
    };
    IC3ClientV1Adapter.prototype.handlePollData = function (eventData) {
        if (!eventData || !eventData.eventMessages) {
            return;
        }
        for (var _i = 0, _a = eventData.eventMessages; _i < _a.length; _i++) {
            var eventMessage = _a[_i];
            this.handlePollEventMessage(eventMessage);
        }
    };
    IC3ClientV1Adapter.prototype.handlePollEventMessage = function (eventMessage) {
        if (eventMessage.resourceType === ResourceType_1.default.NewMessage
            || eventMessage.resourceType === ResourceType_1.default.MessageUpdate) {
            this.handleNewMessageEvent(eventMessage);
        }
        else if (eventMessage.resourceType === ResourceType_1.default.ThreadUpdate) {
            this.handleThreadUpdate(eventMessage);
        }
        else if (eventMessage.resourceType === ResourceType_1.default.ConversationUpdate) {
            this.handleConversationUpdateEvent(eventMessage);
        }
    };
    /**
     * Updates the token info following the below steps:
     * Stops raising events from the ongoing poll
     * Creates new endpoint and subscription
     * Starts polling with the new endpoint
     * Stops polling from the ongoing poll
     * Raises all the distinct events received during this period
     * Updates the current ic3Info with the new ic3Info
     * Reverts in case of any errors in the above state
     * The above steps take care that no event is dropped or raised multiple times while transitioning
     * @param ic3Info - IIC3Info object used to update the token
     */
    IC3ClientV1Adapter.prototype.updateToken = function (ic3Info) {
        return __awaiter(this, void 0, void 0, function () {
            var pollDataFromOngoingPoll, handlePollDataFromOngoingPoll, pollDataFromNewPoll, handlePollDataFromNewPoll, currentIc3Initializer, newIc3Initializer, currentUpdateTokenClearTimeoutHandle, currentIc3Info, newIc3Info, matchingIC3EventIndex, updateTokenPromise;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger && this.logger.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.UpdateToken, {
                            EndpointUrl: this.EndpointUrl,
                            EndpointId: this.ic3Info.endpointId
                        });
                        pollDataFromOngoingPoll = [];
                        handlePollDataFromOngoingPoll = function (pollData) {
                            if (pollData && pollData.eventMessages) {
                                Utilities_1.default.concatArrays(pollDataFromOngoingPoll, pollData.eventMessages);
                            }
                        };
                        pollDataFromNewPoll = [];
                        handlePollDataFromNewPoll = function (pollData) {
                            if (pollData && pollData.eventMessages) {
                                Utilities_1.default.concatArrays(pollDataFromNewPoll, pollData.eventMessages);
                            }
                        };
                        currentIc3Initializer = this.ic3Initializer;
                        newIc3Initializer = new IC3Initializer_1.default();
                        currentUpdateTokenClearTimeoutHandle = this.updateTokenClearTimeoutHandle;
                        currentIc3Info = this.ic3Info;
                        currentIc3Initializer.getPoller().onNewData = handlePollDataFromOngoingPoll;
                        if (!this.logger) return [3 /*break*/, 2];
                        return [4 /*yield*/, newIc3Initializer.setup(this.logger)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        updateTokenPromise = newIc3Initializer.setIc3Info(ic3Info)
                            .then(function () { return newIc3Initializer.initializeIC3(handlePollDataFromNewPoll); })
                            .then(function (response) { newIc3Info = response; })
                            .then(function () { return _this.getMatchingIC3EventIndex(pollDataFromOngoingPoll, pollDataFromNewPoll); })
                            .then(function (response) { matchingIC3EventIndex = response; })
                            .then(function () { return currentIc3Initializer.reset(true); })
                            .then(function () { return _this.syncPollingData(pollDataFromOngoingPoll, pollDataFromNewPoll, matchingIC3EventIndex); })
                            .then(function () {
                            _this.ic3Info = newIc3Info;
                            _this.ic3Initializer = newIc3Initializer;
                            _this.ic3Initializer.getPoller().onNewData = _this.handlePollData.bind(_this);
                        })
                            .catch(function (e) {
                            if (_this.updateTokenClearTimeoutHandle !== currentUpdateTokenClearTimeoutHandle) {
                                clearTimeout(_this.updateTokenClearTimeoutHandle);
                                _this.updateTokenClearTimeoutHandle = currentUpdateTokenClearTimeoutHandle;
                            }
                            _this.ic3Info = currentIc3Info;
                            _this.ic3Initializer.getPoller().onNewData = _this.handlePollData.bind(_this);
                            _this.ic3Initializer.getPoller().start();
                            throw new Error("Update token failed: " + (e && e.message));
                        });
                        return [2 /*return*/, updateTokenPromise];
                }
            });
        });
    };
    /**
     * Returns indices of the first event common among events from ongoing and new polls
     * Waits for Constants.timeBetweenStabilizingPoll * Constants.stabilizePollMaxRetryCount milliseconds
     * till the common event is found.
     * Returns { -1, -1 } as the common index if no common event is found within the above time
     * @param pollDataFromOngoingPoll - Events from ongoing poll
     * @param pollDataFromNewPoll - Events from new poll
     * @param currentRetryCount - Current retry count
     */
    IC3ClientV1Adapter.prototype.getMatchingIC3EventIndex = function (pollDataFromOngoingPoll, pollDataFromNewPoll, currentRetryCount) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            currentRetryCount = currentRetryCount || 0;
            if (currentRetryCount === Constants_1.default.stabilizePollMaxRetryCount) {
                resolve({ newPollIndex: -1, previousPollIndex: -1 });
            }
            else {
                var ongoingPollIndex = 0;
                var newPollIndex = 0;
                while (ongoingPollIndex < pollDataFromOngoingPoll.length && newPollIndex < pollDataFromNewPoll.length) {
                    var ongoingPollData = pollDataFromOngoingPoll[ongoingPollIndex];
                    var newPollData = pollDataFromNewPoll[newPollIndex];
                    if (ongoingPollData.time === newPollData.time) {
                        resolve({ newPollIndex: newPollIndex, previousPollIndex: ongoingPollIndex });
                        return;
                    }
                    else if (new Date(ongoingPollData.time) < new Date(ongoingPollData.time)) {
                        ongoingPollIndex++;
                    }
                    else {
                        newPollIndex++;
                    }
                }
                setTimeout(function () {
                    _this.getMatchingIC3EventIndex(pollDataFromOngoingPoll, pollDataFromNewPoll, currentRetryCount + 1)
                        .then(function (response) { resolve(response); })
                        .catch(function (e) { reject(e); });
                }, Constants_1.default.timeBetweenStabilizingPoll);
            }
        });
    };
    /**
     * Syncs the polling data.
     * Processes all the distinct events received during the simultaneous running of both the polls
     * @param pollDataFromOngoingPoll - Events from ongoing poll
     * @param pollDataFromNewPoll - Events from new poll
     * @param matchingIC3EventIndex - Indices of the first common event between the polls
     */
    IC3ClientV1Adapter.prototype.syncPollingData = function (pollDataFromOngoingPoll, pollDataFromNewPoll, matchingIC3EventIndex) {
        this.logger && this.logger.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.SyncingPollData, {
            EndpointUrl: this.EndpointUrl,
            EndpointId: this.ic3Info.endpointId
        });
        var previousPollLastIndex = matchingIC3EventIndex.previousPollIndex;
        var newPollStartIndex = matchingIC3EventIndex.newPollIndex + 1;
        if (matchingIC3EventIndex.previousPollIndex === -1 && matchingIC3EventIndex.newPollIndex === -1) {
            previousPollLastIndex = pollDataFromOngoingPoll.length - 1;
            newPollStartIndex = 0;
        }
        for (var ind = 0; ind <= previousPollLastIndex; ind++) {
            this.handlePollEventMessage(pollDataFromOngoingPoll[ind]);
        }
        for (var ind = newPollStartIndex; ind < pollDataFromNewPoll.length; ind++) {
            this.handlePollEventMessage(pollDataFromNewPoll[ind]);
        }
    };
    return IC3ClientV1Adapter;
}(IC3ClientAdapter_1.default));
exports.default = IC3ClientV1Adapter;
//# sourceMappingURL=IC3ClientV1Adapter.js.map