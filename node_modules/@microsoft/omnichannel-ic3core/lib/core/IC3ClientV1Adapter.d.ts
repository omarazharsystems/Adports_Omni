import HostType from "../interfaces/HostType";
import IC3ClientAdapter from "./IC3ClientAdapter";
import IFileMetadata from '../model/IFileMetadata';
import IIC3Adapter from "../interfaces/IIC3Adapter";
import IInitializationInfo from '../model/IInitializationInfo';
import IRawConversation from "../model/IRawConversation";
import IRawMessage from "../model/IRawMessage";
import IRawSDKSetupParameters from "../interfaces/IRawSDKSetupParameters";
import IRawThread from "../interfaces/IRawThread";
export default class IC3ClientV1Adapter extends IC3ClientAdapter implements IIC3Adapter {
    private updateTokenClearTimeoutHandle;
    constructor(id: string, hostType: HostType);
    startPolling(): void;
    stopPolling(): void;
    setup(setupParams: IRawSDKSetupParameters): Promise<void>;
    initialize(sessionInfo: IInitializationInfo): Promise<void>;
    update(sessionInfo: IInitializationInfo): Promise<void>;
    dispose(): Promise<void>;
    joinConversation(conversationId: string, sendHeartBeat?: boolean): Promise<IRawConversation>;
    sendMessage(conversation: IRawConversation, message: IRawMessage): Promise<void>;
    sendFileMessage(conversation: IRawConversation, fileMetadata: IFileMetadata, message: IRawMessage): Promise<void>;
    getMessages(conversation: IRawConversation): Promise<IRawMessage[]>;
    registerOnNewMessage(conversation: IRawConversation, callback: (message: IRawMessage) => void): Promise<void>;
    registerOnThreadUpdate(conversation: IRawConversation, callback: (message: IRawThread) => void): Promise<void>;
    disconnectFromConversation(conversation: IRawConversation): Promise<void>;
    private setSkypeTokenCookie;
    private getThreadRequest;
    private newMessageReceived;
    private newThreadUpdate;
    private handleNewMessageEvent;
    private handleConversationUpdateEvent;
    private handleThreadUpdate;
    private handlePollData;
    private handlePollEventMessage;
    /**
     * Updates the token info following the below steps:
     * Stops raising events from the ongoing poll
     * Creates new endpoint and subscription
     * Starts polling with the new endpoint
     * Stops polling from the ongoing poll
     * Raises all the distinct events received during this period
     * Updates the current ic3Info with the new ic3Info
     * Reverts in case of any errors in the above state
     * The above steps take care that no event is dropped or raised multiple times while transitioning
     * @param ic3Info - IIC3Info object used to update the token
     */
    private updateToken;
    /**
     * Returns indices of the first event common among events from ongoing and new polls
     * Waits for Constants.timeBetweenStabilizingPoll * Constants.stabilizePollMaxRetryCount milliseconds
     * till the common event is found.
     * Returns { -1, -1 } as the common index if no common event is found within the above time
     * @param pollDataFromOngoingPoll - Events from ongoing poll
     * @param pollDataFromNewPoll - Events from new poll
     * @param currentRetryCount - Current retry count
     */
    private getMatchingIC3EventIndex;
    /**
     * Syncs the polling data.
     * Processes all the distinct events received during the simultaneous running of both the polls
     * @param pollDataFromOngoingPoll - Events from ongoing poll
     * @param pollDataFromNewPoll - Events from new poll
     * @param matchingIC3EventIndex - Indices of the first common event between the polls
     */
    private syncPollingData;
}
