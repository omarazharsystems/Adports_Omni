import {
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __rest,
  init_tslib_es6
} from "./chunk-AI3I5DMF.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/@microsoft/omnichannel-ic3core/lib/model/MessageType.js
var require_MessageType = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/model/MessageType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var MessageType = (
      /** @class */
      function() {
        function MessageType2() {
        }
        MessageType2.UserMessage = "UserMessage";
        MessageType2.SwiftCard = "SwiftCard";
        MessageType2.Typing = "Control/Typing";
        MessageType2.ClearTyping = "Control/ClearTyping";
        MessageType2.LiveState = "Control/LiveState";
        return MessageType2;
      }()
    );
    exports2.default = MessageType;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/model/DeliveryMode.js
var require_DeliveryMode = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/model/DeliveryMode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var DeliveryMode = (
      /** @class */
      function() {
        function DeliveryMode2() {
        }
        DeliveryMode2.Bridged = "bridged";
        DeliveryMode2.Unbridged = "unbridged";
        return DeliveryMode2;
      }()
    );
    exports2.default = DeliveryMode;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/model/MessageContentType.js
var require_MessageContentType = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/model/MessageContentType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var MessageContentType = (
      /** @class */
      function() {
        function MessageContentType2() {
        }
        MessageContentType2.RichText = "RichText";
        MessageContentType2.Text = "Text";
        return MessageContentType2;
      }()
    );
    exports2.default = MessageContentType;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/model/PersonType.js
var require_PersonType = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/model/PersonType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PersonType;
    (function(PersonType2) {
      PersonType2[PersonType2["Unknown"] = 0] = "Unknown";
      PersonType2[PersonType2["User"] = 1] = "User";
      PersonType2[PersonType2["Bot"] = 2] = "Bot";
    })(PersonType || (PersonType = {}));
    exports2.default = PersonType;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/interfaces/HostType.js
var require_HostType = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/interfaces/HostType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var HostType = (
      /** @class */
      function() {
        function HostType2() {
        }
        HostType2.IFrame = 0;
        HostType2.Page = 1;
        return HostType2;
      }()
    );
    exports2.default = HostType;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uuidv4 = void 0;
    var uuidv4 = function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    };
    exports2.uuidv4 = uuidv4;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/core/ClientBridge.js
var require_ClientBridge = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/core/ClientBridge.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f3, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f3 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var HostType_1 = require_HostType();
    var uuid_1 = require_uuid();
    var ClientBridge = (
      /** @class */
      function() {
        function ClientBridge2(protocolType) {
          this.hostType = HostType_1.default.Page;
          this.id = (0, uuid_1.uuidv4)();
          this.protocolType = protocolType;
          this.newConversationMessageListeners = {};
          this.threadUpdateListeners = {};
          this.debug = false;
        }
        ClientBridge2.prototype.setDebug = function(flag) {
          this.debug = flag;
        };
        ClientBridge2.prototype.joinConversation = function(conversationId, sendHeartBeat) {
          var _this = this;
          return this.onJoinConversation(conversationId, sendHeartBeat).then(function(conversation) {
            var clientConversation = {
              disconnect: _this.disconnectFromConversation.bind(_this, conversation),
              downloadFile: _this.downloadFile.bind(_this, conversation),
              getFileStatus: _this.getFileStatus.bind(_this, conversation),
              getMembers: _this.getMembers.bind(_this, conversation),
              getMessages: _this.getMessages.bind(_this, conversation),
              id: conversation.id,
              indicateTypingStatus: _this.indicateTypingStatus.bind(_this, conversation),
              registerOnNewMessage: _this.registerOnNewMessage.bind(_this, conversation),
              registerOnThreadUpdate: _this.registerOnThreadUpdate.bind(_this, conversation),
              sendFileMessage: _this.sendFileMessage.bind(_this, conversation),
              sendMessage: _this.sendMessage.bind(_this, conversation),
              sendMessageToBot: _this.sendMessageToBot.bind(_this, conversation),
              uploadFile: _this.uploadFile.bind(_this, conversation),
              sendFileData: _this.sendFileData.bind(_this, conversation)
            };
            return clientConversation;
          });
        };
        ClientBridge2.prototype.registerOnNewMessage = function(conversation, callback) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              return [2, Promise.resolve()];
            });
          });
        };
        ClientBridge2.prototype.registerOnThreadUpdate = function(conversation, callback) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              return [2, Promise.resolve()];
            });
          });
        };
        ClientBridge2.prototype.uploadFile = function(conversation, fileToSend, fileSharingProtocolType) {
          return Promise.resolve();
        };
        ClientBridge2.prototype.downloadFile = function(conversation, fileMetadata) {
          this.debug && console.debug("IC3Core/ClientBridge/downloadFile");
          return this.downloadFileData(conversation, fileMetadata).then(function(dataAsArrayBuffer) {
            var dataAsBlob = dataAsArrayBuffer;
            if (dataAsBlob && dataAsBlob.size) {
              return dataAsBlob;
            }
            var blob = new Blob([new Uint8Array(dataAsArrayBuffer)]);
            return !blob || blob.size === 0 && blob.type === "" ? dataAsArrayBuffer : blob;
          });
        };
        return ClientBridge2;
      }()
    );
    exports2.default = ClientBridge;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/common/Constants.js
var require_Constants = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/common/Constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Constants2 = (
      /** @class */
      function() {
        function Constants3() {
        }
        Constants3.NewMessageEvent = "NewMessage";
        Constants3.MessageUpdateEvent = "MessageUpdate";
        Constants3.ThreadUpdateEvent = "ThreadUpdate";
        Constants3.ConversationUpdateEvent = "ConversationUpdate";
        Constants3.HttpLongPoll = "HttpLongPoll";
        Constants3.ContentTypeJson = "application/json";
        Constants3.ContentTypeTextPlain = "text/plain;charset=UTF-8";
        Constants3.ContentTypeForm = "application/x-www-form-urlencoded";
        Constants3.RedirectAs404 = "redirectAs404";
        Constants3.NoCache = "no-cache";
        Constants3.User = "user";
        Constants3.Web = "web";
        Constants3.ClientInfoValue = "os=Windows; osVer=10; proc=Win32; lcid=en-us; deviceType=1; country=IN; clientName=swc; clientVer=912/0.106.0.34//swc";
        Constants3.TextPlainMimeType = "text/plain";
        Constants3.SwcName = "SWC";
        Constants3.Image = "image";
        Constants3.ClientVersion = "937/0.123.0.9";
        Constants3.DelayForAms = 50;
        Constants3.Reset_Flag = "reset_ic3_needed";
        Constants3.Malware = "malware";
        Constants3.Ready = "ready";
        Constants3.InProgress = "in progress";
        Constants3.Failed = "failed";
        Constants3.Expired = "expired";
        Constants3.ImageView = "imgpsh_fullsize_anim";
        Constants3.FileView = "original";
        Constants3.DocumentTypeImage = "pish/image";
        Constants3.DocumentTypeFile = "sharing/file";
        Constants3.ImageContent = "imgpsh";
        Constants3.FileContent = "original";
        Constants3.AMSAcceptHeaderValue = "image/webp,image/ *,*/*;q=0.8";
        Constants3.AMSAcceptEncodingHeaderValue = "gzip, deflate, sdch, br";
        Constants3.AMSAuthorizationSkypeTokenValue = "skype_token ";
        Constants3.stabilizePollMaxRetryCount = 50;
        Constants3.timeBetweenStabilizingPoll = 1e3;
        Constants3.retryCount = 2;
        Constants3.retry404Count = 3;
        Constants3.retryOtherCount = 3;
        Constants3.liveStateRetryCount = 3;
        Constants3.timeBetweenOperationRetry = 1e3;
        Constants3.heartBeatDuration = 3e4;
        Constants3.endpointRequestLog = "Endpoint request";
        Constants3.subscriptionRequestLog = "Subscription request";
        Constants3.setPropertiesRequestLog = "Set message properties request";
        Constants3.unsubscribeRequestLog = "Unsubscribe from endpoint request";
        Constants3.pollRequestLog = "Polling";
        Constants3.oldInitializer = "Old initializer";
        Constants3.newInitializer = "New Initializer";
        Constants3.skypeTokenAuthURL = "/v1/skypetokenauth";
        Constants3.skypeTokenConstantForData = "skypetoken=";
        return Constants3;
      }()
    );
    exports2.default = Constants2;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/http/HttpHeaders.js
var require_HttpHeaders = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/http/HttpHeaders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var HttpHeaders2 = (
      /** @class */
      function() {
        function HttpHeaders3() {
        }
        HttpHeaders3.LocationHeader = "location";
        HttpHeaders3.SetRegistrationTokenHeader = "set-registrationtoken";
        HttpHeaders3.RegistrationTokenHeader = "RegistrationToken";
        HttpHeaders3.RegistrationTokenHeaderValue = "registrationToken=";
        HttpHeaders3.ContentTypeHeader = "content-type";
        HttpHeaders3.AuthenticationHeader = "authentication";
        HttpHeaders3.BehaviorOverrideHeader = "behavioroverride";
        HttpHeaders3.SkypeTokenHeaderValue = "skypetoken=";
        HttpHeaders3.SetEndpointProperty = "supportsMessageProperties";
        return HttpHeaders3;
      }()
    );
    exports2.default = HttpHeaders2;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/http/HttpRequestType.js
var require_HttpRequestType = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/http/HttpRequestType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var HttpRequestType;
    (function(HttpRequestType2) {
      HttpRequestType2["GET"] = "get";
      HttpRequestType2["POST"] = "post";
      HttpRequestType2["PUT"] = "put";
      HttpRequestType2["DELETE"] = "delete";
    })(HttpRequestType || (HttpRequestType = {}));
    exports2.default = HttpRequestType;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/common/Utilities.js
var require_Utilities = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/common/Utilities.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var HttpHeaders_1 = require_HttpHeaders();
    var Utilities = (
      /** @class */
      function() {
        function Utilities2() {
        }
        Utilities2.isNullOrEmptyString = function(s) {
          return Utilities2.isNullOrUndefined(s) || s === "";
        };
        Utilities2.isNullOrUndefinedOrEmptyArray = function(obj) {
          return Utilities2.isNullOrUndefined(obj) || obj.length === 0;
        };
        Utilities2.isNullOrUndefined = function(obj) {
          return obj === null || obj === void 0;
        };
        Utilities2.isPrimitiveString = function(obj) {
          return typeof obj === "string";
        };
        Utilities2.convertStringToBoolean = function(input) {
          return !Utilities2.isNullOrUndefined(input) && input.toLowerCase() === "true";
        };
        Utilities2.sanitizeUrlWithBackSlash = function(url) {
          return url.endsWith("/") ? url : url + "/";
        };
        Utilities2.getRegistrationTokenValue = function(registrationTokenHeader) {
          var regToken = registrationTokenHeader.match(/registrationToken=(.+); expires=(\d+)/);
          if (regToken && regToken.length >= 2) {
            return HttpHeaders_1.default.RegistrationTokenHeaderValue + regToken[1];
          }
          return "";
        };
        Utilities2.addQueryParametersToPath = function(basePath, queryParameters) {
          var finalPath = basePath;
          if (!Utilities2.isNullOrUndefined(queryParameters)) {
            if (!(finalPath.indexOf("?") >= 0)) {
              finalPath += "?";
            }
            for (var queryParamKey in queryParameters) {
              if (queryParameters.hasOwnProperty(queryParamKey)) {
                var queryParamData = queryParamKey + "=" + queryParameters[queryParamKey];
                if (finalPath[finalPath.length - 1] !== "?") {
                  queryParamData = "&" + queryParamData;
                }
                finalPath += queryParamData;
              }
            }
          }
          return finalPath;
        };
        Utilities2.getResponseHeader = function(jqXHR, headerName) {
          var headerValue;
          if (!Utilities2.isNullOrUndefined(jqXHR)) {
            headerValue = jqXHR.headers[headerName];
          }
          return headerValue;
        };
        Utilities2.timer = function() {
          var timeStart = (/* @__PURE__ */ new Date()).getTime();
          return {
            get milliSecondsElapsed() {
              var ms = (/* @__PURE__ */ new Date()).getTime() - timeStart;
              return ms;
            }
          };
        };
        Utilities2.concatArrays = function(arr1, arr2) {
          if (!Utilities2.isNullOrUndefined(arr1) && !Utilities2.isNullOrUndefined(arr2)) {
            arr2.forEach(function(entry) {
              arr1.push(entry);
            });
          }
        };
        return Utilities2;
      }()
    );
    exports2.default = Utilities;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/logging/IC3TelemetryEvent.js
var require_IC3TelemetryEvent = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/logging/IC3TelemetryEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var IC3TelemetryEvent;
    (function(IC3TelemetryEvent2) {
      IC3TelemetryEvent2["JoinConversation"] = "JoinConversation";
      IC3TelemetryEvent2["RegisterOnNewMessage"] = "RegisterOnNewMessage";
      IC3TelemetryEvent2["RegisterOnThreadUpdate"] = "RegisterOnThreadUpdate";
      IC3TelemetryEvent2["OnNewMessageFailure"] = "OnNewMessageFailure";
      IC3TelemetryEvent2["OnThreadUpdateFailure"] = "OnThreadUpdateFailure";
      IC3TelemetryEvent2["SendLiveStateFailure"] = "SendLiveStateFailure";
      IC3TelemetryEvent2["JoinConversationV1GetThreadRequestFailed"] = "JoinConversationV1GetThreadRequestFailed";
      IC3TelemetryEvent2["UpdateToken"] = "UpdateToken";
      IC3TelemetryEvent2["SyncingPollData"] = "SyncingPollData";
      IC3TelemetryEvent2["IC3InitializationBegins"] = "IC3InitializationBegins";
      IC3TelemetryEvent2["IC3StartedPolling"] = "IC3StartedPolling";
      IC3TelemetryEvent2["IC3StoppedPolling"] = "IC3StoppedPolling";
      IC3TelemetryEvent2["IC3EndpointCreationSuccess"] = "IC3EndpointCreationSuccess";
      IC3TelemetryEvent2["RedirectOnRequestCreationFailure"] = "RedirectOnRequestCreationFailure";
      IC3TelemetryEvent2["ResetOnRequestCreationFailure"] = "ResetOnRequestCreationFailure";
      IC3TelemetryEvent2["MaxRetryCountReachedForRedirect"] = "MaxRetryCountReachedForRedirect";
      IC3TelemetryEvent2["OnRequestCreationFailureRedirect"] = "OnRequestCreationFailureRedirect";
      IC3TelemetryEvent2["OnRequestCreationSuccessRedirect"] = "OnRequestCreationSuccessRedirect";
      IC3TelemetryEvent2["ErrorDuringPolling"] = "ErrorDuringPolling";
      IC3TelemetryEvent2["HTTPRequestFailed"] = "HTTPRequestFailed";
      IC3TelemetryEvent2["HTTPRequestUnusualResponse"] = "HTTPRequestUnusualResponse";
    })(IC3TelemetryEvent || (IC3TelemetryEvent = {}));
    exports2.default = IC3TelemetryEvent;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/logging/LogLevel.js
var require_LogLevel = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/logging/LogLevel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2["INFO"] = "INFO";
      LogLevel2["DEBUG"] = "DEBUG";
      LogLevel2["WARN"] = "WARN";
      LogLevel2["ERROR"] = "ERROR";
    })(LogLevel || (LogLevel = {}));
    exports2.default = LogLevel;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/http/HttpCode.js
var require_HttpCode = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/http/HttpCode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var HttpCode = (
      /** @class */
      function() {
        function HttpCode2() {
        }
        HttpCode2.OK = 200;
        HttpCode2.Created = 201;
        HttpCode2.Accepted = 202;
        HttpCode2.NoContent = 204;
        HttpCode2.Unauthorized = 401;
        HttpCode2.Forbidden = 403;
        HttpCode2.Redirect = 404;
        HttpCode2.TooManyRequests = 429;
        HttpCode2.InternalServerError = 500;
        HttpCode2.ServiceUnavailable = 503;
        HttpCode2.NotFound = 729;
        return HttpCode2;
      }()
    );
    exports2.default = HttpCode;
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber2(val) {
      return typeof val === "number";
    }
    function isObject3(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob2(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject3(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str2) {
      return str2.trim ? str2.trim() : str2.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend2(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber: isNumber2,
      isObject: isObject3,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob: isBlob2,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend: extend2,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports2, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders2(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders2 = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders2(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(resolve, reject, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject(cancel);
            request = null;
          });
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status2) {
        return status2 >= 200 && status2 < 300;
      }
    };
    defaults.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context3 = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context3, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      var valueFromConfig2Keys = ["url", "method", "data"];
      var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
      var defaultToConfig2Keys = [
        "baseURL",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "timeoutMessage",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "decompress",
        "maxContentLength",
        "maxBodyLength",
        "maxRedirects",
        "transport",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath",
        "responseEncoding"
      ];
      var directMergeKeys = ["validateStatus"];
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      }
      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        }
      });
      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
      var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils.forEach(otherKeys, mergeDeepProperties);
      return config;
    };
  }
});

// node_modules/axios/package.json
var require_package = __commonJS({
  "node_modules/axios/package.json"(exports2, module2) {
    module2.exports = {
      name: "axios",
      version: "0.21.4",
      description: "Promise based HTTP client for the browser and node.js",
      main: "index.js",
      scripts: {
        test: "grunt test",
        start: "node ./sandbox/server.js",
        build: "NODE_ENV=production grunt build",
        preversion: "npm test",
        version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
        postversion: "git push && git push --tags",
        examples: "node ./examples/server.js",
        coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
        fix: "eslint --fix lib/**/*.js"
      },
      repository: {
        type: "git",
        url: "https://github.com/axios/axios.git"
      },
      keywords: [
        "xhr",
        "http",
        "ajax",
        "promise",
        "node"
      ],
      author: "Matt Zabriskie",
      license: "MIT",
      bugs: {
        url: "https://github.com/axios/axios/issues"
      },
      homepage: "https://axios-http.com",
      devDependencies: {
        coveralls: "^3.0.0",
        "es6-promise": "^4.2.4",
        grunt: "^1.3.0",
        "grunt-banner": "^0.6.0",
        "grunt-cli": "^1.2.0",
        "grunt-contrib-clean": "^1.1.0",
        "grunt-contrib-watch": "^1.0.0",
        "grunt-eslint": "^23.0.0",
        "grunt-karma": "^4.0.0",
        "grunt-mocha-test": "^0.13.3",
        "grunt-ts": "^6.0.0-beta.19",
        "grunt-webpack": "^4.0.2",
        "istanbul-instrumenter-loader": "^1.0.0",
        "jasmine-core": "^2.4.1",
        karma: "^6.3.2",
        "karma-chrome-launcher": "^3.1.0",
        "karma-firefox-launcher": "^2.1.0",
        "karma-jasmine": "^1.1.1",
        "karma-jasmine-ajax": "^0.1.13",
        "karma-safari-launcher": "^1.0.0",
        "karma-sauce-launcher": "^4.3.6",
        "karma-sinon": "^1.0.5",
        "karma-sourcemap-loader": "^0.3.8",
        "karma-webpack": "^4.0.2",
        "load-grunt-tasks": "^3.5.2",
        minimist: "^1.2.0",
        mocha: "^8.2.1",
        sinon: "^4.5.0",
        "terser-webpack-plugin": "^4.2.3",
        typescript: "^4.0.5",
        "url-search-params": "^0.10.0",
        webpack: "^4.44.2",
        "webpack-dev-server": "^3.11.0"
      },
      browser: {
        "./lib/adapters/http.js": "./lib/adapters/xhr.js"
      },
      jsdelivr: "dist/axios.min.js",
      unpkg: "dist/axios.min.js",
      typings: "./index.d.ts",
      dependencies: {
        "follow-redirects": "^1.14.0"
      },
      bundlesize: [
        {
          path: "./dist/axios.min.js",
          threshold: "5kB"
        }
      ]
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    var pkg = require_package();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split(".");
    function isOlderVersion(version2, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
      var destVer = version2.split(".");
      for (var i = 0; i < 3; i++) {
        if (pkgVersionArr[i] > destVer[i]) {
          return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
          return false;
        }
      }
      return false;
    }
    validators.transitional = function transitional(validator, version2, message) {
      var isDeprecated = version2 && isOlderVersion(version2);
      function formatMessage(opt, desc) {
        return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed in " + version2));
        }
        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      isOlderVersion,
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context3 = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context3);
      utils.extend(instance, Axios.prototype, context3);
      utils.extend(instance, context3);
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module2.exports = axios;
    module2.exports.default = axios;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios();
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/http/HttpClient.js
var require_HttpClient = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/http/HttpClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = void 0;
    var Utilities_1 = require_Utilities();
    var Constants_1 = require_Constants();
    var IC3TelemetryEvent_1 = require_IC3TelemetryEvent();
    var LogLevel_1 = require_LogLevel();
    var HttpHeaders_1 = require_HttpHeaders();
    var HttpCode_1 = require_HttpCode();
    var axios_1 = require_axios2();
    var HttpClient = (
      /** @class */
      function() {
        function HttpClient2() {
        }
        HttpClient2.MakeRequest = function(requestAttributes) {
          var responsePromise = new Promise(function(resolve, reject) {
            function onSuccess(data, response) {
              if (response.status >= 400) {
                var exceptionDetails = {
                  ResponseText: response.statusText,
                  Status: status
                };
                HttpClient2.logWarning("Requesting " + requestAttributes.url, response.status, exceptionDetails);
              }
              if (requestAttributes.callbackOnSuccess) {
                requestAttributes.callbackOnSuccess(response);
              }
              resolve(data);
            }
            function onFailure(error) {
              var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
              var exceptionDetails = {
                ErrorThrown: error.message,
                ResponseText: (_a2 = error.response) === null || _a2 === void 0 ? void 0 : _a2.statusText,
                Status: (_b = error.response) === null || _b === void 0 ? void 0 : _b.status
              };
              var rejectAsError = function() {
                var _a3, _b2;
                HttpClient2.logError("Request to " + requestAttributes.url + " failed.", ((_a3 = error.response) === null || _a3 === void 0 ? void 0 : _a3.status) || 0, exceptionDetails);
                reject(new Error(((_b2 = error.response) === null || _b2 === void 0 ? void 0 : _b2.statusText) || ""));
              };
              var rejectAsRedirect = function() {
                var _a3;
                HttpClient2.logError("Request to " + requestAttributes.url + " failed. Resetting endpoint.", ((_a3 = error.response) === null || _a3 === void 0 ? void 0 : _a3.status) || 0, exceptionDetails);
                if (requestAttributes.callbackOnFailure) {
                  requestAttributes.callbackOnFailure(error);
                }
                reject(new Error(Constants_1.default.Reset_Flag));
              };
              var retry3 = function() {
                var _a3;
                currentRetryCount++;
                var timeBetweenRetry = requestAttributes.timeBetweenRetry || 0;
                if (requestAttributes.enableExponentialBackoff || ((_a3 = error.response) === null || _a3 === void 0 ? void 0 : _a3.status) === HttpCode_1.default.TooManyRequests) {
                  timeBetweenRetry = timeBetweenRetry * Math.exp(currentRetryCount);
                }
                setTimeout(function() {
                  makeAxiosRequest();
                }, timeBetweenRetry);
              };
              var locationHeader = (_c = error.response) === null || _c === void 0 ? void 0 : _c.headers[HttpHeaders_1.default.LocationHeader];
              var registrationTokenHeader = (_d = error.response) === null || _d === void 0 ? void 0 : _d.headers[HttpHeaders_1.default.SetRegistrationTokenHeader];
              if (((_e = error.response) === null || _e === void 0 ? void 0 : _e.status) === HttpCode_1.default.Redirect && !Utilities_1.default.isNullOrEmptyString(locationHeader)) {
                if (requestAttributes.shouldRedirectOn404) {
                  rejectAsRedirect();
                } else if (currentRetryCount <= maxRetryCount) {
                  requestAttributes.url = locationHeader;
                  retry3();
                } else {
                  rejectAsError();
                }
              } else if ((((_f = error.response) === null || _f === void 0 ? void 0 : _f.status) === HttpCode_1.default.Unauthorized || ((_g = error.response) === null || _g === void 0 ? void 0 : _g.status) === HttpCode_1.default.Forbidden) && !Utilities_1.default.isNullOrEmptyString(registrationTokenHeader)) {
                if (currentRetryCount <= maxRetryCount && requestAttributes.shouldRetryOnFailure && requestAttributes.shouldRetryOnFailure(((_h = error.response) === null || _h === void 0 ? void 0 : _h.status) || 0)) {
                  if (requestAttributes.headers) {
                    requestAttributes.headers[HttpHeaders_1.default.RegistrationTokenHeader] = Utilities_1.default.getRegistrationTokenValue(registrationTokenHeader);
                  }
                  retry3();
                } else if (requestAttributes.shouldResetOnFailure) {
                  rejectAsRedirect();
                } else {
                  rejectAsError();
                }
              } else {
                if (currentRetryCount <= maxRetryCount && requestAttributes.shouldRetryOnFailure && requestAttributes.shouldRetryOnFailure(((_j = error.response) === null || _j === void 0 ? void 0 : _j.status) || 0) || ((_k = error.response) === null || _k === void 0 ? void 0 : _k.status) === HttpCode_1.default.TooManyRequests) {
                  retry3();
                } else if (requestAttributes.shouldResetOnFailure) {
                  rejectAsRedirect();
                } else {
                  rejectAsError();
                }
              }
            }
            var currentRetryCount = 0;
            var maxRetryCount = requestAttributes.retryCount || 1;
            var axiosConfig = {
              url: requestAttributes.url,
              method: requestAttributes.type,
              data: requestAttributes.data,
              timeout: requestAttributes.timeout,
              headers: requestAttributes.headers,
              withCredentials: requestAttributes.useXHRWithCredentials || false
            };
            var makeAxiosRequest = function() {
              axios_1.default.request(axiosConfig).then(function(response) {
                onSuccess(response.data, response);
              }).catch(function(error) {
                onFailure(error);
              });
            };
            makeAxiosRequest();
          });
          return responsePromise;
        };
        HttpClient2.isClientError = function(e) {
          if (!e) {
            return false;
          }
          var errorMsg = e.message;
          var isClientError = false;
          if (!Utilities_1.default.isNullOrEmptyString(errorMsg)) {
            isClientError = errorMsg.search(/Status- 40\d/) >= -1;
          }
          return isClientError;
        };
        HttpClient2.setLogger = function(logger5) {
          HttpClient2.logger = logger5;
        };
        HttpClient2.logError = function(errorDescription, errorCode, errorResponse) {
          if (HttpClient2.logger) {
            HttpClient2.logger.log(LogLevel_1.default.ERROR, IC3TelemetryEvent_1.default.HTTPRequestFailed, {
              Description: errorDescription,
              ErrorCode: errorCode.toString(),
              ExceptionDetails: errorResponse
            });
          }
        };
        HttpClient2.logWarning = function(warningDescription, warningCode, warningResponse) {
          if (HttpClient2.logger) {
            HttpClient2.logger.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.HTTPRequestUnusualResponse, {
              Description: warningDescription,
              ErrorCode: warningCode.toString(),
              ExceptionDetails: warningResponse
            });
          }
        };
        return HttpClient2;
      }()
    );
    exports2.HttpClient = HttpClient;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/common/ServiceEndpointHelper.js
var require_ServiceEndpointHelper = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/common/ServiceEndpointHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Constants_1 = require_Constants();
    var HttpHeaders_1 = require_HttpHeaders();
    var Utilities_1 = require_Utilities();
    var ServiceEndpointHelper = (
      /** @class */
      function() {
        function ServiceEndpointHelper2() {
        }
        ServiceEndpointHelper2.getV2EndpointUrl = function(epid, regionGtms) {
          return regionGtms.chatService + "/v2/users/ME/endpoints/" + epid;
        };
        ServiceEndpointHelper2.getThreadUrl = function(threadId, regionGtms) {
          return regionGtms.chatService + "/v1/threads/" + threadId + "?view=msnp24Equivalent";
        };
        ServiceEndpointHelper2.getMessagesUrl = function(threadId, regionGtms) {
          return regionGtms.chatService + "/v1/users/ME/conversations/" + threadId + "/messages";
        };
        ServiceEndpointHelper2.getBotMessagesUrl = function(botId, regionGtms) {
          return regionGtms.chatService + "/v1/agents/" + botId + "/invoke";
        };
        ServiceEndpointHelper2.getAmsObjectsUrl = function(regionGtms) {
          return Utilities_1.default.sanitizeUrlWithBackSlash(regionGtms.ams) + "v1/objects";
        };
        ServiceEndpointHelper2.getAmsObjectContentUrl = function(id, regionGtms, isImageFile) {
          if (isImageFile === void 0) {
            isImageFile = false;
          }
          var cloudDataContent = isImageFile ? Constants_1.default.ImageContent : Constants_1.default.FileContent;
          return Utilities_1.default.sanitizeUrlWithBackSlash(regionGtms.ams) + "v1/objects/" + id + "/content/" + cloudDataContent;
        };
        ServiceEndpointHelper2.getAmsObjectViewUrl = function(id, regionGtms, isImageFile) {
          if (isImageFile === void 0) {
            isImageFile = false;
          }
          var fileView = isImageFile ? Constants_1.default.ImageView : Constants_1.default.FileView;
          return Utilities_1.default.sanitizeUrlWithBackSlash(regionGtms.ams) + "v1/objects/" + id + "/views/" + fileView;
        };
        ServiceEndpointHelper2.getAmsStatusUrl = function(id, regionGtms, isImageFile) {
          if (isImageFile === void 0) {
            isImageFile = false;
          }
          var fileView = isImageFile ? Constants_1.default.ImageView : Constants_1.default.FileView;
          var url = Utilities_1.default.sanitizeUrlWithBackSlash(regionGtms.ams) + "v1/objects/" + id + "/views/" + fileView + "/status";
          return url;
        };
        ServiceEndpointHelper2.getV1EndpointUrl = function(regionGtms) {
          return regionGtms.chatService + "/v1/users/ME/endpoints";
        };
        ServiceEndpointHelper2.getV1DeleteEndpointUrl = function(regionGtms, epid) {
          return regionGtms.chatService + "/v1/users/ME/endpoints/" + epid;
        };
        ServiceEndpointHelper2.getV1SubscriptionUrl = function(regionGtms) {
          return regionGtms.chatService + "/v1/users/ME/endpoints/SELF/subscriptions";
        };
        ServiceEndpointHelper2.getV1PollUrl = function(regionGtms, sid) {
          return regionGtms.chatService + "/v1/users/ME/endpoints/SELF/subscriptions/" + sid + "/poll";
        };
        ServiceEndpointHelper2.getV1SetPropertiesUrl = function(regionGtms) {
          return regionGtms.chatService + "/v1/users/ME/endpoints/SELF/properties?name=" + HttpHeaders_1.default.SetEndpointProperty;
        };
        return ServiceEndpointHelper2;
      }()
    );
    exports2.default = ServiceEndpointHelper;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/http/RequestHelper.js
var require_RequestHelper = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/http/RequestHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Constants_1 = require_Constants();
    var uuid_1 = require_uuid();
    var RequestHelper = (
      /** @class */
      function() {
        function RequestHelper2() {
        }
        RequestHelper2.getDefaultIC3Headers = function() {
          return {
            Accept: Constants_1.default.ContentTypeJson,
            BehaviorOverride: Constants_1.default.RedirectAs404,
            ClientInfo: Constants_1.default.ClientInfoValue,
            ContextId: "tcid=" + (0, uuid_1.uuidv4)(),
            Expires: 0,
            Pragma: Constants_1.default.NoCache,
            "x-ms-client-type": Constants_1.default.Web,
            "x-ms-user-type": Constants_1.default.User
          };
        };
        RequestHelper2.getDefaultBaseIC3Headers = function() {
          return {
            Accept: Constants_1.default.ContentTypeJson,
            BehaviorOverride: Constants_1.default.RedirectAs404,
            "content-type": Constants_1.default.ContentTypeJson
          };
        };
        RequestHelper2.getDefaultGetMessagesQueryParameters = function() {
          return {
            pageSize: 20,
            startTime: 0,
            view: "msnp24Equivalent|supportsMessageProperties"
          };
        };
        RequestHelper2.getDefaultAMSHeaders = function(token) {
          return {
            Authorization: Constants_1.default.AMSAuthorizationSkypeTokenValue + token,
            "X-MS-Client-Version": Constants_1.default.ClientInfoValue
          };
        };
        RequestHelper2.getDefaultAMSViewHeaders = function(token) {
          return {
            Accept: Constants_1.default.AMSAcceptHeaderValue,
            "Accept-Encoding": Constants_1.default.AMSAcceptEncodingHeaderValue,
            Authorization: Constants_1.default.AMSAuthorizationSkypeTokenValue + token,
            "X-MS-Client-Version": Constants_1.default.ClientInfoValue
          };
        };
        return RequestHelper2;
      }()
    );
    exports2.default = RequestHelper;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/ams/AMSFilePermissions.js
var require_AMSFilePermissions = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/ams/AMSFilePermissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var AMSFilePermissions = (
      /** @class */
      function() {
        function AMSFilePermissions2() {
        }
        AMSFilePermissions2.read = "read";
        return AMSFilePermissions2;
      }()
    );
    exports2.default = AMSFilePermissions;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/model/FileStatus.js
var require_FileStatus = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/model/FileStatus.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var FileStatus;
    (function(FileStatus2) {
      FileStatus2[FileStatus2["Unknown"] = 0] = "Unknown";
      FileStatus2[FileStatus2["InProgress"] = 1] = "InProgress";
      FileStatus2[FileStatus2["Success"] = 2] = "Success";
      FileStatus2[FileStatus2["Error"] = 3] = "Error";
    })(FileStatus || (FileStatus = {}));
    exports2.default = FileStatus;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/model/FileSharingProtocolType.js
var require_FileSharingProtocolType = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/model/FileSharingProtocolType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var FileSharingProtocolType;
    (function(FileSharingProtocolType2) {
      FileSharingProtocolType2[FileSharingProtocolType2["AmsBasedFileSharing"] = 0] = "AmsBasedFileSharing";
    })(FileSharingProtocolType || (FileSharingProtocolType = {}));
    exports2.default = FileSharingProtocolType;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/model/MessagePayloadType.js
var require_MessagePayloadType = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/model/MessagePayloadType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var MessagePayloadType = (
      /** @class */
      function() {
        function MessagePayloadType2() {
        }
        MessagePayloadType2.Text = "Text";
        MessagePayloadType2.RichText = "RichText";
        MessagePayloadType2.RichTextHtml = "RichText/Html";
        MessagePayloadType2.ControlTyping = "Control/Typing";
        MessagePayloadType2.ControlClearTyping = "Control/ClearTyping";
        MessagePayloadType2.LiveState = "Control/LiveState";
        return MessagePayloadType2;
      }()
    );
    exports2.default = MessagePayloadType;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/model/TypingStatus.js
var require_TypingStatus = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/model/TypingStatus.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TypingStatus;
    (function(TypingStatus2) {
      TypingStatus2[TypingStatus2["Typing"] = 0] = "Typing";
      TypingStatus2[TypingStatus2["ClearTyping"] = 1] = "ClearTyping";
    })(TypingStatus || (TypingStatus = {}));
    exports2.default = TypingStatus;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/common/Util.js
var require_Util = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/common/Util.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Constants_1 = require_Constants();
    var DeliveryMode_1 = require_DeliveryMode();
    var FileSharingProtocolType_1 = require_FileSharingProtocolType();
    var HttpCode_1 = require_HttpCode();
    var MessageContentType_1 = require_MessageContentType();
    var MessagePayloadType_1 = require_MessagePayloadType();
    var MessageType_1 = require_MessageType();
    var PersonType_1 = require_PersonType();
    var ServiceEndpointHelper_1 = require_ServiceEndpointHelper();
    var TypingStatus_1 = require_TypingStatus();
    var Utilities_1 = require_Utilities();
    var Util = (
      /** @class */
      function() {
        function Util2() {
        }
        Util2.createMessageData = function(message) {
          var messageType = message.contentType === MessageContentType_1.default.Text ? MessagePayloadType_1.default.Text : MessagePayloadType_1.default.RichTextHtml;
          var encodedMessage = message.content;
          var messageData = Util2.createBaseMessageData(messageType, message.contentType.toString(), encodedMessage);
          messageData.properties = this.getMessageProperties(message);
          if (!Utilities_1.default.isNullOrUndefined(message.sender.displayName)) {
            messageData.imdisplayname = message.sender.displayName;
          }
          return messageData;
        };
        Util2.createBaseMessageData = function(messagetype, contenttype, content) {
          var messageData = {
            "Has-Mentions": "false",
            clientmessageid: Date.now().toString(),
            composetime: (/* @__PURE__ */ new Date()).toISOString(),
            content,
            contenttype,
            messagetype
          };
          return messageData;
        };
        Util2.getMessageProperties = function(message) {
          var properties = {};
          properties.deliveryMode = message.deliveryMode.toString();
          if (message.tags) {
            var tags_1 = [];
            message.tags.forEach(function(tagName) {
              tags_1.push(tagName);
            });
            properties.tags = tags_1.join();
          }
          return properties;
        };
        Util2.createTypingStatusThreadMessageData = function(typingStatus, optionalProperties) {
          var messageType = "";
          switch (typingStatus) {
            case TypingStatus_1.default.Typing:
              messageType = MessagePayloadType_1.default.ControlTyping;
              break;
            case TypingStatus_1.default.ClearTyping:
              messageType = MessagePayloadType_1.default.ControlClearTyping;
              break;
          }
          var messageData = Util2.createBaseMessageData(messageType, MessageContentType_1.default.Text, "");
          if (!Utilities_1.default.isNullOrUndefined(optionalProperties)) {
            messageData = __assign(__assign({}, optionalProperties), messageData);
          }
          return messageData;
        };
        Util2.createBotMessageData = function(conversationId, message) {
          var botMessage = {
            conversation: {
              id: conversationId
            },
            value: message
          };
          return JSON.stringify(botMessage);
        };
        Util2.createFileMessage = function(filemetadata, ic3Info, message) {
          var messageType = MessagePayloadType_1.default.Text;
          var contentType2 = MessageContentType_1.default.Text.toString().toLowerCase();
          var messageData = Util2.createBaseMessageData(messageType, contentType2.toString(), "");
          messageData.amsreferences = JSON.stringify([filemetadata.id]);
          messageData.properties = JSON.stringify(this.createFileMessageProperties(filemetadata, ic3Info, message));
          if (!Utilities_1.default.isNullOrUndefined(message.sender.displayName)) {
            messageData.imdisplayname = message.sender.displayName;
          }
          return messageData;
        };
        Util2.createFileMessageProperties = function(fileInfo, ic3Info, message) {
          var properties = {};
          properties.deliveryMode = message.deliveryMode.toString();
          properties.files = JSON.stringify([this.createFileProperty(fileInfo, ic3Info)]);
          properties.importance = "";
          properties.subject = "";
          if (message.tags) {
            var tags_2 = [];
            message.tags.forEach(function(tagName) {
              tags_2.push(tagName);
            });
            properties.tags = tags_2.join();
          }
          return properties;
        };
        Util2.createFileProperty = function(fileInfo, ic3Info) {
          var isFileImage = Util2.isDocumentTypeImage(fileInfo.type) ? true : false;
          return {
            "@type": "http://schema.skype.com/File",
            "type": fileInfo.type,
            "itemid": "",
            "baseUrl": "",
            "providerData": "",
            "version": 2,
            "id": fileInfo.id,
            "title": fileInfo.name,
            "state": "active",
            "objectUrl": ServiceEndpointHelper_1.default.getAmsObjectViewUrl(fileInfo.id, ic3Info.RegionGtms, isFileImage),
            "fileName": fileInfo.name,
            "fileType": Util2.getNameAndExtension(fileInfo.name).extension,
            "botFileProperties": {
              url: ServiceEndpointHelper_1.default.getAmsObjectViewUrl(fileInfo.id, ic3Info.RegionGtms, isFileImage)
            },
            "fileInfo": {
              fileUrl: ServiceEndpointHelper_1.default.getAmsObjectContentUrl(fileInfo.id, ic3Info.RegionGtms, isFileImage),
              siteUrl: "",
              serverRelativeUrl: ""
            },
            "filePreview": {
              previewUrl: ""
            }
          };
        };
        Util2.getNameAndExtension = function(filename) {
          var nameAndExtensionMatcher = (filename || "").split(".");
          var name = "";
          var extension = "";
          if (nameAndExtensionMatcher.length > 1) {
            extension = nameAndExtensionMatcher.pop().toLowerCase();
            name = nameAndExtensionMatcher.join(".");
          } else {
            extension = "";
            name = nameAndExtensionMatcher[0];
          }
          return { name, extension };
        };
        Util2.createIRawMessage = function(message, ic3Info, resourceType) {
          var rawMessage = {
            clientmessageid: message.clientmessageid,
            content: message.content,
            contentType: Util2.getMessageContentType(message),
            deliveryMode: !Utilities_1.default.isNullOrUndefined(message.properties) && message.properties.deliveryMode === DeliveryMode_1.default.Bridged ? DeliveryMode_1.default.Bridged : DeliveryMode_1.default.Unbridged,
            messageType: Util2.getMessageType(message),
            properties: message.properties,
            sender: { displayName: message.imdisplayname, id: message.from, type: Util2.getPersonType(message.from) },
            timestamp: new Date(Date.parse(message.originalarrivaltime))
          };
          if (resourceType) {
            rawMessage.resourceType = resourceType;
          }
          if (!Utilities_1.default.isNullOrUndefined(message.properties)) {
            if (!Utilities_1.default.isNullOrEmptyString(message.properties.tags)) {
              var tagsReceived = [];
              tagsReceived = message.properties.tags.split(",");
              rawMessage.tags = tagsReceived;
            }
          }
          if (!Utilities_1.default.isNullOrUndefined(message.properties)) {
            if (!Utilities_1.default.isNullOrEmptyString(message.properties.files)) {
              var filesRecieved = [];
              filesRecieved = JSON.parse(message.properties.files);
              if (filesRecieved.length > 0) {
                var fileId = filesRecieved[0].id;
                if (Utilities_1.default.isNullOrUndefined(fileId) && message.amsreferences) {
                  fileId = message.amsreferences[0];
                }
                var fileUrl = Util2.getFileUrl(filesRecieved[0], fileId, ic3Info);
                var fileMetadata = {
                  fileSharingProtocolType: FileSharingProtocolType_1.default.AmsBasedFileSharing,
                  id: fileId,
                  name: filesRecieved[0].fileName,
                  size: filesRecieved[0].version,
                  type: filesRecieved[0].fileType,
                  url: fileUrl
                };
                rawMessage.fileMetadata = fileMetadata;
              }
            }
          }
          return rawMessage;
        };
        Util2.createIRawThread = function(message) {
          var rawThread = {
            id: message.id,
            members: message.members,
            messages: message.messages,
            properties: message.properties,
            rosterVersion: message.rosterVersion,
            type: message.type,
            version: message.version
          };
          return rawThread;
        };
        Util2.getConversationIdFromUrl = function(url) {
          var matches = url && url.match(/\/(\d+:[^\/]*)[\/]?/);
          return matches && matches[1] ? matches[1] : void 0;
        };
        Util2.isSystemMessage = function(message) {
          var isSystemMessage = false;
          if (!Utilities_1.default.isNullOrEmptyString(message.messagetype)) {
            isSystemMessage = Util2.getSystemMessageTypes().reduce(function(isSystemMessageTillNow, systemMessageType) {
              return isSystemMessageTillNow || message.messagetype.toLowerCase().indexOf(systemMessageType.toLowerCase()) === 0;
            }, isSystemMessage);
          }
          return isSystemMessage;
        };
        Util2.getPersonType = function(personId) {
          var personType = PersonType_1.default.Unknown;
          var sanitizedPersonId = personId.split("/").pop();
          if (sanitizedPersonId.indexOf("28:") === 0) {
            personType = PersonType_1.default.Bot;
          } else if (sanitizedPersonId.indexOf("19:") === 0) {
            personType = PersonType_1.default.User;
          }
          return personType;
        };
        Util2.isImageType = function(fileType) {
          switch (fileType.toLowerCase()) {
            case "jpeg":
            case "jpg":
            case "gif":
            case "png":
            case "bmp":
            case "tiff":
            case "jfif":
              return true;
            default:
              return false;
          }
        };
        Util2.getMessageType = function(message) {
          var messageType;
          switch (message.messagetype) {
            case MessageType_1.default.Typing:
              messageType = MessageType_1.default.Typing;
              break;
            case MessageType_1.default.ClearTyping:
              messageType = MessageType_1.default.ClearTyping;
              break;
            default:
              messageType = MessageType_1.default.UserMessage;
          }
          return messageType;
        };
        Util2.getMessageContentType = function(message) {
          var messageContentType;
          var contentType2 = message.contenttype ? message.contenttype : message.messagetype;
          if (contentType2 === MessagePayloadType_1.default.Text.toLowerCase()) {
            messageContentType = MessageContentType_1.default.Text;
          } else if (contentType2.indexOf(Constants_1.default.TextPlainMimeType) >= 0) {
            messageContentType = MessageContentType_1.default.Text;
          } else {
            messageContentType = MessageContentType_1.default.RichText;
          }
          return messageContentType;
        };
        Util2.getSystemMessageTypes = function() {
          return [
            "ThreadActivity"
          ];
        };
        Util2.getFileUrl = function(fileProperty, fileId, ic3Info) {
          var fileInfo = fileProperty.fileInfo;
          var fileUrl;
          if (fileInfo && fileInfo.fileUrl) {
            fileUrl = fileInfo.fileUrl;
          } else if (fileId) {
            var isFileImage = Util2.isImageType(fileProperty.fileType);
            fileUrl = ServiceEndpointHelper_1.default.getAmsObjectContentUrl(fileId, ic3Info.RegionGtms, isFileImage);
          }
          return fileUrl;
        };
        Util2.isDocumentTypeImage = function(contentType2) {
          return contentType2.indexOf(Constants_1.default.Image) !== -1;
        };
        Util2.getDomainRegexp = function() {
          return new RegExp(/^(https?:.+?\.microsoft\.com)/i);
        };
        Util2.parseDomain = function(url) {
          var match = url.match(Util2.getDomainRegexp());
          if (match) {
            return match[1];
          }
          return null;
        };
        Util2.parseChatServiceHostUrl = function(url) {
          return Util2.parseDomain(url);
        };
        Util2.shouldRetryOnFailure = function(status2) {
          return status2 !== HttpCode_1.default.Accepted && status2 !== HttpCode_1.default.Created;
        };
        return Util2;
      }()
    );
    exports2.default = Util;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/ams/AmsHelper.js
var require_AmsHelper = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/ams/AmsHelper.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f3, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f3 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Constants_1 = require_Constants();
    var HttpHeaders_1 = require_HttpHeaders();
    var HttpRequestType_1 = require_HttpRequestType();
    var HttpClient_1 = require_HttpClient();
    var ServiceEndpointHelper_1 = require_ServiceEndpointHelper();
    var RequestHelper_1 = require_RequestHelper();
    var AMSFilePermissions_1 = require_AMSFilePermissions();
    var FileStatus_1 = require_FileStatus();
    var Util_1 = require_Util();
    var AmsHelper = (
      /** @class */
      function() {
        function AmsHelper2() {
        }
        AmsHelper2.getDocumentTypeFromContentType = function(contentType2) {
          return Util_1.default.isDocumentTypeImage(contentType2) ? Constants_1.default.DocumentTypeImage : Constants_1.default.DocumentTypeFile;
        };
        AmsHelper2.createNewDocument = function(conversationId, file, ic3Info) {
          return __awaiter(this, void 0, void 0, function() {
            var permissions, body, url, headers, requestParameters;
            var _a2;
            return __generator(this, function(_b) {
              permissions = (_a2 = {}, _a2[conversationId] = [AMSFilePermissions_1.default[AMSFilePermissions_1.default.read]], _a2);
              body = {
                filename: file.name,
                permissions,
                type: AmsHelper2.getDocumentTypeFromContentType(file.type)
              };
              url = ServiceEndpointHelper_1.default.getAmsObjectsUrl(ic3Info.RegionGtms);
              headers = RequestHelper_1.default.getDefaultAMSHeaders(ic3Info.SkypeToken);
              headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeJson;
              requestParameters = {
                data: JSON.stringify(body),
                headers,
                type: HttpRequestType_1.default.POST,
                url
              };
              return [2, HttpClient_1.HttpClient.MakeRequest(requestParameters)];
            });
          });
        };
        AmsHelper2.uploadDocument = function(documentId, file, ic3Info) {
          return __awaiter(this, void 0, void 0, function() {
            var isFileImage, url, headers, requestParameters;
            return __generator(this, function(_a2) {
              console.log("AmsHelper.ts uploadDocument(): " + documentId + ", " + file + ", " + ic3Info);
              isFileImage = Util_1.default.isDocumentTypeImage(file.type);
              url = ServiceEndpointHelper_1.default.getAmsObjectContentUrl(documentId, ic3Info.RegionGtms, isFileImage);
              headers = RequestHelper_1.default.getDefaultAMSHeaders(ic3Info.SkypeToken);
              requestParameters = {
                data: file.data,
                headers,
                processData: false,
                type: HttpRequestType_1.default.PUT,
                url
              };
              return [2, HttpClient_1.HttpClient.MakeRequest(requestParameters)];
            });
          });
        };
        AmsHelper2.getFileStatus = function(fileInfo, ic3Info) {
          var isFileImage = Util_1.default.isImageType(fileInfo.type);
          var url = ServiceEndpointHelper_1.default.getAmsStatusUrl(fileInfo.id, ic3Info.RegionGtms, isFileImage);
          return this.getViewStatus(url, ic3Info).then(function(response) {
            var isScanFailed = response.scan && response.scan.status === Constants_1.default.Malware;
            if (isScanFailed) {
              return FileStatus_1.default.Error;
            }
            if (response.view_state === Constants_1.default.Ready) {
              return FileStatus_1.default.Success;
            }
            var isScanInProgress = response.scan && response.scan.status === Constants_1.default.InProgress;
            if (isScanInProgress) {
              return FileStatus_1.default.InProgress;
            }
            if (response.view_state && response.view_state !== Constants_1.default.Failed) {
              return FileStatus_1.default.InProgress;
            }
            return FileStatus_1.default.Error;
          }).catch(function() {
            return Promise.reject({});
          });
        };
        AmsHelper2.downloadDocument = function(fileMetadata, ic3Info) {
          var _this = this;
          var isFileImage = Util_1.default.isImageType(fileMetadata.type);
          var statusUri = ServiceEndpointHelper_1.default.getAmsStatusUrl(fileMetadata.id, ic3Info.RegionGtms, isFileImage);
          return new Promise(function(resolve) {
            _this.getViewUri(statusUri, ic3Info).then(function(vUrl) {
              var headers = new Headers();
              headers.append("Authorization", "skype_token " + ic3Info.SkypeToken);
              headers.append("X-MS-Client-Version", Constants_1.default.ClientVersion);
              if (isFileImage) {
                headers.append("accept", Constants_1.default.AMSAcceptHeaderValue);
                headers.append("Accept-Encoding", Constants_1.default.AMSAcceptEncodingHeaderValue);
              }
              var requestParameters = {
                headers,
                method: HttpRequestType_1.default.GET
              };
              return fetch(vUrl, requestParameters).then(function(response) {
                resolve(response.blob());
              }).catch(function() {
                return Promise.reject({});
              });
            });
          });
        };
        AmsHelper2.getViewUri = function(statusUri, ic3Info) {
          var _this = this;
          return this.getViewStatus(statusUri, ic3Info).then(function(response) {
            var isScanFailed = response.scan && response.scan.status === Constants_1.default.Malware;
            if (!response.view_location || response.view_state === Constants_1.default.Failed || isScanFailed) {
              return Promise.reject({});
            }
            if (response.view_state && response.view_state !== Constants_1.default.Ready) {
              return _this.getViewUri(statusUri, ic3Info);
            }
            if (response.content_state === Constants_1.default.Expired) {
              return Promise.reject({});
            }
            return Promise.resolve(response.view_location);
          }).catch(function() {
            return Promise.reject("");
          });
        };
        AmsHelper2.getViewStatus = function(url, ic3Info) {
          var _this = this;
          console.log("AmsHelper.ts getViewStatus(): " + url + ", " + ic3Info);
          return new Promise(function(resolve) {
            setTimeout(resolve, Constants_1.default.DelayForAms);
          }).then(function() {
            var headers = RequestHelper_1.default.getDefaultAMSViewHeaders(ic3Info.SkypeToken);
            var requestParameters = {
              headers,
              type: HttpRequestType_1.default.GET,
              url
            };
            return HttpClient_1.HttpClient.MakeRequest(requestParameters).then(function(response) {
              if (response.status_location && !response.view_state) {
                return _this.getViewStatus(response.status_location, ic3Info);
              }
              return Promise.resolve(response);
            }).catch(function(response) {
              if (response.status === 401 || response.status === 403) {
                return Promise.reject("unauthorized");
              }
              return Promise.reject({});
            });
          });
        };
        return AmsHelper2;
      }()
    );
    exports2.default = AmsHelper;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/http/HttpDataType.js
var require_HttpDataType = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/http/HttpDataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var HttpDataType = (
      /** @class */
      function() {
        function HttpDataType2() {
        }
        HttpDataType2.TEXT = "text";
        return HttpDataType2;
      }()
    );
    exports2.default = HttpDataType;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/interfaces/ProtocoleType.js
var require_ProtocoleType = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/interfaces/ProtocoleType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ProtocolType = (
      /** @class */
      function() {
        function ProtocolType2() {
        }
        ProtocolType2.IC3V1SDK = 0;
        ProtocolType2.IC3V2SDK = 1;
        ProtocolType2.MockIC3SDK = 2;
        return ProtocolType2;
      }()
    );
    exports2.default = ProtocolType;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/core/IC3ClientAdapter.js
var require_IC3ClientAdapter = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/core/IC3ClientAdapter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var AmsHelper_1 = require_AmsHelper();
    var Constants_1 = require_Constants();
    var FileSharingProtocolType_1 = require_FileSharingProtocolType();
    var FileStatus_1 = require_FileStatus();
    var HostType_1 = require_HostType();
    var HttpClient_1 = require_HttpClient();
    var HttpDataType_1 = require_HttpDataType();
    var HttpHeaders_1 = require_HttpHeaders();
    var HttpRequestType_1 = require_HttpRequestType();
    var IC3TelemetryEvent_1 = require_IC3TelemetryEvent();
    var LogLevel_1 = require_LogLevel();
    var MessageContentType_1 = require_MessageContentType();
    var MessagePayloadType_1 = require_MessagePayloadType();
    var ProtocoleType_1 = require_ProtocoleType();
    var RequestHelper_1 = require_RequestHelper();
    var ServiceEndpointHelper_1 = require_ServiceEndpointHelper();
    var Util_1 = require_Util();
    var Utilities_1 = require_Utilities();
    var IC3ClientAdapter = (
      /** @class */
      function() {
        function IC3ClientAdapter2(id) {
          this.hostType = HostType_1.default.Page;
          this.protocolType = ProtocoleType_1.default.IC3V1SDK;
          this.id = id;
          this.conversations = [];
          this.newConversationMessageListeners = {};
          this.threadUpdateListeners = {};
          this.internalConversationsData = {};
          this.liveStateFailureCount = 0;
          this.debug = false;
        }
        IC3ClientAdapter2.prototype.startPolling = function() {
          this.ic3Initializer && this.ic3Initializer.startPolling();
        };
        IC3ClientAdapter2.prototype.stopPolling = function() {
          this.ic3Initializer && this.ic3Initializer.stopPolling();
        };
        IC3ClientAdapter2.prototype.setup = function(setupParams) {
          this.logger = setupParams.logger;
          HttpClient_1.HttpClient.setLogger(this.logger);
          return Promise.resolve();
        };
        IC3ClientAdapter2.prototype.initialize = function(sessionInfo) {
          this.setupSession(sessionInfo);
          return Promise.resolve();
        };
        IC3ClientAdapter2.prototype.update = function(_sessionInfo) {
          return Promise.resolve();
        };
        IC3ClientAdapter2.prototype.dispose = function() {
          this.conversations = [];
          this.newConversationMessageListeners = {};
          this.threadUpdateListeners = {};
          this.internalConversationsData = {};
          return Promise.resolve();
        };
        IC3ClientAdapter2.prototype.joinConversation = function(conversationId, sendHeartBeat) {
          var _a2;
          if (sendHeartBeat === void 0) {
            sendHeartBeat = true;
          }
          var timer = Utilities_1.default.timer();
          var conversation = {
            id: conversationId
          };
          var conversationIndex = this.conversations.findIndex(function(conv) {
            return conv.id === conversation.id;
          });
          if (conversationIndex === -1) {
            this.conversations.push(conversation);
            this.newConversationMessageListeners[conversation.id] = this.newConversationMessageListeners[conversation.id] || [];
            this.threadUpdateListeners[conversation.id] = this.threadUpdateListeners[conversation.id] || [];
          }
          (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.JoinConversation, {
            ElapsedTimeInMilliseconds: timer.milliSecondsElapsed,
            EndpointUrl: this.EndpointUrl,
            EndpointId: this.EndpointId
          });
          if (!Utilities_1.default.isNullOrUndefined(sendHeartBeat) && sendHeartBeat === true) {
            this.sendHeartBeat(conversation.id);
          }
          return Promise.resolve(conversation);
        };
        IC3ClientAdapter2.prototype.sendLiveState = function(conversationId) {
          var _this = this;
          this.debug && console.debug("IC3Core/sendLiveState");
          var messageType = MessagePayloadType_1.default.LiveState;
          var messageContentType = MessageContentType_1.default.Text;
          var messagePayload = Util_1.default.createBaseMessageData(messageType, messageContentType, "");
          return this.sendMessageToIC3(conversationId, messagePayload).then(function() {
            _this.liveStateFailureCount = 0;
            return Promise.resolve();
          }).catch(function(e) {
            var _a2;
            _this.liveStateFailureCount++;
            if (_this.liveStateFailureCount >= Constants_1.default.liveStateRetryCount) {
              (_a2 = _this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.ERROR, IC3TelemetryEvent_1.default.SendLiveStateFailure, {
                ExceptionDetails: e,
                EndpointUrl: _this.EndpointUrl,
                EndpointId: _this.EndpointId
              });
              _this.stopHeartBeat();
              _this.liveStateFailureCount = 0;
            }
          });
        };
        IC3ClientAdapter2.prototype.sendHeartBeat = function(conversationId) {
          if (!this.heartBeatTimer) {
            this.debug && console.debug("IC3Core/sendHeartBeat");
            this.sendLiveState(conversationId);
            this.heartBeatTimer = window.setInterval(this.sendLiveState.bind(this, conversationId), Constants_1.default.heartBeatDuration);
          }
        };
        IC3ClientAdapter2.prototype.stopHeartBeat = function() {
          clearInterval(this.heartBeatTimer);
        };
        IC3ClientAdapter2.prototype.sendMessage = function(conversation, message) {
          var messagePayload = Util_1.default.createMessageData(message);
          return this.sendMessageToIC3(conversation.id, messagePayload);
        };
        IC3ClientAdapter2.prototype.getMessages = function(conversation) {
          var _this = this;
          var defaultGetMessagesQueryParameters = RequestHelper_1.default.getDefaultGetMessagesQueryParameters();
          var url = Utilities_1.default.addQueryParametersToPath(ServiceEndpointHelper_1.default.getMessagesUrl(conversation.id, this.ic3Info.RegionGtms), defaultGetMessagesQueryParameters);
          var headers = RequestHelper_1.default.getDefaultIC3Headers();
          headers[HttpHeaders_1.default.RegistrationTokenHeader] = this.ic3Info.RegistrationToken;
          headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeJson;
          var requestParameters = {
            enableExponentialBackoff: true,
            headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: false,
            shouldResetOnFailure: false,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.GET,
            url
          };
          return HttpClient_1.HttpClient.MakeRequest(requestParameters).then(function(response) {
            var previousMessages = [];
            for (var _i = 0, _a2 = response.messages; _i < _a2.length; _i++) {
              var message = _a2[_i];
              if (!Util_1.default.isSystemMessage(message)) {
                previousMessages.push(Util_1.default.createIRawMessage(message, _this.ic3Info));
              }
            }
            return _this.getAllMessagesFromBackwardLinkUrl(response._metadata.backwardLink, defaultGetMessagesQueryParameters.startTime, previousMessages);
          });
        };
        IC3ClientAdapter2.prototype.registerOnNewMessage = function(conversation, callback) {
          var _a2;
          this.newConversationMessageListeners[conversation.id].push(callback);
          (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.RegisterOnNewMessage, {
            EndpointUrl: this.EndpointUrl,
            EndpointId: this.EndpointId
          });
          return Promise.resolve();
        };
        IC3ClientAdapter2.prototype.registerOnThreadUpdate = function(conversation, callback) {
          var _a2;
          this.threadUpdateListeners[conversation.id].push(callback);
          (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.RegisterOnThreadUpdate, {
            EndpointUrl: this.EndpointUrl,
            EndpointId: this.EndpointId
          });
          return Promise.resolve();
        };
        IC3ClientAdapter2.prototype.disconnectFromConversation = function(conversation) {
          this.conversations.findIndex(function(conv) {
            return conv.id === conversation.id;
          });
          delete this.internalConversationsData[conversation.id];
          if (this.ic3Info.visitor) {
            this.stopHeartBeat();
            this.stopPolling();
          }
          return Promise.resolve();
        };
        IC3ClientAdapter2.prototype.sendFileData = function(conversation, fileInfo, fileSharingProtocolType) {
          var _this = this;
          if (Utilities_1.default.isNullOrUndefined(fileSharingProtocolType)) {
            fileSharingProtocolType = FileSharingProtocolType_1.default.AmsBasedFileSharing;
          }
          if (fileInfo.size <= 0) {
            throw new Error("File size is lesser or equal to zero.");
          }
          var fileMetadata = {
            fileSharingProtocolType,
            id: "",
            name: fileInfo.name,
            size: fileInfo.size,
            type: fileInfo.type,
            url: ""
          };
          return new Promise(function(resolve, reject) {
            AmsHelper_1.default.createNewDocument(conversation.id, fileInfo, _this.ic3Info).then(function(response) {
              fileMetadata.id = response.id;
              var isFileImage = Util_1.default.isDocumentTypeImage(fileInfo.type);
              fileMetadata.url = ServiceEndpointHelper_1.default.getAmsObjectContentUrl(response.id, _this.ic3Info.RegionGtms, isFileImage);
              AmsHelper_1.default.uploadDocument(response.id, fileInfo, _this.ic3Info).then(function() {
                resolve(fileMetadata);
              }).catch(function(e) {
                reject(e);
              });
            }).catch(function(e) {
              reject(e);
            });
          });
        };
        IC3ClientAdapter2.prototype.sendFileMessage = function(conversation, fileMetadata, message) {
          return this.sendMessageToIC3(conversation.id, Util_1.default.createFileMessage(fileMetadata, this.ic3Info, message));
        };
        IC3ClientAdapter2.prototype.downloadFileData = function(_conversation, fileMetaData) {
          var _this = this;
          this.debug && console.debug("IC3Core/IC3ClientAdapter/downloadFileData");
          return new Promise(function(resolve, reject) {
            var fileProtocolType = fileMetaData.fileSharingProtocolType;
            if (Utilities_1.default.isNullOrUndefined(fileProtocolType)) {
              fileProtocolType = FileSharingProtocolType_1.default.AmsBasedFileSharing;
            }
            if (fileProtocolType === FileSharingProtocolType_1.default.AmsBasedFileSharing) {
              AmsHelper_1.default.downloadDocument(fileMetaData, _this.ic3Info).then(function(response) {
                resolve(response);
              }).catch(function(e) {
                reject(e);
              });
            } else {
              reject("This Protocol is not implemented");
            }
          });
        };
        IC3ClientAdapter2.prototype.getFileStatus = function(_conversation, fileMetadata) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var fileProtocolType = fileMetadata.fileSharingProtocolType;
            if (Utilities_1.default.isNullOrUndefined(fileProtocolType)) {
              fileProtocolType = FileSharingProtocolType_1.default.AmsBasedFileSharing;
            }
            if (fileProtocolType === FileSharingProtocolType_1.default.AmsBasedFileSharing) {
              AmsHelper_1.default.getFileStatus(fileMetadata, _this.ic3Info).then(function(response) {
                resolve(response);
              }).catch(function(e) {
                reject(FileStatus_1.default.Error + " e");
              });
            } else {
              reject("This Protocol is not implemented");
            }
          });
        };
        IC3ClientAdapter2.prototype.indicateTypingStatus = function(conversation, typingStatus, optionalProperties) {
          var messageData = Util_1.default.createTypingStatusThreadMessageData(typingStatus, optionalProperties);
          return this.sendMessageToIC3(conversation.id, messageData);
        };
        IC3ClientAdapter2.prototype.sendMessageToBot = function(conversation, botId, botMessage) {
          var messageData = Util_1.default.createBotMessageData(conversation.id, botMessage);
          var url = ServiceEndpointHelper_1.default.getBotMessagesUrl(botId, this.ic3Info.RegionGtms);
          var headers = RequestHelper_1.default.getDefaultIC3Headers();
          headers[HttpHeaders_1.default.RegistrationTokenHeader] = this.ic3Info.RegistrationToken;
          headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeTextPlain;
          var requestParameters = {
            data: messageData,
            dataType: HttpDataType_1.default.TEXT,
            enableExponentialBackoff: true,
            headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: false,
            shouldResetOnFailure: false,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.POST,
            url
          };
          return HttpClient_1.HttpClient.MakeRequest(requestParameters);
        };
        IC3ClientAdapter2.prototype.getMembers = function(conversation) {
          var conversationMembers = this.internalConversationsData[conversation.id].members;
          var members = [];
          if (!Utilities_1.default.isNullOrUndefinedOrEmptyArray(conversationMembers)) {
            conversationMembers.forEach(function(conversationMember) {
              var memberToAdd = {
                displayName: conversationMember.friendlyName,
                id: conversationMember.id,
                type: Util_1.default.getPersonType(conversationMember.id)
              };
              members.push(memberToAdd);
            });
          }
          return Promise.resolve(members);
        };
        IC3ClientAdapter2.prototype.sendMessageToIC3 = function(conversationId, messageData) {
          var url = ServiceEndpointHelper_1.default.getMessagesUrl(conversationId, this.ic3Info.RegionGtms);
          var headers = RequestHelper_1.default.getDefaultIC3Headers();
          headers[HttpHeaders_1.default.RegistrationTokenHeader] = this.ic3Info.RegistrationToken;
          headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeJson;
          var requestParameters = {
            data: JSON.stringify(messageData),
            enableExponentialBackoff: true,
            headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: false,
            shouldResetOnFailure: false,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.POST,
            url
          };
          return HttpClient_1.HttpClient.MakeRequest(requestParameters);
        };
        IC3ClientAdapter2.prototype.onNewMessage = function(conversation, message, resourceType) {
          var _this = this;
          var _a2;
          var timer = Utilities_1.default.timer();
          try {
            if (conversation) {
              if (!Utilities_1.default.isNullOrUndefined(this.newConversationMessageListeners[conversation.id])) {
                if (!Util_1.default.isSystemMessage(message)) {
                  this.newConversationMessageListeners[conversation.id].forEach(function(callback) {
                    var messageToBeSent = Util_1.default.createIRawMessage(message, _this.ic3Info, resourceType);
                    callback(messageToBeSent);
                    return;
                  });
                }
              }
            }
          } catch (e) {
            var elapsedTimeInMilliseconds = timer.milliSecondsElapsed;
            (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.ERROR, IC3TelemetryEvent_1.default.OnNewMessageFailure, {
              ExceptionDetails: e,
              ElapsedTimeInMilliseconds: elapsedTimeInMilliseconds,
              EndpointUrl: this.EndpointUrl,
              EndpointId: this.EndpointId
            });
            return;
          }
        };
        IC3ClientAdapter2.prototype.onThreadUpdate = function(conversation, message) {
          var _a2;
          var timer = Utilities_1.default.timer();
          try {
            if (conversation) {
              if (!Utilities_1.default.isNullOrUndefined(this.threadUpdateListeners[conversation.id])) {
                this.threadUpdateListeners[conversation.id].forEach(function(callback) {
                  var messageToBeSent = Util_1.default.createIRawThread(message);
                  callback(messageToBeSent);
                  return;
                });
              }
            }
          } catch (e) {
            var elapsedTimeInMilliseconds = timer.milliSecondsElapsed;
            (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.ERROR, IC3TelemetryEvent_1.default.OnThreadUpdateFailure, {
              ExceptionDetails: e,
              ElapsedTimeInMilliseconds: elapsedTimeInMilliseconds,
              EndpointUrl: this.EndpointUrl,
              EndpointId: this.EndpointId
            });
            return;
          }
        };
        IC3ClientAdapter2.prototype.getAllMessagesFromBackwardLinkUrl = function(backwardLinkUrl, startTime2, previousMessages) {
          var _this = this;
          if (Utilities_1.default.isNullOrEmptyString(backwardLinkUrl)) {
            return Promise.resolve(previousMessages);
          }
          return this.getMessagesFromBackwardLinkUrl(backwardLinkUrl, startTime2).then(function(response) {
            for (var _i = 0, _a2 = response.messages; _i < _a2.length; _i++) {
              var message = _a2[_i];
              if (!Util_1.default.isSystemMessage(message)) {
                previousMessages.push(Util_1.default.createIRawMessage(message, _this.ic3Info));
              }
            }
            return _this.getAllMessagesFromBackwardLinkUrl(response._metadata.backwardLink, startTime2, previousMessages);
          });
        };
        IC3ClientAdapter2.prototype.getMessagesFromBackwardLinkUrl = function(backwardLinkUrl, startTime2) {
          var startTimeQueryParameter = { startTime: startTime2 };
          var url = Utilities_1.default.addQueryParametersToPath(backwardLinkUrl, startTimeQueryParameter);
          var headers = RequestHelper_1.default.getDefaultIC3Headers();
          headers[HttpHeaders_1.default.RegistrationTokenHeader] = this.ic3Info.RegistrationToken;
          headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeJson;
          var requestParameters = {
            enableExponentialBackoff: true,
            headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: false,
            shouldResetOnFailure: false,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.GET,
            url
          };
          return HttpClient_1.HttpClient.MakeRequest(requestParameters);
        };
        IC3ClientAdapter2.prototype.setupSession = function(sessionInfo) {
          this.ic3Info = { SkypeToken: sessionInfo.token, RegionGtms: sessionInfo.regionGtms, visitor: sessionInfo.visitor };
          if (!Utilities_1.default.isNullOrUndefined(this.ic3Info)) {
            this.EndpointId = this.ic3Info.endpointId;
            this.EndpointUrl = this.ic3Info.RegionGtms ? this.ic3Info.RegionGtms.chatService : "";
          }
        };
        IC3ClientAdapter2.prototype.setDebug = function(flag) {
          if (flag === void 0) {
            flag = false;
          }
          this.debug = flag;
        };
        return IC3ClientAdapter2;
      }()
    );
    exports2.default = IC3ClientAdapter;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/model/IC3PollingV1InterestedResources.js
var require_IC3PollingV1InterestedResources = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/model/IC3PollingV1InterestedResources.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var IC3PollingV1InterestedResources = (
      /** @class */
      function() {
        function IC3PollingV1InterestedResources2() {
        }
        IC3PollingV1InterestedResources2.ConversationProperties = "/v1/users/ME/conversations/ALL/properties";
        IC3PollingV1InterestedResources2.ConversationMessages = "/v1/users/ME/conversations/ALL/messages";
        IC3PollingV1InterestedResources2.Threads = "/v1/threads/ALL";
        IC3PollingV1InterestedResources2.Contacts = "/v1/users/ME/contacts/ALL";
        return IC3PollingV1InterestedResources2;
      }()
    );
    exports2.default = IC3PollingV1InterestedResources;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/model/IC3PollingV2EndpointFeatures.js
var require_IC3PollingV2EndpointFeatures = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/model/IC3PollingV2EndpointFeatures.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var IC3PollingV2EndpointFeatures = (
      /** @class */
      function() {
        function IC3PollingV2EndpointFeatures2() {
        }
        IC3PollingV2EndpointFeatures2.Agent = "Agent";
        IC3PollingV2EndpointFeatures2.MessageProperties = "MessageProperties";
        IC3PollingV2EndpointFeatures2.InviteFree = "InviteFree";
        return IC3PollingV2EndpointFeatures2;
      }()
    );
    exports2.default = IC3PollingV2EndpointFeatures;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/polling/V1PollingHelper.js
var require_V1PollingHelper = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/polling/V1PollingHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Constants_1 = require_Constants();
    var HttpClient_1 = require_HttpClient();
    var HttpHeaders_1 = require_HttpHeaders();
    var HttpRequestType_1 = require_HttpRequestType();
    var RequestHelper_1 = require_RequestHelper();
    var Util_1 = require_Util();
    var V1PollingHelper = (
      /** @class */
      function() {
        function V1PollingHelper2() {
        }
        V1PollingHelper2.poll = function(url, registrationToken, callback) {
          var headers = RequestHelper_1.default.getDefaultIC3Headers();
          headers[HttpHeaders_1.default.RegistrationTokenHeader] = registrationToken;
          headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeJson;
          var payload = JSON.stringify({});
          var requestParameters = {
            callbackOnFailure: callback,
            data: payload,
            enableExponentialBackoff: true,
            headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: true,
            shouldResetOnFailure: true,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.POST,
            url
          };
          return HttpClient_1.HttpClient.MakeRequest(requestParameters);
        };
        return V1PollingHelper2;
      }()
    );
    exports2.default = V1PollingHelper;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/polling/Poller.js
var require_Poller = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/polling/Poller.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ServiceEndpointHelper_1 = require_ServiceEndpointHelper();
    var V1PollingHelper_1 = require_V1PollingHelper();
    var Constants_1 = require_Constants();
    var Poller = (
      /** @class */
      function() {
        function Poller2(ic3Info, onNewData, onError, callbackOnFailure) {
          this.isPolling = false;
          this._ic3Info = ic3Info;
          this._onNewData = onNewData;
          this._onError = onError;
          this.callbackOnFailure = callbackOnFailure;
        }
        Poller2.prototype.start = function() {
          if (!this.isPolling) {
            this.isPolling = true;
            this.startPolling();
          }
          return Promise.resolve();
        };
        Poller2.prototype.stop = function() {
          this.isPolling = false;
          return Promise.resolve();
        };
        Object.defineProperty(Poller2.prototype, "onNewData", {
          get: function() {
            return this._onNewData;
          },
          set: function(input) {
            this._onNewData = input;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Poller2.prototype, "onError", {
          get: function() {
            return this._onError;
          },
          set: function(input) {
            this._onError = input;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Poller2.prototype, "setCallbackOnFailure", {
          set: function(input) {
            this.setCallbackOnFailure = input;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Poller2.prototype, "ic3Info", {
          get: function() {
            return this._ic3Info;
          },
          set: function(input) {
            this._ic3Info = input;
          },
          enumerable: false,
          configurable: true
        });
        Poller2.prototype.startPolling = function() {
          var _this = this;
          if (this.isPolling) {
            this.poll().then(function(data) {
              if (_this.isPolling && _this._onNewData) {
                _this._onNewData(data);
              }
            }).catch(function(e) {
              if (_this._onError) {
                _this._onError(e);
              }
            }).then(function() {
              _this.startPolling();
            });
          }
        };
        Poller2.prototype.poll = function() {
          var url = ServiceEndpointHelper_1.default.getV1PollUrl(this._ic3Info.RegionGtms, this._ic3Info.subscriptionId);
          return V1PollingHelper_1.default.poll(url, this._ic3Info.RegistrationToken, this.callbackOnEachRequestCompleted.bind(this));
        };
        Poller2.prototype.callbackOnEachRequestCompleted = function(jqXHR) {
          this.callbackOnFailure(jqXHR, Constants_1.default.pollRequestLog);
        };
        return Poller2;
      }()
    );
    exports2.default = Poller;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/core/IC3Initializer.js
var require_IC3Initializer = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/core/IC3Initializer.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f3, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f3 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Constants_1 = require_Constants();
    var HttpHeaders_1 = require_HttpHeaders();
    var IC3PollingV1InterestedResources_1 = require_IC3PollingV1InterestedResources();
    var IC3PollingV2EndpointFeatures_1 = require_IC3PollingV2EndpointFeatures();
    var RequestHelper_1 = require_RequestHelper();
    var ServiceEndpointHelper_1 = require_ServiceEndpointHelper();
    var Utilities_1 = require_Utilities();
    var Poller_1 = require_Poller();
    var LogLevel_1 = require_LogLevel();
    var IC3TelemetryEvent_1 = require_IC3TelemetryEvent();
    var HttpCode_1 = require_HttpCode();
    var Util_1 = require_Util();
    var HttpClient_1 = require_HttpClient();
    var HttpRequestType_1 = require_HttpRequestType();
    var IC3Initializer = (
      /** @class */
      function() {
        function IC3Initializer2() {
          this.debug = false;
          this.current404RetryCount = 0;
          this.currentOtherRetryCount = 0;
          this.skipUnsubscribe = false;
          this.telemetryMessage = "";
          this.errorCode = "";
          this.pollDataHandler = function(data) {
          };
          this.resetRetryCount();
        }
        IC3Initializer2.prototype.setup = function(logger5) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              this.logger = logger5;
              return [
                2
                /*return*/
              ];
            });
          });
        };
        IC3Initializer2.prototype.getPoller = function() {
          var pollDataHandler = this.pollDataHandler.bind(this);
          if (!this.poller) {
            this.poller = new Poller_1.default(
              this.ic3Info,
              pollDataHandler,
              this.redirectErrorHandler.bind(this),
              this.onRequestCreationFailure.bind(this)
              // eslint-disable-line @typescript-eslint/no-explicit-any
            );
          }
          return this.poller;
        };
        IC3Initializer2.prototype.setIc3Info = function(ic3Info) {
          return __awaiter(this, void 0, void 0, function() {
            var localIc3Info;
            return __generator(this, function(_a2) {
              localIc3Info = {
                RegionGtms: JSON.parse(JSON.stringify(ic3Info.RegionGtms)),
                SkypeToken: ic3Info.SkypeToken,
                visitor: ic3Info.visitor
              };
              this.ic3Info = localIc3Info;
              return [
                2
                /*return*/
              ];
            });
          });
        };
        IC3Initializer2.prototype.initializeIC3 = function(pollDataHandler) {
          var _this = this;
          var _a2;
          if (pollDataHandler) {
            this.pollDataHandler = pollDataHandler;
          }
          (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.IC3InitializationBegins, {
            Description: "Endpoint to poll is " + JSON.stringify(this.ic3Info.RegionGtms.chatService),
            EndpointUrl: this.ic3Info.RegionGtms.chatService,
            EndpointId: this.ic3Info.endpointId
          });
          var initializeIC3Promise = this.createEndpoint().then(function() {
            return _this.createSubscription();
          }).then(function() {
            return _this.setEndpointProperty();
          }).then(function() {
            return _this.startPolling(pollDataHandler);
          }).then(function() {
            return _this.resetRetryCount();
          }).then(function() {
            return Promise.resolve(_this.ic3Info);
          }).catch(function(e) {
            return _this.redirectErrorHandler(e);
          });
          return initializeIC3Promise;
        };
        IC3Initializer2.prototype.startPolling = function(handlePollData) {
          var _a2;
          var handler = !handlePollData && this.pollDataHandler ? this.pollDataHandler.bind(this) : this.pollDataHandler;
          if (!this.poller) {
            this.poller = new Poller_1.default(
              this.ic3Info,
              handler,
              this.redirectErrorHandler.bind(this),
              this.onRequestCreationFailure.bind(this)
              // eslint-disable-line @typescript-eslint/no-explicit-any
            );
          }
          this.poller.ic3Info = this.ic3Info;
          (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.IC3StartedPolling, {
            EndpointUrl: this.ic3Info.RegionGtms.chatService,
            EndpointId: this.ic3Info.endpointId
          });
          this.poller.start();
        };
        IC3Initializer2.prototype.stopPolling = function(oldInitializer) {
          var _a2;
          var initializer = oldInitializer ? Constants_1.default.oldInitializer : Constants_1.default.newInitializer;
          (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.IC3StoppedPolling, {
            Description: initializer + " stopped polling.",
            EndpointUrl: this.ic3Info.RegionGtms.chatService,
            EndpointId: this.ic3Info.endpointId
          });
          if (this.poller) {
            this.poller.stop();
          }
        };
        IC3Initializer2.prototype.reset = function(oldInitializer) {
          this.stopPolling(oldInitializer);
          return this.unsubscribeFromEndpoint();
        };
        IC3Initializer2.prototype.resetRetryCount = function() {
          this.current404RetryCount = 0;
          this.currentOtherRetryCount = 0;
        };
        IC3Initializer2.prototype.onEndpointCreationFailure = function(jqXHR) {
          this.onRequestCreationFailure(jqXHR, Constants_1.default.endpointRequestLog);
        };
        IC3Initializer2.prototype.onEndpointCreationSuccess = function(jqXHR) {
          var _a2, _b;
          var registrationTokenHeader = Utilities_1.default.getResponseHeader(jqXHR, HttpHeaders_1.default.SetRegistrationTokenHeader);
          if (!Utilities_1.default.isNullOrUndefined(registrationTokenHeader)) {
            this.ic3Info.RegistrationToken = Utilities_1.default.getRegistrationTokenValue(registrationTokenHeader);
          }
          var locationHeader = Utilities_1.default.getResponseHeader(jqXHR, HttpHeaders_1.default.LocationHeader);
          if (!Utilities_1.default.isNullOrUndefined(locationHeader)) {
            var epidMatch = locationHeader.match(/endpoints\/(%7B[\da-z\-]+%7D)/);
            this.ic3Info.endpointId = epidMatch && epidMatch[1];
            (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.IC3EndpointCreationSuccess, {
              Description: "IC3 endpoint Id is " + this.ic3Info.endpointId,
              EndpointUrl: this.ic3Info.RegionGtms.chatService,
              EndpointId: this.ic3Info.endpointId
            });
            if (jqXHR.status === HttpCode_1.default.Created && Util_1.default.parseChatServiceHostUrl(locationHeader) !== this.ic3Info.RegionGtms.chatService) {
              this.ic3Info.RegionGtms.chatService = Util_1.default.parseChatServiceHostUrl(locationHeader);
              (_b = this.logger) === null || _b === void 0 ? void 0 : _b.log(LogLevel_1.default.WARN, IC3TelemetryEvent_1.default.OnRequestCreationSuccessRedirect, {
                Description: "Endpoint changed",
                EndpointUrl: this.ic3Info.RegionGtms.chatService,
                EndpointId: this.ic3Info.endpointId
              });
            }
          }
        };
        IC3Initializer2.prototype.createEndpointRequest = function() {
          var url = ServiceEndpointHelper_1.default.getV1EndpointUrl(this.ic3Info.RegionGtms);
          var headers = RequestHelper_1.default.getDefaultIC3Headers();
          headers[HttpHeaders_1.default.AuthenticationHeader] = HttpHeaders_1.default.SkypeTokenHeaderValue + this.ic3Info.SkypeToken;
          headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeJson;
          var features = [
            IC3PollingV2EndpointFeatures_1.default.Agent,
            IC3PollingV2EndpointFeatures_1.default.InviteFree,
            IC3PollingV2EndpointFeatures_1.default.MessageProperties
          ];
          var payload = {
            endpointFeatures: features.join(",")
          };
          var requestParameters = {
            callbackOnFailure: this.onEndpointCreationFailure.bind(this),
            callbackOnSuccess: this.onEndpointCreationSuccess.bind(this),
            data: JSON.stringify(payload),
            enableExponentialBackoff: true,
            headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: true,
            shouldResetOnFailure: true,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.POST,
            url
          };
          return HttpClient_1.HttpClient.MakeRequest(requestParameters);
        };
        IC3Initializer2.prototype.createEndpoint = function() {
          var _this = this;
          return this.createEndpointRequest().then(function(response) {
            if (response.subscriptions && response.subscriptions.length > 0) {
              _this.ic3Info.subscriptionId = response.subscriptions[0].id;
            }
            return response;
          });
        };
        IC3Initializer2.prototype.onSubscriptionCreationFailure = function(jqXHR) {
          this.onRequestCreationFailure(jqXHR, Constants_1.default.subscriptionRequestLog);
        };
        IC3Initializer2.prototype.onSubscriptionCreationSuccess = function(jqXHR) {
          var _a2;
          var locationHeader = Utilities_1.default.getResponseHeader(jqXHR, HttpHeaders_1.default.LocationHeader) || "";
          if (jqXHR.status === HttpCode_1.default.Created && !Utilities_1.default.isNullOrUndefined(locationHeader) && Util_1.default.parseChatServiceHostUrl(locationHeader) !== this.ic3Info.RegionGtms.chatService) {
            this.ic3Info.RegionGtms.chatService = Util_1.default.parseChatServiceHostUrl(locationHeader);
            (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.WARN, IC3TelemetryEvent_1.default.OnRequestCreationSuccessRedirect, {
              Description: "Endpoint changed",
              EndpointUrl: this.ic3Info.RegionGtms.chatService,
              EndpointId: this.ic3Info.endpointId
            });
          }
          var subscriptionIdMatch = locationHeader.match(/\/(\d+)$/);
          if (subscriptionIdMatch) {
            this.ic3Info.subscriptionId = subscriptionIdMatch[1];
          }
        };
        IC3Initializer2.prototype.createSubscriptionRequest = function() {
          var url = ServiceEndpointHelper_1.default.getV1SubscriptionUrl(this.ic3Info.RegionGtms);
          var headers = RequestHelper_1.default.getDefaultIC3Headers();
          headers[HttpHeaders_1.default.RegistrationTokenHeader] = this.ic3Info.RegistrationToken;
          headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeJson;
          var payload = {
            channelType: Constants_1.default.HttpLongPoll,
            interestedResources: [
              IC3PollingV1InterestedResources_1.default.ConversationMessages,
              IC3PollingV1InterestedResources_1.default.ConversationProperties,
              IC3PollingV1InterestedResources_1.default.Threads,
              IC3PollingV1InterestedResources_1.default.Contacts
            ]
          };
          var requestParameters = {
            callbackOnFailure: this.onSubscriptionCreationFailure.bind(this),
            callbackOnSuccess: this.onSubscriptionCreationSuccess.bind(this),
            data: JSON.stringify(payload),
            enableExponentialBackoff: true,
            headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: true,
            shouldResetOnFailure: true,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.POST,
            url
          };
          return HttpClient_1.HttpClient.MakeRequest(requestParameters);
        };
        IC3Initializer2.prototype.createSubscription = function() {
          return this.createSubscriptionRequest();
        };
        IC3Initializer2.prototype.onSetEndpointPropertyCreationFailure = function(jqXHR) {
          this.onRequestCreationFailure(jqXHR, Constants_1.default.setPropertiesRequestLog);
        };
        IC3Initializer2.prototype.setEndpointProperty = function() {
          if (this.ic3Info.visitor) {
            return Promise.resolve();
          }
          var url = ServiceEndpointHelper_1.default.getV1SetPropertiesUrl(this.ic3Info.RegionGtms);
          var payload = {};
          var property = HttpHeaders_1.default.SetEndpointProperty;
          payload[property] = true;
          var headers = RequestHelper_1.default.getDefaultIC3Headers();
          headers[HttpHeaders_1.default.AuthenticationHeader] = HttpHeaders_1.default.SkypeTokenHeaderValue + this.ic3Info.SkypeToken;
          headers[HttpHeaders_1.default.RegistrationTokenHeader] = this.ic3Info.RegistrationToken;
          headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeJson;
          var requestParameters = {
            callbackOnFailure: this.onSetEndpointPropertyCreationFailure.bind(this),
            data: JSON.stringify(payload),
            enableExponentialBackoff: true,
            headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: true,
            shouldResetOnFailure: true,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.PUT,
            url
          };
          return HttpClient_1.HttpClient.MakeRequest(requestParameters);
        };
        IC3Initializer2.prototype.onUnsubscribeCreationFailure = function(jqXHR) {
          this.onRequestCreationFailure(jqXHR, Constants_1.default.unsubscribeRequestLog);
        };
        IC3Initializer2.prototype.unsubscribeFromEndpoint = function() {
          if (this.ic3Info.visitor || Utilities_1.default.isNullOrUndefined(this.ic3Info.endpointId) || this.skipUnsubscribe) {
            this.skipUnsubscribe = true;
            return Promise.resolve();
          }
          var url = ServiceEndpointHelper_1.default.getV1DeleteEndpointUrl(this.ic3Info.RegionGtms, this.ic3Info.endpointId);
          var headers = RequestHelper_1.default.getDefaultIC3Headers();
          headers[HttpHeaders_1.default.AuthenticationHeader] = HttpHeaders_1.default.SkypeTokenHeaderValue + this.ic3Info.SkypeToken;
          headers[HttpHeaders_1.default.RegistrationTokenHeader] = this.ic3Info.RegistrationToken;
          headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeJson;
          var requestParameters = {
            callbackOnFailure: this.onUnsubscribeCreationFailure.bind(this),
            enableExponentialBackoff: true,
            headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: true,
            shouldResetOnFailure: true,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.DELETE,
            url
          };
          return HttpClient_1.HttpClient.MakeRequest(requestParameters);
        };
        IC3Initializer2.prototype.onRequestCreationFailure = function(jqXHR, request) {
          var _a2, _b;
          var locationHeader = Utilities_1.default.getResponseHeader(jqXHR, HttpHeaders_1.default.LocationHeader);
          this.telemetryMessage = request + " failed. Error Code: " + jqXHR.status + ".";
          this.errorCode = jqXHR.status.toString();
          this.skipUnsubscribe = true;
          if (jqXHR.status === HttpCode_1.default.Redirect && !Utilities_1.default.isNullOrEmptyString(locationHeader)) {
            (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.WARN, IC3TelemetryEvent_1.default.RedirectOnRequestCreationFailure, {
              Description: this.telemetryMessage + " Trying to redirect.",
              ErrorCode: jqXHR.status.toString(),
              EndpointUrl: this.ic3Info.RegionGtms.chatService,
              EndpointId: this.ic3Info.endpointId
            });
            this.onRequestCreationFailureRedirect(jqXHR);
          } else {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.log(LogLevel_1.default.WARN, IC3TelemetryEvent_1.default.ResetOnRequestCreationFailure, {
              Description: this.telemetryMessage + " Trying to reset.",
              ErrorCode: jqXHR.status.toString(),
              EndpointUrl: this.ic3Info.RegionGtms.chatService,
              EndpointId: this.ic3Info.endpointId
            });
            this.current404RetryCount = 0;
            this.currentOtherRetryCount++;
          }
        };
        IC3Initializer2.prototype.redirectErrorHandler = function(e) {
          var _this = this;
          var _a2;
          if (e.message === Constants_1.default.Reset_Flag && this.current404RetryCount <= Constants_1.default.retry404Count && this.currentOtherRetryCount <= Constants_1.default.retryCount) {
            return this.reset().then(function() {
              return _this.initializeIC3();
            });
          } else {
            (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.ERROR, IC3TelemetryEvent_1.default.MaxRetryCountReachedForRedirect, {
              Description: "Fatal Error. Initialization failed. Maximum retry count reached. Exiting. " + this.telemetryMessage,
              ErrorCode: this.errorCode,
              ExceptionDetails: e,
              EndpointUrl: this.ic3Info.RegionGtms.chatService,
              EndpointId: this.ic3Info.endpointId
            });
            return this.reset().then(function() {
              return Promise.reject(e.message);
            });
          }
        };
        IC3Initializer2.prototype.onRequestCreationFailureRedirect = function(jqXHR) {
          var _a2;
          this.current404RetryCount++;
          this.currentOtherRetryCount = 0;
          this.ic3Info.RegionGtms.chatService = Util_1.default.parseChatServiceHostUrl(Utilities_1.default.getResponseHeader(jqXHR, HttpHeaders_1.default.LocationHeader));
          (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(LogLevel_1.default.WARN, IC3TelemetryEvent_1.default.OnRequestCreationFailureRedirect, {
            Description: "Endpoint changed.",
            EndpointUrl: this.ic3Info.RegionGtms.chatService,
            EndpointId: this.ic3Info.endpointId
          });
        };
        return IC3Initializer2;
      }()
    );
    exports2.default = IC3Initializer;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/model/ResourceType.js
var require_ResourceType = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/model/ResourceType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ResourceType = (
      /** @class */
      function() {
        function ResourceType2() {
        }
        ResourceType2.NewMessage = "NewMessage";
        ResourceType2.MessageUpdate = "MessageUpdate";
        ResourceType2.UserPresence = "UserPresence";
        ResourceType2.ConversationUpdate = "ConversationUpdate";
        ResourceType2.ThreadUpdate = "ThreadUpdate";
        return ResourceType2;
      }()
    );
    exports2.default = ResourceType;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/core/IC3ClientV1Adapter.js
var require_IC3ClientV1Adapter = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/core/IC3ClientV1Adapter.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f3, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f3 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Constants_1 = require_Constants();
    var HttpHeaders_1 = require_HttpHeaders();
    var HttpRequestType_1 = require_HttpRequestType();
    var IC3ClientAdapter_1 = require_IC3ClientAdapter();
    var IC3Initializer_1 = require_IC3Initializer();
    var IC3TelemetryEvent_1 = require_IC3TelemetryEvent();
    var HttpClient_1 = require_HttpClient();
    var LogLevel_1 = require_LogLevel();
    var ProtocoleType_1 = require_ProtocoleType();
    var RequestHelper_1 = require_RequestHelper();
    var ResourceType_1 = require_ResourceType();
    var ServiceEndpointHelper_1 = require_ServiceEndpointHelper();
    var Util_1 = require_Util();
    var Utilities_1 = require_Utilities();
    var IC3ClientV1Adapter = (
      /** @class */
      function(_super) {
        __extends2(IC3ClientV1Adapter2, _super);
        function IC3ClientV1Adapter2(id, hostType) {
          var _this = _super.call(this, id) || this;
          _this.debug && console.debug("IC3Core/Constructor");
          _this.protocolType = ProtocoleType_1.default.IC3V1SDK;
          _this.hostType = hostType;
          _this.ic3Initializer = new IC3Initializer_1.default();
          return _this;
        }
        IC3ClientV1Adapter2.prototype.startPolling = function() {
          _super.prototype.startPolling.call(this);
        };
        IC3ClientV1Adapter2.prototype.stopPolling = function() {
          _super.prototype.stopPolling.call(this);
        };
        IC3ClientV1Adapter2.prototype.setup = function(setupParams) {
          return _super.prototype.setup.call(this, setupParams);
        };
        IC3ClientV1Adapter2.prototype.initialize = function(sessionInfo) {
          var _this = this;
          return _super.prototype.initialize.call(this, sessionInfo).then(function() {
            var initializeOperation = function() {
              var _a2;
              return (_a2 = _this.ic3Initializer) === null || _a2 === void 0 ? void 0 : _a2.setup(_this.logger).then(function() {
                return _this.setSkypeTokenCookie();
              }).then(function() {
                var _a3;
                return (_a3 = _this.ic3Initializer) === null || _a3 === void 0 ? void 0 : _a3.setIc3Info(_this.ic3Info);
              }).then(function() {
                var _a3;
                return (_a3 = _this.ic3Initializer) === null || _a3 === void 0 ? void 0 : _a3.initializeIC3(_this.handlePollData.bind(_this));
              }).then(function(ic3Info) {
                _this.ic3Info = ic3Info;
              });
            };
            return initializeOperation();
          });
        };
        IC3ClientV1Adapter2.prototype.update = function(sessionInfo) {
          var _this = this;
          return _super.prototype.update.call(this, sessionInfo).then(function() {
            var updateOperation = function() {
              var ic3Info = {
                RegionGtms: sessionInfo.regionGtms,
                SkypeToken: sessionInfo.token,
                visitor: sessionInfo.visitor
              };
              return _this.updateToken(ic3Info);
            };
            return updateOperation();
          });
        };
        IC3ClientV1Adapter2.prototype.dispose = function() {
          var _a2;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_b) {
              (_a2 = this.ic3Initializer) === null || _a2 === void 0 ? void 0 : _a2.stopPolling();
              this.heartBeatTimer && clearInterval(this.heartBeatTimer);
              Promise.resolve();
              return [
                2
                /*return*/
              ];
            });
          });
        };
        IC3ClientV1Adapter2.prototype.joinConversation = function(conversationId, sendHeartBeat) {
          var _this = this;
          var timer = Utilities_1.default.timer();
          return _super.prototype.joinConversation.call(this, conversationId, sendHeartBeat).then(function(conversation) {
            return _this.getThreadRequest(conversation.id).then(function(thread) {
              _this.internalConversationsData[conversation.id] = {
                id: conversationId,
                members: thread.members
              };
              return conversation;
            }).catch(function(ex) {
              var elapsedTimeInMilliseconds = timer.milliSecondsElapsed;
              _this.logger && _this.logger.log(LogLevel_1.default.WARN, IC3TelemetryEvent_1.default.JoinConversationV1GetThreadRequestFailed, {
                Description: "Unable to retrieve thread: " + ex,
                ElapsedTimeInMilliseconds: elapsedTimeInMilliseconds,
                EndpointUrl: _this.EndpointUrl,
                EndpointId: _this.ic3Info.endpointId
              });
              _this.internalConversationsData[conversation.id] = {
                id: conversationId,
                members: []
              };
              return conversation;
            });
          });
        };
        IC3ClientV1Adapter2.prototype.sendMessage = function(conversation, message) {
          return _super.prototype.sendMessage.call(this, conversation, message);
        };
        IC3ClientV1Adapter2.prototype.sendFileMessage = function(conversation, fileMetadata, message) {
          return _super.prototype.sendFileMessage.call(this, conversation, fileMetadata, message);
        };
        IC3ClientV1Adapter2.prototype.getMessages = function(conversation) {
          return _super.prototype.getMessages.call(this, conversation);
        };
        IC3ClientV1Adapter2.prototype.registerOnNewMessage = function(conversation, callback) {
          return _super.prototype.registerOnNewMessage.call(this, conversation, callback);
        };
        IC3ClientV1Adapter2.prototype.registerOnThreadUpdate = function(conversation, callback) {
          return _super.prototype.registerOnThreadUpdate.call(this, conversation, callback);
        };
        IC3ClientV1Adapter2.prototype.disconnectFromConversation = function(conversation) {
          return _super.prototype.disconnectFromConversation.call(this, conversation);
        };
        IC3ClientV1Adapter2.prototype.setSkypeTokenCookie = function() {
          var url = this.ic3Info.RegionGtms.ams.concat(Constants_1.default.skypeTokenAuthURL);
          var headers = RequestHelper_1.default.getDefaultBaseIC3Headers();
          headers[HttpHeaders_1.default.ContentTypeHeader] = Constants_1.default.ContentTypeForm;
          var skypeTokenData = Constants_1.default.skypeTokenConstantForData + this.ic3Info.SkypeToken;
          var requestParameters = {
            data: skypeTokenData,
            enableExponentialBackoff: true,
            useXHRWithCredentials: true,
            headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: false,
            shouldResetOnFailure: false,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.POST,
            url
          };
          return HttpClient_1.HttpClient.MakeRequest(requestParameters);
        };
        IC3ClientV1Adapter2.prototype.getThreadRequest = function(conversationId) {
          var url = ServiceEndpointHelper_1.default.getThreadUrl(conversationId, this.ic3Info.RegionGtms);
          var headers = RequestHelper_1.default.getDefaultBaseIC3Headers();
          headers[HttpHeaders_1.default.RegistrationTokenHeader] = this.ic3Info.RegistrationToken;
          var requestParameters = {
            enableExponentialBackoff: true,
            headers,
            redirect404RetryCount: Constants_1.default.retryCount,
            retryCount: Constants_1.default.retryCount,
            shouldRedirectOn404: true,
            shouldRetryOnFailure: Util_1.default.shouldRetryOnFailure,
            timeBetweenRetry: Constants_1.default.timeBetweenOperationRetry,
            type: HttpRequestType_1.default.GET,
            url
          };
          return HttpClient_1.HttpClient.MakeRequest(requestParameters);
        };
        IC3ClientV1Adapter2.prototype.newMessageReceived = function(conversation, message, resourceType) {
          _super.prototype.onNewMessage.call(this, conversation, message, resourceType);
        };
        IC3ClientV1Adapter2.prototype.newThreadUpdate = function(conversation, message) {
          _super.prototype.onThreadUpdate.call(this, conversation, message);
        };
        IC3ClientV1Adapter2.prototype.handleNewMessageEvent = function(eventMessage) {
          var conversationId;
          if (eventMessage.resource && eventMessage.resource.conversationid) {
            conversationId = eventMessage.resource.conversationid;
          } else if (eventMessage.resource.conversationLink) {
            conversationId = Util_1.default.getConversationIdFromUrl(eventMessage.resource.conversationLink);
          } else {
            conversationId = Util_1.default.getConversationIdFromUrl(eventMessage.resourceLink);
          }
          var conversationIndex = this.conversations.findIndex(function(conv) {
            return conv.id === conversationId;
          });
          var interestedConversation = this.conversations[conversationIndex];
          this.newMessageReceived(interestedConversation, eventMessage.resource, eventMessage.resourceType);
        };
        IC3ClientV1Adapter2.prototype.handleConversationUpdateEvent = function(eventMessage) {
          if (eventMessage.resourceType === ResourceType_1.default.ConversationUpdate) {
          }
        };
        IC3ClientV1Adapter2.prototype.handleThreadUpdate = function(eventMessage) {
          if (eventMessage.resourceType !== ResourceType_1.default.ThreadUpdate) {
            return;
          }
          var conversationId;
          if (eventMessage.resource && eventMessage.resource.id) {
            conversationId = eventMessage.resource.id;
          } else if (eventMessage.resource.messages) {
            conversationId = Util_1.default.getConversationIdFromUrl(eventMessage.resource.messages);
          } else {
            conversationId = Util_1.default.getConversationIdFromUrl(eventMessage.resourceLink);
          }
          var conversationIndex = this.conversations.findIndex(function(conv) {
            return conv.id === conversationId;
          });
          var interestedConversation = this.conversations[conversationIndex];
          this.newThreadUpdate(interestedConversation, eventMessage.resource);
        };
        IC3ClientV1Adapter2.prototype.handlePollData = function(eventData) {
          if (!eventData || !eventData.eventMessages) {
            return;
          }
          for (var _i = 0, _a2 = eventData.eventMessages; _i < _a2.length; _i++) {
            var eventMessage = _a2[_i];
            this.handlePollEventMessage(eventMessage);
          }
        };
        IC3ClientV1Adapter2.prototype.handlePollEventMessage = function(eventMessage) {
          if (eventMessage.resourceType === ResourceType_1.default.NewMessage || eventMessage.resourceType === ResourceType_1.default.MessageUpdate) {
            this.handleNewMessageEvent(eventMessage);
          } else if (eventMessage.resourceType === ResourceType_1.default.ThreadUpdate) {
            this.handleThreadUpdate(eventMessage);
          } else if (eventMessage.resourceType === ResourceType_1.default.ConversationUpdate) {
            this.handleConversationUpdateEvent(eventMessage);
          }
        };
        IC3ClientV1Adapter2.prototype.updateToken = function(ic3Info) {
          return __awaiter(this, void 0, void 0, function() {
            var pollDataFromOngoingPoll, handlePollDataFromOngoingPoll, pollDataFromNewPoll, handlePollDataFromNewPoll, currentIc3Initializer, newIc3Initializer, currentUpdateTokenClearTimeoutHandle, currentIc3Info, newIc3Info, matchingIC3EventIndex, updateTokenPromise;
            var _this = this;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.logger && this.logger.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.UpdateToken, {
                    EndpointUrl: this.EndpointUrl,
                    EndpointId: this.ic3Info.endpointId
                  });
                  pollDataFromOngoingPoll = [];
                  handlePollDataFromOngoingPoll = function(pollData) {
                    if (pollData && pollData.eventMessages) {
                      Utilities_1.default.concatArrays(pollDataFromOngoingPoll, pollData.eventMessages);
                    }
                  };
                  pollDataFromNewPoll = [];
                  handlePollDataFromNewPoll = function(pollData) {
                    if (pollData && pollData.eventMessages) {
                      Utilities_1.default.concatArrays(pollDataFromNewPoll, pollData.eventMessages);
                    }
                  };
                  currentIc3Initializer = this.ic3Initializer;
                  newIc3Initializer = new IC3Initializer_1.default();
                  currentUpdateTokenClearTimeoutHandle = this.updateTokenClearTimeoutHandle;
                  currentIc3Info = this.ic3Info;
                  currentIc3Initializer.getPoller().onNewData = handlePollDataFromOngoingPoll;
                  if (!this.logger)
                    return [3, 2];
                  return [4, newIc3Initializer.setup(this.logger)];
                case 1:
                  _a2.sent();
                  _a2.label = 2;
                case 2:
                  updateTokenPromise = newIc3Initializer.setIc3Info(ic3Info).then(function() {
                    return newIc3Initializer.initializeIC3(handlePollDataFromNewPoll);
                  }).then(function(response) {
                    newIc3Info = response;
                  }).then(function() {
                    return _this.getMatchingIC3EventIndex(pollDataFromOngoingPoll, pollDataFromNewPoll);
                  }).then(function(response) {
                    matchingIC3EventIndex = response;
                  }).then(function() {
                    return currentIc3Initializer.reset(true);
                  }).then(function() {
                    return _this.syncPollingData(pollDataFromOngoingPoll, pollDataFromNewPoll, matchingIC3EventIndex);
                  }).then(function() {
                    _this.ic3Info = newIc3Info;
                    _this.ic3Initializer = newIc3Initializer;
                    _this.ic3Initializer.getPoller().onNewData = _this.handlePollData.bind(_this);
                  }).catch(function(e) {
                    if (_this.updateTokenClearTimeoutHandle !== currentUpdateTokenClearTimeoutHandle) {
                      clearTimeout(_this.updateTokenClearTimeoutHandle);
                      _this.updateTokenClearTimeoutHandle = currentUpdateTokenClearTimeoutHandle;
                    }
                    _this.ic3Info = currentIc3Info;
                    _this.ic3Initializer.getPoller().onNewData = _this.handlePollData.bind(_this);
                    _this.ic3Initializer.getPoller().start();
                    throw new Error("Update token failed: " + (e && e.message));
                  });
                  return [2, updateTokenPromise];
              }
            });
          });
        };
        IC3ClientV1Adapter2.prototype.getMatchingIC3EventIndex = function(pollDataFromOngoingPoll, pollDataFromNewPoll, currentRetryCount) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            currentRetryCount = currentRetryCount || 0;
            if (currentRetryCount === Constants_1.default.stabilizePollMaxRetryCount) {
              resolve({ newPollIndex: -1, previousPollIndex: -1 });
            } else {
              var ongoingPollIndex = 0;
              var newPollIndex = 0;
              while (ongoingPollIndex < pollDataFromOngoingPoll.length && newPollIndex < pollDataFromNewPoll.length) {
                var ongoingPollData = pollDataFromOngoingPoll[ongoingPollIndex];
                var newPollData = pollDataFromNewPoll[newPollIndex];
                if (ongoingPollData.time === newPollData.time) {
                  resolve({ newPollIndex, previousPollIndex: ongoingPollIndex });
                  return;
                } else if (new Date(ongoingPollData.time) < new Date(ongoingPollData.time)) {
                  ongoingPollIndex++;
                } else {
                  newPollIndex++;
                }
              }
              setTimeout(function() {
                _this.getMatchingIC3EventIndex(pollDataFromOngoingPoll, pollDataFromNewPoll, currentRetryCount + 1).then(function(response) {
                  resolve(response);
                }).catch(function(e) {
                  reject(e);
                });
              }, Constants_1.default.timeBetweenStabilizingPoll);
            }
          });
        };
        IC3ClientV1Adapter2.prototype.syncPollingData = function(pollDataFromOngoingPoll, pollDataFromNewPoll, matchingIC3EventIndex) {
          this.logger && this.logger.log(LogLevel_1.default.INFO, IC3TelemetryEvent_1.default.SyncingPollData, {
            EndpointUrl: this.EndpointUrl,
            EndpointId: this.ic3Info.endpointId
          });
          var previousPollLastIndex = matchingIC3EventIndex.previousPollIndex;
          var newPollStartIndex = matchingIC3EventIndex.newPollIndex + 1;
          if (matchingIC3EventIndex.previousPollIndex === -1 && matchingIC3EventIndex.newPollIndex === -1) {
            previousPollLastIndex = pollDataFromOngoingPoll.length - 1;
            newPollStartIndex = 0;
          }
          for (var ind = 0; ind <= previousPollLastIndex; ind++) {
            this.handlePollEventMessage(pollDataFromOngoingPoll[ind]);
          }
          for (var ind = newPollStartIndex; ind < pollDataFromNewPoll.length; ind++) {
            this.handlePollEventMessage(pollDataFromNewPoll[ind]);
          }
        };
        return IC3ClientV1Adapter2;
      }(IC3ClientAdapter_1.default)
    );
    exports2.default = IC3ClientV1Adapter;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/core/FramelessBridge.js
var require_FramelessBridge = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/core/FramelessBridge.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f3, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f3 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ClientBridge_1 = require_ClientBridge();
    var HostType_1 = require_HostType();
    var IC3ClientV1Adapter_1 = require_IC3ClientV1Adapter();
    var FramelessBridge = (
      /** @class */
      function(_super) {
        __extends2(FramelessBridge2, _super);
        function FramelessBridge2(protocolType) {
          var _this = _super.call(this, protocolType) || this;
          _this.hostType = HostType_1.default.Page;
          _this.protocolAdapter = new IC3ClientV1Adapter_1.default("", _this.hostType);
          return _this;
        }
        FramelessBridge2.prototype.setup = function(setupParams) {
          return Promise.resolve();
        };
        FramelessBridge2.prototype.update = function(sessionInfo) {
          return Promise.resolve();
        };
        FramelessBridge2.prototype.onRegisterOnNewMessage = function(conversation) {
          return Promise.resolve();
        };
        FramelessBridge2.prototype.onRegisterOnThreadUpdate = function(conversation) {
          return Promise.resolve();
        };
        FramelessBridge2.prototype.initialize = function(sessionInfo) {
          return this.protocolAdapter.initialize(sessionInfo);
        };
        FramelessBridge2.prototype.dispose = function() {
          return this.protocolAdapter.dispose();
        };
        FramelessBridge2.prototype.sendMessage = function(conversation, message) {
          return this.protocolAdapter.sendMessage(conversation, message);
        };
        FramelessBridge2.prototype.sendFileMessage = function(conversation, fileMetadata, message) {
          return this.protocolAdapter.sendFileMessage(conversation, fileMetadata, message);
        };
        FramelessBridge2.prototype.getMessages = function(conversation) {
          return this.protocolAdapter.getMessages(conversation);
        };
        FramelessBridge2.prototype.disconnectFromConversation = function(conversation) {
          return this.protocolAdapter.disconnectFromConversation(conversation);
        };
        FramelessBridge2.prototype.onJoinConversation = function(conversationId, sendHeartBeat) {
          return this.protocolAdapter.joinConversation(conversationId, sendHeartBeat);
        };
        FramelessBridge2.prototype.sendFileData = function(conversation, fileInfo, fileSharingProtocolType) {
          return this.protocolAdapter.sendFileData(conversation, fileInfo, fileSharingProtocolType);
        };
        FramelessBridge2.prototype.downloadFileData = function(conversation, fileMetadata) {
          return this.protocolAdapter.downloadFileData(conversation, fileMetadata);
        };
        FramelessBridge2.prototype.getFileStatus = function(conversation, fileMetadata) {
          return this.protocolAdapter.getFileStatus(conversation, fileMetadata);
        };
        FramelessBridge2.prototype.indicateTypingStatus = function(conversation, typingStatus, optionalProperties) {
          return this.protocolAdapter.indicateTypingStatus(conversation, typingStatus, optionalProperties);
        };
        FramelessBridge2.prototype.sendMessageToBot = function(conversation, botId, botMessage) {
          return this.protocolAdapter.sendMessageToBot(conversation, botId, botMessage);
        };
        FramelessBridge2.prototype.getMembers = function(conversation) {
          return this.protocolAdapter.getMembers(conversation);
        };
        FramelessBridge2.prototype.registerOnNewMessage = function(conversation, callback) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              this.protocolAdapter.registerOnNewMessage(conversation, callback);
              return [2, Promise.resolve()];
            });
          });
        };
        FramelessBridge2.prototype.registerOnThreadUpdate = function(conversation, callback) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              this.protocolAdapter.registerOnThreadUpdate(conversation, callback);
              return [2, Promise.resolve()];
            });
          });
        };
        FramelessBridge2.prototype.setDebug = function(flag) {
          if (flag === void 0) {
            flag = false;
          }
          this.protocolAdapter.setDebug(flag);
        };
        return FramelessBridge2;
      }(ClientBridge_1.default)
    );
    exports2.default = FramelessBridge;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/core/ClientBridgeFactory.js
var require_ClientBridgeFactory = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/core/ClientBridgeFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var FramelessBridge_1 = require_FramelessBridge();
    var HostType_1 = require_HostType();
    var ClientBridgeFactory = (
      /** @class */
      function() {
        function ClientBridgeFactory2() {
        }
        ClientBridgeFactory2.getClientBridge = function(protocolInfo) {
          switch (protocolInfo.hostType) {
            case HostType_1.default.IFrame:
              throw new Error("Framed bridge not implemented for " + protocolInfo.hostType + " in IC3Core");
            case HostType_1.default.Page:
              return new FramelessBridge_1.default(protocolInfo.protocolType);
            default:
              throw new Error("Client bridge not implemented for " + protocolInfo.hostType + " in IC3Core");
          }
        };
        return ClientBridgeFactory2;
      }()
    );
    exports2.default = ClientBridgeFactory;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/logging/TelemetryHelper.js
var require_TelemetryHelper = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/logging/TelemetryHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TelemetryHelper = (
      /** @class */
      function() {
        function TelemetryHelper2() {
        }
        TelemetryHelper2.getTelemetryEventData = function(sdk, telemetryEvent, customData) {
          var logData = {
            Description: customData.Description,
            ElapsedTimeInMilliseconds: customData.ElapsedTimeInMilliseconds,
            EndpointUrl: customData.EndpointUrl,
            EndpointId: customData.EndpointId,
            ErrorCode: customData.ErrorCode,
            Event: telemetryEvent,
            ExceptionDetails: customData.ExceptionDetails,
            ShouldBubbleToHost: customData.ShouldBubbleToHost,
            SubscriptionId: sdk.id
          };
          return logData;
        };
        return TelemetryHelper2;
      }()
    );
    exports2.default = TelemetryHelper;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/logging/RawLogger.js
var require_RawLogger = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/logging/RawLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Utilities_1 = require_Utilities();
    var TelemetryHelper_1 = require_TelemetryHelper();
    var RawLogger = (
      /** @class */
      function() {
        function RawLogger2(sdk, logger5) {
          this.sdk = sdk;
          this.logger = logger5;
        }
        RawLogger2.prototype.log = function(loglevel, telemetryEvent, customData) {
          if (this.isLoggingEnabled()) {
            var logData = TelemetryHelper_1.default.getTelemetryEventData(this.sdk, telemetryEvent, customData);
            this.logEvent(loglevel, logData);
          }
        };
        RawLogger2.prototype.logEvent = function(logLevel, logData) {
          if (this.isLoggingEnabled()) {
            setTimeout(this.logger.logClientSdkTelemetryEvent.bind(this.logger), 0, logLevel, logData);
          }
        };
        RawLogger2.prototype.isLoggingEnabled = function() {
          return !Utilities_1.default.isNullOrUndefined(this.logger);
        };
        return RawLogger2;
      }()
    );
    exports2.default = RawLogger;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/core/SDKProvider.js
var require_SDKProvider = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/core/SDKProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ClientBridgeFactory_1 = require_ClientBridgeFactory();
    var RawLogger_1 = require_RawLogger();
    var SDKProvider = (
      /** @class */
      function() {
        function SDKProvider2() {
        }
        SDKProvider2.getSDK = function(initializationParams) {
          return new Promise(function(resolve) {
            var protocolInfo = {
              hostType: initializationParams.hostType,
              protocolType: initializationParams.protocolType
            };
            var clientBridge = ClientBridgeFactory_1.default.getClientBridge(protocolInfo);
            var clientBridgeSetupParameters = {
              logger: new RawLogger_1.default(clientBridge, initializationParams.logger)
            };
            return clientBridge.setup(clientBridgeSetupParameters).then(function() {
              var clientSdk = {
                dispose: clientBridge.dispose.bind(clientBridge),
                id: clientBridge.id,
                initialize: clientBridge.initialize.bind(clientBridge),
                joinConversation: clientBridge.joinConversation.bind(clientBridge),
                update: clientBridge.update.bind(clientBridge),
                setDebug: clientBridge.setDebug.bind(clientBridge)
              };
              return resolve(clientSdk);
            });
          });
        };
        return SDKProvider2;
      }()
    );
    exports2.default = SDKProvider;
  }
});

// node_modules/@microsoft/omnichannel-ic3core/lib/index.js
var require_lib = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SDKProvider = void 0;
    var SDKProvider_1 = require_SDKProvider();
    exports2.SDKProvider = SDKProvider_1.default;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports2, module2) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return module2.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof(obj);
    }
    module2.exports = _typeof, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports2, module2) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module2.exports = _interopRequireDefault, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/AMSLogger.js
var require_AMSLogger = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/AMSLogger.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var AMSLogger = (
      /** @class */
      function() {
        function AMSLogger2(logger5) {
          this.debug = false;
          this.debug = false;
          this.logger = logger5;
        }
        AMSLogger2.prototype.setDebug = function(flag) {
          this.debug = flag;
        };
        AMSLogger2.prototype.log = function(logLevel, telemetryEvent, customData) {
          var _a2;
          var logData = __assign({ Event: telemetryEvent }, customData);
          this.debug && console.log(logData);
          (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.logClientSdkTelemetryEvent(logLevel, logData);
        };
        return AMSLogger2;
      }()
    );
    exports2.default = AMSLogger;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/config.js
var require_config = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/config.js"(exports2) {
    exports2.baseUrl = "https://comms.omnichannelengagementhub.com/ams";
    exports2.sdkVersion = "0.1.4";
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/GlobalConfiguration.js
var require_GlobalConfiguration = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/GlobalConfiguration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var GlobalConfiguration = (
      /** @class */
      function() {
        function GlobalConfiguration2() {
        }
        GlobalConfiguration2.silentError = true;
        GlobalConfiguration2.debug = false;
        return GlobalConfiguration2;
      }()
    );
    exports2.default = GlobalConfiguration;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/utils/platform.js
var require_platform = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/utils/platform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isReactNative = exports2.isNode = exports2.isBrowser = void 0;
    var isBrowser = function() {
      return typeof window !== "undefined" && typeof window.document !== "undefined";
    };
    exports2.isBrowser = isBrowser;
    var isNode3 = function() {
      return typeof process !== "undefined" && process.versions != null && process.versions.node != null;
    };
    exports2.isNode = isNode3;
    var isReactNative = function() {
      return typeof navigator != "undefined" && navigator.product == "ReactNative";
    };
    exports2.isReactNative = isReactNative;
    exports2.default = {
      isBrowser: exports2.isBrowser,
      isNode: exports2.isNode,
      isReactNative: exports2.isReactNative
    };
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/PostMessageEventName.js
var require_PostMessageEventName = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/PostMessageEventName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PostMessageEventName;
    (function(PostMessageEventName2) {
      PostMessageEventName2["IframeLoaded"] = "AMSIframeLoaded";
      PostMessageEventName2["SkypeTokenAuth"] = "AMSSkypeTokenAuth";
      PostMessageEventName2["CreateObject"] = "AMSCreateObject";
      PostMessageEventName2["UploadDocument"] = "AMSUploadDocument";
      PostMessageEventName2["GetViewStatus"] = "AMSGetViewStatus";
      PostMessageEventName2["GetView"] = "AMSGetView";
      PostMessageEventName2["SendTelemetry"] = "AMSSendTelemetry";
    })(PostMessageEventName || (PostMessageEventName = {}));
    exports2.default = PostMessageEventName;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/PostMessageEventType.js
var require_PostMessageEventType = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/PostMessageEventType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PostMessageEventType;
    (function(PostMessageEventType2) {
      PostMessageEventType2["None"] = "None";
      PostMessageEventType2["Request"] = "Request";
      PostMessageEventType2["Response"] = "Response";
    })(PostMessageEventType || (PostMessageEventType = {}));
    exports2.default = PostMessageEventType;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/utils/uuid.js
var require_uuid2 = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uuidv4 = void 0;
    var uuidv4 = function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    };
    exports2.uuidv4 = uuidv4;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/FramedClient.js
var require_FramedClient = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/FramedClient.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f3, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f3 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var config_1 = require_config();
    var GlobalConfiguration_1 = require_GlobalConfiguration();
    var platform_1 = require_platform();
    var PostMessageEventName_1 = require_PostMessageEventName();
    var PostMessageEventType_1 = require_PostMessageEventType();
    var uuid_1 = require_uuid2();
    var version2 = config_1.sdkVersion;
    var iframePrefix = "Microsoft_Omnichannel_AMSClient_Iframe_Window";
    var FramedClient = (
      /** @class */
      function() {
        function FramedClient2(logger5, framedClientConfig) {
          if (logger5 === void 0) {
            logger5 = void 0;
          }
          if (framedClientConfig === void 0) {
            framedClientConfig = void 0;
          }
          this.runtimeId = uuid_1.uuidv4();
          this.clientId = uuid_1.uuidv4();
          this.origin = window.location.origin;
          this.requestCallbacks = {};
          this.debug = false;
          this.iframeLoaded = false;
          this.logger = logger5;
          this.iframeId = iframePrefix;
          if (framedClientConfig && framedClientConfig.multiClient) {
            this.iframeId = this.clientId;
          }
        }
        FramedClient2.prototype.setDebug = function(flag) {
          this.debug = flag;
        };
        FramedClient2.prototype.setup = function() {
          return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.debug && console.log("[FramedClient][initialize]");
                  this.onMessageEvent(function(event) {
                    return _this.handleEvent(event);
                  });
                  if (!platform_1.default.isBrowser()) {
                    throw new Error("FramedMode was used in non-Web platform");
                  }
                  return [4, this.loadIframe()];
                case 1:
                  _a2.sent();
                  if (!this.iframeLoaded) {
                    !GlobalConfiguration_1.default.silentError && console.error("iframe not loaded");
                  }
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FramedClient2.prototype.initialize = function(initConfig) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.debug && console.log("[FramedClient][initialize]");
                  this.chatToken = initConfig.chatToken;
                  return [4, this.skypeTokenAuth()];
                case 1:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FramedClient2.prototype.skypeTokenAuth = function(chatToken) {
          if (chatToken === void 0) {
            chatToken = null;
          }
          return __awaiter(this, void 0, void 0, function() {
            var data;
            var _this = this;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.debug && console.log("[FramedClient][skypeAuth]");
                  data = {
                    chatToken: chatToken || this.chatToken
                  };
                  return [4, this.loadIframe()];
                case 1:
                  _a2.sent();
                  return [2, new Promise(function(resolve, reject) {
                    _this.postMessage(PostMessageEventType_1.default.Request, PostMessageEventName_1.default.SkypeTokenAuth, data, resolve, reject);
                  })];
              }
            });
          });
        };
        FramedClient2.prototype.createObject = function(id, file, chatToken, supportedImagesMimeTypes) {
          if (chatToken === void 0) {
            chatToken = null;
          }
          if (supportedImagesMimeTypes === void 0) {
            supportedImagesMimeTypes = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var data;
            var _this = this;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.debug && console.log("[FramedClient][createObject]");
                  data = {
                    id,
                    file,
                    chatToken: chatToken || this.chatToken,
                    supportedImagesMimeTypes
                  };
                  return [4, this.loadIframe()];
                case 1:
                  _a2.sent();
                  return [2, new Promise(function(resolve, reject) {
                    _this.postMessage(PostMessageEventType_1.default.Request, PostMessageEventName_1.default.CreateObject, data, resolve, reject);
                  })];
              }
            });
          });
        };
        FramedClient2.prototype.uploadDocument = function(documentId, file, chatToken, supportedImagesMimeTypes) {
          if (chatToken === void 0) {
            chatToken = null;
          }
          if (supportedImagesMimeTypes === void 0) {
            supportedImagesMimeTypes = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var data;
            var _this = this;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.debug && console.log("[FramedClient][uploadDocument]");
                  data = {
                    documentId,
                    file,
                    chatToken: chatToken || this.chatToken,
                    supportedImagesMimeTypes
                  };
                  return [4, this.loadIframe()];
                case 1:
                  _a2.sent();
                  return [2, new Promise(function(resolve, reject) {
                    _this.postMessage(PostMessageEventType_1.default.Request, PostMessageEventName_1.default.UploadDocument, data, resolve, reject);
                  })];
              }
            });
          });
        };
        FramedClient2.prototype.getViewStatus = function(fileMetadata, chatToken, supportedImagesMimeTypes) {
          if (chatToken === void 0) {
            chatToken = null;
          }
          if (supportedImagesMimeTypes === void 0) {
            supportedImagesMimeTypes = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var data;
            var _this = this;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  data = {
                    fileMetadata,
                    chatToken: chatToken || this.chatToken,
                    supportedImagesMimeTypes
                  };
                  return [4, this.loadIframe()];
                case 1:
                  _a2.sent();
                  return [2, new Promise(function(resolve, reject) {
                    _this.postMessage(PostMessageEventType_1.default.Request, PostMessageEventName_1.default.GetViewStatus, data, resolve, reject);
                  })];
              }
            });
          });
        };
        FramedClient2.prototype.getView = function(fileMetadata, viewLocation, chatToken, supportedImagesMimeTypes) {
          if (chatToken === void 0) {
            chatToken = null;
          }
          if (supportedImagesMimeTypes === void 0) {
            supportedImagesMimeTypes = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var data;
            var _this = this;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  data = {
                    fileMetadata,
                    viewLocation,
                    chatToken: chatToken || this.chatToken,
                    supportedImagesMimeTypes
                  };
                  return [4, this.loadIframe()];
                case 1:
                  _a2.sent();
                  return [2, new Promise(function(resolve, reject) {
                    _this.postMessage(PostMessageEventType_1.default.Request, PostMessageEventName_1.default.GetView, data, resolve, reject);
                  })];
              }
            });
          });
        };
        FramedClient2.prototype.fetchBlob = function(contentUrl) {
          return __awaiter(this, void 0, void 0, function() {
            var response, blobResponse, error_1;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  _a2.trys.push([0, 3, , 4]);
                  return [4, fetch(contentUrl)];
                case 1:
                  response = _a2.sent();
                  return [4, response.blob()];
                case 2:
                  blobResponse = _a2.sent();
                  return [2, blobResponse];
                case 3:
                  error_1 = _a2.sent();
                  !GlobalConfiguration_1.default.silentError && console.log(error_1);
                  throw new Error("fetchBlob");
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FramedClient2.prototype.onMessageEvent = function(cb) {
          window.addEventListener("message", cb, true);
        };
        FramedClient2.prototype.postMessage = function(eventType, eventName, data, resolve, reject) {
          if (data === void 0) {
            data = {};
          }
          if (resolve === void 0) {
            resolve = function(data2) {
              return {};
            };
          }
          if (reject === void 0) {
            reject = function(data2) {
              return {};
            };
          }
          var requestId = uuid_1.uuidv4();
          this.requestCallbacks[requestId] = {
            resolve,
            reject
          };
          if (!this.targetWindow) {
            !GlobalConfiguration_1.default.silentError && console.error("Target window not found!");
            return;
          }
          this.targetWindow.postMessage(__assign({
            runtimeId: this.runtimeId,
            clientId: this.clientId,
            requestId,
            eventType,
            eventName
          }, data), "*");
        };
        FramedClient2.prototype.handleEvent = function(event) {
          var _a2;
          return __awaiter(this, void 0, void 0, function() {
            var data;
            return __generator(this, function(_b) {
              if (event.origin !== this.origin && !config_1.baseUrl.includes(event.origin)) {
                return [
                  2
                  /*return*/
                ];
              }
              if (event.data.clientId !== this.clientId) {
                return [
                  2
                  /*return*/
                ];
              }
              this.debug && console.log(event);
              if (event.source) {
                this.targetWindow = event.source;
              }
              if (event.data.eventType === PostMessageEventType_1.default.Response) {
                this.debug && console.log("[FramedClient][Response]");
                data = event.data;
                if (event.data.eventName === PostMessageEventName_1.default.SkypeTokenAuth) {
                  if (data.requestId in this.requestCallbacks) {
                    this.requestCallbacks[data.requestId].resolve();
                    delete this.requestCallbacks[data.requestId];
                  }
                } else if (event.data.eventName === PostMessageEventName_1.default.CreateObject) {
                  if (data.requestId in this.requestCallbacks) {
                    this.requestCallbacks[data.requestId].resolve(data.response);
                    delete this.requestCallbacks[data.requestId];
                  }
                } else if (event.data.eventName === PostMessageEventName_1.default.UploadDocument) {
                  if (data.requestId in this.requestCallbacks) {
                    this.requestCallbacks[data.requestId].resolve(data.response);
                    delete this.requestCallbacks[data.requestId];
                  }
                } else if (event.data.eventName === PostMessageEventName_1.default.GetViewStatus) {
                  if (data.requestId in this.requestCallbacks) {
                    this.requestCallbacks[data.requestId].resolve(data.response);
                    delete this.requestCallbacks[data.requestId];
                  }
                } else if (event.data.eventName === PostMessageEventName_1.default.GetView) {
                  if (data.requestId in this.requestCallbacks) {
                    this.requestCallbacks[data.requestId].resolve(data.response);
                    delete this.requestCallbacks[data.requestId];
                  }
                } else if (event.data.eventName === PostMessageEventName_1.default.SendTelemetry) {
                  (_a2 = this.logger) === null || _a2 === void 0 ? void 0 : _a2.log(data.logLevel, data.logData.Event, data.logData);
                }
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        FramedClient2.prototype.dispose = function() {
          var _a2;
          (_a2 = document.getElementById(this.iframeId)) === null || _a2 === void 0 ? void 0 : _a2.remove();
          this.requestCallbacks = {};
          this.iframeLoaded = false;
        };
        FramedClient2.prototype.loadIframe = function() {
          return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a2) {
              return [2, new Promise(function(resolve, reject) {
                var iframeElements = Array.from(document.getElementsByTagName("iframe"));
                var foundIframeElement = iframeElements.filter(function(iframeElement2) {
                  return iframeElement2.id == _this.iframeId;
                });
                if (foundIframeElement.length) {
                  return resolve();
                }
                var iframeElement = document.createElement("iframe");
                iframeElement.id = _this.iframeId;
                iframeElement.src = config_1.baseUrl + "/" + version2 + "/iframe.html?clientId=" + _this.clientId + "&debug=" + _this.debug + "&telemetry=true";
                iframeElement.addEventListener("load", function() {
                  _this.debug && console.log("iframe loaded!");
                  _this.iframeLoaded = true;
                  resolve();
                });
                iframeElement.addEventListener("error", function() {
                  reject();
                });
                document.head.append(iframeElement);
              })];
            });
          });
        };
        return FramedClient2;
      }()
    );
    exports2.default = FramedClient;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/API.js
var require_API = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/API.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f3, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f3 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var GlobalConfiguration_1 = require_GlobalConfiguration();
    var AmsApiOperation;
    (function(AmsApiOperation2) {
      AmsApiOperation2["Create"] = "Create";
      AmsApiOperation2["Upload"] = "Upload";
    })(AmsApiOperation || (AmsApiOperation = {}));
    var DocumentTypes;
    (function(DocumentTypes2) {
      DocumentTypes2["CreateDocumentType"] = "sharing/file";
      DocumentTypes2["UploadDocumentType"] = "original";
      DocumentTypes2["CreateImageType"] = "pish/image";
      DocumentTypes2["UploadImageType"] = "imgpsh";
    })(DocumentTypes || (DocumentTypes = {}));
    var HeadersName;
    (function(HeadersName2) {
      HeadersName2["Accept"] = "Accept";
      HeadersName2["AcceptEncoding"] = "Accept-Encoding";
      HeadersName2["BehaviorOverride"] = "BehaviorOverride";
      HeadersName2["Authorization"] = "Authorization";
      HeadersName2["ClientVersion"] = "X-MS-Client-Version";
      HeadersName2["ContentType"] = "Content-Type";
    })(HeadersName || (HeadersName = {}));
    var MIMEType;
    (function(MIMEType2) {
      MIMEType2["applicationFormUrlEncoded"] = "application/x-www-form-urlencoded";
      MIMEType2["applicationJson"] = "application/json";
    })(MIMEType || (MIMEType = {}));
    var AMSFileStatus;
    (function(AMSFileStatus2) {
      AMSFileStatus2["Expired"] = "expired";
      AMSFileStatus2["Failed"] = "failed";
      AMSFileStatus2["InProgress"] = "in progress";
      AMSFileStatus2["Malware"] = "malware";
      AMSFileStatus2["Ready"] = "ready";
    })(AMSFileStatus || (AMSFileStatus = {}));
    var defaultSupportedImagesMimeTypes = ["image/jpeg", "image/png", "image/gif"];
    var patchChatToken = function(chatToken) {
      if (!chatToken.regionGTMS) {
        chatToken.regionGTMS = {
          ams: "https://us-api.asm.skype.com"
        };
      }
    };
    var createDefaultHeaders = function(token) {
      var _a2;
      return _a2 = {}, _a2[HeadersName.Authorization] = "skype_token " + token, _a2[HeadersName.ClientVersion] = "os=Windows; osVer=10; proc=Win32; lcid=en-us; deviceType=1; country=IN; clientName=swc; clientVer=912/0.106.0.34//swc", _a2;
    };
    var skypeTokenAuth = function(chatToken) {
      return __awaiter(void 0, void 0, void 0, function() {
        var url, headers, request, response, error_1;
        var _a2;
        var _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              GlobalConfiguration_1.default.debug && console.log("[API][skypeTokenAuth]");
              patchChatToken(chatToken);
              url = (chatToken.amsEndpoint || ((_b = chatToken.regionGTMS) === null || _b === void 0 ? void 0 : _b.ams)) + "/v1/skypetokenauth";
              headers = (_a2 = {}, _a2[HeadersName.Authorization] = "skype_token " + chatToken.token, _a2[HeadersName.Accept] = MIMEType.applicationJson, _a2[HeadersName.BehaviorOverride] = "redirectAs404", _a2[HeadersName.ContentType] = MIMEType.applicationFormUrlEncoded, _a2);
              request = {
                headers,
                method: "POST",
                body: "skypetoken=" + chatToken.token
              };
              _c.label = 1;
            case 1:
              _c.trys.push([1, 3, , 4]);
              return [4, fetch(url, request)];
            case 2:
              response = _c.sent();
              return [2, response];
            case 3:
              error_1 = _c.sent();
              !GlobalConfiguration_1.default.silentError && console.log(error_1);
              throw new Error("AMSAuth");
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var defineSupportedImagesMimeTypes = function(supportedImagesMimeTypes) {
      return supportedImagesMimeTypes && supportedImagesMimeTypes.length > 0 ? supportedImagesMimeTypes : defaultSupportedImagesMimeTypes;
    };
    var defineTypeForOperation = function(fileType, apiOperation, supportedImagesMimeTypes) {
      var mimeTypes = defineSupportedImagesMimeTypes(supportedImagesMimeTypes);
      if (mimeTypes.includes(fileType.toLowerCase())) {
        return apiOperation === AmsApiOperation.Create ? DocumentTypes.CreateImageType : DocumentTypes.UploadImageType;
      }
      return apiOperation === AmsApiOperation.Create ? DocumentTypes.CreateDocumentType : DocumentTypes.UploadDocumentType;
    };
    var createObject = function(id, file, chatToken, supportedImagesMimeTypes) {
      return __awaiter(void 0, void 0, void 0, function() {
        var permissions, typeObject, body, url, headers, request, response, jsonResponse, error_2;
        var _a2, _b;
        var _c;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              GlobalConfiguration_1.default.debug && console.log("[API][createObject]");
              permissions = (_a2 = {}, _a2[id] = ["read"], _a2);
              typeObject = defineTypeForOperation(file.type, AmsApiOperation.Create, supportedImagesMimeTypes);
              body = {
                filename: file.name,
                permissions,
                type: typeObject
              };
              patchChatToken(chatToken);
              url = (chatToken.amsEndpoint || ((_c = chatToken === null || chatToken === void 0 ? void 0 : chatToken.regionGTMS) === null || _c === void 0 ? void 0 : _c.ams)) + "/v1/objects";
              headers = __assign(__assign({}, createDefaultHeaders(chatToken.token)), (_b = {}, _b[HeadersName.ContentType] = MIMEType.applicationJson, _b));
              request = {
                headers,
                method: "POST",
                body: JSON.stringify(body),
                credentials: "include"
              };
              _d.label = 1;
            case 1:
              _d.trys.push([1, 4, , 5]);
              return [4, fetch(url, request)];
            case 2:
              response = _d.sent();
              return [4, response.json()];
            case 3:
              jsonResponse = _d.sent();
              return [2, jsonResponse];
            case 4:
              error_2 = _d.sent();
              !GlobalConfiguration_1.default.silentError && console.log(error_2);
              throw new Error("AMSCreateObjectFailed");
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var uploadDocument = function(documentId, file, chatToken, supportedImagesMimeTypes) {
      return __awaiter(void 0, void 0, void 0, function() {
        var typeObject, url, headers, request, fileMetadata, error_3;
        var _a2;
        var _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              GlobalConfiguration_1.default.debug && console.log("[API][uploadDocument]");
              patchChatToken(chatToken);
              typeObject = defineTypeForOperation(file.type, AmsApiOperation.Upload, supportedImagesMimeTypes);
              url = (chatToken.amsEndpoint || ((_b = chatToken === null || chatToken === void 0 ? void 0 : chatToken.regionGTMS) === null || _b === void 0 ? void 0 : _b.ams)) + "/v1/objects/" + documentId + "/content/" + typeObject;
              headers = __assign(__assign({}, createDefaultHeaders(chatToken.token)), (_a2 = {}, _a2[HeadersName.ContentType] = MIMEType.applicationFormUrlEncoded, _a2));
              request = {
                headers,
                method: "PUT",
                body: file.data ? file.data : file
                // eslint-disable-line @typescript-eslint/no-explicit-any
              };
              _c.label = 1;
            case 1:
              _c.trys.push([1, 3, , 4]);
              return [4, fetch(url, request)];
            case 2:
              _c.sent();
              fileMetadata = {
                name: file.name,
                size: file.size,
                type: file.type,
                id: documentId,
                url,
                fileSharingProtocolType: 0
                // AMSBasedFileSharing
              };
              return [2, fileMetadata];
            case 3:
              error_3 = _c.sent();
              !GlobalConfiguration_1.default.silentError && console.log(error_3);
              throw new Error("AMSUploadDocumentFailed");
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var getViewStatus = function(fileMetadata, chatToken, supportedImagesMimeTypes) {
      return __awaiter(void 0, void 0, void 0, function() {
        var url, headers, request, response, jsonResponse, content_state, view_state, view_location, error_4;
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              GlobalConfiguration_1.default.debug && console.log("[API][getViewStatus]");
              patchChatToken(chatToken);
              url = (chatToken.amsEndpoint || ((_a2 = chatToken === null || chatToken === void 0 ? void 0 : chatToken.regionGTMS) === null || _a2 === void 0 ? void 0 : _a2.ams)) + "/v1/objects/" + fileMetadata.id + "/views/" + (defineSupportedImagesMimeTypes(supportedImagesMimeTypes).includes(fileMetadata.type) ? "imgpsh_fullsize_anim" : "original") + "/status";
              headers = createDefaultHeaders(chatToken.token);
              request = {
                headers,
                method: "GET"
              };
              _b.label = 1;
            case 1:
              _b.trys.push([1, 4, , 5]);
              return [4, fetch(url, request)];
            case 2:
              response = _b.sent();
              return [4, response.json()];
            case 3:
              jsonResponse = _b.sent();
              content_state = jsonResponse.content_state, view_state = jsonResponse.view_state, view_location = jsonResponse.view_location;
              if (!view_location) {
                throw new Error("view_location is empty");
              }
              if (view_state && view_state !== AMSFileStatus.Ready.toString()) {
                !GlobalConfiguration_1.default.silentError && console.error("view_state is not ready");
              }
              if (content_state === AMSFileStatus.Expired.toString()) {
                throw new Error("content_state is expired");
              }
              return [2, jsonResponse];
            case 4:
              error_4 = _b.sent();
              !GlobalConfiguration_1.default.silentError && console.log(error_4);
              throw new Error("AMSGetViewStatusFailed");
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    var getView = function(fileMetadata, viewLocation, chatToken, supportedImagesMimeTypes) {
      return __awaiter(void 0, void 0, void 0, function() {
        var url, headers, request, response, blobResponse, error_5;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              GlobalConfiguration_1.default.debug && console.log("[API][getView]");
              patchChatToken(chatToken);
              url = viewLocation;
              headers = createDefaultHeaders(chatToken.token);
              if (defineSupportedImagesMimeTypes(supportedImagesMimeTypes).includes(fileMetadata.type)) {
                headers[HeadersName.Accept] = "image/webp,image/ *,*/*;q=0.8";
                headers[HeadersName.AcceptEncoding] = "gzip, deflate, sdch, br";
              }
              request = {
                headers,
                method: "GET"
              };
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 4, , 5]);
              return [4, fetch(url, request)];
            case 2:
              response = _a2.sent();
              return [4, response.blob()];
            case 3:
              blobResponse = _a2.sent();
              return [2, blobResponse];
            case 4:
              error_5 = _a2.sent();
              !GlobalConfiguration_1.default.silentError && console.log(error_5);
              throw new Error("AMSGetViewFailed");
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports2.default = {
      skypeTokenAuth,
      createObject,
      uploadDocument,
      getViewStatus,
      getView
    };
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/LogLevel.js
var require_LogLevel2 = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/LogLevel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2["INFO"] = "INFO";
      LogLevel2["DEBUG"] = "DEBUG";
      LogLevel2["WARN"] = "WARN";
      LogLevel2["ERROR"] = "ERROR";
      LogLevel2["LOG"] = "LOG";
    })(LogLevel || (LogLevel = {}));
    exports2.default = LogLevel;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/telemetry/EventMarker.js
var require_EventMarker = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/telemetry/EventMarker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.failEvent = exports2.completeEvent = exports2.startEvent = void 0;
    var startEvent = function(event) {
      return event + "Started";
    };
    exports2.startEvent = startEvent;
    var completeEvent = function(event) {
      return event + "Completed";
    };
    exports2.completeEvent = completeEvent;
    var failEvent = function(event) {
      return event + "Failed";
    };
    exports2.failEvent = failEvent;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/telemetry/StopWatch.js
var require_StopWatch = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/telemetry/StopWatch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var StopWatch = (
      /** @class */
      function() {
        function StopWatch2() {
        }
        StopWatch2.prototype.start = function() {
          this.timeStart = (/* @__PURE__ */ new Date()).getTime();
        };
        StopWatch2.prototype.stop = function() {
          return (/* @__PURE__ */ new Date()).getTime() - this.timeStart;
        };
        return StopWatch2;
      }()
    );
    exports2.default = StopWatch;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/telemetry/ScenarioMarker.js
var require_ScenarioMarker = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/telemetry/ScenarioMarker.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var LogLevel_1 = require_LogLevel2();
    var config_1 = require_config();
    var EventMarker_1 = require_EventMarker();
    var StopWatch_1 = require_StopWatch();
    var ScenarioMarker = (
      /** @class */
      function() {
        function ScenarioMarker2(logger5) {
          this.runtimeId = "";
          this.sdkVersion = "";
          this.logger = logger5;
          this.sdkVersion = config_1.sdkVersion;
          this.telemetryEvents = /* @__PURE__ */ new Map();
        }
        ScenarioMarker2.prototype.setRuntimeId = function(runtimeId) {
          this.runtimeId = runtimeId;
        };
        ScenarioMarker2.prototype.startScenario = function(event, additionalProperties) {
          if (additionalProperties === void 0) {
            additionalProperties = {};
          }
          if (!this.telemetryEvents.has(event)) {
            var stopWatch = new StopWatch_1.default();
            stopWatch.start();
            this.telemetryEvents.set(event, stopWatch);
          }
          var properties = __assign({ AMSClientRuntimeId: this.runtimeId, Event: EventMarker_1.startEvent(event), AMSClientVersion: this.sdkVersion }, additionalProperties);
          this.logger.log(LogLevel_1.default.INFO, event, properties);
        };
        ScenarioMarker2.prototype.failScenario = function(event, additionalProperties) {
          if (additionalProperties === void 0) {
            additionalProperties = {};
          }
          if (!this.telemetryEvents.has(event)) {
            console.warn("'" + event + "' event has not started.");
            return;
          }
          var stopWatch = this.telemetryEvents.get(event);
          this.telemetryEvents.delete(event);
          var properties = __assign({ AMSClientRuntimeId: this.runtimeId, Event: EventMarker_1.failEvent(event), AMSClientVersion: this.sdkVersion, ElapsedTimeInMilliseconds: stopWatch.stop() }, additionalProperties);
          this.logger.log(LogLevel_1.default.ERROR, event, properties);
        };
        ScenarioMarker2.prototype.completeScenario = function(event, additionalProperties) {
          if (additionalProperties === void 0) {
            additionalProperties = {};
          }
          if (!this.telemetryEvents.has(event)) {
            console.warn("'" + event + "' event has not started.");
            return;
          }
          var stopWatch = this.telemetryEvents.get(event);
          this.telemetryEvents.delete(event);
          var properties = __assign({ AMSClientRuntimeId: this.runtimeId, Event: EventMarker_1.completeEvent(event), AMSClientVersion: this.sdkVersion, ElapsedTimeInMilliseconds: stopWatch.stop() }, additionalProperties);
          this.logger.log(LogLevel_1.default.INFO, event, properties);
        };
        return ScenarioMarker2;
      }()
    );
    exports2.default = ScenarioMarker;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/utils/extractFileExtension.js
var require_extractFileExtension = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/utils/extractFileExtension.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var extractFileExtension = function(fileName) {
      if (!fileName)
        return "";
      var tokens = fileName.split(".");
      if (tokens.length > 2) {
        return "." + tokens[tokens.length - 1];
      }
      if (tokens.length == 2) {
        var left = tokens[0], right = tokens[1];
        if (!left && right) {
          return "";
        }
        if (left && !right) {
          return ".";
        }
        return "." + tokens[tokens.length - 1];
      }
      return "";
    };
    exports2.default = extractFileExtension;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/FramedlessClient.js
var require_FramedlessClient = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/FramedlessClient.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f3, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f3 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var API_1 = require_API();
    var PostMessageEventName_1 = require_PostMessageEventName();
    var platform_1 = require_platform();
    var ScenarioMarker_1 = require_ScenarioMarker();
    var uuid_1 = require_uuid2();
    var extractFileExtension_1 = require_extractFileExtension();
    var FramedlessClient = (
      /** @class */
      function() {
        function FramedlessClient2(logger5) {
          if (logger5 === void 0) {
            logger5 = void 0;
          }
          this.runtimeId = uuid_1.uuidv4();
          this.debug = false;
          this.logger = logger5;
          if (platform_1.default.isBrowser()) {
            console.error("FramedMode should be used on Web platform");
          }
          if (logger5) {
            this.scenarioMarker = new ScenarioMarker_1.default(logger5);
            this.scenarioMarker.setRuntimeId(this.runtimeId);
          }
        }
        FramedlessClient2.prototype.setDebug = function(flag) {
          this.debug = flag;
        };
        FramedlessClient2.prototype.setup = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              return [2, Promise.resolve()];
            });
          });
        };
        FramedlessClient2.prototype.initialize = function(initConfig) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.debug && console.log("[FramedlessClient][initialize]");
                  this.chatToken = initConfig.chatToken;
                  return [4, this.skypeTokenAuth()];
                case 1:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FramedlessClient2.prototype.skypeTokenAuth = function(chatToken) {
          var _a2, _b, _c, _d, _e, _f, _g, _h;
          if (chatToken === void 0) {
            chatToken = null;
          }
          return __awaiter(this, void 0, void 0, function() {
            var response, error_1;
            return __generator(this, function(_j) {
              switch (_j.label) {
                case 0:
                  (_a2 = this.scenarioMarker) === null || _a2 === void 0 ? void 0 : _a2.startScenario(PostMessageEventName_1.default.SkypeTokenAuth, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_b = this.chatToken) === null || _b === void 0 ? void 0 : _b.chatId
                  });
                  _j.label = 1;
                case 1:
                  _j.trys.push([1, 3, , 4]);
                  return [4, API_1.default.skypeTokenAuth(chatToken || this.chatToken)];
                case 2:
                  response = _j.sent();
                  if (!response.ok) {
                    (_c = this.scenarioMarker) === null || _c === void 0 ? void 0 : _c.failScenario(PostMessageEventName_1.default.SkypeTokenAuth, {
                      AMSClientRuntimeId: this.runtimeId,
                      ChatId: chatToken ? chatToken.chatId : (_d = this.chatToken) === null || _d === void 0 ? void 0 : _d.chatId,
                      ExceptionDetails: {
                        status: response.status
                      }
                    });
                  }
                  (_e = this.scenarioMarker) === null || _e === void 0 ? void 0 : _e.completeScenario(PostMessageEventName_1.default.SkypeTokenAuth, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_f = this.chatToken) === null || _f === void 0 ? void 0 : _f.chatId
                  });
                  return [2, response];
                case 3:
                  error_1 = _j.sent();
                  (_g = this.scenarioMarker) === null || _g === void 0 ? void 0 : _g.failScenario(PostMessageEventName_1.default.SkypeTokenAuth, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_h = this.chatToken) === null || _h === void 0 ? void 0 : _h.chatId,
                    ExceptionDetails: error_1
                  });
                  throw new Error("skypeTokenAuth");
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FramedlessClient2.prototype.createObject = function(id, file, chatToken, supportedImagesMimeTypes) {
          var _a2, _b, _c, _d, _e, _f;
          if (chatToken === void 0) {
            chatToken = null;
          }
          if (supportedImagesMimeTypes === void 0) {
            supportedImagesMimeTypes = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var response, error_2;
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  (_a2 = this.scenarioMarker) === null || _a2 === void 0 ? void 0 : _a2.startScenario(PostMessageEventName_1.default.CreateObject, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_b = this.chatToken) === null || _b === void 0 ? void 0 : _b.chatId,
                    MimeType: file.type,
                    FileExtension: extractFileExtension_1.default(file.name)
                  });
                  _g.label = 1;
                case 1:
                  _g.trys.push([1, 3, , 4]);
                  return [4, API_1.default.createObject(id, file, chatToken || this.chatToken, supportedImagesMimeTypes)];
                case 2:
                  response = _g.sent();
                  (_c = this.scenarioMarker) === null || _c === void 0 ? void 0 : _c.completeScenario(PostMessageEventName_1.default.CreateObject, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_d = this.chatToken) === null || _d === void 0 ? void 0 : _d.chatId,
                    DocumentId: response === null || response === void 0 ? void 0 : response.id,
                    MimeType: file.type,
                    FileExtension: extractFileExtension_1.default(file.name)
                  });
                  return [2, response];
                case 3:
                  error_2 = _g.sent();
                  (_e = this.scenarioMarker) === null || _e === void 0 ? void 0 : _e.failScenario(PostMessageEventName_1.default.CreateObject, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_f = this.chatToken) === null || _f === void 0 ? void 0 : _f.chatId,
                    MimeType: file.type,
                    FileExtension: extractFileExtension_1.default(file.name),
                    ExceptionDetails: error_2
                  });
                  throw new Error("createObject");
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FramedlessClient2.prototype.uploadDocument = function(documentId, file, chatToken, supportedImagesMimeTypes) {
          var _a2, _b, _c, _d, _e, _f;
          if (chatToken === void 0) {
            chatToken = null;
          }
          if (supportedImagesMimeTypes === void 0) {
            supportedImagesMimeTypes = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var response, error_3;
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  (_a2 = this.scenarioMarker) === null || _a2 === void 0 ? void 0 : _a2.startScenario(PostMessageEventName_1.default.UploadDocument, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_b = this.chatToken) === null || _b === void 0 ? void 0 : _b.chatId,
                    DocumentId: documentId,
                    MimeType: file.type,
                    FileExtension: extractFileExtension_1.default(file.name)
                  });
                  _g.label = 1;
                case 1:
                  _g.trys.push([1, 3, , 4]);
                  return [4, API_1.default.uploadDocument(documentId, file, chatToken || this.chatToken, supportedImagesMimeTypes)];
                case 2:
                  response = _g.sent();
                  (_c = this.scenarioMarker) === null || _c === void 0 ? void 0 : _c.completeScenario(PostMessageEventName_1.default.UploadDocument, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_d = this.chatToken) === null || _d === void 0 ? void 0 : _d.chatId,
                    DocumentId: documentId,
                    MimeType: file.type,
                    FileExtension: extractFileExtension_1.default(file.name)
                  });
                  return [2, response];
                case 3:
                  error_3 = _g.sent();
                  (_e = this.scenarioMarker) === null || _e === void 0 ? void 0 : _e.failScenario(PostMessageEventName_1.default.UploadDocument, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_f = this.chatToken) === null || _f === void 0 ? void 0 : _f.chatId,
                    DocumentId: documentId,
                    MimeType: file.type,
                    FileExtension: extractFileExtension_1.default(file.name),
                    ExceptionDetails: error_3
                  });
                  throw new Error("uploadDocument");
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FramedlessClient2.prototype.getViewStatus = function(fileMetadata, chatToken, supportedImagesMimeTypes) {
          var _a2, _b, _c, _d, _e, _f;
          if (chatToken === void 0) {
            chatToken = null;
          }
          if (supportedImagesMimeTypes === void 0) {
            supportedImagesMimeTypes = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var response, error_4;
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  (_a2 = this.scenarioMarker) === null || _a2 === void 0 ? void 0 : _a2.startScenario(PostMessageEventName_1.default.GetViewStatus, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_b = this.chatToken) === null || _b === void 0 ? void 0 : _b.chatId,
                    DocumentId: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.id,
                    MimeType: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.type,
                    FileExtension: extractFileExtension_1.default((fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.name) || "")
                  });
                  _g.label = 1;
                case 1:
                  _g.trys.push([1, 3, , 4]);
                  return [4, API_1.default.getViewStatus(fileMetadata, chatToken || this.chatToken, supportedImagesMimeTypes)];
                case 2:
                  response = _g.sent();
                  (_c = this.scenarioMarker) === null || _c === void 0 ? void 0 : _c.completeScenario(PostMessageEventName_1.default.GetViewStatus, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_d = this.chatToken) === null || _d === void 0 ? void 0 : _d.chatId,
                    DocumentId: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.id,
                    MimeType: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.type,
                    FileExtension: extractFileExtension_1.default((fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.name) || "")
                  });
                  return [2, response];
                case 3:
                  error_4 = _g.sent();
                  (_e = this.scenarioMarker) === null || _e === void 0 ? void 0 : _e.failScenario(PostMessageEventName_1.default.GetViewStatus, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_f = this.chatToken) === null || _f === void 0 ? void 0 : _f.chatId,
                    DocumentId: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.id,
                    MimeType: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.type,
                    FileExtension: extractFileExtension_1.default((fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.name) || ""),
                    ExceptionDetails: error_4
                  });
                  throw new Error("getViewStatus");
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FramedlessClient2.prototype.getView = function(fileMetadata, viewLocation, chatToken, supportedImagesMimeTypes) {
          var _a2, _b, _c, _d, _e, _f;
          if (chatToken === void 0) {
            chatToken = null;
          }
          if (supportedImagesMimeTypes === void 0) {
            supportedImagesMimeTypes = [];
          }
          return __awaiter(this, void 0, void 0, function() {
            var response, error_5;
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  (_a2 = this.scenarioMarker) === null || _a2 === void 0 ? void 0 : _a2.startScenario(PostMessageEventName_1.default.GetView, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_b = this.chatToken) === null || _b === void 0 ? void 0 : _b.chatId,
                    DocumentId: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.id,
                    MimeType: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.type,
                    FileExtension: extractFileExtension_1.default((fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.name) || "")
                  });
                  _g.label = 1;
                case 1:
                  _g.trys.push([1, 3, , 4]);
                  return [4, API_1.default.getView(fileMetadata, viewLocation, chatToken || this.chatToken, supportedImagesMimeTypes)];
                case 2:
                  response = _g.sent();
                  (_c = this.scenarioMarker) === null || _c === void 0 ? void 0 : _c.completeScenario(PostMessageEventName_1.default.GetView, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_d = this.chatToken) === null || _d === void 0 ? void 0 : _d.chatId,
                    DocumentId: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.id,
                    MimeType: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.type,
                    FileExtension: extractFileExtension_1.default((fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.name) || "")
                  });
                  return [2, response];
                case 3:
                  error_5 = _g.sent();
                  (_e = this.scenarioMarker) === null || _e === void 0 ? void 0 : _e.failScenario(PostMessageEventName_1.default.GetView, {
                    AMSClientRuntimeId: this.runtimeId,
                    ChatId: chatToken ? chatToken.chatId : (_f = this.chatToken) === null || _f === void 0 ? void 0 : _f.chatId,
                    DocumentId: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.id,
                    MimeType: fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.type,
                    FileExtension: extractFileExtension_1.default((fileMetadata === null || fileMetadata === void 0 ? void 0 : fileMetadata.name) || ""),
                    ExceptionDetails: error_5
                  });
                  throw new Error("getView");
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FramedlessClient2.prototype.fetchBlob = function(contentUrl) {
          return __awaiter(this, void 0, void 0, function() {
            var response, blobResponse, error_6;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  _a2.trys.push([0, 3, , 4]);
                  return [4, fetch(contentUrl)];
                case 1:
                  response = _a2.sent();
                  return [4, response.blob()];
                case 2:
                  blobResponse = _a2.sent();
                  return [2, blobResponse];
                case 3:
                  error_6 = _a2.sent();
                  console.log(error_6);
                  throw new Error("fetchBlob");
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return FramedlessClient2;
      }()
    );
    exports2.default = FramedlessClient;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/createAMSClient.js
var require_createAMSClient = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/createAMSClient.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f3, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f3)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f3 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var AMSLogger_1 = require_AMSLogger();
    var FramedClient_1 = require_FramedClient();
    var FramedlessClient_1 = require_FramedlessClient();
    var GlobalConfiguration_1 = require_GlobalConfiguration();
    var createAMSClient = function(config) {
      return __awaiter(void 0, void 0, void 0, function() {
        var logger5, framedClientConfig, client;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              config.debug && console.log("[createAMSClient] " + (config.framedMode ? "FramedClient" : "FramedlessClient"));
              logger5 = new AMSLogger_1.default(config.logger);
              framedClientConfig = {
                multiClient: config.multiClient || false
              };
              client = config.framedMode ? new FramedClient_1.default(logger5, framedClientConfig) : new FramedlessClient_1.default(logger5);
              return [4, client.setup()];
            case 1:
              _a2.sent();
              config.debug && client.setDebug(config.debug || false);
              GlobalConfiguration_1.default.debug = config.debug || false;
              GlobalConfiguration_1.default.silentError = config.silentError || true;
              return [2, client];
          }
        });
      });
    };
    exports2.default = createAMSClient;
  }
});

// node_modules/@microsoft/omnichannel-amsclient/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var createAMSClient_1 = require_createAMSClient();
    var FramedlessClient_1 = require_FramedlessClient();
    var FramedClient_1 = require_FramedClient();
    exports2.default = createAMSClient_1.default;
    (function() {
      if (typeof window === void 0) {
        throw new Error("window object not found");
      }
      if (!("Microsoft" in window)) {
        window.Microsoft = {};
      }
      if (!("CRM" in window.Microsoft)) {
        window.Microsoft.CRM = {};
      }
      if (!("Omnichannel" in window.Microsoft.CRM)) {
        window.Microsoft.CRM.Omnichannel = {};
      }
      if (!("AMSClient" in window.Microsoft.CRM.Omnichannel)) {
        window.Microsoft.CRM.Omnichannel.AMS = {
          SDK: {
            createAMSClient: createAMSClient_1.default,
            FramedClient: FramedClient_1.default,
            FramedlessClient: FramedlessClient_1.default
          }
        };
      }
    })();
  }
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports2, module2) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    module2.exports = _classCallCheck, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports2, module2) {
    var _typeof = require_typeof()["default"];
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    module2.exports = _toPrimitive, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports2, module2) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function _toPropertyKey(arg) {
      var key = toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    module2.exports = _toPropertyKey, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime/helpers/createClass.js"(exports2, module2) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    module2.exports = _createClass, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@azure/communication-common/node_modules/jwt-decode/lib/atob.js
var require_atob = __commonJS({
  "node_modules/@azure/communication-common/node_modules/jwt-decode/lib/atob.js"(exports2, module2) {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function InvalidCharacterError(message) {
      this.message = message;
    }
    InvalidCharacterError.prototype = new Error();
    InvalidCharacterError.prototype.name = "InvalidCharacterError";
    function polyfill(input) {
      var str2 = String(input).replace(/=+$/, "");
      if (str2.length % 4 == 1) {
        throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
      }
      for (
        var bc = 0, bs, buffer, idx = 0, output = "";
        // get next character
        buffer = str2.charAt(idx++);
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
      ) {
        buffer = chars.indexOf(buffer);
      }
      return output;
    }
    module2.exports = typeof window !== "undefined" && window.atob && window.atob.bind(window) || polyfill;
  }
});

// node_modules/@azure/communication-common/node_modules/jwt-decode/lib/base64_url_decode.js
var require_base64_url_decode = __commonJS({
  "node_modules/@azure/communication-common/node_modules/jwt-decode/lib/base64_url_decode.js"(exports2, module2) {
    var atob2 = require_atob();
    function b64DecodeUnicode(str2) {
      return decodeURIComponent(atob2(str2).replace(/(.)/g, function(m, p) {
        var code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
          code = "0" + code;
        }
        return "%" + code;
      }));
    }
    module2.exports = function(str2) {
      var output = str2.replace(/-/g, "+").replace(/_/g, "/");
      switch (output.length % 4) {
        case 0:
          break;
        case 2:
          output += "==";
          break;
        case 3:
          output += "=";
          break;
        default:
          throw "Illegal base64url string!";
      }
      try {
        return b64DecodeUnicode(output);
      } catch (err) {
        return atob2(output);
      }
    };
  }
});

// node_modules/@azure/communication-common/node_modules/jwt-decode/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@azure/communication-common/node_modules/jwt-decode/lib/index.js"(exports2, module2) {
    "use strict";
    var base64_url_decode = require_base64_url_decode();
    function InvalidTokenError(message) {
      this.message = message;
    }
    InvalidTokenError.prototype = new Error();
    InvalidTokenError.prototype.name = "InvalidTokenError";
    module2.exports = function(token, options) {
      if (typeof token !== "string") {
        throw new InvalidTokenError("Invalid token specified");
      }
      options = options || {};
      var pos = options.header === true ? 0 : 1;
      try {
        return JSON.parse(base64_url_decode(token.split(".")[pos]));
      } catch (e) {
        throw new InvalidTokenError("Invalid token specified: " + e.message);
      }
    };
    module2.exports.InvalidTokenError = InvalidTokenError;
  }
});

// node_modules/@azure/communication-common/dist-esm/src/tokenParser.js
var import_jwt_decode, parseToken;
var init_tokenParser = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/tokenParser.js"() {
    import_jwt_decode = __toESM(require_lib3());
    parseToken = (token) => {
      const { exp } = (0, import_jwt_decode.default)(token);
      return {
        token,
        expiresOnTimestamp: exp * 1e3
      };
    };
  }
});

// node_modules/@azure/communication-common/dist-esm/src/staticTokenCredential.js
var StaticTokenCredential;
var init_staticTokenCredential = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/staticTokenCredential.js"() {
    StaticTokenCredential = class {
      constructor(token) {
        this.token = token;
      }
      async getToken() {
        return this.token;
      }
      dispose() {
      }
    };
  }
});

// node_modules/@azure/communication-common/dist-esm/src/autoRefreshTokenCredential.js
var expiredToken, minutesToMs, defaultRefreshingInterval, AutoRefreshTokenCredential;
var init_autoRefreshTokenCredential = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/autoRefreshTokenCredential.js"() {
    init_tokenParser();
    expiredToken = { token: "", expiresOnTimestamp: -10 };
    minutesToMs = (minutes) => minutes * 1e3 * 60;
    defaultRefreshingInterval = minutesToMs(10);
    AutoRefreshTokenCredential = class {
      constructor(refreshArgs) {
        this.refreshingIntervalInMs = defaultRefreshingInterval;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.disposed = false;
        const { tokenRefresher, token, refreshProactively } = refreshArgs;
        this.refresh = tokenRefresher;
        this.currentToken = token ? parseToken(token) : expiredToken;
        this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;
        if (this.refreshProactively) {
          this.scheduleRefresh();
        }
      }
      async getToken(options) {
        if (!this.isCurrentTokenExpiringSoon) {
          return this.currentToken;
        }
        const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);
        if (!this.isCurrentTokenValid) {
          await updatePromise;
        }
        return this.currentToken;
      }
      dispose() {
        this.disposed = true;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.currentToken = expiredToken;
        if (this.activeTimeout) {
          clearTimeout(this.activeTimeout);
        }
      }
      async updateTokenAndReschedule(abortSignal2) {
        if (this.activeTokenUpdating) {
          return this.activeTokenUpdating;
        }
        this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal2);
        try {
          await this.activeTokenUpdating;
        } finally {
          this.activeTokenUpdating = null;
        }
      }
      async refreshTokenAndReschedule(abortSignal2) {
        this.currentToken = await this.refreshToken(abortSignal2);
        if (this.refreshProactively) {
          this.scheduleRefresh();
        }
      }
      async refreshToken(abortSignal2) {
        try {
          if (!this.activeTokenFetching) {
            this.activeTokenFetching = this.refresh(abortSignal2);
          }
          return parseToken(await this.activeTokenFetching);
        } finally {
          this.activeTokenFetching = null;
        }
      }
      scheduleRefresh() {
        if (this.disposed) {
          return;
        }
        if (this.activeTimeout) {
          clearTimeout(this.activeTimeout);
        }
        const timespanInMs = this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;
        this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);
      }
      get isCurrentTokenValid() {
        return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;
      }
      get isCurrentTokenExpiringSoon() {
        return !this.currentToken || Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs;
      }
    };
  }
});

// node_modules/@azure/communication-common/dist-esm/src/communicationTokenCredential.js
var AzureCommunicationTokenCredential;
var init_communicationTokenCredential = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/communicationTokenCredential.js"() {
    init_tokenParser();
    init_staticTokenCredential();
    init_autoRefreshTokenCredential();
    AzureCommunicationTokenCredential = class {
      constructor(tokenOrRefreshOptions) {
        this.disposed = false;
        if (typeof tokenOrRefreshOptions === "string") {
          this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));
        } else {
          this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);
        }
      }
      /**
       * Gets an `AccessToken` for the user. Throws if already disposed.
       * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.
       */
      async getToken(options) {
        this.throwIfDisposed();
        const token = await this.tokenCredential.getToken(options);
        this.throwIfDisposed();
        return token;
      }
      /**
       * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.
       */
      dispose() {
        this.disposed = true;
        this.tokenCredential.dispose();
      }
      throwIfDisposed() {
        if (this.disposed) {
          throw new Error("User credential is disposed");
        }
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/httpHeaders.js
function getHeaderKey(headerName) {
  return headerName.toLowerCase();
}
function isHttpHeadersLike(object) {
  if (object && typeof object === "object") {
    const castObject = object;
    if (typeof castObject.rawHeaders === "function" && typeof castObject.clone === "function" && typeof castObject.get === "function" && typeof castObject.set === "function" && typeof castObject.contains === "function" && typeof castObject.remove === "function" && typeof castObject.headersArray === "function" && typeof castObject.headerValues === "function" && typeof castObject.headerNames === "function" && typeof castObject.toJson === "function") {
      return true;
    }
  }
  return false;
}
var HttpHeaders;
var init_httpHeaders = __esm({
  "node_modules/@azure/core-http/dist-esm/src/httpHeaders.js"() {
    HttpHeaders = class _HttpHeaders {
      constructor(rawHeaders) {
        this._headersMap = {};
        if (rawHeaders) {
          for (const headerName in rawHeaders) {
            this.set(headerName, rawHeaders[headerName]);
          }
        }
      }
      /**
       * Set a header in this collection with the provided name and value. The name is
       * case-insensitive.
       * @param headerName - The name of the header to set. This value is case-insensitive.
       * @param headerValue - The value of the header to set.
       */
      set(headerName, headerValue) {
        this._headersMap[getHeaderKey(headerName)] = {
          name: headerName,
          value: headerValue.toString()
        };
      }
      /**
       * Get the header value for the provided header name, or undefined if no header exists in this
       * collection with the provided name.
       * @param headerName - The name of the header.
       */
      get(headerName) {
        const header = this._headersMap[getHeaderKey(headerName)];
        return !header ? void 0 : header.value;
      }
      /**
       * Get whether or not this header collection contains a header entry for the provided header name.
       */
      contains(headerName) {
        return !!this._headersMap[getHeaderKey(headerName)];
      }
      /**
       * Remove the header with the provided headerName. Return whether or not the header existed and
       * was removed.
       * @param headerName - The name of the header to remove.
       */
      remove(headerName) {
        const result = this.contains(headerName);
        delete this._headersMap[getHeaderKey(headerName)];
        return result;
      }
      /**
       * Get the headers that are contained this collection as an object.
       */
      rawHeaders() {
        return this.toJson({ preserveCase: true });
      }
      /**
       * Get the headers that are contained in this collection as an array.
       */
      headersArray() {
        const headers = [];
        for (const headerKey in this._headersMap) {
          headers.push(this._headersMap[headerKey]);
        }
        return headers;
      }
      /**
       * Get the header names that are contained in this collection.
       */
      headerNames() {
        const headerNames = [];
        const headers = this.headersArray();
        for (let i = 0; i < headers.length; ++i) {
          headerNames.push(headers[i].name);
        }
        return headerNames;
      }
      /**
       * Get the header values that are contained in this collection.
       */
      headerValues() {
        const headerValues = [];
        const headers = this.headersArray();
        for (let i = 0; i < headers.length; ++i) {
          headerValues.push(headers[i].value);
        }
        return headerValues;
      }
      /**
       * Get the JSON object representation of this HTTP header collection.
       */
      toJson(options = {}) {
        const result = {};
        if (options.preserveCase) {
          for (const headerKey in this._headersMap) {
            const header = this._headersMap[headerKey];
            result[header.name] = header.value;
          }
        } else {
          for (const headerKey in this._headersMap) {
            const header = this._headersMap[headerKey];
            result[getHeaderKey(header.name)] = header.value;
          }
        }
        return result;
      }
      /**
       * Get the string representation of this HTTP header collection.
       */
      toString() {
        return JSON.stringify(this.toJson({ preserveCase: true }));
      }
      /**
       * Create a deep clone/copy of this HttpHeaders collection.
       */
      clone() {
        const resultPreservingCasing = {};
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          resultPreservingCasing[header.name] = header.value;
        }
        return new _HttpHeaders(resultPreservingCasing);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/base64.browser.js
function encodeString(value) {
  return btoa(value);
}
function encodeByteArray(value) {
  let str2 = "";
  for (let i = 0; i < value.length; i++) {
    str2 += String.fromCharCode(value[i]);
  }
  return btoa(str2);
}
function decodeString(value) {
  const byteString = atob(value);
  const arr = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    arr[i] = byteString.charCodeAt(i);
  }
  return arr;
}
var init_base64_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/base64.browser.js"() {
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/constants.js
var Constants;
var init_constants = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/constants.js"() {
    Constants = {
      /**
       * The core-http version
       */
      coreHttpVersion: "2.3.2",
      /**
       * Specifies HTTP.
       */
      HTTP: "http:",
      /**
       * Specifies HTTPS.
       */
      HTTPS: "https:",
      /**
       * Specifies HTTP Proxy.
       */
      HTTP_PROXY: "HTTP_PROXY",
      /**
       * Specifies HTTPS Proxy.
       */
      HTTPS_PROXY: "HTTPS_PROXY",
      /**
       * Specifies NO Proxy.
       */
      NO_PROXY: "NO_PROXY",
      /**
       * Specifies ALL Proxy.
       */
      ALL_PROXY: "ALL_PROXY",
      HttpConstants: {
        /**
         * Http Verbs
         */
        HttpVerbs: {
          PUT: "PUT",
          GET: "GET",
          DELETE: "DELETE",
          POST: "POST",
          MERGE: "MERGE",
          HEAD: "HEAD",
          PATCH: "PATCH"
        },
        StatusCodes: {
          TooManyRequests: 429,
          ServiceUnavailable: 503
        }
      },
      /**
       * Defines constants for use with HTTP headers.
       */
      HeaderConstants: {
        /**
         * The Authorization header.
         */
        AUTHORIZATION: "authorization",
        AUTHORIZATION_SCHEME: "Bearer",
        /**
         * The Retry-After response-header field can be used with a 503 (Service
         * Unavailable) or 349 (Too Many Requests) responses to indicate how long
         * the service is expected to be unavailable to the requesting client.
         */
        RETRY_AFTER: "Retry-After",
        /**
         * The UserAgent header.
         */
        USER_AGENT: "User-Agent"
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/serializer.common.js
var XML_ATTRKEY, XML_CHARKEY;
var init_serializer_common = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/serializer.common.js"() {
    XML_ATTRKEY = "$";
    XML_CHARKEY = "_";
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-browser/stringify.js
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, i, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str2) {
  str2 = unescape(encodeURIComponent(str2));
  var bytes = [];
  for (var i = 0; i < str2.length; ++i) {
    bytes.push(str2.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID2(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID2.name = name;
  } catch (err) {
  }
  generateUUID2.DNS = DNS;
  generateUUID2.URL = URL2;
  return generateUUID2;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/sha1.js
function f2(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes[_i * 64 + j2 * 4] << 24 | bytes[_i * 64 + j2 * 4 + 1] << 16 | bytes[_i * 64 + j2 * 4 + 2] << 8 | bytes[_i * 64 + j2 * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f2(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-browser/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-browser/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-browser/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = {};
__export(esm_browser_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/utils.js
function encodeUri(uri) {
  return encodeURIComponent(uri).replace(/!/g, "%21").replace(/"/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
}
function stripResponse(response) {
  const strippedResponse = {};
  strippedResponse.body = response.bodyAsText;
  strippedResponse.headers = response.headers;
  strippedResponse.status = response.status;
  return strippedResponse;
}
function stripRequest(request) {
  const strippedRequest = request.clone();
  if (strippedRequest.headers) {
    strippedRequest.headers.remove("authorization");
  }
  return strippedRequest;
}
function isValidUuid(uuid) {
  return validUuidRegex.test(uuid);
}
function generateUuid() {
  return v4_default();
}
function executePromisesSequentially(promiseFactories, kickstart) {
  let result = Promise.resolve(kickstart);
  promiseFactories.forEach((promiseFactory) => {
    result = result.then(promiseFactory);
  });
  return result;
}
function promiseToCallback(promise) {
  if (typeof promise.then !== "function") {
    throw new Error("The provided input is not a Promise.");
  }
  return (cb) => {
    promise.then((data) => {
      return cb(void 0, data);
    }).catch((err) => {
      cb(err);
    });
  };
}
function promiseToServiceCallback(promise) {
  if (typeof promise.then !== "function") {
    throw new Error("The provided input is not a Promise.");
  }
  return (cb) => {
    promise.then((data) => {
      return process.nextTick(cb, void 0, data.parsedBody, data.request, data);
    }).catch((err) => {
      process.nextTick(cb, err);
    });
  };
}
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  if (!Array.isArray(obj)) {
    obj = [obj];
  }
  if (!xmlNamespaceKey || !xmlNamespace) {
    return { [elementName]: obj };
  }
  const result = { [elementName]: obj };
  result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
  return result;
}
function applyMixins(targetCtorParam, sourceCtors) {
  const castTargetCtorParam = targetCtorParam;
  sourceCtors.forEach((sourceCtor) => {
    Object.getOwnPropertyNames(sourceCtor.prototype).forEach((name) => {
      castTargetCtorParam.prototype[name] = sourceCtor.prototype[name];
    });
  });
}
function isDuration(value) {
  return validateISODuration.test(value);
}
function replaceAll(value, searchValue, replaceValue) {
  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
}
function isPrimitiveType(value) {
  return typeof value !== "object" && typeof value !== "function" || value === null;
}
function isObject(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}
var validUuidRegex, isNode, validateISODuration;
var init_utils = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/utils.js"() {
    init_constants();
    init_serializer_common();
    init_esm_browser();
    validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
    isNode = typeof process !== "undefined" && !!process.version && !!process.versions && !!process.versions.node;
    validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  }
});

// node_modules/@azure/core-http/dist-esm/src/serializer.js
function trimEnd(str2, ch) {
  let len = str2.length;
  while (len - 1 >= 0 && str2[len - 1] === ch) {
    --len;
  }
  return str2.substr(0, len);
}
function bufferToBase64Url(buffer) {
  if (!buffer) {
    return void 0;
  }
  if (!(buffer instanceof Uint8Array)) {
    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
  }
  const str2 = encodeByteArray(buffer);
  return trimEnd(str2, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64UrlToByteArray(str2) {
  if (!str2) {
    return void 0;
  }
  if (str2 && typeof str2.valueOf() !== "string") {
    throw new Error("Please provide an input of type string for converting to Uint8Array");
  }
  str2 = str2.replace(/-/g, "+").replace(/_/g, "/");
  return decodeString(str2);
}
function splitSerializeName(prop) {
  const classes = [];
  let partialclass = "";
  if (prop) {
    const subwords = prop.split(".");
    for (const item of subwords) {
      if (item.charAt(item.length - 1) === "\\") {
        partialclass += item.substr(0, item.length - 1) + ".";
      } else {
        partialclass += item;
        classes.push(partialclass);
        partialclass = "";
      }
    }
  }
  return classes;
}
function dateToUnixTime(d) {
  if (!d) {
    return void 0;
  }
  if (typeof d.valueOf() === "string") {
    d = new Date(d);
  }
  return Math.floor(d.getTime() / 1e3);
}
function unixTimeToDate(n) {
  if (!n) {
    return void 0;
  }
  return new Date(n * 1e3);
}
function serializeBasicTypes(typeName, objectName, value) {
  if (value !== null && value !== void 0) {
    if (typeName.match(/^Number$/i) !== null) {
      if (typeof value !== "number") {
        throw new Error(`${objectName} with value ${value} must be of type number.`);
      }
    } else if (typeName.match(/^String$/i) !== null) {
      if (typeof value.valueOf() !== "string") {
        throw new Error(`${objectName} with value "${value}" must be of type string.`);
      }
    } else if (typeName.match(/^Uuid$/i) !== null) {
      if (!(typeof value.valueOf() === "string" && isValidUuid(value))) {
        throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
      }
    } else if (typeName.match(/^Boolean$/i) !== null) {
      if (typeof value !== "boolean") {
        throw new Error(`${objectName} with value ${value} must be of type boolean.`);
      }
    } else if (typeName.match(/^Stream$/i) !== null) {
      const objectType = typeof value;
      if (objectType !== "string" && objectType !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob)) {
        throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`);
      }
    }
  }
  return value;
}
function serializeEnumType(objectName, allowedValues, value) {
  if (!allowedValues) {
    throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
  }
  const isPresent = allowedValues.some((item) => {
    if (typeof item.valueOf() === "string") {
      return item.toLowerCase() === value.toLowerCase();
    }
    return item === value;
  });
  if (!isPresent) {
    throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
  }
  return value;
}
function serializeByteArrayType(objectName, value) {
  let returnValue = "";
  if (value != void 0) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    returnValue = encodeByteArray(value);
  }
  return returnValue;
}
function serializeBase64UrlType(objectName, value) {
  let returnValue = "";
  if (value != void 0) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    returnValue = bufferToBase64Url(value) || "";
  }
  return returnValue;
}
function serializeDateTypes(typeName, value, objectName) {
  if (value != void 0) {
    if (typeName.match(/^Date$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
    } else if (typeName.match(/^DateTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
      }
      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
    } else if (typeName.match(/^UnixTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
      }
      value = dateToUnixTime(value);
    } else if (typeName.match(/^TimeSpan$/i) !== null) {
      if (!isDuration(value)) {
        throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
      }
    }
  }
  return value;
}
function serializeSequenceType(serializer3, mapper, object, objectName, isXml, options) {
  if (!Array.isArray(object)) {
    throw new Error(`${objectName} must be of type Array.`);
  }
  const elementType = mapper.type.element;
  if (!elementType || typeof elementType !== "object") {
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}.`);
  }
  const tempArray = [];
  for (let i = 0; i < object.length; i++) {
    const serializedValue = serializer3.serialize(elementType, object[i], objectName, options);
    if (isXml && elementType.xmlNamespace) {
      const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
      if (elementType.type.name === "Composite") {
        tempArray[i] = Object.assign({}, serializedValue);
        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
      } else {
        tempArray[i] = {};
        tempArray[i][options.xmlCharKey] = serializedValue;
        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
      }
    } else {
      tempArray[i] = serializedValue;
    }
  }
  return tempArray;
}
function serializeDictionaryType(serializer3, mapper, object, objectName, isXml, options) {
  if (typeof object !== "object") {
    throw new Error(`${objectName} must be of type object.`);
  }
  const valueType = mapper.type.value;
  if (!valueType || typeof valueType !== "object") {
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}.`);
  }
  const tempDictionary = {};
  for (const key of Object.keys(object)) {
    const serializedValue = serializer3.serialize(valueType, object[key], objectName, options);
    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
  }
  if (isXml && mapper.xmlNamespace) {
    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
    const result = tempDictionary;
    result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
    return result;
  }
  return tempDictionary;
}
function resolveAdditionalProperties(serializer3, mapper, objectName) {
  const additionalProperties = mapper.type.additionalProperties;
  if (!additionalProperties && mapper.type.className) {
    const modelMapper = resolveReferencedMapper(serializer3, mapper, objectName);
    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
  }
  return additionalProperties;
}
function resolveReferencedMapper(serializer3, mapper, objectName) {
  const className = mapper.type.className;
  if (!className) {
    throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, void 0, 2)}".`);
  }
  return serializer3.modelMappers[className];
}
function resolveModelProperties(serializer3, mapper, objectName) {
  let modelProps = mapper.type.modelProperties;
  if (!modelProps) {
    const modelMapper = resolveReferencedMapper(serializer3, mapper, objectName);
    if (!modelMapper) {
      throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
    }
    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
    if (!modelProps) {
      throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
    }
  }
  return modelProps;
}
function serializeCompositeType(serializer3, mapper, object, objectName, isXml, options) {
  if (getPolymorphicDiscriminatorRecursively(serializer3, mapper)) {
    mapper = getPolymorphicMapper(serializer3, mapper, object, "clientName");
  }
  if (object != void 0) {
    const payload = {};
    const modelProps = resolveModelProperties(serializer3, mapper, objectName);
    for (const key of Object.keys(modelProps)) {
      const propertyMapper = modelProps[key];
      if (propertyMapper.readOnly) {
        continue;
      }
      let propName;
      let parentObject = payload;
      if (serializer3.isXML) {
        if (propertyMapper.xmlIsWrapped) {
          propName = propertyMapper.xmlName;
        } else {
          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
        }
      } else {
        const paths = splitSerializeName(propertyMapper.serializedName);
        propName = paths.pop();
        for (const pathName of paths) {
          const childObject = parentObject[pathName];
          if (childObject == void 0 && (object[key] != void 0 || propertyMapper.defaultValue !== void 0)) {
            parentObject[pathName] = {};
          }
          parentObject = parentObject[pathName];
        }
      }
      if (parentObject != void 0) {
        if (isXml && mapper.xmlNamespace) {
          const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
          parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });
        }
        const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
        let toSerialize = object[key];
        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer3, mapper);
        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == void 0) {
          toSerialize = mapper.serializedName;
        }
        const serializedValue = serializer3.serialize(propertyMapper, toSerialize, propertyObjectName, options);
        if (serializedValue !== void 0 && propName != void 0) {
          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
          if (isXml && propertyMapper.xmlIsAttribute) {
            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};
            parentObject[XML_ATTRKEY][propName] = serializedValue;
          } else if (isXml && propertyMapper.xmlIsWrapped) {
            parentObject[propName] = { [propertyMapper.xmlElementName]: value };
          } else {
            parentObject[propName] = value;
          }
        }
      }
    }
    const additionalPropertiesMapper = resolveAdditionalProperties(serializer3, mapper, objectName);
    if (additionalPropertiesMapper) {
      const propNames = Object.keys(modelProps);
      for (const clientPropName in object) {
        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
        if (isAdditionalProperty) {
          payload[clientPropName] = serializer3.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
        }
      }
    }
    return payload;
  }
  return object;
}
function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
  if (!isXml || !propertyMapper.xmlNamespace) {
    return serializedValue;
  }
  const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
  if (["Composite"].includes(propertyMapper.type.name)) {
    if (serializedValue[XML_ATTRKEY]) {
      return serializedValue;
    } else {
      const result2 = Object.assign({}, serializedValue);
      result2[XML_ATTRKEY] = xmlNamespace;
      return result2;
    }
  }
  const result = {};
  result[options.xmlCharKey] = serializedValue;
  result[XML_ATTRKEY] = xmlNamespace;
  return result;
}
function isSpecialXmlProperty(propertyName, options) {
  return [XML_ATTRKEY, options.xmlCharKey].includes(propertyName);
}
function deserializeCompositeType(serializer3, mapper, responseBody, objectName, options) {
  var _a2, _b;
  const xmlCharKey = (_a2 = options.xmlCharKey) !== null && _a2 !== void 0 ? _a2 : XML_CHARKEY;
  if (getPolymorphicDiscriminatorRecursively(serializer3, mapper)) {
    mapper = getPolymorphicMapper(serializer3, mapper, responseBody, "serializedName");
  }
  const modelProps = resolveModelProperties(serializer3, mapper, objectName);
  let instance = {};
  const handledPropertyNames = [];
  for (const key of Object.keys(modelProps)) {
    const propertyMapper = modelProps[key];
    const paths = splitSerializeName(modelProps[key].serializedName);
    handledPropertyNames.push(paths[0]);
    const { serializedName, xmlName, xmlElementName } = propertyMapper;
    let propertyObjectName = objectName;
    if (serializedName !== "" && serializedName !== void 0) {
      propertyObjectName = objectName + "." + serializedName;
    }
    const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
    if (headerCollectionPrefix) {
      const dictionary = {};
      for (const headerKey of Object.keys(responseBody)) {
        if (headerKey.startsWith(headerCollectionPrefix)) {
          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer3.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
        }
        handledPropertyNames.push(headerKey);
      }
      instance[key] = dictionary;
    } else if (serializer3.isXML) {
      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {
        instance[key] = serializer3.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);
      } else if (propertyMapper.xmlIsMsText) {
        if (responseBody[xmlCharKey] !== void 0) {
          instance[key] = responseBody[xmlCharKey];
        } else if (typeof responseBody === "string") {
          instance[key] = responseBody;
        }
      } else {
        const propertyName = xmlElementName || xmlName || serializedName;
        if (propertyMapper.xmlIsWrapped) {
          const wrapped = responseBody[xmlName];
          const elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];
          instance[key] = serializer3.deserialize(propertyMapper, elementList, propertyObjectName, options);
        } else {
          const property = responseBody[propertyName];
          instance[key] = serializer3.deserialize(propertyMapper, property, propertyObjectName, options);
        }
      }
    } else {
      let propertyInstance;
      let res = responseBody;
      for (const item of paths) {
        if (!res)
          break;
        res = res[item];
      }
      propertyInstance = res;
      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && propertyInstance == void 0) {
        propertyInstance = mapper.serializedName;
      }
      let serializedValue;
      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
        propertyInstance = responseBody[key];
        const arrayInstance = serializer3.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        for (const [k, v] of Object.entries(instance)) {
          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
            arrayInstance[k] = v;
          }
        }
        instance = arrayInstance;
      } else if (propertyInstance !== void 0 || propertyMapper.defaultValue !== void 0) {
        serializedValue = serializer3.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        instance[key] = serializedValue;
      }
    }
  }
  const additionalPropertiesMapper = mapper.type.additionalProperties;
  if (additionalPropertiesMapper) {
    const isAdditionalProperty = (responsePropName) => {
      for (const clientPropName in modelProps) {
        const paths = splitSerializeName(modelProps[clientPropName].serializedName);
        if (paths[0] === responsePropName) {
          return false;
        }
      }
      return true;
    };
    for (const responsePropName in responseBody) {
      if (isAdditionalProperty(responsePropName)) {
        instance[responsePropName] = serializer3.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
      }
    }
  } else if (responseBody) {
    for (const key of Object.keys(responseBody)) {
      if (instance[key] === void 0 && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {
        instance[key] = responseBody[key];
      }
    }
  }
  return instance;
}
function deserializeDictionaryType(serializer3, mapper, responseBody, objectName, options) {
  const value = mapper.type.value;
  if (!value || typeof value !== "object") {
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}`);
  }
  if (responseBody) {
    const tempDictionary = {};
    for (const key of Object.keys(responseBody)) {
      tempDictionary[key] = serializer3.deserialize(value, responseBody[key], objectName, options);
    }
    return tempDictionary;
  }
  return responseBody;
}
function deserializeSequenceType(serializer3, mapper, responseBody, objectName, options) {
  const element = mapper.type.element;
  if (!element || typeof element !== "object") {
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}`);
  }
  if (responseBody) {
    if (!Array.isArray(responseBody)) {
      responseBody = [responseBody];
    }
    const tempArray = [];
    for (let i = 0; i < responseBody.length; i++) {
      tempArray[i] = serializer3.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
    }
    return tempArray;
  }
  return responseBody;
}
function getPolymorphicMapper(serializer3, mapper, object, polymorphicPropertyName) {
  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer3, mapper);
  if (polymorphicDiscriminator) {
    const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
    if (discriminatorName != void 0) {
      const discriminatorValue = object[discriminatorName];
      if (discriminatorValue != void 0) {
        const typeName = mapper.type.uberParent || mapper.type.className;
        const indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + "." + discriminatorValue;
        const polymorphicMapper = serializer3.modelMappers.discriminators[indexDiscriminator];
        if (polymorphicMapper) {
          mapper = polymorphicMapper;
        }
      }
    }
  }
  return mapper;
}
function getPolymorphicDiscriminatorRecursively(serializer3, mapper) {
  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer3, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer3, mapper.type.className);
}
function getPolymorphicDiscriminatorSafely(serializer3, typeName) {
  return typeName && serializer3.modelMappers[typeName] && serializer3.modelMappers[typeName].type.polymorphicDiscriminator;
}
function serializeObject(toSerialize) {
  const castToSerialize = toSerialize;
  if (toSerialize == void 0)
    return void 0;
  if (toSerialize instanceof Uint8Array) {
    toSerialize = encodeByteArray(toSerialize);
    return toSerialize;
  } else if (toSerialize instanceof Date) {
    return toSerialize.toISOString();
  } else if (Array.isArray(toSerialize)) {
    const array = [];
    for (let i = 0; i < toSerialize.length; i++) {
      array.push(serializeObject(toSerialize[i]));
    }
    return array;
  } else if (typeof toSerialize === "object") {
    const dictionary = {};
    for (const property in toSerialize) {
      dictionary[property] = serializeObject(castToSerialize[property]);
    }
    return dictionary;
  }
  return toSerialize;
}
function strEnum(o) {
  const result = {};
  for (const key of o) {
    result[key] = key;
  }
  return result;
}
var Serializer, MapperType;
var init_serializer = __esm({
  "node_modules/@azure/core-http/dist-esm/src/serializer.js"() {
    init_base64_browser();
    init_utils();
    init_serializer_common();
    Serializer = class {
      constructor(modelMappers = {}, isXML) {
        this.modelMappers = modelMappers;
        this.isXML = isXML;
      }
      /**
       * Validates constraints, if any. This function will throw if the provided value does not respect those constraints.
       * @param mapper - The definition of data models.
       * @param value - The value.
       * @param objectName - Name of the object. Used in the error messages.
       * @deprecated Removing the constraints validation on client side.
       */
      validateConstraints(mapper, value, objectName) {
        const failValidation = (constraintName, constraintValue) => {
          throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
        };
        if (mapper.constraints && value != void 0) {
          const valueAsNumber = value;
          const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
          if (ExclusiveMaximum != void 0 && valueAsNumber >= ExclusiveMaximum) {
            failValidation("ExclusiveMaximum", ExclusiveMaximum);
          }
          if (ExclusiveMinimum != void 0 && valueAsNumber <= ExclusiveMinimum) {
            failValidation("ExclusiveMinimum", ExclusiveMinimum);
          }
          if (InclusiveMaximum != void 0 && valueAsNumber > InclusiveMaximum) {
            failValidation("InclusiveMaximum", InclusiveMaximum);
          }
          if (InclusiveMinimum != void 0 && valueAsNumber < InclusiveMinimum) {
            failValidation("InclusiveMinimum", InclusiveMinimum);
          }
          const valueAsArray = value;
          if (MaxItems != void 0 && valueAsArray.length > MaxItems) {
            failValidation("MaxItems", MaxItems);
          }
          if (MaxLength != void 0 && valueAsArray.length > MaxLength) {
            failValidation("MaxLength", MaxLength);
          }
          if (MinItems != void 0 && valueAsArray.length < MinItems) {
            failValidation("MinItems", MinItems);
          }
          if (MinLength != void 0 && valueAsArray.length < MinLength) {
            failValidation("MinLength", MinLength);
          }
          if (MultipleOf != void 0 && valueAsNumber % MultipleOf !== 0) {
            failValidation("MultipleOf", MultipleOf);
          }
          if (Pattern) {
            const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
            if (typeof value !== "string" || value.match(pattern) === null) {
              failValidation("Pattern", Pattern);
            }
          }
          if (UniqueItems && valueAsArray.some((item, i, ar) => ar.indexOf(item) !== i)) {
            failValidation("UniqueItems", UniqueItems);
          }
        }
      }
      /**
       * Serialize the given object based on its metadata defined in the mapper.
       *
       * @param mapper - The mapper which defines the metadata of the serializable object.
       * @param object - A valid Javascript object to be serialized.
       * @param objectName - Name of the serialized object.
       * @param options - additional options to deserialization.
       * @returns A valid serialized Javascript object.
       */
      serialize(mapper, object, objectName, options = {}) {
        var _a2, _b, _c;
        const updatedOptions = {
          rootName: (_a2 = options.rootName) !== null && _a2 !== void 0 ? _a2 : "",
          includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
          xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
        };
        let payload = {};
        const mapperType = mapper.type.name;
        if (!objectName) {
          objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Sequence$/i) !== null) {
          payload = [];
        }
        if (mapper.isConstant) {
          object = mapper.defaultValue;
        }
        const { required, nullable } = mapper;
        if (required && nullable && object === void 0) {
          throw new Error(`${objectName} cannot be undefined.`);
        }
        if (required && !nullable && object == void 0) {
          throw new Error(`${objectName} cannot be null or undefined.`);
        }
        if (!required && nullable === false && object === null) {
          throw new Error(`${objectName} cannot be null.`);
        }
        if (object == void 0) {
          payload = object;
        } else {
          if (mapperType.match(/^any$/i) !== null) {
            payload = object;
          } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
            payload = serializeBasicTypes(mapperType, objectName, object);
          } else if (mapperType.match(/^Enum$/i) !== null) {
            const enumMapper = mapper;
            payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
          } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
            payload = serializeDateTypes(mapperType, object, objectName);
          } else if (mapperType.match(/^ByteArray$/i) !== null) {
            payload = serializeByteArrayType(objectName, object);
          } else if (mapperType.match(/^Base64Url$/i) !== null) {
            payload = serializeBase64UrlType(objectName, object);
          } else if (mapperType.match(/^Sequence$/i) !== null) {
            payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          } else if (mapperType.match(/^Dictionary$/i) !== null) {
            payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          } else if (mapperType.match(/^Composite$/i) !== null) {
            payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          }
        }
        return payload;
      }
      /**
       * Deserialize the given object based on its metadata defined in the mapper.
       *
       * @param mapper - The mapper which defines the metadata of the serializable object.
       * @param responseBody - A valid Javascript entity to be deserialized.
       * @param objectName - Name of the deserialized object.
       * @param options - Controls behavior of XML parser and builder.
       * @returns A valid deserialized Javascript object.
       */
      deserialize(mapper, responseBody, objectName, options = {}) {
        var _a2, _b, _c;
        const updatedOptions = {
          rootName: (_a2 = options.rootName) !== null && _a2 !== void 0 ? _a2 : "",
          includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
          xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
        };
        if (responseBody == void 0) {
          if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
            responseBody = [];
          }
          if (mapper.defaultValue !== void 0) {
            responseBody = mapper.defaultValue;
          }
          return responseBody;
        }
        let payload;
        const mapperType = mapper.type.name;
        if (!objectName) {
          objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Composite$/i) !== null) {
          payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
        } else {
          if (this.isXML) {
            const xmlCharKey = updatedOptions.xmlCharKey;
            const castResponseBody = responseBody;
            if (castResponseBody[XML_ATTRKEY] != void 0 && castResponseBody[xmlCharKey] != void 0) {
              responseBody = castResponseBody[xmlCharKey];
            }
          }
          if (mapperType.match(/^Number$/i) !== null) {
            payload = parseFloat(responseBody);
            if (isNaN(payload)) {
              payload = responseBody;
            }
          } else if (mapperType.match(/^Boolean$/i) !== null) {
            if (responseBody === "true") {
              payload = true;
            } else if (responseBody === "false") {
              payload = false;
            } else {
              payload = responseBody;
            }
          } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
            payload = responseBody;
          } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
            payload = new Date(responseBody);
          } else if (mapperType.match(/^UnixTime$/i) !== null) {
            payload = unixTimeToDate(responseBody);
          } else if (mapperType.match(/^ByteArray$/i) !== null) {
            payload = decodeString(responseBody);
          } else if (mapperType.match(/^Base64Url$/i) !== null) {
            payload = base64UrlToByteArray(responseBody);
          } else if (mapperType.match(/^Sequence$/i) !== null) {
            payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
          } else if (mapperType.match(/^Dictionary$/i) !== null) {
            payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
          }
        }
        if (mapper.isConstant) {
          payload = mapper.defaultValue;
        }
        return payload;
      }
    };
    MapperType = strEnum([
      "Base64Url",
      "Boolean",
      "ByteArray",
      "Composite",
      "Date",
      "DateTime",
      "DateTimeRfc1123",
      "Dictionary",
      "Enum",
      "Number",
      "Object",
      "Sequence",
      "String",
      "Stream",
      "TimeSpan",
      "UnixTime"
    ]);
  }
});

// node_modules/@azure/core-http/dist-esm/src/webResource.js
function isWebResourceLike(object) {
  if (object && typeof object === "object") {
    const castObject = object;
    if (typeof castObject.url === "string" && typeof castObject.method === "string" && typeof castObject.headers === "object" && isHttpHeadersLike(castObject.headers) && typeof castObject.validateRequestProperties === "function" && typeof castObject.prepare === "function" && typeof castObject.clone === "function") {
      return true;
    }
  }
  return false;
}
var WebResource;
var init_webResource = __esm({
  "node_modules/@azure/core-http/dist-esm/src/webResource.js"() {
    init_httpHeaders();
    init_serializer();
    init_utils();
    WebResource = class _WebResource {
      constructor(url, method, body, query, headers, streamResponseBody, withCredentials, abortSignal2, timeout, onUploadProgress, onDownloadProgress, proxySettings, keepAlive, decompressResponse, streamResponseStatusCodes) {
        this.streamResponseBody = streamResponseBody;
        this.streamResponseStatusCodes = streamResponseStatusCodes;
        this.url = url || "";
        this.method = method || "GET";
        this.headers = isHttpHeadersLike(headers) ? headers : new HttpHeaders(headers);
        this.body = body;
        this.query = query;
        this.formData = void 0;
        this.withCredentials = withCredentials || false;
        this.abortSignal = abortSignal2;
        this.timeout = timeout || 0;
        this.onUploadProgress = onUploadProgress;
        this.onDownloadProgress = onDownloadProgress;
        this.proxySettings = proxySettings;
        this.keepAlive = keepAlive;
        this.decompressResponse = decompressResponse;
        this.requestId = this.headers.get("x-ms-client-request-id") || generateUuid();
      }
      /**
       * Validates that the required properties such as method, url, headers["Content-Type"],
       * headers["accept-language"] are defined. It will throw an error if one of the above
       * mentioned properties are not defined.
       */
      validateRequestProperties() {
        if (!this.method) {
          throw new Error("WebResource.method is required.");
        }
        if (!this.url) {
          throw new Error("WebResource.url is required.");
        }
      }
      /**
       * Prepares the request.
       * @param options - Options to provide for preparing the request.
       * @returns Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.
       */
      prepare(options) {
        if (!options) {
          throw new Error("options object is required");
        }
        if (options.method === void 0 || options.method === null || typeof options.method.valueOf() !== "string") {
          throw new Error("options.method must be a string.");
        }
        if (options.url && options.pathTemplate) {
          throw new Error("options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.");
        }
        if ((options.pathTemplate === void 0 || options.pathTemplate === null || typeof options.pathTemplate.valueOf() !== "string") && (options.url === void 0 || options.url === null || typeof options.url.valueOf() !== "string")) {
          throw new Error("Please provide exactly one of options.pathTemplate or options.url.");
        }
        if (options.url) {
          if (typeof options.url !== "string") {
            throw new Error('options.url must be of type "string".');
          }
          this.url = options.url;
        }
        if (options.method) {
          const validMethods = ["GET", "PUT", "HEAD", "DELETE", "OPTIONS", "POST", "PATCH", "TRACE"];
          if (validMethods.indexOf(options.method.toUpperCase()) === -1) {
            throw new Error('The provided method "' + options.method + '" is invalid. Supported HTTP methods are: ' + JSON.stringify(validMethods));
          }
        }
        this.method = options.method.toUpperCase();
        if (options.pathTemplate) {
          const { pathTemplate, pathParameters } = options;
          if (typeof pathTemplate !== "string") {
            throw new Error('options.pathTemplate must be of type "string".');
          }
          if (!options.baseUrl) {
            options.baseUrl = "https://management.azure.com";
          }
          const baseUrl = options.baseUrl;
          let url = baseUrl + (baseUrl.endsWith("/") ? "" : "/") + (pathTemplate.startsWith("/") ? pathTemplate.slice(1) : pathTemplate);
          const segments = url.match(/({[\w-]*\s*[\w-]*})/gi);
          if (segments && segments.length) {
            if (!pathParameters) {
              throw new Error(`pathTemplate: ${pathTemplate} has been provided. Hence, options.pathParameters must also be provided.`);
            }
            segments.forEach(function(item) {
              const pathParamName = item.slice(1, -1);
              const pathParam = pathParameters[pathParamName];
              if (pathParam === null || pathParam === void 0 || !(typeof pathParam === "string" || typeof pathParam === "object")) {
                const stringifiedPathParameters = JSON.stringify(pathParameters, void 0, 2);
                throw new Error(`pathTemplate: ${pathTemplate} contains the path parameter ${pathParamName} however, it is not present in parameters: ${stringifiedPathParameters}.The value of the path parameter can either be a "string" of the form { ${pathParamName}: "some sample value" } or it can be an "object" of the form { "${pathParamName}": { value: "some sample value", skipUrlEncoding: true } }.`);
              }
              if (typeof pathParam.valueOf() === "string") {
                url = url.replace(item, encodeURIComponent(pathParam));
              }
              if (typeof pathParam.valueOf() === "object") {
                if (!pathParam.value) {
                  throw new Error(`options.pathParameters[${pathParamName}] is of type "object" but it does not contain a "value" property.`);
                }
                if (pathParam.skipUrlEncoding) {
                  url = url.replace(item, pathParam.value);
                } else {
                  url = url.replace(item, encodeURIComponent(pathParam.value));
                }
              }
            });
          }
          this.url = url;
        }
        if (options.queryParameters) {
          const queryParameters = options.queryParameters;
          if (typeof queryParameters !== "object") {
            throw new Error(`options.queryParameters must be of type object. It should be a JSON object of "query-parameter-name" as the key and the "query-parameter-value" as the value. The "query-parameter-value" may be fo type "string" or an "object" of the form { value: "query-parameter-value", skipUrlEncoding: true }.`);
          }
          if (this.url && this.url.indexOf("?") === -1) {
            this.url += "?";
          }
          const queryParams = [];
          this.query = {};
          for (const queryParamName in queryParameters) {
            const queryParam = queryParameters[queryParamName];
            if (queryParam) {
              if (typeof queryParam === "string") {
                queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam));
                this.query[queryParamName] = encodeURIComponent(queryParam);
              } else if (typeof queryParam === "object") {
                if (!queryParam.value) {
                  throw new Error(`options.queryParameters[${queryParamName}] is of type "object" but it does not contain a "value" property.`);
                }
                if (queryParam.skipUrlEncoding) {
                  queryParams.push(queryParamName + "=" + queryParam.value);
                  this.query[queryParamName] = queryParam.value;
                } else {
                  queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam.value));
                  this.query[queryParamName] = encodeURIComponent(queryParam.value);
                }
              }
            }
          }
          this.url += queryParams.join("&");
        }
        if (options.headers) {
          const headers = options.headers;
          for (const headerName of Object.keys(options.headers)) {
            this.headers.set(headerName, headers[headerName]);
          }
        }
        if (!this.headers.get("accept-language")) {
          this.headers.set("accept-language", "en-US");
        }
        if (!this.headers.get("x-ms-client-request-id") && !options.disableClientRequestId) {
          this.headers.set("x-ms-client-request-id", this.requestId);
        }
        if (!this.headers.get("Content-Type")) {
          this.headers.set("Content-Type", "application/json; charset=utf-8");
        }
        this.body = options.body;
        if (options.body !== void 0 && options.body !== null) {
          if (options.bodyIsStream) {
            if (!this.headers.get("Transfer-Encoding")) {
              this.headers.set("Transfer-Encoding", "chunked");
            }
            if (this.headers.get("Content-Type") !== "application/octet-stream") {
              this.headers.set("Content-Type", "application/octet-stream");
            }
          } else {
            if (options.serializationMapper) {
              this.body = new Serializer(options.mappers).serialize(options.serializationMapper, options.body, "requestBody");
            }
            if (!options.disableJsonStringifyOnBody) {
              this.body = JSON.stringify(options.body);
            }
          }
        }
        if (options.spanOptions) {
          this.spanOptions = options.spanOptions;
        }
        if (options.tracingContext) {
          this.tracingContext = options.tracingContext;
        }
        this.abortSignal = options.abortSignal;
        this.onDownloadProgress = options.onDownloadProgress;
        this.onUploadProgress = options.onUploadProgress;
        return this;
      }
      /**
       * Clone this WebResource HTTP request object.
       * @returns The clone of this WebResource HTTP request object.
       */
      clone() {
        const result = new _WebResource(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive, this.decompressResponse, this.streamResponseStatusCodes);
        if (this.formData) {
          result.formData = this.formData;
        }
        if (this.operationSpec) {
          result.operationSpec = this.operationSpec;
        }
        if (this.shouldDeserialize) {
          result.shouldDeserialize = this.shouldDeserialize;
        }
        if (this.operationResponseGetter) {
          result.operationResponseGetter = this.operationResponseGetter;
        }
        return result;
      }
    };
  }
});

// node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js
var init_AbortSignal = __esm({
  "node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js"() {
  }
});

// node_modules/@azure/abort-controller/dist-esm/src/AbortController.js
var AbortError;
var init_AbortController = __esm({
  "node_modules/@azure/abort-controller/dist-esm/src/AbortController.js"() {
    init_AbortSignal();
    AbortError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
  }
});

// node_modules/@azure/abort-controller/dist-esm/src/index.js
var init_src = __esm({
  "node_modules/@azure/abort-controller/dist-esm/src/index.js"() {
    init_AbortController();
    init_AbortSignal();
  }
});

// node_modules/@azure/core-http/dist-esm/src/url.js
function isAlphaNumericCharacter(character) {
  const characterCode = character.charCodeAt(0);
  return 48 <= characterCode && characterCode <= 57 || 65 <= characterCode && characterCode <= 90 || 97 <= characterCode && characterCode <= 122;
}
function readRemaining(tokenizer) {
  let result = "";
  if (tokenizer._currentIndex < tokenizer._textLength) {
    result = tokenizer._text.substring(tokenizer._currentIndex);
    tokenizer._currentIndex = tokenizer._textLength;
  }
  return result;
}
function hasCurrentCharacter(tokenizer) {
  return tokenizer._currentIndex < tokenizer._textLength;
}
function getCurrentCharacter(tokenizer) {
  return tokenizer._text[tokenizer._currentIndex];
}
function nextCharacter(tokenizer, step) {
  if (hasCurrentCharacter(tokenizer)) {
    if (!step) {
      step = 1;
    }
    tokenizer._currentIndex += step;
  }
}
function peekCharacters(tokenizer, charactersToPeek) {
  let endIndex = tokenizer._currentIndex + charactersToPeek;
  if (tokenizer._textLength < endIndex) {
    endIndex = tokenizer._textLength;
  }
  return tokenizer._text.substring(tokenizer._currentIndex, endIndex);
}
function readWhile(tokenizer, condition) {
  let result = "";
  while (hasCurrentCharacter(tokenizer)) {
    const currentCharacter = getCurrentCharacter(tokenizer);
    if (!condition(currentCharacter)) {
      break;
    } else {
      result += currentCharacter;
      nextCharacter(tokenizer);
    }
  }
  return result;
}
function readWhileLetterOrDigit(tokenizer) {
  return readWhile(tokenizer, (character) => isAlphaNumericCharacter(character));
}
function readUntilCharacter(tokenizer, ...terminatingCharacters) {
  return readWhile(tokenizer, (character) => terminatingCharacters.indexOf(character) === -1);
}
function nextScheme(tokenizer) {
  const scheme = readWhileLetterOrDigit(tokenizer);
  tokenizer._currentToken = URLToken.scheme(scheme);
  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else {
    tokenizer._currentState = "HOST";
  }
}
function nextSchemeOrHost(tokenizer) {
  const schemeOrHost = readUntilCharacter(tokenizer, ":", "/", "?");
  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentToken = URLToken.host(schemeOrHost);
    tokenizer._currentState = "DONE";
  } else if (getCurrentCharacter(tokenizer) === ":") {
    if (peekCharacters(tokenizer, 3) === "://") {
      tokenizer._currentToken = URLToken.scheme(schemeOrHost);
      tokenizer._currentState = "HOST";
    } else {
      tokenizer._currentToken = URLToken.host(schemeOrHost);
      tokenizer._currentState = "PORT";
    }
  } else {
    tokenizer._currentToken = URLToken.host(schemeOrHost);
    if (getCurrentCharacter(tokenizer) === "/") {
      tokenizer._currentState = "PATH";
    } else {
      tokenizer._currentState = "QUERY";
    }
  }
}
function nextHost(tokenizer) {
  if (peekCharacters(tokenizer, 3) === "://") {
    nextCharacter(tokenizer, 3);
  }
  const host = readUntilCharacter(tokenizer, ":", "/", "?");
  tokenizer._currentToken = URLToken.host(host);
  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else if (getCurrentCharacter(tokenizer) === ":") {
    tokenizer._currentState = "PORT";
  } else if (getCurrentCharacter(tokenizer) === "/") {
    tokenizer._currentState = "PATH";
  } else {
    tokenizer._currentState = "QUERY";
  }
}
function nextPort(tokenizer) {
  if (getCurrentCharacter(tokenizer) === ":") {
    nextCharacter(tokenizer);
  }
  const port = readUntilCharacter(tokenizer, "/", "?");
  tokenizer._currentToken = URLToken.port(port);
  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else if (getCurrentCharacter(tokenizer) === "/") {
    tokenizer._currentState = "PATH";
  } else {
    tokenizer._currentState = "QUERY";
  }
}
function nextPath(tokenizer) {
  const path = readUntilCharacter(tokenizer, "?");
  tokenizer._currentToken = URLToken.path(path);
  if (!hasCurrentCharacter(tokenizer)) {
    tokenizer._currentState = "DONE";
  } else {
    tokenizer._currentState = "QUERY";
  }
}
function nextQuery(tokenizer) {
  if (getCurrentCharacter(tokenizer) === "?") {
    nextCharacter(tokenizer);
  }
  const query = readRemaining(tokenizer);
  tokenizer._currentToken = URLToken.query(query);
  tokenizer._currentState = "DONE";
}
var URLQuery, URLBuilder, URLToken, URLTokenizer;
var init_url = __esm({
  "node_modules/@azure/core-http/dist-esm/src/url.js"() {
    init_utils();
    URLQuery = class _URLQuery {
      constructor() {
        this._rawQuery = {};
      }
      /**
       * Get whether or not there any query parameters in this URLQuery.
       */
      any() {
        return Object.keys(this._rawQuery).length > 0;
      }
      /**
       * Get the keys of the query string.
       */
      keys() {
        return Object.keys(this._rawQuery);
      }
      /**
       * Set a query parameter with the provided name and value. If the parameterValue is undefined or
       * empty, then this will attempt to remove an existing query parameter with the provided
       * parameterName.
       */
      set(parameterName, parameterValue) {
        const caseParameterValue = parameterValue;
        if (parameterName) {
          if (caseParameterValue !== void 0 && caseParameterValue !== null) {
            const newValue = Array.isArray(caseParameterValue) ? caseParameterValue : caseParameterValue.toString();
            this._rawQuery[parameterName] = newValue;
          } else {
            delete this._rawQuery[parameterName];
          }
        }
      }
      /**
       * Get the value of the query parameter with the provided name. If no parameter exists with the
       * provided parameter name, then undefined will be returned.
       */
      get(parameterName) {
        return parameterName ? this._rawQuery[parameterName] : void 0;
      }
      /**
       * Get the string representation of this query. The return value will not start with a "?".
       */
      toString() {
        let result = "";
        for (const parameterName in this._rawQuery) {
          if (result) {
            result += "&";
          }
          const parameterValue = this._rawQuery[parameterName];
          if (Array.isArray(parameterValue)) {
            const parameterStrings = [];
            for (const parameterValueElement of parameterValue) {
              parameterStrings.push(`${parameterName}=${parameterValueElement}`);
            }
            result += parameterStrings.join("&");
          } else {
            result += `${parameterName}=${parameterValue}`;
          }
        }
        return result;
      }
      /**
       * Parse a URLQuery from the provided text.
       */
      static parse(text2) {
        const result = new _URLQuery();
        if (text2) {
          if (text2.startsWith("?")) {
            text2 = text2.substring(1);
          }
          let currentState = "ParameterName";
          let parameterName = "";
          let parameterValue = "";
          for (let i = 0; i < text2.length; ++i) {
            const currentCharacter = text2[i];
            switch (currentState) {
              case "ParameterName":
                switch (currentCharacter) {
                  case "=":
                    currentState = "ParameterValue";
                    break;
                  case "&":
                    parameterName = "";
                    parameterValue = "";
                    break;
                  default:
                    parameterName += currentCharacter;
                    break;
                }
                break;
              case "ParameterValue":
                switch (currentCharacter) {
                  case "&":
                    result.set(parameterName, parameterValue);
                    parameterName = "";
                    parameterValue = "";
                    currentState = "ParameterName";
                    break;
                  default:
                    parameterValue += currentCharacter;
                    break;
                }
                break;
              default:
                throw new Error("Unrecognized URLQuery parse state: " + currentState);
            }
          }
          if (currentState === "ParameterValue") {
            result.set(parameterName, parameterValue);
          }
        }
        return result;
      }
    };
    URLBuilder = class _URLBuilder {
      /**
       * Set the scheme/protocol for this URL. If the provided scheme contains other parts of a URL
       * (such as a host, port, path, or query), those parts will be added to this URL as well.
       */
      setScheme(scheme) {
        if (!scheme) {
          this._scheme = void 0;
        } else {
          this.set(scheme, "SCHEME");
        }
      }
      /**
       * Get the scheme that has been set in this URL.
       */
      getScheme() {
        return this._scheme;
      }
      /**
       * Set the host for this URL. If the provided host contains other parts of a URL (such as a
       * port, path, or query), those parts will be added to this URL as well.
       */
      setHost(host) {
        if (!host) {
          this._host = void 0;
        } else {
          this.set(host, "SCHEME_OR_HOST");
        }
      }
      /**
       * Get the host that has been set in this URL.
       */
      getHost() {
        return this._host;
      }
      /**
       * Set the port for this URL. If the provided port contains other parts of a URL (such as a
       * path or query), those parts will be added to this URL as well.
       */
      setPort(port) {
        if (port === void 0 || port === null || port === "") {
          this._port = void 0;
        } else {
          this.set(port.toString(), "PORT");
        }
      }
      /**
       * Get the port that has been set in this URL.
       */
      getPort() {
        return this._port;
      }
      /**
       * Set the path for this URL. If the provided path contains a query, then it will be added to
       * this URL as well.
       */
      setPath(path) {
        if (!path) {
          this._path = void 0;
        } else {
          const schemeIndex = path.indexOf("://");
          if (schemeIndex !== -1) {
            const schemeStart = path.lastIndexOf("/", schemeIndex);
            this.set(schemeStart === -1 ? path : path.substr(schemeStart + 1), "SCHEME");
          } else {
            this.set(path, "PATH");
          }
        }
      }
      /**
       * Append the provided path to this URL's existing path. If the provided path contains a query,
       * then it will be added to this URL as well.
       */
      appendPath(path) {
        if (path) {
          let currentPath = this.getPath();
          if (currentPath) {
            if (!currentPath.endsWith("/")) {
              currentPath += "/";
            }
            if (path.startsWith("/")) {
              path = path.substring(1);
            }
            path = currentPath + path;
          }
          this.set(path, "PATH");
        }
      }
      /**
       * Get the path that has been set in this URL.
       */
      getPath() {
        return this._path;
      }
      /**
       * Set the query in this URL.
       */
      setQuery(query) {
        if (!query) {
          this._query = void 0;
        } else {
          this._query = URLQuery.parse(query);
        }
      }
      /**
       * Set a query parameter with the provided name and value in this URL's query. If the provided
       * query parameter value is undefined or empty, then the query parameter will be removed if it
       * existed.
       */
      setQueryParameter(queryParameterName, queryParameterValue) {
        if (queryParameterName) {
          if (!this._query) {
            this._query = new URLQuery();
          }
          this._query.set(queryParameterName, queryParameterValue);
        }
      }
      /**
       * Get the value of the query parameter with the provided query parameter name. If no query
       * parameter exists with the provided name, then undefined will be returned.
       */
      getQueryParameterValue(queryParameterName) {
        return this._query ? this._query.get(queryParameterName) : void 0;
      }
      /**
       * Get the query in this URL.
       */
      getQuery() {
        return this._query ? this._query.toString() : void 0;
      }
      /**
       * Set the parts of this URL by parsing the provided text using the provided startState.
       */
      set(text2, startState) {
        const tokenizer = new URLTokenizer(text2, startState);
        while (tokenizer.next()) {
          const token = tokenizer.current();
          let tokenPath;
          if (token) {
            switch (token.type) {
              case "SCHEME":
                this._scheme = token.text || void 0;
                break;
              case "HOST":
                this._host = token.text || void 0;
                break;
              case "PORT":
                this._port = token.text || void 0;
                break;
              case "PATH":
                tokenPath = token.text || void 0;
                if (!this._path || this._path === "/" || tokenPath !== "/") {
                  this._path = tokenPath;
                }
                break;
              case "QUERY":
                this._query = URLQuery.parse(token.text);
                break;
              default:
                throw new Error(`Unrecognized URLTokenType: ${token.type}`);
            }
          }
        }
      }
      /**
       * Serializes the URL as a string.
       * @returns the URL as a string.
       */
      toString() {
        let result = "";
        if (this._scheme) {
          result += `${this._scheme}://`;
        }
        if (this._host) {
          result += this._host;
        }
        if (this._port) {
          result += `:${this._port}`;
        }
        if (this._path) {
          if (!this._path.startsWith("/")) {
            result += "/";
          }
          result += this._path;
        }
        if (this._query && this._query.any()) {
          result += `?${this._query.toString()}`;
        }
        return result;
      }
      /**
       * If the provided searchValue is found in this URLBuilder, then replace it with the provided
       * replaceValue.
       */
      replaceAll(searchValue, replaceValue) {
        if (searchValue) {
          this.setScheme(replaceAll(this.getScheme(), searchValue, replaceValue));
          this.setHost(replaceAll(this.getHost(), searchValue, replaceValue));
          this.setPort(replaceAll(this.getPort(), searchValue, replaceValue));
          this.setPath(replaceAll(this.getPath(), searchValue, replaceValue));
          this.setQuery(replaceAll(this.getQuery(), searchValue, replaceValue));
        }
      }
      /**
       * Parses a given string URL into a new {@link URLBuilder}.
       */
      static parse(text2) {
        const result = new _URLBuilder();
        result.set(text2, "SCHEME_OR_HOST");
        return result;
      }
    };
    URLToken = class _URLToken {
      constructor(text2, type) {
        this.text = text2;
        this.type = type;
      }
      static scheme(text2) {
        return new _URLToken(text2, "SCHEME");
      }
      static host(text2) {
        return new _URLToken(text2, "HOST");
      }
      static port(text2) {
        return new _URLToken(text2, "PORT");
      }
      static path(text2) {
        return new _URLToken(text2, "PATH");
      }
      static query(text2) {
        return new _URLToken(text2, "QUERY");
      }
    };
    URLTokenizer = class {
      constructor(_text, state) {
        this._text = _text;
        this._textLength = _text ? _text.length : 0;
        this._currentState = state !== void 0 && state !== null ? state : "SCHEME_OR_HOST";
        this._currentIndex = 0;
      }
      /**
       * Get the current URLToken this URLTokenizer is pointing at, or undefined if the URLTokenizer
       * hasn't started or has finished tokenizing.
       */
      current() {
        return this._currentToken;
      }
      /**
       * Advance to the next URLToken and return whether or not a URLToken was found.
       */
      next() {
        if (!hasCurrentCharacter(this)) {
          this._currentToken = void 0;
        } else {
          switch (this._currentState) {
            case "SCHEME":
              nextScheme(this);
              break;
            case "SCHEME_OR_HOST":
              nextSchemeOrHost(this);
              break;
            case "HOST":
              nextHost(this);
              break;
            case "PORT":
              nextPort(this);
              break;
            case "PATH":
              nextPath(this);
              break;
            case "QUERY":
              nextQuery(this);
              break;
            default:
              throw new Error(`Unrecognized URLTokenizerState: ${this._currentState}`);
          }
        }
        return !!this._currentToken;
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/sanitizer.js
var RedactedString, defaultAllowedHeaderNames, defaultAllowedQueryParameters, Sanitizer;
var init_sanitizer = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/sanitizer.js"() {
    init_url();
    init_utils();
    RedactedString = "REDACTED";
    defaultAllowedHeaderNames = [
      "x-ms-client-request-id",
      "x-ms-return-client-request-id",
      "x-ms-useragent",
      "x-ms-correlation-request-id",
      "x-ms-request-id",
      "client-request-id",
      "ms-cv",
      "return-client-request-id",
      "traceparent",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Origin",
      "Accept",
      "Accept-Encoding",
      "Cache-Control",
      "Connection",
      "Content-Length",
      "Content-Type",
      "Date",
      "ETag",
      "Expires",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "Last-Modified",
      "Pragma",
      "Request-Id",
      "Retry-After",
      "Server",
      "Transfer-Encoding",
      "User-Agent",
      "WWW-Authenticate"
    ];
    defaultAllowedQueryParameters = ["api-version"];
    Sanitizer = class {
      constructor({ allowedHeaderNames = [], allowedQueryParameters = [] } = {}) {
        allowedHeaderNames = Array.isArray(allowedHeaderNames) ? defaultAllowedHeaderNames.concat(allowedHeaderNames) : defaultAllowedHeaderNames;
        allowedQueryParameters = Array.isArray(allowedQueryParameters) ? defaultAllowedQueryParameters.concat(allowedQueryParameters) : defaultAllowedQueryParameters;
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
      }
      sanitize(obj) {
        const seen = /* @__PURE__ */ new Set();
        return JSON.stringify(obj, (key, value) => {
          if (value instanceof Error) {
            return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
          }
          if (key === "_headersMap") {
            return this.sanitizeHeaders(value);
          } else if (key === "url") {
            return this.sanitizeUrl(value);
          } else if (key === "query") {
            return this.sanitizeQuery(value);
          } else if (key === "body") {
            return void 0;
          } else if (key === "response") {
            return void 0;
          } else if (key === "operationSpec") {
            return void 0;
          } else if (Array.isArray(value) || isObject(value)) {
            if (seen.has(value)) {
              return "[Circular]";
            }
            seen.add(value);
          }
          return value;
        }, 2);
      }
      sanitizeHeaders(value) {
        return this.sanitizeObject(value, this.allowedHeaderNames, (v, k) => v[k].value);
      }
      sanitizeQuery(value) {
        return this.sanitizeObject(value, this.allowedQueryParameters, (v, k) => v[k]);
      }
      sanitizeObject(value, allowedKeys, accessor) {
        if (typeof value !== "object" || value === null) {
          return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
          if (allowedKeys.has(k.toLowerCase())) {
            sanitized[k] = accessor(value, k);
          } else {
            sanitized[k] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeUrl(value) {
        if (typeof value !== "string" || value === null) {
          return value;
        }
        const urlBuilder = URLBuilder.parse(value);
        const queryString = urlBuilder.getQuery();
        if (!queryString) {
          return value;
        }
        const query = URLQuery.parse(queryString);
        for (const k of query.keys()) {
          if (!this.allowedQueryParameters.has(k.toLowerCase())) {
            query.set(k, RedactedString);
          }
        }
        urlBuilder.setQuery(query.toString());
        return urlBuilder.toString();
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/inspect.browser.js
var custom;
var init_inspect_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/inspect.browser.js"() {
    custom = {};
  }
});

// node_modules/@azure/core-http/dist-esm/src/restError.js
var errorSanitizer, RestError;
var init_restError = __esm({
  "node_modules/@azure/core-http/dist-esm/src/restError.js"() {
    init_sanitizer();
    init_inspect_browser();
    errorSanitizer = new Sanitizer();
    RestError = class _RestError extends Error {
      constructor(message, code, statusCode, request, response) {
        super(message);
        this.name = "RestError";
        this.code = code;
        this.statusCode = statusCode;
        this.request = request;
        this.response = response;
        Object.setPrototypeOf(this, _RestError.prototype);
      }
      /**
       * Logging method for util.inspect in Node
       */
      [custom]() {
        return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(this)}`;
      }
    };
    RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    RestError.PARSE_ERROR = "PARSE_ERROR";
  }
});

// node_modules/@azure/core-http/dist-esm/src/xhrHttpClient.js
function handleBlobResponse(xhr, request, res, rej) {
  xhr.addEventListener("readystatechange", () => {
    var _a2;
    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
      if (request.streamResponseBody || ((_a2 = request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(xhr.status))) {
        const blobBody = new Promise((resolve, reject) => {
          xhr.addEventListener("load", () => {
            resolve(xhr.response);
          });
          rejectOnTerminalEvent(request, xhr, reject);
        });
        res({
          request,
          status: xhr.status,
          headers: parseHeaders(xhr),
          blobBody
        });
      } else {
        xhr.addEventListener("load", () => {
          if (xhr.response) {
            const reader = new FileReader();
            reader.onload = function(e) {
              var _a3;
              const text2 = (_a3 = e.target) === null || _a3 === void 0 ? void 0 : _a3.result;
              res({
                request,
                status: xhr.status,
                headers: parseHeaders(xhr),
                bodyAsText: text2
              });
            };
            reader.onerror = function(_e) {
              rej(reader.error);
            };
            reader.readAsText(xhr.response, "UTF-8");
          } else {
            res({
              request,
              status: xhr.status,
              headers: parseHeaders(xhr)
            });
          }
        });
      }
    }
  });
}
function addProgressListener(xhr, listener) {
  if (listener) {
    xhr.addEventListener("progress", (rawEvent) => listener({
      loadedBytes: rawEvent.loaded
    }));
  }
}
function parseHeaders(xhr) {
  const responseHeaders = new HttpHeaders();
  const headerLines = xhr.getAllResponseHeaders().trim().split(/[\r\n]+/);
  for (const line of headerLines) {
    const index2 = line.indexOf(":");
    const headerName = line.slice(0, index2);
    const headerValue = line.slice(index2 + 2);
    responseHeaders.set(headerName, headerValue);
  }
  return responseHeaders;
}
function rejectOnTerminalEvent(request, xhr, reject) {
  xhr.addEventListener("error", () => reject(new RestError(`Failed to send request to ${request.url}`, RestError.REQUEST_SEND_ERROR, void 0, request)));
  const abortError = new AbortError("The operation was aborted.");
  xhr.addEventListener("abort", () => reject(abortError));
  xhr.addEventListener("timeout", () => reject(abortError));
}
var XhrHttpClient;
var init_xhrHttpClient = __esm({
  "node_modules/@azure/core-http/dist-esm/src/xhrHttpClient.js"() {
    init_httpHeaders();
    init_src();
    init_restError();
    XhrHttpClient = class {
      sendRequest(request) {
        var _a2;
        const xhr = new XMLHttpRequest();
        if (request.proxySettings) {
          throw new Error("HTTP proxy is not supported in browser environment");
        }
        const abortSignal2 = request.abortSignal;
        if (abortSignal2) {
          if (abortSignal2.aborted) {
            return Promise.reject(new AbortError("The operation was aborted."));
          }
          const listener = () => {
            xhr.abort();
          };
          abortSignal2.addEventListener("abort", listener);
          xhr.addEventListener("readystatechange", () => {
            if (xhr.readyState === XMLHttpRequest.DONE) {
              abortSignal2.removeEventListener("abort", listener);
            }
          });
        }
        addProgressListener(xhr.upload, request.onUploadProgress);
        addProgressListener(xhr, request.onDownloadProgress);
        if (request.formData) {
          const formData = request.formData;
          const requestForm = new FormData();
          const appendFormValue = (key, value) => {
            if (value && Object.prototype.hasOwnProperty.call(value, "value") && Object.prototype.hasOwnProperty.call(value, "options")) {
              requestForm.append(key, value.value, value.options);
            } else {
              requestForm.append(key, value);
            }
          };
          for (const formKey of Object.keys(formData)) {
            const formValue = formData[formKey];
            if (Array.isArray(formValue)) {
              for (let j2 = 0; j2 < formValue.length; j2++) {
                appendFormValue(formKey, formValue[j2]);
              }
            } else {
              appendFormValue(formKey, formValue);
            }
          }
          request.body = requestForm;
          request.formData = void 0;
          const contentType2 = request.headers.get("Content-Type");
          if (contentType2 && contentType2.indexOf("multipart/form-data") !== -1) {
            request.headers.remove("Content-Type");
          }
        }
        xhr.open(request.method, request.url);
        xhr.timeout = request.timeout;
        xhr.withCredentials = request.withCredentials;
        for (const header of request.headers.headersArray()) {
          xhr.setRequestHeader(header.name, header.value);
        }
        xhr.responseType = ((_a2 = request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.size) || request.streamResponseBody ? "blob" : "text";
        xhr.send(request.body === void 0 ? null : request.body);
        if (xhr.responseType === "blob") {
          return new Promise((resolve, reject) => {
            handleBlobResponse(xhr, request, resolve, reject);
            rejectOnTerminalEvent(request, xhr, reject);
          });
        } else {
          return new Promise(function(resolve, reject) {
            xhr.addEventListener("load", () => resolve({
              request,
              status: xhr.status,
              headers: parseHeaders(xhr),
              bodyAsText: xhr.responseText
            }));
            rejectOnTerminalEvent(request, xhr, reject);
          });
        }
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/defaultHttpClient.browser.js
var init_defaultHttpClient_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/defaultHttpClient.browser.js"() {
    init_xhrHttpClient();
  }
});

// node_modules/@azure/core-http/dist-esm/src/httpPipelineLogLevel.js
var HttpPipelineLogLevel;
var init_httpPipelineLogLevel = __esm({
  "node_modules/@azure/core-http/dist-esm/src/httpPipelineLogLevel.js"() {
    (function(HttpPipelineLogLevel2) {
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["OFF"] = 0] = "OFF";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["ERROR"] = 1] = "ERROR";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["WARNING"] = 2] = "WARNING";
      HttpPipelineLogLevel2[HttpPipelineLogLevel2["INFO"] = 3] = "INFO";
    })(HttpPipelineLogLevel || (HttpPipelineLogLevel = {}));
  }
});

// node_modules/@azure/core-http/dist-esm/src/operationOptions.js
function operationOptionsToRequestOptionsBase(opts) {
  const { requestOptions, tracingOptions } = opts, additionalOptions = __rest(opts, ["requestOptions", "tracingOptions"]);
  let result = additionalOptions;
  if (requestOptions) {
    result = Object.assign(Object.assign({}, result), requestOptions);
  }
  if (tracingOptions) {
    result.tracingContext = tracingOptions.tracingContext;
    result.spanOptions = tracingOptions === null || tracingOptions === void 0 ? void 0 : tracingOptions.spanOptions;
  }
  return result;
}
var init_operationOptions = __esm({
  "node_modules/@azure/core-http/dist-esm/src/operationOptions.js"() {
    init_tslib_es6();
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/requestPolicy.js
var BaseRequestPolicy, RequestPolicyOptions;
var init_requestPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/requestPolicy.js"() {
    init_httpPipelineLogLevel();
    BaseRequestPolicy = class {
      /**
       * The main method to implement that manipulates a request/response.
       */
      constructor(_nextPolicy, _options) {
        this._nextPolicy = _nextPolicy;
        this._options = _options;
      }
      /**
       * Get whether or not a log with the provided log level should be logged.
       * @param logLevel - The log level of the log that will be logged.
       * @returns Whether or not a log with the provided log level should be logged.
       */
      shouldLog(logLevel) {
        return this._options.shouldLog(logLevel);
      }
      /**
       * Attempt to log the provided message to the provided logger. If no logger was provided or if
       * the log level does not meat the logger's threshold, then nothing will be logged.
       * @param logLevel - The log level of this log.
       * @param message - The message of this log.
       */
      log(logLevel, message) {
        this._options.log(logLevel, message);
      }
    };
    RequestPolicyOptions = class {
      constructor(_logger) {
        this._logger = _logger;
      }
      /**
       * Get whether or not a log with the provided log level should be logged.
       * @param logLevel - The log level of the log that will be logged.
       * @returns Whether or not a log with the provided log level should be logged.
       */
      shouldLog(logLevel) {
        return !!this._logger && logLevel !== HttpPipelineLogLevel.OFF && logLevel <= this._logger.minimumLogLevel;
      }
      /**
       * Attempt to log the provided message to the provided logger. If no logger was provided or if
       * the log level does not meet the logger's threshold, then nothing will be logged.
       * @param logLevel - The log level of this log.
       * @param message - The message of this log.
       */
      log(logLevel, message) {
        if (this._logger && this.shouldLog(logLevel)) {
          this._logger.log(logLevel, message);
        }
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/xml.browser.js
function getDoc() {
  if (!cachedDoc) {
    cachedDoc = document.implementation.createDocument(null, null, null);
  }
  return cachedDoc;
}
function getParser() {
  if (!cachedParser) {
    cachedParser = new DOMParser();
  }
  return cachedParser;
}
function getSerializer() {
  if (!cachedSerializer) {
    cachedSerializer = new XMLSerializer();
  }
  return cachedSerializer;
}
function parseXML(str2, opts = {}) {
  var _a2, _b, _c, _d;
  try {
    const updatedOptions = {
      rootName: (_a2 = opts.rootName) !== null && _a2 !== void 0 ? _a2 : "",
      includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
      xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
    };
    const dom = getParser().parseFromString((_d = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(str2)) !== null && _d !== void 0 ? _d : str2, "application/xml");
    throwIfError(dom);
    let obj;
    if (updatedOptions.includeRoot) {
      obj = domToObject(dom, updatedOptions);
    } else {
      obj = domToObject(dom.childNodes[0], updatedOptions);
    }
    return Promise.resolve(obj);
  } catch (err) {
    return Promise.reject(err);
  }
}
function getErrorNamespace() {
  var _a2, _b;
  if (errorNS === void 0) {
    try {
      const invalidXML = (_a2 = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML("INVALID")) !== null && _a2 !== void 0 ? _a2 : "INVALID";
      errorNS = (_b = getParser().parseFromString(invalidXML, "text/xml").getElementsByTagName("parsererror")[0].namespaceURI) !== null && _b !== void 0 ? _b : "";
    } catch (ignored) {
      errorNS = "";
    }
  }
  return errorNS;
}
function throwIfError(dom) {
  const parserErrors = dom.getElementsByTagName("parsererror");
  if (parserErrors.length > 0 && getErrorNamespace()) {
    for (let i = 0; i < parserErrors.length; i++) {
      if (parserErrors[i].namespaceURI === errorNS) {
        throw new Error(parserErrors[i].innerHTML);
      }
    }
  }
}
function isElement(node) {
  return !!node.attributes;
}
function asElementWithAttributes(node) {
  return isElement(node) && node.hasAttributes() ? node : void 0;
}
function domToObject(node, options) {
  let result = {};
  const childNodeCount = node.childNodes.length;
  const firstChildNode = node.childNodes[0];
  const onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || void 0;
  const elementWithAttributes = asElementWithAttributes(node);
  if (elementWithAttributes) {
    result[XML_ATTRKEY] = {};
    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {
      const attr = elementWithAttributes.attributes[i];
      result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;
    }
    if (onlyChildTextValue) {
      result[options.xmlCharKey] = onlyChildTextValue;
    }
  } else if (childNodeCount === 0) {
    result = "";
  } else if (onlyChildTextValue) {
    result = onlyChildTextValue;
  }
  if (!onlyChildTextValue) {
    for (let i = 0; i < childNodeCount; i++) {
      const child = node.childNodes[i];
      if (child.nodeType !== Node.TEXT_NODE) {
        const childObject = domToObject(child, options);
        if (!result[child.nodeName]) {
          result[child.nodeName] = childObject;
        } else if (Array.isArray(result[child.nodeName])) {
          result[child.nodeName].push(childObject);
        } else {
          result[child.nodeName] = [result[child.nodeName], childObject];
        }
      }
    }
  }
  return result;
}
function stringifyXML(content, opts = {}) {
  var _a2, _b, _c;
  const updatedOptions = {
    rootName: (_a2 = opts.rootName) !== null && _a2 !== void 0 ? _a2 : "root",
    includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
    xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
  };
  const dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];
  return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + getSerializer().serializeToString(dom);
}
function buildAttributes(attrs) {
  const result = [];
  for (const key of Object.keys(attrs)) {
    const attr = getDoc().createAttribute(key);
    attr.value = attrs[key].toString();
    result.push(attr);
  }
  return result;
}
function buildNode(obj, elementName, options) {
  if (obj === void 0 || obj === null || typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean") {
    const elem = getDoc().createElement(elementName);
    elem.textContent = obj === void 0 || obj === null ? "" : obj.toString();
    return [elem];
  } else if (Array.isArray(obj)) {
    const result = [];
    for (const arrayElem of obj) {
      for (const child of buildNode(arrayElem, elementName, options)) {
        result.push(child);
      }
    }
    return result;
  } else if (typeof obj === "object") {
    const elem = getDoc().createElement(elementName);
    for (const key of Object.keys(obj)) {
      if (key === XML_ATTRKEY) {
        for (const attr of buildAttributes(obj[key])) {
          elem.attributes.setNamedItem(attr);
        }
      } else if (key === options.xmlCharKey) {
        elem.textContent = obj[key].toString();
      } else {
        for (const child of buildNode(obj[key], key, options)) {
          elem.appendChild(child);
        }
      }
    }
    return [elem];
  } else {
    throw new Error(`Illegal value passed to buildObject: ${obj}`);
  }
}
var cachedDoc, cachedParser, cachedSerializer, ttPolicy, errorNS;
var init_xml_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/xml.browser.js"() {
    init_serializer_common();
    if (!self.document || !self.DOMParser || !self.Node || !self.XMLSerializer) {
      throw new Error(`This library depends on the following DOM objects: ["document", "DOMParser", "Node", "XMLSerializer"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. `);
    }
    if (typeof self.trustedTypes !== "undefined") {
      ttPolicy = self.trustedTypes.createPolicy("@azure/core-http#xml.browser", {
        createHTML: (s) => s
      });
    }
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/deserializationPolicy.js
function deserializationPolicy(deserializationContentTypes, parsingOptions) {
  return {
    create: (nextPolicy, options) => {
      return new DeserializationPolicy(nextPolicy, options, deserializationContentTypes, parsingOptions);
    }
  };
}
function getOperationResponse(parsedResponse) {
  let result;
  const request = parsedResponse.request;
  const operationSpec = request.operationSpec;
  if (operationSpec) {
    const operationResponseGetter = request.operationResponseGetter;
    if (!operationResponseGetter) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationResponseGetter(operationSpec, parsedResponse);
    }
  }
  return result;
}
function shouldDeserializeResponse(parsedResponse) {
  const shouldDeserialize = parsedResponse.request.shouldDeserialize;
  let result;
  if (shouldDeserialize === void 0) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }
  return result;
}
function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options = {}) {
  var _a2, _b, _c;
  const updatedOptions = {
    rootName: (_a2 = options.rootName) !== null && _a2 !== void 0 ? _a2 : "",
    includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
    xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
  };
  return parse2(jsonContentTypes, xmlContentTypes, response, updatedOptions).then((parsedResponse) => {
    if (!shouldDeserializeResponse(parsedResponse)) {
      return parsedResponse;
    }
    const operationSpec = parsedResponse.request.operationSpec;
    if (!operationSpec || !operationSpec.responses) {
      return parsedResponse;
    }
    const responseSpec = getOperationResponse(parsedResponse);
    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec);
    if (error) {
      throw error;
    } else if (shouldReturnResponse) {
      return parsedResponse;
    }
    if (responseSpec) {
      if (responseSpec.bodyMapper) {
        let valueToDeserialize = parsedResponse.parsedBody;
        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence) {
          valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
        }
        try {
          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
        } catch (innerError) {
          const restError = new RestError(`Error ${innerError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, void 0, parsedResponse.status, parsedResponse.request, parsedResponse);
          throw restError;
        }
      } else if (operationSpec.httpMethod === "HEAD") {
        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
      }
      if (responseSpec.headersMapper) {
        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJson(), "operationRes.parsedHeaders", options);
      }
    }
    return parsedResponse;
  });
}
function isOperationSpecEmpty(operationSpec) {
  const expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec) {
  var _a2;
  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return { error: null, shouldReturnResponse: false };
      }
    } else {
      return { error: null, shouldReturnResponse: false };
    }
  }
  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
  const streaming = ((_a2 = parsedResponse.request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(parsedResponse.status)) || parsedResponse.request.streamResponseBody;
  const initialErrorMessage = streaming ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
  const error = new RestError(initialErrorMessage, void 0, parsedResponse.status, parsedResponse.request, parsedResponse);
  if (!errorResponseSpec) {
    throw error;
  }
  const defaultBodyMapper = errorResponseSpec.bodyMapper;
  const defaultHeadersMapper = errorResponseSpec.headersMapper;
  try {
    if (parsedResponse.parsedBody) {
      const parsedBody = parsedResponse.parsedBody;
      let parsedError;
      if (defaultBodyMapper) {
        let valueToDeserialize = parsedBody;
        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperType.Sequence) {
          valueToDeserialize = typeof parsedBody === "object" ? parsedBody[defaultBodyMapper.xmlElementName] : [];
        }
        parsedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody");
      }
      const internalError = parsedBody.error || parsedError || parsedBody;
      error.code = internalError.code;
      if (internalError.message) {
        error.message = internalError.message;
      }
      if (defaultBodyMapper) {
        error.response.parsedBody = parsedError;
      }
    }
    if (parsedResponse.headers && defaultHeadersMapper) {
      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJson(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
  }
  return { error, shouldReturnResponse: false };
}
function parse2(jsonContentTypes, xmlContentTypes, operationResponse, opts) {
  var _a2;
  const errorHandler = (err) => {
    const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
    const errCode = err.code || RestError.PARSE_ERROR;
    const e = new RestError(msg, errCode, operationResponse.status, operationResponse.request, operationResponse);
    return Promise.reject(e);
  };
  const streaming = ((_a2 = operationResponse.request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(operationResponse.status)) || operationResponse.request.streamResponseBody;
  if (!streaming && operationResponse.bodyAsText) {
    const text2 = operationResponse.bodyAsText;
    const contentType2 = operationResponse.headers.get("Content-Type") || "";
    const contentComponents = !contentType2 ? [] : contentType2.split(";").map((component) => component.toLowerCase());
    if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
      return new Promise((resolve) => {
        operationResponse.parsedBody = JSON.parse(text2);
        resolve(operationResponse);
      }).catch(errorHandler);
    } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
      return parseXML(text2, opts).then((body) => {
        operationResponse.parsedBody = body;
        return operationResponse;
      }).catch(errorHandler);
    }
  }
  return Promise.resolve(operationResponse);
}
var defaultJsonContentTypes, defaultXmlContentTypes, DefaultDeserializationOptions, DeserializationPolicy;
var init_deserializationPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/deserializationPolicy.js"() {
    init_requestPolicy();
    init_serializer_common();
    init_serializer();
    init_restError();
    init_xml_browser();
    defaultJsonContentTypes = ["application/json", "text/json"];
    defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
    DefaultDeserializationOptions = {
      expectedContentTypes: {
        json: defaultJsonContentTypes,
        xml: defaultXmlContentTypes
      }
    };
    DeserializationPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, requestPolicyOptions, deserializationContentTypes, parsingOptions = {}) {
        var _a2;
        super(nextPolicy, requestPolicyOptions);
        this.jsonContentTypes = deserializationContentTypes && deserializationContentTypes.json || defaultJsonContentTypes;
        this.xmlContentTypes = deserializationContentTypes && deserializationContentTypes.xml || defaultXmlContentTypes;
        this.xmlCharKey = (_a2 = parsingOptions.xmlCharKey) !== null && _a2 !== void 0 ? _a2 : XML_CHARKEY;
      }
      async sendRequest(request) {
        return this._nextPolicy.sendRequest(request).then((response) => deserializeResponseBody(this.jsonContentTypes, this.xmlContentTypes, response, {
          xmlCharKey: this.xmlCharKey
        }));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/keepAlivePolicy.js
function keepAlivePolicy(keepAliveOptions) {
  return {
    create: (nextPolicy, options) => {
      return new KeepAlivePolicy(nextPolicy, options, keepAliveOptions || DefaultKeepAliveOptions);
    }
  };
}
var DefaultKeepAliveOptions, KeepAlivePolicy;
var init_keepAlivePolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/keepAlivePolicy.js"() {
    init_requestPolicy();
    DefaultKeepAliveOptions = {
      enable: true
    };
    KeepAlivePolicy = class extends BaseRequestPolicy {
      /**
       * Creates an instance of KeepAlivePolicy.
       *
       * @param nextPolicy -
       * @param options -
       * @param keepAliveOptions -
       */
      constructor(nextPolicy, options, keepAliveOptions) {
        super(nextPolicy, options);
        this.keepAliveOptions = keepAliveOptions;
      }
      /**
       * Sends out request.
       *
       * @param request -
       * @returns
       */
      async sendRequest(request) {
        request.keepAlive = this.keepAliveOptions.enable;
        return this._nextPolicy.sendRequest(request);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/redirectPolicy.js
function redirectPolicy(maximumRetries = 20) {
  return {
    create: (nextPolicy, options) => {
      return new RedirectPolicy(nextPolicy, options, maximumRetries);
    }
  };
}
function handleRedirect(policy, response, currentRetries) {
  const { request, status: status2 } = response;
  const locationHeader = response.headers.get("location");
  if (locationHeader && (status2 === 300 || status2 === 301 && allowedRedirect.includes(request.method) || status2 === 302 && allowedRedirect.includes(request.method) || status2 === 303 && request.method === "POST" || status2 === 307) && (!policy.maxRetries || currentRetries < policy.maxRetries)) {
    const builder = URLBuilder.parse(request.url);
    builder.setPath(locationHeader);
    request.url = builder.toString();
    if (status2 === 303) {
      request.method = "GET";
      delete request.body;
    }
    return policy._nextPolicy.sendRequest(request).then((res) => handleRedirect(policy, res, currentRetries + 1));
  }
  return Promise.resolve(response);
}
var allowedRedirect, DefaultRedirectOptions, RedirectPolicy;
var init_redirectPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/redirectPolicy.js"() {
    init_requestPolicy();
    init_url();
    allowedRedirect = ["GET", "HEAD"];
    DefaultRedirectOptions = {
      handleRedirects: true,
      maxRetries: 20
    };
    RedirectPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, maxRetries = 20) {
        super(nextPolicy, options);
        this.maxRetries = maxRetries;
      }
      sendRequest(request) {
        return this._nextPolicy.sendRequest(request).then((response) => handleRedirect(this, response, 0));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/exponentialBackoffStrategy.js
function isNumber(n) {
  return typeof n === "number";
}
function shouldRetry(retryLimit, predicate, retryData, response, error) {
  if (!predicate(response, error)) {
    return false;
  }
  return retryData.retryCount < retryLimit;
}
function updateRetryData(retryOptions, retryData = { retryCount: 0, retryInterval: 0 }, err) {
  if (err) {
    if (retryData.error) {
      err.innerError = retryData.error;
    }
    retryData.error = err;
  }
  retryData.retryCount++;
  let incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;
  const boundedRandDelta = retryOptions.retryInterval * 0.8 + Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));
  incrementDelta *= boundedRandDelta;
  retryData.retryInterval = Math.min(retryOptions.minRetryInterval + incrementDelta, retryOptions.maxRetryInterval);
  return retryData;
}
var DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_MIN_RETRY_INTERVAL;
var init_exponentialBackoffStrategy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/exponentialBackoffStrategy.js"() {
    DEFAULT_CLIENT_RETRY_COUNT = 3;
    DEFAULT_CLIENT_RETRY_INTERVAL = 1e3 * 30;
    DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 90;
    DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1e3 * 3;
  }
});

// node_modules/@azure/core-util/dist-esm/src/isNode.browser.js
var isNode2;
var init_isNode_browser = __esm({
  "node_modules/@azure/core-util/dist-esm/src/isNode.browser.js"() {
    isNode2 = false;
  }
});

// node_modules/@azure/core-util/dist-esm/src/createAbortablePromise.js
function createAbortablePromise(buildPromise, options) {
  const { cleanupBeforeAbort, abortSignal: abortSignal2, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
  return new Promise((resolve, reject) => {
    function rejectOnAbort() {
      reject(new AbortError(abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : "The operation was aborted."));
    }
    function removeListeners() {
      abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.removeEventListener("abort", onAbort);
    }
    function onAbort() {
      cleanupBeforeAbort === null || cleanupBeforeAbort === void 0 ? void 0 : cleanupBeforeAbort();
      removeListeners();
      rejectOnAbort();
    }
    if (abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.aborted) {
      return rejectOnAbort();
    }
    try {
      buildPromise((x) => {
        removeListeners();
        resolve(x);
      }, (x) => {
        removeListeners();
        reject(x);
      });
    } catch (err) {
      reject(err);
    }
    abortSignal2 === null || abortSignal2 === void 0 ? void 0 : abortSignal2.addEventListener("abort", onAbort);
  });
}
var init_createAbortablePromise = __esm({
  "node_modules/@azure/core-util/dist-esm/src/createAbortablePromise.js"() {
    init_src();
  }
});

// node_modules/@azure/core-util/dist-esm/src/delay.js
function delay(timeInMs, options) {
  let token;
  const { abortSignal: abortSignal2, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
  return createAbortablePromise((resolve) => {
    token = setTimeout(resolve, timeInMs);
  }, {
    cleanupBeforeAbort: () => clearTimeout(token),
    abortSignal: abortSignal2,
    abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : StandardAbortMessage
  });
}
var StandardAbortMessage;
var init_delay = __esm({
  "node_modules/@azure/core-util/dist-esm/src/delay.js"() {
    init_createAbortablePromise();
    StandardAbortMessage = "The delay was aborted.";
  }
});

// node_modules/@azure/core-util/dist-esm/src/random.js
function getRandomIntegerInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  const offset = Math.floor(Math.random() * (max - min + 1));
  return offset + min;
}
var init_random = __esm({
  "node_modules/@azure/core-util/dist-esm/src/random.js"() {
  }
});

// node_modules/@azure/core-util/dist-esm/src/object.js
function isObject2(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}
var init_object = __esm({
  "node_modules/@azure/core-util/dist-esm/src/object.js"() {
  }
});

// node_modules/@azure/core-util/dist-esm/src/error.js
function isError(e) {
  if (isObject2(e)) {
    const hasName = typeof e.name === "string";
    const hasMessage = typeof e.message === "string";
    return hasName && hasMessage;
  }
  return false;
}
function getErrorMessage(e) {
  if (isError(e)) {
    return e.message;
  } else {
    let stringified;
    try {
      if (typeof e === "object" && e) {
        stringified = JSON.stringify(e);
      } else {
        stringified = String(e);
      }
    } catch (err) {
      stringified = "[unable to stringify input]";
    }
    return `Unknown error ${stringified}`;
  }
}
var init_error = __esm({
  "node_modules/@azure/core-util/dist-esm/src/error.js"() {
    init_object();
  }
});

// node_modules/@azure/core-util/dist-esm/src/base64.browser.js
var init_base64_browser2 = __esm({
  "node_modules/@azure/core-util/dist-esm/src/base64.browser.js"() {
  }
});

// node_modules/@azure/core-util/dist-esm/src/hex.js
var init_hex = __esm({
  "node_modules/@azure/core-util/dist-esm/src/hex.js"() {
  }
});

// node_modules/@azure/core-util/dist-esm/src/utf8.browser.js
var init_utf8_browser = __esm({
  "node_modules/@azure/core-util/dist-esm/src/utf8.browser.js"() {
  }
});

// node_modules/@azure/core-util/dist-esm/src/sha256.browser.js
var init_sha256_browser = __esm({
  "node_modules/@azure/core-util/dist-esm/src/sha256.browser.js"() {
    init_base64_browser2();
    init_hex();
    init_utf8_browser();
  }
});

// node_modules/@azure/core-util/dist-esm/src/typeGuards.js
var init_typeGuards = __esm({
  "node_modules/@azure/core-util/dist-esm/src/typeGuards.js"() {
  }
});

// node_modules/@azure/core-util/dist-esm/src/uuidUtils.native.js
function generateUUID() {
  let uuid = "";
  for (let i = 0; i < 32; i++) {
    const randomNumber = Math.floor(Math.random() * 16);
    if (i === 12) {
      uuid += "4";
    } else if (i === 16) {
      uuid += randomNumber & 3 | 8;
    } else {
      uuid += randomNumber.toString(16);
    }
    if (i === 7 || i === 11 || i === 15 || i === 19) {
      uuid += "-";
    }
  }
  return uuid;
}
var init_uuidUtils_native = __esm({
  "node_modules/@azure/core-util/dist-esm/src/uuidUtils.native.js"() {
  }
});

// node_modules/@azure/core-util/dist-esm/src/uuidUtils.browser.js
function randomUUID() {
  return uuidFunction();
}
var _a, uuidFunction;
var init_uuidUtils_browser = __esm({
  "node_modules/@azure/core-util/dist-esm/src/uuidUtils.browser.js"() {
    init_uuidUtils_native();
    uuidFunction = typeof ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : generateUUID;
  }
});

// node_modules/@azure/core-util/dist-esm/src/index.js
var init_src2 = __esm({
  "node_modules/@azure/core-util/dist-esm/src/index.js"() {
    init_isNode_browser();
    init_delay();
    init_createAbortablePromise();
    init_random();
    init_object();
    init_error();
    init_sha256_browser();
    init_typeGuards();
    init_uuidUtils_browser();
  }
});

// node_modules/@azure/logger/dist-esm/src/log.browser.js
function log(...args) {
  if (args.length > 0) {
    const firstArg = String(args[0]);
    if (firstArg.includes(":error")) {
      console.error(...args);
    } else if (firstArg.includes(":warning")) {
      console.warn(...args);
    } else if (firstArg.includes(":info")) {
      console.info(...args);
    } else if (firstArg.includes(":verbose")) {
      console.debug(...args);
    } else {
      console.debug(...args);
    }
  }
}
var init_log_browser = __esm({
  "node_modules/@azure/logger/dist-esm/src/log.browser.js"() {
  }
});

// node_modules/@azure/logger/dist-esm/src/debug.js
function enable(namespaces) {
  enabledString = namespaces;
  enabledNamespaces = [];
  skippedNamespaces = [];
  const wildcard = /\*/g;
  const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
  for (const ns of namespaceList) {
    if (ns.startsWith("-")) {
      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
    } else {
      enabledNamespaces.push(new RegExp(`^${ns}$`));
    }
  }
  for (const instance of debuggers) {
    instance.enabled = enabled(instance.namespace);
  }
}
function enabled(namespace) {
  if (namespace.endsWith("*")) {
    return true;
  }
  for (const skipped of skippedNamespaces) {
    if (skipped.test(namespace)) {
      return false;
    }
  }
  for (const enabledNamespace of enabledNamespaces) {
    if (enabledNamespace.test(namespace)) {
      return true;
    }
  }
  return false;
}
function disable() {
  const result = enabledString || "";
  enable("");
  return result;
}
function createDebugger(namespace) {
  const newDebugger = Object.assign(debug, {
    enabled: enabled(namespace),
    destroy,
    log: debugObj.log,
    namespace,
    extend
  });
  function debug(...args) {
    if (!newDebugger.enabled) {
      return;
    }
    if (args.length > 0) {
      args[0] = `${namespace} ${args[0]}`;
    }
    newDebugger.log(...args);
  }
  debuggers.push(newDebugger);
  return newDebugger;
}
function destroy() {
  const index2 = debuggers.indexOf(this);
  if (index2 >= 0) {
    debuggers.splice(index2, 1);
    return true;
  }
  return false;
}
function extend(namespace) {
  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
  newDebugger.log = this.log;
  return newDebugger;
}
var debugEnvVariable, enabledString, enabledNamespaces, skippedNamespaces, debuggers, debugObj, debug_default;
var init_debug = __esm({
  "node_modules/@azure/logger/dist-esm/src/debug.js"() {
    init_log_browser();
    debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
    enabledNamespaces = [];
    skippedNamespaces = [];
    debuggers = [];
    if (debugEnvVariable) {
      enable(debugEnvVariable);
    }
    debugObj = Object.assign((namespace) => {
      return createDebugger(namespace);
    }, {
      enable,
      enabled,
      disable,
      log
    });
    debug_default = debugObj;
  }
});

// node_modules/@azure/logger/dist-esm/src/index.js
function setLogLevel(level) {
  if (level && !isAzureLogLevel(level)) {
    throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
  }
  azureLogLevel = level;
  const enabledNamespaces2 = [];
  for (const logger5 of registeredLoggers) {
    if (shouldEnable(logger5)) {
      enabledNamespaces2.push(logger5.namespace);
    }
  }
  debug_default.enable(enabledNamespaces2.join(","));
}
function createClientLogger(namespace) {
  const clientRootLogger = AzureLogger.extend(namespace);
  patchLogMethod(AzureLogger, clientRootLogger);
  return {
    error: createLogger(clientRootLogger, "error"),
    warning: createLogger(clientRootLogger, "warning"),
    info: createLogger(clientRootLogger, "info"),
    verbose: createLogger(clientRootLogger, "verbose")
  };
}
function patchLogMethod(parent, child) {
  child.log = (...args) => {
    parent.log(...args);
  };
}
function createLogger(parent, level) {
  const logger5 = Object.assign(parent.extend(level), {
    level
  });
  patchLogMethod(parent, logger5);
  if (shouldEnable(logger5)) {
    const enabledNamespaces2 = debug_default.disable();
    debug_default.enable(enabledNamespaces2 + "," + logger5.namespace);
  }
  registeredLoggers.add(logger5);
  return logger5;
}
function shouldEnable(logger5) {
  return Boolean(azureLogLevel && levelMap[logger5.level] <= levelMap[azureLogLevel]);
}
function isAzureLogLevel(logLevel) {
  return AZURE_LOG_LEVELS.includes(logLevel);
}
var registeredLoggers, logLevelFromEnv, azureLogLevel, AzureLogger, AZURE_LOG_LEVELS, levelMap;
var init_src3 = __esm({
  "node_modules/@azure/logger/dist-esm/src/index.js"() {
    init_debug();
    registeredLoggers = /* @__PURE__ */ new Set();
    logLevelFromEnv = typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL || void 0;
    AzureLogger = debug_default("azure");
    AzureLogger.log = (...args) => {
      debug_default.log(...args);
    };
    AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
    if (logLevelFromEnv) {
      if (isAzureLogLevel(logLevelFromEnv)) {
        setLogLevel(logLevelFromEnv);
      } else {
        console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
      }
    }
    levelMap = {
      verbose: 400,
      info: 300,
      warning: 200,
      error: 100
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/log.js
var logger;
var init_log = __esm({
  "node_modules/@azure/core-http/dist-esm/src/log.js"() {
    init_src3();
    logger = createClientLogger("core-http");
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/exponentialRetryPolicy.js
function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {
  return {
    create: (nextPolicy, options) => {
      return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);
    }
  };
}
async function retry(policy, request, response, retryData, requestError) {
  function shouldPolicyRetry(responseParam) {
    const statusCode = responseParam === null || responseParam === void 0 ? void 0 : responseParam.status;
    if (statusCode === 503 && (response === null || response === void 0 ? void 0 : response.headers.get(Constants.HeaderConstants.RETRY_AFTER))) {
      return false;
    }
    if (statusCode === void 0 || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) {
      return false;
    }
    return true;
  }
  retryData = updateRetryData({
    retryInterval: policy.retryInterval,
    minRetryInterval: 0,
    maxRetryInterval: policy.maxRetryInterval
  }, retryData, requestError);
  const isAborted = request.abortSignal && request.abortSignal.aborted;
  if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {
    logger.info(`Retrying request in ${retryData.retryInterval}`);
    try {
      await delay(retryData.retryInterval);
      const res = await policy._nextPolicy.sendRequest(request.clone());
      return retry(policy, request, res, retryData);
    } catch (err) {
      return retry(policy, request, response, retryData, err);
    }
  } else if (isAborted || requestError || !response) {
    const err = retryData.error || new RestError("Failed to send the request.", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);
    throw err;
  } else {
    return response;
  }
}
var RetryMode, DefaultRetryOptions, ExponentialRetryPolicy;
var init_exponentialRetryPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/exponentialRetryPolicy.js"() {
    init_requestPolicy();
    init_exponentialBackoffStrategy();
    init_constants();
    init_restError();
    init_src2();
    init_log();
    (function(RetryMode2) {
      RetryMode2[RetryMode2["Exponential"] = 0] = "Exponential";
    })(RetryMode || (RetryMode = {}));
    DefaultRetryOptions = {
      maxRetries: DEFAULT_CLIENT_RETRY_COUNT,
      retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,
      maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL
    };
    ExponentialRetryPolicy = class extends BaseRequestPolicy {
      /**
       * @param nextPolicy - The next RequestPolicy in the pipeline chain.
       * @param options - The options for this RequestPolicy.
       * @param retryCount - The client retry count.
       * @param retryInterval - The client retry interval, in milliseconds.
       * @param minRetryInterval - The minimum retry interval, in milliseconds.
       * @param maxRetryInterval - The maximum retry interval, in milliseconds.
       */
      constructor(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {
        super(nextPolicy, options);
        this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;
        this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;
        this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
      }
      sendRequest(request) {
        return this._nextPolicy.sendRequest(request.clone()).then((response) => retry(this, request, response)).catch((error) => retry(this, request, error.response, void 0, error));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/logPolicy.js
function logPolicy(loggingOptions = {}) {
  return {
    create: (nextPolicy, options) => {
      return new LogPolicy(nextPolicy, options, loggingOptions);
    }
  };
}
var LogPolicy;
var init_logPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/logPolicy.js"() {
    init_requestPolicy();
    init_sanitizer();
    init_log();
    LogPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, { logger: logger5 = logger.info, allowedHeaderNames = [], allowedQueryParameters = [] } = {}) {
        super(nextPolicy, options);
        this.logger = logger5;
        this.sanitizer = new Sanitizer({ allowedHeaderNames, allowedQueryParameters });
      }
      /**
       * Header names whose values will be logged when logging is enabled. Defaults to
       * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
       * specified in this field will be added to that list.  Any other values will
       * be written to logs as "REDACTED".
       * @deprecated Pass these into the constructor instead.
       */
      get allowedHeaderNames() {
        return this.sanitizer.allowedHeaderNames;
      }
      /**
       * Header names whose values will be logged when logging is enabled. Defaults to
       * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
       * specified in this field will be added to that list.  Any other values will
       * be written to logs as "REDACTED".
       * @deprecated Pass these into the constructor instead.
       */
      set allowedHeaderNames(allowedHeaderNames) {
        this.sanitizer.allowedHeaderNames = allowedHeaderNames;
      }
      /**
       * Query string names whose values will be logged when logging is enabled. By default no
       * query string values are logged.
       * @deprecated Pass these into the constructor instead.
       */
      get allowedQueryParameters() {
        return this.sanitizer.allowedQueryParameters;
      }
      /**
       * Query string names whose values will be logged when logging is enabled. By default no
       * query string values are logged.
       * @deprecated Pass these into the constructor instead.
       */
      set allowedQueryParameters(allowedQueryParameters) {
        this.sanitizer.allowedQueryParameters = allowedQueryParameters;
      }
      sendRequest(request) {
        if (!this.logger.enabled)
          return this._nextPolicy.sendRequest(request);
        this.logRequest(request);
        return this._nextPolicy.sendRequest(request).then((response) => this.logResponse(response));
      }
      logRequest(request) {
        this.logger(`Request: ${this.sanitizer.sanitize(request)}`);
      }
      logResponse(response) {
        this.logger(`Response status code: ${response.status}`);
        this.logger(`Headers: ${this.sanitizer.sanitize(response.headers)}`);
        return response;
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/operationParameter.js
function getPathStringFromParameter(parameter) {
  return getPathStringFromParameterPath(parameter.parameterPath, parameter.mapper);
}
function getPathStringFromParameterPath(parameterPath, mapper) {
  let result;
  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }
  return result;
}
var init_operationParameter = __esm({
  "node_modules/@azure/core-http/dist-esm/src/operationParameter.js"() {
  }
});

// node_modules/@azure/core-http/dist-esm/src/operationSpec.js
function getStreamResponseStatusCodes(operationSpec) {
  const result = /* @__PURE__ */ new Set();
  for (const statusCode in operationSpec.responses) {
    const operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperType.Stream) {
      result.add(Number(statusCode));
    }
  }
  return result;
}
var init_operationSpec = __esm({
  "node_modules/@azure/core-http/dist-esm/src/operationSpec.js"() {
    init_serializer();
  }
});

// node_modules/@azure/core-auth/dist-esm/src/azureKeyCredential.js
var AzureKeyCredential;
var init_azureKeyCredential = __esm({
  "node_modules/@azure/core-auth/dist-esm/src/azureKeyCredential.js"() {
    AzureKeyCredential = class {
      /**
       * Create an instance of an AzureKeyCredential for use
       * with a service client.
       *
       * @param key - The initial value of the key to use in authentication
       */
      constructor(key) {
        if (!key) {
          throw new Error("key must be a non-empty string");
        }
        this._key = key;
      }
      /**
       * The value of the key to be used in authentication
       */
      get key() {
        return this._key;
      }
      /**
       * Change the value of the key.
       *
       * Updates will take effect upon the next request after
       * updating the key value.
       *
       * @param newKey - The new key value to be used
       */
      update(newKey) {
        this._key = newKey;
      }
    };
  }
});

// node_modules/@azure/core-auth/dist-esm/src/typeguards.js
var init_typeguards = __esm({
  "node_modules/@azure/core-auth/dist-esm/src/typeguards.js"() {
  }
});

// node_modules/@azure/core-auth/dist-esm/src/azureNamedKeyCredential.js
var init_azureNamedKeyCredential = __esm({
  "node_modules/@azure/core-auth/dist-esm/src/azureNamedKeyCredential.js"() {
    init_typeguards();
  }
});

// node_modules/@azure/core-auth/dist-esm/src/azureSASCredential.js
var init_azureSASCredential = __esm({
  "node_modules/@azure/core-auth/dist-esm/src/azureSASCredential.js"() {
    init_typeguards();
  }
});

// node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js
function isTokenCredential(credential) {
  const castCredential = credential;
  return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
}
var init_tokenCredential = __esm({
  "node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js"() {
  }
});

// node_modules/@azure/core-auth/dist-esm/src/index.js
var init_src4 = __esm({
  "node_modules/@azure/core-auth/dist-esm/src/index.js"() {
    init_azureKeyCredential();
    init_azureNamedKeyCredential();
    init_azureSASCredential();
    init_tokenCredential();
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/msRestUserAgentPolicy.browser.js
function getDefaultUserAgentKey() {
  return "x-ms-useragent";
}
function getPlatformSpecificData() {
  const navigator2 = self.navigator;
  const osInfo = {
    key: "OS",
    value: (navigator2.oscpu || navigator2.platform).replace(" ", "")
  };
  return [osInfo];
}
var init_msRestUserAgentPolicy_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/msRestUserAgentPolicy.browser.js"() {
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/userAgentPolicy.js
function getRuntimeInfo() {
  const msRestRuntime = {
    key: "core-http",
    value: Constants.coreHttpVersion
  };
  return [msRestRuntime];
}
function getUserAgentString(telemetryInfo, keySeparator = " ", valueSeparator = "/") {
  return telemetryInfo.map((info) => {
    const value = info.value ? `${valueSeparator}${info.value}` : "";
    return `${info.key}${value}`;
  }).join(keySeparator);
}
function getDefaultUserAgentValue() {
  const runtimeInfo = getRuntimeInfo();
  const platformSpecificData = getPlatformSpecificData();
  const userAgent = getUserAgentString(runtimeInfo.concat(platformSpecificData));
  return userAgent;
}
function userAgentPolicy(userAgentData) {
  const key = !userAgentData || userAgentData.key === void 0 || userAgentData.key === null ? getDefaultUserAgentKey() : userAgentData.key;
  const value = !userAgentData || userAgentData.value === void 0 || userAgentData.value === null ? getDefaultUserAgentValue() : userAgentData.value;
  return {
    create: (nextPolicy, options) => {
      return new UserAgentPolicy(nextPolicy, options, key, value);
    }
  };
}
var getDefaultUserAgentHeaderName, UserAgentPolicy;
var init_userAgentPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/userAgentPolicy.js"() {
    init_requestPolicy();
    init_msRestUserAgentPolicy_browser();
    init_constants();
    init_httpHeaders();
    getDefaultUserAgentHeaderName = getDefaultUserAgentKey;
    UserAgentPolicy = class extends BaseRequestPolicy {
      constructor(_nextPolicy, _options, headerKey, headerValue) {
        super(_nextPolicy, _options);
        this._nextPolicy = _nextPolicy;
        this._options = _options;
        this.headerKey = headerKey;
        this.headerValue = headerValue;
      }
      sendRequest(request) {
        this.addUserAgentHeader(request);
        return this._nextPolicy.sendRequest(request);
      }
      /**
       * Adds the user agent header to the outgoing request.
       */
      addUserAgentHeader(request) {
        if (!request.headers) {
          request.headers = new HttpHeaders();
        }
        if (!request.headers.get(this.headerKey) && this.headerValue) {
          request.headers.set(this.headerKey, this.headerValue);
        }
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/queryCollectionFormat.js
var QueryCollectionFormat;
var init_queryCollectionFormat = __esm({
  "node_modules/@azure/core-http/dist-esm/src/queryCollectionFormat.js"() {
    (function(QueryCollectionFormat2) {
      QueryCollectionFormat2["Csv"] = ",";
      QueryCollectionFormat2["Ssv"] = " ";
      QueryCollectionFormat2["Tsv"] = "	";
      QueryCollectionFormat2["Pipes"] = "|";
      QueryCollectionFormat2["Multi"] = "Multi";
    })(QueryCollectionFormat || (QueryCollectionFormat = {}));
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js
async function beginRefresh(getAccessToken, retryIntervalInMs, timeoutInMs) {
  async function tryGetAccessToken() {
    if (Date.now() < timeoutInMs) {
      try {
        return await getAccessToken();
      } catch (_a2) {
        return null;
      }
    } else {
      const finalToken = await getAccessToken();
      if (finalToken === null) {
        throw new Error("Failed to refresh access token.");
      }
      return finalToken;
    }
  }
  let token = await tryGetAccessToken();
  while (token === null) {
    await delay(retryIntervalInMs);
    token = await tryGetAccessToken();
  }
  return token;
}
function createTokenCycler(credential, scopes, tokenCyclerOptions) {
  let refreshWorker = null;
  let token = null;
  const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
  const cycler = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return refreshWorker !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      var _a2;
      return !cycler.isRefreshing && ((_a2 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a2 !== void 0 ? _a2 : 0) - options.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  function refresh(getTokenOptions) {
    var _a2;
    if (!cycler.isRefreshing) {
      const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
      refreshWorker = beginRefresh(
        tryGetAccessToken,
        options.retryIntervalInMs,
        // If we don't have a token, then we should timeout immediately
        (_a2 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a2 !== void 0 ? _a2 : Date.now()
      ).then((_token) => {
        refreshWorker = null;
        token = _token;
        return token;
      }).catch((reason) => {
        refreshWorker = null;
        token = null;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return async (tokenOptions) => {
    if (cycler.mustRefresh)
      return refresh(tokenOptions);
    if (cycler.shouldRefresh) {
      refresh(tokenOptions);
    }
    return token;
  };
}
function bearerTokenAuthenticationPolicy(credential, scopes) {
  const getToken = createTokenCycler(
    credential,
    scopes
    /* , options */
  );
  class BearerTokenAuthenticationPolicy extends BaseRequestPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
    async sendRequest(webResource) {
      if (!webResource.url.toLowerCase().startsWith("https://")) {
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      }
      const { token } = await getToken({
        abortSignal: webResource.abortSignal,
        tracingOptions: {
          tracingContext: webResource.tracingContext
        }
      });
      webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${token}`);
      return this._nextPolicy.sendRequest(webResource);
    }
  }
  return {
    create: (nextPolicy, options) => {
      return new BearerTokenAuthenticationPolicy(nextPolicy, options);
    }
  };
}
var DEFAULT_CYCLER_OPTIONS;
var init_bearerTokenAuthenticationPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js"() {
    init_requestPolicy();
    init_constants();
    init_src2();
    DEFAULT_CYCLER_OPTIONS = {
      forcedRefreshWindowInMs: 1e3,
      retryIntervalInMs: 3e3,
      refreshWindowInMs: 1e3 * 60 * 2
      // Start refreshing 2m before expiry
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/disableResponseDecompressionPolicy.browser.js
function disableResponseDecompressionPolicy() {
  return {
    create: (_nextPolicy, _options) => {
      throw DisbleResponseDecompressionNotSupportedInBrowser;
    }
  };
}
var DisbleResponseDecompressionNotSupportedInBrowser;
var init_disableResponseDecompressionPolicy_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/disableResponseDecompressionPolicy.browser.js"() {
    init_requestPolicy();
    DisbleResponseDecompressionNotSupportedInBrowser = new Error("DisableResponseDecompressionPolicy is not supported in browser environment");
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/generateClientRequestIdPolicy.js
function generateClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
  return {
    create: (nextPolicy, options) => {
      return new GenerateClientRequestIdPolicy(nextPolicy, options, requestIdHeaderName);
    }
  };
}
var GenerateClientRequestIdPolicy;
var init_generateClientRequestIdPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/generateClientRequestIdPolicy.js"() {
    init_requestPolicy();
    GenerateClientRequestIdPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, _requestIdHeaderName) {
        super(nextPolicy, options);
        this._requestIdHeaderName = _requestIdHeaderName;
      }
      sendRequest(request) {
        if (!request.headers.contains(this._requestIdHeaderName)) {
          request.headers.set(this._requestIdHeaderName, request.requestId);
        }
        return this._nextPolicy.sendRequest(request);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/httpClientCache.js
function getCachedDefaultHttpClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = new XhrHttpClient();
  }
  return cachedHttpClient;
}
var cachedHttpClient;
var init_httpClientCache = __esm({
  "node_modules/@azure/core-http/dist-esm/src/httpClientCache.js"() {
    init_defaultHttpClient_browser();
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/ndJsonPolicy.js
function ndJsonPolicy() {
  return {
    create: (nextPolicy, options) => {
      return new NdJsonPolicy(nextPolicy, options);
    }
  };
}
var NdJsonPolicy;
var init_ndJsonPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/ndJsonPolicy.js"() {
    init_requestPolicy();
    NdJsonPolicy = class extends BaseRequestPolicy {
      /**
       * Creates an instance of KeepAlivePolicy.
       */
      constructor(nextPolicy, options) {
        super(nextPolicy, options);
      }
      /**
       * Sends a request.
       */
      async sendRequest(request) {
        if (typeof request.body === "string" && request.body.startsWith("[")) {
          const body = JSON.parse(request.body);
          if (Array.isArray(body)) {
            request.body = body.map((item) => JSON.stringify(item) + "\n").join("");
          }
        }
        return this._nextPolicy.sendRequest(request);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/proxyPolicy.browser.js
function getDefaultProxySettings(_proxyUrl) {
  return void 0;
}
function proxyPolicy(_proxySettings) {
  return {
    create: (_nextPolicy, _options) => {
      throw proxyNotSupportedInBrowser;
    }
  };
}
var proxyNotSupportedInBrowser;
var init_proxyPolicy_browser = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/proxyPolicy.browser.js"() {
    init_requestPolicy();
    proxyNotSupportedInBrowser = new Error("ProxyPolicy is not supported in browser environment");
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/rpRegistrationPolicy.js
function rpRegistrationPolicy(retryTimeout = 30) {
  return {
    create: (nextPolicy, options) => {
      return new RPRegistrationPolicy(nextPolicy, options, retryTimeout);
    }
  };
}
function registerIfNeeded(policy, request, response) {
  if (response.status === 409) {
    const rpName = checkRPNotRegisteredError(response.bodyAsText);
    if (rpName) {
      const urlPrefix = extractSubscriptionUrl(request.url);
      return registerRP(policy, urlPrefix, rpName, request).catch(() => false).then((registrationStatus) => {
        if (registrationStatus) {
          request.headers.set("x-ms-client-request-id", generateUuid());
          return policy._nextPolicy.sendRequest(request.clone());
        }
        return response;
      });
    }
  }
  return Promise.resolve(response);
}
function getRequestEssentials(originalRequest, reuseUrlToo = false) {
  const reqOptions = originalRequest.clone();
  if (reuseUrlToo) {
    reqOptions.url = originalRequest.url;
  }
  reqOptions.headers.set("x-ms-client-request-id", generateUuid());
  reqOptions.headers.set("Content-Type", "application/json; charset=utf-8");
  return reqOptions;
}
function checkRPNotRegisteredError(body) {
  let result, responseBody;
  if (body) {
    try {
      responseBody = JSON.parse(body);
    } catch (err) {
    }
    if (responseBody && responseBody.error && responseBody.error.message && responseBody.error.code && responseBody.error.code === "MissingSubscriptionRegistration") {
      const matchRes = responseBody.error.message.match(/.*'(.*)'/i);
      if (matchRes) {
        result = matchRes.pop();
      }
    }
  }
  return result;
}
function extractSubscriptionUrl(url) {
  let result;
  const matchRes = url.match(/.*\/subscriptions\/[a-f0-9-]+\//gi);
  if (matchRes && matchRes[0]) {
    result = matchRes[0];
  } else {
    throw new Error(`Unable to extract subscriptionId from the given url - ${url}.`);
  }
  return result;
}
async function registerRP(policy, urlPrefix, provider, originalRequest) {
  const postUrl = `${urlPrefix}providers/${provider}/register?api-version=2016-02-01`;
  const getUrl = `${urlPrefix}providers/${provider}?api-version=2016-02-01`;
  const reqOptions = getRequestEssentials(originalRequest);
  reqOptions.method = "POST";
  reqOptions.url = postUrl;
  const response = await policy._nextPolicy.sendRequest(reqOptions);
  if (response.status !== 200) {
    throw new Error(`Autoregistration of ${provider} failed. Please try registering manually.`);
  }
  return getRegistrationStatus(policy, getUrl, originalRequest);
}
async function getRegistrationStatus(policy, url, originalRequest) {
  const reqOptions = getRequestEssentials(originalRequest);
  reqOptions.url = url;
  reqOptions.method = "GET";
  const res = await policy._nextPolicy.sendRequest(reqOptions);
  const obj = res.parsedBody;
  if (res.parsedBody && obj.registrationState && obj.registrationState === "Registered") {
    return true;
  } else {
    await delay(policy._retryTimeout * 1e3);
    return getRegistrationStatus(policy, url, originalRequest);
  }
}
var RPRegistrationPolicy;
var init_rpRegistrationPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/rpRegistrationPolicy.js"() {
    init_utils();
    init_requestPolicy();
    init_src2();
    RPRegistrationPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, _retryTimeout = 30) {
        super(nextPolicy, options);
        this._retryTimeout = _retryTimeout;
      }
      sendRequest(request) {
        return this._nextPolicy.sendRequest(request.clone()).then((response) => registerIfNeeded(this, request, response));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/signingPolicy.js
function signingPolicy(authenticationProvider) {
  return {
    create: (nextPolicy, options) => {
      return new SigningPolicy(nextPolicy, options, authenticationProvider);
    }
  };
}
var SigningPolicy;
var init_signingPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/signingPolicy.js"() {
    init_requestPolicy();
    SigningPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, authenticationProvider) {
        super(nextPolicy, options);
        this.authenticationProvider = authenticationProvider;
      }
      signRequest(request) {
        return this.authenticationProvider.signRequest(request);
      }
      sendRequest(request) {
        return this.signRequest(request).then((nextRequest) => this._nextPolicy.sendRequest(nextRequest));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/systemErrorRetryPolicy.js
function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
  return {
    create: (nextPolicy, options) => {
      return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);
    }
  };
}
async function retry2(policy, request, operationResponse, err, retryData) {
  retryData = updateRetryData(policy, retryData, err);
  function shouldPolicyRetry(_response, error) {
    if (error && error.code && (error.code === "ETIMEDOUT" || error.code === "ESOCKETTIMEDOUT" || error.code === "ECONNREFUSED" || error.code === "ECONNRESET" || error.code === "ENOENT")) {
      return true;
    }
    return false;
  }
  if (shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) {
    try {
      await delay(retryData.retryInterval);
      return policy._nextPolicy.sendRequest(request.clone());
    } catch (nestedErr) {
      return retry2(policy, request, operationResponse, nestedErr, retryData);
    }
  } else {
    if (err) {
      return Promise.reject(retryData.error);
    }
    return operationResponse;
  }
}
var SystemErrorRetryPolicy;
var init_systemErrorRetryPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/systemErrorRetryPolicy.js"() {
    init_requestPolicy();
    init_exponentialBackoffStrategy();
    init_src2();
    SystemErrorRetryPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
        super(nextPolicy, options);
        this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;
        this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;
        this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;
        this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
      }
      sendRequest(request) {
        return this._nextPolicy.sendRequest(request.clone()).catch((error) => retry2(this, request, error.response, error));
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/util/throttlingRetryStrategy.js
var DEFAULT_CLIENT_MAX_RETRY_COUNT;
var init_throttlingRetryStrategy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/util/throttlingRetryStrategy.js"() {
    DEFAULT_CLIENT_MAX_RETRY_COUNT = 3;
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/throttlingRetryPolicy.js
function throttlingRetryPolicy() {
  return {
    create: (nextPolicy, options) => {
      return new ThrottlingRetryPolicy(nextPolicy, options);
    }
  };
}
var StatusCodes, StandardAbortMessage2, ThrottlingRetryPolicy;
var init_throttlingRetryPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/throttlingRetryPolicy.js"() {
    init_requestPolicy();
    init_src();
    init_constants();
    init_throttlingRetryStrategy();
    init_src2();
    StatusCodes = Constants.HttpConstants.StatusCodes;
    StandardAbortMessage2 = "The operation was aborted.";
    ThrottlingRetryPolicy = class _ThrottlingRetryPolicy extends BaseRequestPolicy {
      constructor(nextPolicy, options, _handleResponse) {
        super(nextPolicy, options);
        this.numberOfRetries = 0;
        this._handleResponse = _handleResponse || this._defaultResponseHandler;
      }
      async sendRequest(httpRequest) {
        const response = await this._nextPolicy.sendRequest(httpRequest.clone());
        if (response.status !== StatusCodes.TooManyRequests && response.status !== StatusCodes.ServiceUnavailable) {
          return response;
        } else {
          return this._handleResponse(httpRequest, response);
        }
      }
      async _defaultResponseHandler(httpRequest, httpResponse) {
        var _a2;
        const retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER);
        if (retryAfterHeader) {
          const delayInMs = _ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);
          if (delayInMs) {
            this.numberOfRetries += 1;
            await delay(delayInMs, {
              abortSignal: httpRequest.abortSignal,
              abortErrorMsg: StandardAbortMessage2
            });
            if ((_a2 = httpRequest.abortSignal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
              throw new AbortError(StandardAbortMessage2);
            }
            if (this.numberOfRetries < DEFAULT_CLIENT_MAX_RETRY_COUNT) {
              return this.sendRequest(httpRequest);
            } else {
              return this._nextPolicy.sendRequest(httpRequest);
            }
          }
        }
        return httpResponse;
      }
      static parseRetryAfterHeader(headerValue) {
        const retryAfterInSeconds = Number(headerValue);
        if (Number.isNaN(retryAfterInSeconds)) {
          return _ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);
        } else {
          return retryAfterInSeconds * 1e3;
        }
      }
      static parseDateRetryAfterHeader(headerValue) {
        try {
          const now = Date.now();
          const date2 = Date.parse(headerValue);
          const diff = date2 - now;
          return Number.isNaN(diff) ? void 0 : diff;
        } catch (error) {
          return void 0;
        }
      }
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/browser/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/browser/globalThis.js"() {
    _globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
  }
});

// node_modules/@opentelemetry/api/build/esm/platform/browser/index.js
var init_browser = __esm({
  "node_modules/@opentelemetry/api/build/esm/platform/browser/index.js"() {
    init_globalThis();
  }
});

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION;
var init_version2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/version.js"() {
    VERSION = "1.4.1";
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var re, isCompatible;
var init_semver = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    init_version2();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a2;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a2 !== void 0 ? _a2 : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a2, _b;
  var globalVersion = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a2 === void 0 ? void 0 : _a2.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global;
var init_global_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    init_browser();
    init_version2();
    init_semver();
    major = VERSION.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args) {
  var logger5 = getGlobal("diag");
  if (!logger5) {
    return;
  }
  args.unshift(namespace);
  return logger5[funcName].apply(logger5, __spreadArray([], __read(args), false));
}
var __read, __spreadArray, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    init_global_utils();
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    DiagComponentLogger = /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger5) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger5 = logger5 || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger5[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger5);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    init_types();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME, DiagAPI;
var init_diag = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME = "diag";
    DiagAPI = /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger5 = getGlobal("diag");
            if (!logger5)
              return;
            return logger5[funcName].apply(logger5, __spreadArray2([], __read2(args), false));
          };
        }
        var self2 = this;
        var setLogger = function(logger5, optionsOrLogLevel) {
          var _a2, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger5 === self2) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a2 = err.stack) !== null && _a2 !== void 0 ? _a2 : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger5);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self2, true);
        };
        self2.setLogger = setLogger;
        self2.disable = function() {
          unregisterGlobal(API_NAME, self2);
        };
        self2.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3, __values, BaggageImpl;
var init_baggage_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    BaggageImpl = /** @class */
    function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a2) {
          var _b = __read3(_a2, 2), k = _b[0], v = _b[1];
          return [k, v];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var e_1, _a2;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a2 = keys_1.return))
              _a2.call(keys_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol;
var init_symbol = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/utils.js
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
var diag;
var init_utils2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    BaseContext = /** @class */
    function() {
      function BaseContext2(parentContext) {
        var self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = function(key) {
          return self2._currentContext.get(key);
        };
        self2.setValue = function(key, value) {
          var context3 = new BaseContext2(self2._currentContext);
          context3._currentContext.set(key, value);
          return context3;
        };
        self2.deleteValue = function(key) {
          var context3 = new BaseContext2(self2._currentContext);
          context3._currentContext.delete(key);
          return context3;
        };
      }
      return BaseContext2;
    }();
    ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
var consoleMap, DiagConsoleLogger;
var init_consoleLogger = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js"() {
    consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    DiagConsoleLogger = /** @class */
    function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      return DiagConsoleLogger2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
var __extends, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
var init_NoopMeter = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    __extends = function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    NoopMeter = /** @class */
    function() {
      function NoopMeter2() {
      }
      NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      };
      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      };
      return NoopMeter2;
    }();
    NoopMetric = /** @class */
    function() {
      function NoopMetric2() {
      }
      return NoopMetric2;
    }();
    NoopCounterMetric = /** @class */
    function(_super) {
      __extends(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopCounterMetric2;
    }(NoopMetric);
    NoopUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopUpDownCounterMetric2;
    }(NoopMetric);
    NoopHistogramMetric = /** @class */
    function(_super) {
      __extends(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopHistogramMetric2;
    }(NoopMetric);
    NoopObservableMetric = /** @class */
    function() {
      function NoopObservableMetric2() {
      }
      NoopObservableMetric2.prototype.addCallback = function(_callback) {
      };
      NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      };
      return NoopObservableMetric2;
    }();
    NoopObservableCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric2;
    }(NoopObservableMetric);
    NoopObservableGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric2;
    }(NoopObservableMetric);
    NoopObservableUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric2;
    }(NoopObservableMetric);
    NOOP_METER = new NoopMeter();
    NOOP_COUNTER_METRIC = new NoopCounterMetric();
    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType;
var init_Metric = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/Metric.js"() {
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter, defaultTextMapSetter;
var init_TextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys: function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    defaultTextMapSetter = {
      set: function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4, __spreadArray3, NoopContextManager;
var init_NoopContextManager = __esm({
  "node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    init_context();
    __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    NoopContextManager = /** @class */
    function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read5 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context3, fn, thisArg) {
        var _a2;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a2 = this._getContextManager()).with.apply(_a2, __spreadArray4([context3, fn, thisArg], __read5(args), false));
      };
      ContextAPI2.prototype.bind = function(context3, target) {
        return this._getContextManager().bind(context3, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context3) {
  return context3.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context3, span) {
  return context3.setValue(SPAN_KEY, span);
}
function deleteSpan(context3) {
  return context3.deleteValue(SPAN_KEY);
}
function setSpanContext(context3, spanContext) {
  return setSpan(context3, new NonRecordingSpan(spanContext));
}
function getSpanContext(context3) {
  var _a2;
  return (_a2 = getSpan(context3)) === null || _a2 === void 0 ? void 0 : _a2.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name, options, context3) {
        if (context3 === void 0) {
          context3 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context3 && getSpanContext(context3);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    function() {
      function ProxyTracer2(_provider, name, version2, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version2;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name, options, context3) {
        return this._getTracer().startSpan(name, options, context3);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name, version2, options) {
        var _a2;
        return (_a2 = this.getDelegateTracer(name, version2, options)) !== null && _a2 !== void 0 ? _a2 : new ProxyTracer(this, name, version2, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a2;
        return (_a2 = this._delegate) !== null && _a2 !== void 0 ? _a2 : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version2, options) {
        var _a2;
        return (_a2 = this._delegate) === null || _a2 === void 0 ? void 0 : _a2.getTracer(name, version2, options);
      };
      return ProxyTracerProvider2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
var init_SamplingResult = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
var init_span_kind = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    (function(SpanKind3) {
      SpanKind3[SpanKind3["INTERNAL"] = 0] = "INTERNAL";
      SpanKind3[SpanKind3["SERVER"] = 1] = "SERVER";
      SpanKind3[SpanKind3["CLIENT"] = 2] = "CLIENT";
      SpanKind3[SpanKind3["PRODUCER"] = 3] = "PRODUCER";
      SpanKind3[SpanKind3["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    (function(SpanStatusCode3) {
      SpanStatusCode3[SpanStatusCode3["UNSET"] = 0] = "UNSET";
      SpanStatusCode3[SpanStatusCode3["OK"] = 1] = "OK";
      SpanStatusCode3[SpanStatusCode3["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX;
var init_tracestate_validators = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js"() {
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceStateImpl;
var init_tracestate_impl = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js"() {
    init_tracestate_validators();
    MAX_TRACE_STATE_ITEMS = 32;
    MAX_TRACE_STATE_LEN = 512;
    LIST_MEMBERS_SEPARATOR = ",";
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    TraceStateImpl = /** @class */
    function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js
var init_utils3 = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js"() {
    init_tracestate_impl();
  }
});

// node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2;
var init_diag_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    init_diag();
    diag2 = DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider, NOOP_METER_PROVIDER;
var init_NoopMeterProvider = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    function() {
      function NoopMeterProvider2() {
      }
      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider2;
    }();
    NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3, MetricsAPI;
var init_metrics = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME3 = "metrics";
    MetricsAPI = /** @class */
    function() {
      function MetricsAPI2() {
      }
      MetricsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new MetricsAPI2();
        }
        return this._instance;
      };
      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal(API_NAME3, provider, DiagAPI.instance());
      };
      MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
      };
      MetricsAPI2.prototype.getMeter = function(name, version2, options) {
        return this.getMeterProvider().getMeter(name, version2, options);
      };
      MetricsAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
      };
      return MetricsAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics;
var init_metrics_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator;
var init_NoopTextMapPropagator = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    NoopTextMapPropagator = /** @class */
    function() {
      function NoopTextMapPropagator2() {
      }
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context3, _carrier) {
        return context3;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
function getBaggage(context3) {
  return context3.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context3, baggage) {
  return context3.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context3) {
  return context3.deleteValue(BAGGAGE_KEY);
}
var BAGGAGE_KEY;
var init_context_helpers = __esm({
  "node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
  }
});

// node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI;
var init_propagation = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils2();
    init_diag();
    API_NAME4 = "propagation";
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    PropagationAPI = /** @class */
    function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context3, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context3, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context3, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context3, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation;
var init_propagation_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5, TraceAPI;
var init_trace = __esm({
  "node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME5 = "trace";
    TraceAPI = /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME5) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version2) {
        return this.getTracerProvider().getTracer(name, version2);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME5, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }();
  }
});

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/esm/index.js
var init_esm = __esm({
  "node_modules/@opentelemetry/api/build/esm/index.js"() {
    init_utils2();
    init_context();
    init_consoleLogger();
    init_types();
    init_NoopMeter();
    init_Metric();
    init_TextMapPropagator();
    init_ProxyTracer();
    init_ProxyTracerProvider();
    init_SamplingResult();
    init_span_kind();
    init_status();
    init_trace_flags();
    init_utils3();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
  }
});

// node_modules/@azure/core-tracing/dist-esm/src/interfaces.js
function setSpan2(context3, span) {
  return trace.setSpan(context3, span);
}
function isSpanContextValid2(context3) {
  return trace.isSpanContextValid(context3);
}
function getTracer(name, version2) {
  return trace.getTracer(name || "azure/core-tracing", version2);
}
var SpanKind2, context2, SpanStatusCode2;
var init_interfaces = __esm({
  "node_modules/@azure/core-tracing/dist-esm/src/interfaces.js"() {
    init_esm();
    (function(SpanKind3) {
      SpanKind3[SpanKind3["INTERNAL"] = 0] = "INTERNAL";
      SpanKind3[SpanKind3["SERVER"] = 1] = "SERVER";
      SpanKind3[SpanKind3["CLIENT"] = 2] = "CLIENT";
      SpanKind3[SpanKind3["PRODUCER"] = 3] = "PRODUCER";
      SpanKind3[SpanKind3["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind2 || (SpanKind2 = {}));
    context2 = context;
    (function(SpanStatusCode3) {
      SpanStatusCode3[SpanStatusCode3["UNSET"] = 0] = "UNSET";
      SpanStatusCode3[SpanStatusCode3["OK"] = 1] = "OK";
      SpanStatusCode3[SpanStatusCode3["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode2 || (SpanStatusCode2 = {}));
  }
});

// node_modules/@azure/core-tracing/dist-esm/src/createSpan.js
function isTracingDisabled() {
  var _a2;
  if (typeof process === "undefined") {
    return false;
  }
  const azureTracingDisabledValue = (_a2 = process.env.AZURE_TRACING_DISABLED) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase();
  if (azureTracingDisabledValue === "false" || azureTracingDisabledValue === "0") {
    return false;
  }
  return Boolean(azureTracingDisabledValue);
}
function createSpanFunction(args) {
  return function(operationName, operationOptions) {
    const tracer = getTracer();
    const tracingOptions = (operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) || {};
    const spanOptions = Object.assign({ kind: SpanKind2.INTERNAL }, tracingOptions.spanOptions);
    const spanName = args.packagePrefix ? `${args.packagePrefix}.${operationName}` : operationName;
    let span;
    if (isTracingDisabled()) {
      span = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
    } else {
      span = tracer.startSpan(spanName, spanOptions, tracingOptions.tracingContext);
    }
    if (args.namespace) {
      span.setAttribute("az.namespace", args.namespace);
    }
    let newSpanOptions = tracingOptions.spanOptions || {};
    if (span.isRecording() && args.namespace) {
      newSpanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": args.namespace }) });
    }
    const newTracingOptions = Object.assign(Object.assign({}, tracingOptions), { spanOptions: newSpanOptions, tracingContext: setSpan2(tracingOptions.tracingContext || context2.active(), span) });
    const newOperationOptions = Object.assign(Object.assign({}, operationOptions), { tracingOptions: newTracingOptions });
    return {
      span,
      updatedOptions: newOperationOptions
    };
  };
}
var init_createSpan = __esm({
  "node_modules/@azure/core-tracing/dist-esm/src/createSpan.js"() {
    init_interfaces();
    init_esm();
  }
});

// node_modules/@azure/core-tracing/dist-esm/src/utils/traceParentHeader.js
function getTraceParentHeader(spanContext) {
  const missingFields = [];
  if (!spanContext.traceId) {
    missingFields.push("traceId");
  }
  if (!spanContext.spanId) {
    missingFields.push("spanId");
  }
  if (missingFields.length) {
    return;
  }
  const flags = spanContext.traceFlags || 0;
  const hexFlags = flags.toString(16);
  const traceFlags = hexFlags.length === 1 ? `0${hexFlags}` : hexFlags;
  return `${VERSION2}-${spanContext.traceId}-${spanContext.spanId}-${traceFlags}`;
}
var VERSION2;
var init_traceParentHeader = __esm({
  "node_modules/@azure/core-tracing/dist-esm/src/utils/traceParentHeader.js"() {
    VERSION2 = "00";
  }
});

// node_modules/@azure/core-tracing/dist-esm/src/index.js
var init_src5 = __esm({
  "node_modules/@azure/core-tracing/dist-esm/src/index.js"() {
    init_createSpan();
    init_interfaces();
    init_traceParentHeader();
  }
});

// node_modules/@azure/core-http/dist-esm/src/policies/tracingPolicy.js
function tracingPolicy(tracingOptions = {}) {
  return {
    create(nextPolicy, options) {
      return new TracingPolicy(nextPolicy, options, tracingOptions);
    }
  };
}
var createSpan, TracingPolicy;
var init_tracingPolicy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/policies/tracingPolicy.js"() {
    init_requestPolicy();
    init_src5();
    init_log();
    createSpan = createSpanFunction({
      packagePrefix: "",
      namespace: ""
    });
    TracingPolicy = class extends BaseRequestPolicy {
      constructor(nextPolicy, options, tracingOptions) {
        super(nextPolicy, options);
        this.userAgent = tracingOptions.userAgent;
      }
      async sendRequest(request) {
        if (!request.tracingContext) {
          return this._nextPolicy.sendRequest(request);
        }
        const span = this.tryCreateSpan(request);
        if (!span) {
          return this._nextPolicy.sendRequest(request);
        }
        try {
          const response = await this._nextPolicy.sendRequest(request);
          this.tryProcessResponse(span, response);
          return response;
        } catch (err) {
          this.tryProcessError(span, err);
          throw err;
        }
      }
      tryCreateSpan(request) {
        var _a2;
        try {
          const { span } = createSpan(`HTTP ${request.method}`, {
            tracingOptions: {
              spanOptions: Object.assign(Object.assign({}, request.spanOptions), { kind: SpanKind2.CLIENT }),
              tracingContext: request.tracingContext
            }
          });
          if (!span.isRecording()) {
            span.end();
            return void 0;
          }
          const namespaceFromContext = (_a2 = request.tracingContext) === null || _a2 === void 0 ? void 0 : _a2.getValue(Symbol.for("az.namespace"));
          if (typeof namespaceFromContext === "string") {
            span.setAttribute("az.namespace", namespaceFromContext);
          }
          span.setAttributes({
            "http.method": request.method,
            "http.url": request.url,
            requestId: request.requestId
          });
          if (this.userAgent) {
            span.setAttribute("http.user_agent", this.userAgent);
          }
          const spanContext = span.spanContext();
          const traceParentHeader = getTraceParentHeader(spanContext);
          if (traceParentHeader && isSpanContextValid2(spanContext)) {
            request.headers.set("traceparent", traceParentHeader);
            const traceState = spanContext.traceState && spanContext.traceState.serialize();
            if (traceState) {
              request.headers.set("tracestate", traceState);
            }
          }
          return span;
        } catch (error) {
          logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);
          return void 0;
        }
      }
      tryProcessError(span, err) {
        try {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: err.message
          });
          if (err.statusCode) {
            span.setAttribute("http.status_code", err.statusCode);
          }
          span.end();
        } catch (error) {
          logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);
        }
      }
      tryProcessResponse(span, response) {
        try {
          span.setAttribute("http.status_code", response.status);
          const serviceRequestId = response.headers.get("x-ms-request-id");
          if (serviceRequestId) {
            span.setAttribute("serviceRequestId", serviceRequestId);
          }
          span.setStatus({
            code: SpanStatusCode2.OK
          });
          span.end();
        } catch (error) {
          logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);
        }
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/serviceClient.js
function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {
  var _a2, _b, _c, _d, _e, _f;
  const serializerOptions = (_b = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.serializerOptions) !== null && _b !== void 0 ? _b : {};
  const updatedOptions = {
    rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : "",
    includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,
    xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY
  };
  const xmlCharKey = serializerOptions.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);
    const bodyMapper = operationSpec.requestBody.mapper;
    const { required, xmlName, xmlElementName, serializedName, xmlNamespace, xmlNamespacePrefix } = bodyMapper;
    const typeName = bodyMapper.type.name;
    try {
      if (httpRequest.body !== void 0 && httpRequest.body !== null || required) {
        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);
        const isStream = typeName === MapperType.Stream;
        if (operationSpec.isXML) {
          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);
          if (typeName === MapperType.Sequence) {
            httpRequest.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          } else if (!isStream) {
            httpRequest.body = stringifyXML(value, {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          }
        } else if (typeName === MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match("text/plain")) || operationSpec.mediaType === "text")) {
          return;
        } else if (!isStream) {
          httpRequest.body = JSON.stringify(httpRequest.body);
        }
      }
    } catch (error) {
      throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    httpRequest.formData = {};
    for (const formDataParameter of operationSpec.formDataParameters) {
      const formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);
      if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
      }
    }
  }
}
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    const result = {};
    result[options.xmlCharKey] = serializedValue;
    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
    return result;
  }
  return serializedValue;
}
function getValueOrFunctionResult(value, defaultValueCreator) {
  let result;
  if (typeof value === "string") {
    result = value;
  } else {
    result = defaultValueCreator();
    if (typeof value === "function") {
      result = value(result);
    }
  }
  return result;
}
function createDefaultRequestPolicyFactories(authPolicyFactory, options) {
  const factories = [];
  if (options.generateClientRequestIdHeader) {
    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));
  }
  if (authPolicyFactory) {
    factories.push(authPolicyFactory);
  }
  const userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);
  const userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);
  if (userAgentHeaderName && userAgentHeaderValue) {
    factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));
  }
  factories.push(redirectPolicy());
  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));
  if (!options.noRetryPolicy) {
    factories.push(exponentialRetryPolicy());
    factories.push(systemErrorRetryPolicy());
    factories.push(throttlingRetryPolicy());
  }
  factories.push(deserializationPolicy(options.deserializationContentTypes));
  if (isNode) {
    factories.push(proxyPolicy(options.proxySettings));
  }
  factories.push(logPolicy({ logger: logger.info }));
  return factories;
}
function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {
  const requestPolicyFactories = [];
  if (pipelineOptions.sendStreamingJson) {
    requestPolicyFactories.push(ndJsonPolicy());
  }
  let userAgentValue = void 0;
  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {
    const userAgentInfo = [];
    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);
    const defaultUserAgentInfo = getDefaultUserAgentValue();
    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {
      userAgentInfo.push(defaultUserAgentInfo);
    }
    userAgentValue = userAgentInfo.join(" ");
  }
  const keepAliveOptions = Object.assign(Object.assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);
  const retryOptions = Object.assign(Object.assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);
  const redirectOptions = Object.assign(Object.assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);
  if (isNode) {
    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));
  }
  const deserializationOptions = Object.assign(Object.assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);
  const loggingOptions = Object.assign({}, pipelineOptions.loggingOptions);
  requestPolicyFactories.push(tracingPolicy({ userAgent: userAgentValue }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({ value: userAgentValue }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));
  if (redirectOptions.handleRedirects) {
    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));
  }
  if (authPolicyFactory) {
    requestPolicyFactories.push(authPolicyFactory);
  }
  requestPolicyFactories.push(logPolicy(loggingOptions));
  if (isNode && pipelineOptions.decompressResponse === false) {
    requestPolicyFactories.push(disableResponseDecompressionPolicy());
  }
  return {
    httpClient: pipelineOptions.httpClient,
    requestPolicyFactories
  };
}
function getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer3) {
  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer3);
}
function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer3) {
  var _a2;
  let value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  const serializerOptions = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.serializerOptions;
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
        if (!propertySearchResult.propertyFound) {
          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);
        }
        let useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }
        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
      const parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);
      serializer3.serialize(parameterMapper, value, parameterPathString, serializerOptions);
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (const propertyName in parameterPath) {
      const propertyMapper = parameterMapper.type.modelProperties[propertyName];
      const propertyPath = parameterPath[propertyName];
      const propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer3);
      const propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);
      serializer3.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);
      if (propertyValue !== void 0 && propertyValue !== null) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
  const result = { propertyFound: false };
  let i = 0;
  for (; i < parameterPath.length; ++i) {
    const parameterPathPart = parameterPath[i];
    if (parent !== void 0 && parent !== null && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
function flattenResponse(_response, responseSpec) {
  const parsedHeaders = _response.parsedHeaders;
  const bodyMapper = responseSpec && responseSpec.bodyMapper;
  const addOperationResponse = (obj) => {
    return Object.defineProperty(obj, "_response", {
      value: _response
    });
  };
  if (bodyMapper) {
    const typeName = bodyMapper.type.name;
    if (typeName === "Stream") {
      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), { blobBody: _response.blobBody, readableStreamBody: _response.readableStreamBody }));
    }
    const modelProperties = typeName === "Composite" && bodyMapper.type.modelProperties || {};
    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
    if (typeName === "Sequence" || isPageableResponse) {
      const arrayResponse = [..._response.parsedBody || []];
      for (const key of Object.keys(modelProperties)) {
        if (modelProperties[key].serializedName) {
          arrayResponse[key] = _response.parsedBody[key];
        }
      }
      if (parsedHeaders) {
        for (const key of Object.keys(parsedHeaders)) {
          arrayResponse[key] = parsedHeaders[key];
        }
      }
      addOperationResponse(arrayResponse);
      return arrayResponse;
    }
    if (typeName === "Composite" || typeName === "Dictionary") {
      return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));
    }
  }
  if (bodyMapper || _response.request.method === "HEAD" || isPrimitiveType(_response.parsedBody)) {
    return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), { body: _response.parsedBody }));
  }
  return addOperationResponse(Object.assign(Object.assign({}, parsedHeaders), _response.parsedBody));
}
function getCredentialScopes(options, baseUri) {
  if (options === null || options === void 0 ? void 0 : options.credentialScopes) {
    const scopes = options.credentialScopes;
    return Array.isArray(scopes) ? scopes.map((scope) => new URL(scope).toString()) : new URL(scopes).toString();
  }
  if (baseUri) {
    return `${baseUri}/.default`;
  }
  return void 0;
}
var ServiceClient;
var init_serviceClient = __esm({
  "node_modules/@azure/core-http/dist-esm/src/serviceClient.js"() {
    init_utils();
    init_serializer();
    init_deserializationPolicy();
    init_keepAlivePolicy();
    init_redirectPolicy();
    init_exponentialRetryPolicy();
    init_logPolicy();
    init_operationParameter();
    init_operationSpec();
    init_webResource();
    init_requestPolicy();
    init_serializer_common();
    init_utils();
    init_src4();
    init_userAgentPolicy();
    init_queryCollectionFormat();
    init_url();
    init_bearerTokenAuthenticationPolicy();
    init_disableResponseDecompressionPolicy_browser();
    init_generateClientRequestIdPolicy();
    init_httpClientCache();
    init_log();
    init_ndJsonPolicy();
    init_proxyPolicy_browser();
    init_rpRegistrationPolicy();
    init_signingPolicy();
    init_xml_browser();
    init_systemErrorRetryPolicy();
    init_throttlingRetryPolicy();
    init_tracingPolicy();
    ServiceClient = class {
      /**
       * The ServiceClient constructor
       * @param credentials - The credentials used for authentication with the service.
       * @param options - The service client options that govern the behavior of the client.
       */
      constructor(credentials, options) {
        if (!options) {
          options = {};
        }
        this._withCredentials = options.withCredentials || false;
        this._httpClient = options.httpClient || getCachedDefaultHttpClient();
        this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);
        let requestPolicyFactories;
        if (Array.isArray(options.requestPolicyFactories)) {
          logger.info("ServiceClient: using custom request policies");
          requestPolicyFactories = options.requestPolicyFactories;
        } else {
          let authPolicyFactory = void 0;
          if (isTokenCredential(credentials)) {
            logger.info("ServiceClient: creating bearer token authentication policy from provided credentials");
            const wrappedPolicyFactory = () => {
              let bearerTokenPolicyFactory = void 0;
              const serviceClient = this;
              const serviceClientOptions = options;
              return {
                create(nextPolicy, createOptions) {
                  const credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);
                  if (!credentialScopes) {
                    throw new Error(`When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`);
                  }
                  if (bearerTokenPolicyFactory === void 0 || bearerTokenPolicyFactory === null) {
                    bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes);
                  }
                  return bearerTokenPolicyFactory.create(nextPolicy, createOptions);
                }
              };
            };
            authPolicyFactory = wrappedPolicyFactory();
          } else if (credentials && typeof credentials.signRequest === "function") {
            logger.info("ServiceClient: creating signing policy from provided credentials");
            authPolicyFactory = signingPolicy(credentials);
          } else if (credentials !== void 0 && credentials !== null) {
            throw new Error("The credentials argument must implement the TokenCredential interface");
          }
          logger.info("ServiceClient: using default request policies");
          requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);
          if (options.requestPolicyFactories) {
            const newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);
            if (newRequestPolicyFactories) {
              requestPolicyFactories = newRequestPolicyFactories;
            }
          }
        }
        this._requestPolicyFactories = requestPolicyFactories;
      }
      /**
       * Send the provided httpRequest.
       */
      sendRequest(options) {
        if (options === null || options === void 0 || typeof options !== "object") {
          throw new Error("options cannot be null or undefined and it must be of type object.");
        }
        let httpRequest;
        try {
          if (isWebResourceLike(options)) {
            options.validateRequestProperties();
            httpRequest = options;
          } else {
            httpRequest = new WebResource();
            httpRequest = httpRequest.prepare(options);
          }
        } catch (error) {
          return Promise.reject(error);
        }
        let httpPipeline = this._httpClient;
        if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {
          for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {
            httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);
          }
        }
        return httpPipeline.sendRequest(httpRequest);
      }
      /**
       * Send an HTTP request that is populated using the provided OperationSpec.
       * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
       * @param operationSpec - The OperationSpec to use to populate the httpRequest.
       * @param callback - The callback to call when the response is received.
       */
      async sendOperationRequest(operationArguments, operationSpec, callback) {
        var _a2;
        if (typeof operationArguments.options === "function") {
          callback = operationArguments.options;
          operationArguments.options = void 0;
        }
        const serializerOptions = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.serializerOptions;
        const httpRequest = new WebResource();
        let result;
        try {
          const baseUri = operationSpec.baseUrl || this.baseUri;
          if (!baseUri) {
            throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.");
          }
          httpRequest.method = operationSpec.httpMethod;
          httpRequest.operationSpec = operationSpec;
          const requestUrl = URLBuilder.parse(baseUri);
          if (operationSpec.path) {
            requestUrl.appendPath(operationSpec.path);
          }
          if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {
            for (const urlParameter of operationSpec.urlParameters) {
              let urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);
              urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);
              if (!urlParameter.skipEncoding) {
                urlParameterValue = encodeURIComponent(urlParameterValue);
              }
              requestUrl.replaceAll(`{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`, urlParameterValue);
            }
          }
          if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {
            for (const queryParameter of operationSpec.queryParameters) {
              let queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);
              if (queryParameterValue !== void 0 && queryParameterValue !== null) {
                queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);
                if (queryParameter.collectionFormat !== void 0 && queryParameter.collectionFormat !== null) {
                  if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {
                    if (queryParameterValue.length === 0) {
                      continue;
                    } else {
                      for (const index2 in queryParameterValue) {
                        const item = queryParameterValue[index2];
                        queryParameterValue[index2] = item === void 0 || item === null ? "" : item.toString();
                      }
                    }
                  } else if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {
                    queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                  }
                }
                if (!queryParameter.skipEncoding) {
                  if (Array.isArray(queryParameterValue)) {
                    for (const index2 in queryParameterValue) {
                      if (queryParameterValue[index2] !== void 0 && queryParameterValue[index2] !== null) {
                        queryParameterValue[index2] = encodeURIComponent(queryParameterValue[index2]);
                      }
                    }
                  } else {
                    queryParameterValue = encodeURIComponent(queryParameterValue);
                  }
                }
                if (queryParameter.collectionFormat !== void 0 && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {
                  queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                }
                requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
              }
            }
          }
          httpRequest.url = requestUrl.toString();
          const contentType2 = operationSpec.contentType || this.requestContentType;
          if (contentType2 && operationSpec.requestBody) {
            httpRequest.headers.set("Content-Type", contentType2);
          }
          if (operationSpec.headerParameters) {
            for (const headerParameter of operationSpec.headerParameters) {
              let headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);
              if (headerValue !== void 0 && headerValue !== null) {
                headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);
                const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
                if (headerCollectionPrefix) {
                  for (const key of Object.keys(headerValue)) {
                    httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);
                  }
                } else {
                  httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
                }
              }
            }
          }
          const options = operationArguments.options;
          if (options) {
            if (options.customHeaders) {
              for (const customHeaderName in options.customHeaders) {
                httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);
              }
            }
            if (options.abortSignal) {
              httpRequest.abortSignal = options.abortSignal;
            }
            if (options.timeout) {
              httpRequest.timeout = options.timeout;
            }
            if (options.onUploadProgress) {
              httpRequest.onUploadProgress = options.onUploadProgress;
            }
            if (options.onDownloadProgress) {
              httpRequest.onDownloadProgress = options.onDownloadProgress;
            }
            if (options.spanOptions) {
              httpRequest.spanOptions = options.spanOptions;
            }
            if (options.tracingContext) {
              httpRequest.tracingContext = options.tracingContext;
            }
            if (options.shouldDeserialize !== void 0 && options.shouldDeserialize !== null) {
              httpRequest.shouldDeserialize = options.shouldDeserialize;
            }
          }
          httpRequest.withCredentials = this._withCredentials;
          serializeRequestBody(this, httpRequest, operationArguments, operationSpec);
          if (httpRequest.streamResponseStatusCodes === void 0) {
            httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);
          }
          let rawResponse;
          let sendRequestError;
          try {
            rawResponse = await this.sendRequest(httpRequest);
          } catch (error) {
            sendRequestError = error;
          }
          if (sendRequestError) {
            if (sendRequestError.response) {
              sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses["default"]);
            }
            result = Promise.reject(sendRequestError);
          } else {
            result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));
          }
        } catch (error) {
          result = Promise.reject(error);
        }
        const cb = callback;
        if (cb) {
          result.then((res) => cb(null, res._response.parsedBody, res._response.request, res._response)).catch((err) => cb(err));
        }
        return result;
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/createSpanLegacy.js
function createSpanFunction2(args) {
  return createSpanFunction(args);
}
var init_createSpanLegacy = __esm({
  "node_modules/@azure/core-http/dist-esm/src/createSpanLegacy.js"() {
    init_src5();
  }
});

// node_modules/@azure/core-http/dist-esm/src/credentials/accessTokenCache.js
var TokenRefreshBufferMs, ExpiringAccessTokenCache;
var init_accessTokenCache = __esm({
  "node_modules/@azure/core-http/dist-esm/src/credentials/accessTokenCache.js"() {
    TokenRefreshBufferMs = 2 * 60 * 1e3;
    ExpiringAccessTokenCache = class {
      /**
       * Constructs an instance of {@link ExpiringAccessTokenCache} with
       * an optional expiration buffer time.
       */
      constructor(tokenRefreshBufferMs = TokenRefreshBufferMs) {
        this.cachedToken = void 0;
        this.tokenRefreshBufferMs = tokenRefreshBufferMs;
      }
      /**
       * Saves an access token into the internal in-memory cache.
       * @param accessToken - Access token or undefined to clear the cache.
       */
      setCachedToken(accessToken) {
        this.cachedToken = accessToken;
      }
      /**
       * Returns the cached access token, or `undefined` if one is not cached or the cached one is expiring soon.
       */
      getCachedToken() {
        if (this.cachedToken && Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp) {
          this.cachedToken = void 0;
        }
        return this.cachedToken;
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/credentials/accessTokenRefresher.js
var AccessTokenRefresher;
var init_accessTokenRefresher = __esm({
  "node_modules/@azure/core-http/dist-esm/src/credentials/accessTokenRefresher.js"() {
    AccessTokenRefresher = class {
      constructor(credential, scopes, requiredMillisecondsBeforeNewRefresh = 3e4) {
        this.credential = credential;
        this.scopes = scopes;
        this.requiredMillisecondsBeforeNewRefresh = requiredMillisecondsBeforeNewRefresh;
        this.lastCalled = 0;
      }
      /**
       * Returns true if the required milliseconds(defaulted to 30000) have been passed signifying
       * that we are ready for a new refresh.
       */
      isReady() {
        return !this.lastCalled || Date.now() - this.lastCalled > this.requiredMillisecondsBeforeNewRefresh;
      }
      /**
       * Stores the time in which it is called,
       * then requests a new token,
       * then sets this.promise to undefined,
       * then returns the token.
       */
      async getToken(options) {
        this.lastCalled = Date.now();
        const token = await this.credential.getToken(this.scopes, options);
        this.promise = void 0;
        return token || void 0;
      }
      /**
       * Requests a new token if we're not currently waiting for a new token.
       * Returns null if the required time between each call hasn't been reached.
       */
      refresh(options) {
        if (!this.promise) {
          this.promise = this.getToken(options);
        }
        return this.promise;
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/credentials/basicAuthenticationCredentials.js
var HeaderConstants, DEFAULT_AUTHORIZATION_SCHEME, BasicAuthenticationCredentials;
var init_basicAuthenticationCredentials = __esm({
  "node_modules/@azure/core-http/dist-esm/src/credentials/basicAuthenticationCredentials.js"() {
    init_base64_browser();
    init_constants();
    init_httpHeaders();
    HeaderConstants = Constants.HeaderConstants;
    DEFAULT_AUTHORIZATION_SCHEME = "Basic";
    BasicAuthenticationCredentials = class {
      /**
       * Creates a new BasicAuthenticationCredentials object.
       *
       * @param userName - User name.
       * @param password - Password.
       * @param authorizationScheme - The authorization scheme.
       */
      constructor(userName, password, authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME) {
        this.authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;
        if (userName === null || userName === void 0 || typeof userName.valueOf() !== "string") {
          throw new Error("userName cannot be null or undefined and must be of type string.");
        }
        if (password === null || password === void 0 || typeof password.valueOf() !== "string") {
          throw new Error("password cannot be null or undefined and must be of type string.");
        }
        this.userName = userName;
        this.password = password;
        this.authorizationScheme = authorizationScheme;
      }
      /**
       * Signs a request with the Authentication header.
       *
       * @param webResource - The WebResourceLike to be signed.
       * @returns The signed request object.
       */
      signRequest(webResource) {
        const credentials = `${this.userName}:${this.password}`;
        const encodedCredentials = `${this.authorizationScheme} ${encodeString(credentials)}`;
        if (!webResource.headers)
          webResource.headers = new HttpHeaders();
        webResource.headers.set(HeaderConstants.AUTHORIZATION, encodedCredentials);
        return Promise.resolve(webResource);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/credentials/apiKeyCredentials.js
var ApiKeyCredentials;
var init_apiKeyCredentials = __esm({
  "node_modules/@azure/core-http/dist-esm/src/credentials/apiKeyCredentials.js"() {
    init_httpHeaders();
    ApiKeyCredentials = class {
      /**
       * @param options - Specifies the options to be provided for auth. Either header or query needs to be provided.
       */
      constructor(options) {
        if (!options || options && !options.inHeader && !options.inQuery) {
          throw new Error(`options cannot be null or undefined. Either "inHeader" or "inQuery" property of the options object needs to be provided.`);
        }
        this.inHeader = options.inHeader;
        this.inQuery = options.inQuery;
      }
      /**
       * Signs a request with the values provided in the inHeader and inQuery parameter.
       *
       * @param webResource - The WebResourceLike to be signed.
       * @returns The signed request object.
       */
      signRequest(webResource) {
        if (!webResource) {
          return Promise.reject(new Error(`webResource cannot be null or undefined and must be of type "object".`));
        }
        if (this.inHeader) {
          if (!webResource.headers) {
            webResource.headers = new HttpHeaders();
          }
          for (const headerName in this.inHeader) {
            webResource.headers.set(headerName, this.inHeader[headerName]);
          }
        }
        if (this.inQuery) {
          if (!webResource.url) {
            return Promise.reject(new Error(`url cannot be null in the request object.`));
          }
          if (webResource.url.indexOf("?") < 0) {
            webResource.url += "?";
          }
          for (const key in this.inQuery) {
            if (!webResource.url.endsWith("?")) {
              webResource.url += "&";
            }
            webResource.url += `${key}=${this.inQuery[key]}`;
          }
        }
        return Promise.resolve(webResource);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/credentials/topicCredentials.js
var TopicCredentials;
var init_topicCredentials = __esm({
  "node_modules/@azure/core-http/dist-esm/src/credentials/topicCredentials.js"() {
    init_apiKeyCredentials();
    TopicCredentials = class extends ApiKeyCredentials {
      /**
       * Creates a new EventGrid TopicCredentials object.
       *
       * @param topicKey - The EventGrid topic key
       */
      constructor(topicKey) {
        if (!topicKey || topicKey && typeof topicKey !== "string") {
          throw new Error("topicKey cannot be null or undefined and must be of type string.");
        }
        const options = {
          inHeader: {
            "aeg-sas-key": topicKey
          }
        };
        super(options);
      }
    };
  }
});

// node_modules/@azure/core-http/dist-esm/src/index.js
var src_exports = {};
__export(src_exports, {
  AccessTokenRefresher: () => AccessTokenRefresher,
  ApiKeyCredentials: () => ApiKeyCredentials,
  BaseRequestPolicy: () => BaseRequestPolicy,
  BasicAuthenticationCredentials: () => BasicAuthenticationCredentials,
  Constants: () => Constants,
  DefaultHttpClient: () => XhrHttpClient,
  ExpiringAccessTokenCache: () => ExpiringAccessTokenCache,
  HttpHeaders: () => HttpHeaders,
  HttpPipelineLogLevel: () => HttpPipelineLogLevel,
  MapperType: () => MapperType,
  QueryCollectionFormat: () => QueryCollectionFormat,
  RequestPolicyOptions: () => RequestPolicyOptions,
  RestError: () => RestError,
  RetryMode: () => RetryMode,
  Serializer: () => Serializer,
  ServiceClient: () => ServiceClient,
  TopicCredentials: () => TopicCredentials,
  URLBuilder: () => URLBuilder,
  URLQuery: () => URLQuery,
  WebResource: () => WebResource,
  XML_ATTRKEY: () => XML_ATTRKEY,
  XML_CHARKEY: () => XML_CHARKEY,
  applyMixins: () => applyMixins,
  bearerTokenAuthenticationPolicy: () => bearerTokenAuthenticationPolicy,
  createPipelineFromOptions: () => createPipelineFromOptions,
  createSpanFunction: () => createSpanFunction2,
  delay: () => delay,
  deserializationPolicy: () => deserializationPolicy,
  deserializeResponseBody: () => deserializeResponseBody,
  disableResponseDecompressionPolicy: () => disableResponseDecompressionPolicy,
  encodeUri: () => encodeUri,
  executePromisesSequentially: () => executePromisesSequentially,
  exponentialRetryPolicy: () => exponentialRetryPolicy,
  flattenResponse: () => flattenResponse,
  generateClientRequestIdPolicy: () => generateClientRequestIdPolicy,
  generateUuid: () => generateUuid,
  getDefaultProxySettings: () => getDefaultProxySettings,
  getDefaultUserAgentValue: () => getDefaultUserAgentValue,
  isDuration: () => isDuration,
  isNode: () => isNode,
  isTokenCredential: () => isTokenCredential,
  isValidUuid: () => isValidUuid,
  keepAlivePolicy: () => keepAlivePolicy,
  logPolicy: () => logPolicy,
  operationOptionsToRequestOptionsBase: () => operationOptionsToRequestOptionsBase,
  parseXML: () => parseXML,
  promiseToCallback: () => promiseToCallback,
  promiseToServiceCallback: () => promiseToServiceCallback,
  proxyPolicy: () => proxyPolicy,
  redirectPolicy: () => redirectPolicy,
  serializeObject: () => serializeObject,
  signingPolicy: () => signingPolicy,
  stringifyXML: () => stringifyXML,
  stripRequest: () => stripRequest,
  stripResponse: () => stripResponse,
  systemErrorRetryPolicy: () => systemErrorRetryPolicy,
  throttlingRetryPolicy: () => throttlingRetryPolicy,
  tracingPolicy: () => tracingPolicy,
  userAgentPolicy: () => userAgentPolicy
});
var init_src6 = __esm({
  "node_modules/@azure/core-http/dist-esm/src/index.js"() {
    init_webResource();
    init_defaultHttpClient_browser();
    init_httpHeaders();
    init_httpPipelineLogLevel();
    init_restError();
    init_operationOptions();
    init_serviceClient();
    init_queryCollectionFormat();
    init_constants();
    init_bearerTokenAuthenticationPolicy();
    init_logPolicy();
    init_requestPolicy();
    init_generateClientRequestIdPolicy();
    init_exponentialRetryPolicy();
    init_systemErrorRetryPolicy();
    init_throttlingRetryPolicy();
    init_proxyPolicy_browser();
    init_redirectPolicy();
    init_keepAlivePolicy();
    init_disableResponseDecompressionPolicy_browser();
    init_signingPolicy();
    init_userAgentPolicy();
    init_deserializationPolicy();
    init_tracingPolicy();
    init_serializer();
    init_utils();
    init_url();
    init_src2();
    init_createSpanLegacy();
    init_src4();
    init_accessTokenCache();
    init_accessTokenRefresher();
    init_basicAuthenticationCredentials();
    init_apiKeyCredentials();
    init_topicCredentials();
    init_xml_browser();
    init_serializer_common();
  }
});

// node_modules/@azure/communication-common/dist-esm/src/credential/encodeUtils.browser.js
function encodeUTF8fromBase64(str2) {
  if (typeof atob !== "function") {
    throw new Error("Your browser environment is missing the global `atob` function");
  }
  const binary = atob(str2);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
function encodeBase64(value) {
  if (typeof btoa !== "function") {
    throw new Error("Your browser environment is missing the global `btoa` function");
  }
  const bytes = new Uint8Array(value);
  let binary = "";
  for (const byte of bytes) {
    binary += String.fromCharCode(byte);
  }
  return btoa(binary);
}
var encodeUTF8;
var init_encodeUtils_browser = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/credential/encodeUtils.browser.js"() {
    encodeUTF8 = (str2) => new TextEncoder().encode(str2);
  }
});

// node_modules/@azure/communication-common/dist-esm/src/credential/cryptoUtils.browser.js
var globalRef, getCrypto, shaHash, shaHMAC;
var init_cryptoUtils_browser = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/credential/cryptoUtils.browser.js"() {
    init_encodeUtils_browser();
    globalRef = globalThis;
    getCrypto = () => {
      if (!globalRef) {
        throw new Error("Could not find global");
      }
      if (!globalRef.crypto || !globalRef.crypto.subtle) {
        throw new Error("Browser does not support cryptography functions");
      }
      return globalRef.crypto.subtle;
    };
    shaHash = async (content) => {
      const data = encodeUTF8(content);
      const hash = await getCrypto().digest("SHA-256", data);
      return encodeBase64(hash);
    };
    shaHMAC = async (secret, content) => {
      const importParams = { name: "HMAC", hash: { name: "SHA-256" } };
      const encodedMessage = encodeUTF8(content);
      const encodedKey = encodeUTF8fromBase64(secret);
      const crypto2 = getCrypto();
      const cryptoKey = await crypto2.importKey("raw", encodedKey, importParams, false, ["sign"]);
      const signature = await crypto2.sign(importParams, cryptoKey, encodedMessage);
      return encodeBase64(signature);
    };
  }
});

// node_modules/@azure/communication-common/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js
var createCommunicationAccessKeyCredentialPolicy, CommunicationAccessKeyCredentialPolicy;
var init_communicationAccessKeyCredentialPolicy = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js"() {
    init_src6();
    init_cryptoUtils_browser();
    createCommunicationAccessKeyCredentialPolicy = (credential) => {
      return {
        create: (nextpolicy, options) => {
          return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);
        }
      };
    };
    CommunicationAccessKeyCredentialPolicy = class extends BaseRequestPolicy {
      /**
       * Initializes a new instance of the CommunicationAccessKeyCredential class
       * using a base64 encoded key.
       * @param accessKey - The base64 encoded key to be used for signing.
       */
      constructor(accessKey, nextPolicy, options) {
        super(nextPolicy, options);
        this.accessKey = accessKey;
      }
      /**
       * Signs a request with the provided access key.
       *
       * @param webResource - The WebResource to be signed.
       */
      async signRequest(webResource) {
        const verb = webResource.method.toUpperCase();
        const utcNow = (/* @__PURE__ */ new Date()).toUTCString();
        const contentHash = await shaHash(webResource.body || "");
        const dateHeader = "x-ms-date";
        const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
        const url = URLBuilder.parse(webResource.url);
        const query = url.getQuery();
        const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();
        const port = url.getPort();
        const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();
        const stringToSign = `${verb}
${urlPathAndQuery}
${utcNow};${hostAndPort};${contentHash}`;
        const signature = await shaHMAC(this.accessKey.key, stringToSign);
        if (isNode) {
          webResource.headers.set("Host", hostAndPort || "");
        }
        webResource.headers.set(dateHeader, utcNow);
        webResource.headers.set("x-ms-content-sha256", contentHash);
        webResource.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
        return webResource;
      }
      /**
       * Signs the request and calls the next policy in the factory.
       */
      async sendRequest(webResource) {
        if (!webResource) {
          throw new Error("webResource cannot be null or undefined");
        }
        return this._nextPolicy.sendRequest(await this.signRequest(webResource));
      }
    };
  }
});

// node_modules/@azure/communication-common/dist-esm/src/credential/communicationAuthPolicy.js
var createCommunicationAuthPolicy;
var init_communicationAuthPolicy = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/credential/communicationAuthPolicy.js"() {
    init_src4();
    init_src6();
    init_communicationAccessKeyCredentialPolicy();
    createCommunicationAuthPolicy = (credential) => {
      if (isTokenCredential(credential)) {
        return bearerTokenAuthenticationPolicy(credential, "https://communication.azure.com//.default");
      } else {
        return createCommunicationAccessKeyCredentialPolicy(credential);
      }
    };
  }
});

// node_modules/@azure/communication-common/dist-esm/src/credential/connectionString.js
var CONNECTION_STRING_REGEX, tryParseConnectionString, parseConnectionString;
var init_connectionString = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/credential/connectionString.js"() {
    init_src4();
    CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;
    tryParseConnectionString = (s) => {
      const match = s.match(CONNECTION_STRING_REGEX);
      if ((match === null || match === void 0 ? void 0 : match[1]) && match[2]) {
        return { endpoint: match[1], credential: new AzureKeyCredential(match[2]) };
      }
      return void 0;
    };
    parseConnectionString = (connectionString) => {
      const parsedConnectionString = tryParseConnectionString(connectionString);
      if (parsedConnectionString) {
        return parsedConnectionString;
      } else {
        throw new Error(`Invalid connection string ${connectionString}`);
      }
    };
  }
});

// node_modules/@azure/communication-common/dist-esm/src/credential/clientArguments.js
var isValidEndpoint, assertValidEndpoint, isKeyCredential, parseClientArguments;
var init_clientArguments = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/credential/clientArguments.js"() {
    init_src4();
    init_src6();
    init_connectionString();
    isValidEndpoint = (host) => {
      var _a2;
      const url = URLBuilder.parse(host);
      return !!((_a2 = url.getScheme()) === null || _a2 === void 0 ? void 0 : _a2.match(/^http[s]?/)) && url.getHost() !== void 0 && url.getHost() !== "" && (url.getPath() === void 0 || url.getPath() === "" || url.getPath() === "/");
    };
    assertValidEndpoint = (host) => {
      if (!isValidEndpoint(host)) {
        throw new Error(`Invalid endpoint url ${host}`);
      }
    };
    isKeyCredential = (credential) => {
      const castCredential = credential;
      return castCredential && typeof castCredential.key === "string" && castCredential.getToken === void 0;
    };
    parseClientArguments = (connectionStringOrUrl, credentialOrOptions) => {
      if (isKeyCredential(credentialOrOptions) || isTokenCredential(credentialOrOptions)) {
        assertValidEndpoint(connectionStringOrUrl);
        return { url: connectionStringOrUrl, credential: credentialOrOptions };
      } else {
        const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);
        assertValidEndpoint(host);
        return { url: host, credential };
      }
    };
  }
});

// node_modules/@azure/communication-common/dist-esm/src/credential/index.js
var init_credential = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/credential/index.js"() {
    init_communicationAccessKeyCredentialPolicy();
    init_communicationAuthPolicy();
    init_clientArguments();
    init_connectionString();
  }
});

// node_modules/@azure/communication-common/dist-esm/src/identifierModels.js
var isCommunicationUserIdentifier, isPhoneNumberIdentifier, isMicrosoftTeamsUserIdentifier, isUnknownIdentifier, getIdentifierKind;
var init_identifierModels = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/identifierModels.js"() {
    isCommunicationUserIdentifier = (identifier) => {
      return typeof identifier.communicationUserId === "string";
    };
    isPhoneNumberIdentifier = (identifier) => {
      return typeof identifier.phoneNumber === "string";
    };
    isMicrosoftTeamsUserIdentifier = (identifier) => {
      return typeof identifier.microsoftTeamsUserId === "string";
    };
    isUnknownIdentifier = (identifier) => {
      return typeof identifier.id === "string";
    };
    getIdentifierKind = (identifier) => {
      if (isCommunicationUserIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "communicationUser" });
      }
      if (isPhoneNumberIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "phoneNumber" });
      }
      if (isMicrosoftTeamsUserIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "microsoftTeamsUser" });
      }
      return Object.assign(Object.assign({}, identifier), { kind: "unknown" });
    };
  }
});

// node_modules/@azure/communication-common/dist-esm/src/identifierModelSerializer.js
var addRawIdIfExisting, assertNotNullOrUndefined, assertMaximumOneNestedModel, serializeCommunicationIdentifier, deserializeCommunicationIdentifier;
var init_identifierModelSerializer = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/identifierModelSerializer.js"() {
    init_tslib_es6();
    init_identifierModels();
    addRawIdIfExisting = (identifier, rawId) => {
      return rawId === void 0 ? identifier : Object.assign(Object.assign({}, identifier), { rawId });
    };
    assertNotNullOrUndefined = (obj, prop) => {
      const subObjName = Object.keys(obj)[0];
      const subObj = obj[subObjName];
      if (prop in subObj) {
        return subObj[prop];
      }
      throw new Error(`Property ${prop} is required for identifier of type ${subObjName}.`);
    };
    assertMaximumOneNestedModel = (identifier) => {
      const { rawId: _rawId } = identifier, props = __rest(identifier, ["rawId"]);
      const keys = Object.keys(props);
      if (keys.length > 1) {
        throw new Error(`Only one of the properties in ${JSON.stringify(keys)} should be present.`);
      }
    };
    serializeCommunicationIdentifier = (identifier) => {
      var _a2, _b;
      const identifierKind = getIdentifierKind(identifier);
      switch (identifierKind.kind) {
        case "communicationUser":
          return { communicationUser: { id: identifierKind.communicationUserId } };
        case "phoneNumber":
          return addRawIdIfExisting({ phoneNumber: { value: identifierKind.phoneNumber } }, identifierKind.rawId);
        case "microsoftTeamsUser":
          return addRawIdIfExisting({
            microsoftTeamsUser: {
              userId: identifierKind.microsoftTeamsUserId,
              isAnonymous: (_a2 = identifierKind.isAnonymous) !== null && _a2 !== void 0 ? _a2 : false,
              cloud: (_b = identifierKind.cloud) !== null && _b !== void 0 ? _b : "public"
            }
          }, identifierKind.rawId);
        case "unknown":
          return { rawId: identifierKind.id };
        default:
          throw new Error(`Can't serialize an identifier with kind ${identifierKind.kind}`);
      }
    };
    deserializeCommunicationIdentifier = (serializedIdentifier) => {
      assertMaximumOneNestedModel(serializedIdentifier);
      const { communicationUser, microsoftTeamsUser, phoneNumber } = serializedIdentifier;
      if (communicationUser) {
        return {
          kind: "communicationUser",
          communicationUserId: assertNotNullOrUndefined({ communicationUser }, "id")
        };
      }
      if (phoneNumber) {
        return {
          kind: "phoneNumber",
          phoneNumber: assertNotNullOrUndefined({ phoneNumber }, "value"),
          rawId: assertNotNullOrUndefined({ phoneNumber: serializedIdentifier }, "rawId")
        };
      }
      if (microsoftTeamsUser) {
        return {
          kind: "microsoftTeamsUser",
          microsoftTeamsUserId: assertNotNullOrUndefined({ microsoftTeamsUser }, "userId"),
          isAnonymous: assertNotNullOrUndefined({ microsoftTeamsUser }, "isAnonymous"),
          cloud: assertNotNullOrUndefined({ microsoftTeamsUser }, "cloud"),
          rawId: assertNotNullOrUndefined({ microsoftTeamsUser: serializedIdentifier }, "rawId")
        };
      }
      return {
        kind: "unknown",
        id: assertNotNullOrUndefined({ unknown: serializedIdentifier }, "rawId")
      };
    };
  }
});

// node_modules/@azure/communication-common/dist-esm/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  AzureCommunicationTokenCredential: () => AzureCommunicationTokenCredential,
  createCommunicationAccessKeyCredentialPolicy: () => createCommunicationAccessKeyCredentialPolicy,
  createCommunicationAuthPolicy: () => createCommunicationAuthPolicy,
  deserializeCommunicationIdentifier: () => deserializeCommunicationIdentifier,
  getIdentifierKind: () => getIdentifierKind,
  isCommunicationUserIdentifier: () => isCommunicationUserIdentifier,
  isKeyCredential: () => isKeyCredential,
  isMicrosoftTeamsUserIdentifier: () => isMicrosoftTeamsUserIdentifier,
  isPhoneNumberIdentifier: () => isPhoneNumberIdentifier,
  isUnknownIdentifier: () => isUnknownIdentifier,
  parseClientArguments: () => parseClientArguments,
  parseConnectionString: () => parseConnectionString,
  serializeCommunicationIdentifier: () => serializeCommunicationIdentifier
});
var init_src7 = __esm({
  "node_modules/@azure/communication-common/dist-esm/src/index.js"() {
    init_communicationTokenCredential();
    init_credential();
    init_credential();
    init_identifierModels();
    init_identifierModelSerializer();
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/models/options.js
var init_options = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/models/options.js"() {
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/models/requests.js
var init_requests = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/models/requests.js"() {
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/models/models.js
var init_models = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/models/models.js"() {
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/models/events.js
var init_events = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/models/events.js"() {
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/models/logger.js
var logger2;
var init_logger = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/models/logger.js"() {
    init_src3();
    logger2 = createClientLogger("communication-chat");
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module2.exports = EventEmitter2;
    module2.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index2) {
      for (; index2 + 1 < list.length; index2++)
        list[index2] = list[index2 + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/@azure/communication-signaling/dist/index.js
var require_dist = __commonJS({
  "node_modules/@azure/communication-signaling/dist/index.js"(exports, module) {
    "use strict";
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var coreHttp = _interopDefault((init_src6(), __toCommonJS(src_exports)));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function unwrapExports(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    function createCommonjsModule(fn, module2) {
      return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
    }
    var tsregistrar = createCommonjsModule(function(module2, exports2) {
      !function(t, e) {
        module2.exports = e();
      }(commonjsGlobal, function() {
        return function(t) {
          function e(n) {
            if (r[n])
              return r[n].exports;
            var i = r[n] = { i: n, l: false, exports: {} };
            return t[n].call(i.exports, i, i.exports, e), i.l = true, i.exports;
          }
          var r = {};
          return e.m = t, e.c = r, e.i = function(t2) {
            return t2;
          }, e.d = function(t2, r2, n) {
            e.o(t2, r2) || Object.defineProperty(t2, r2, { configurable: false, enumerable: true, get: n });
          }, e.n = function(t2) {
            var r2 = t2 && t2.__esModule ? function() {
              return t2.default;
            } : function() {
              return t2;
            };
            return e.d(r2, "a", r2), r2;
          }, e.o = function(t2, e2) {
            return Object.prototype.hasOwnProperty.call(t2, e2);
          }, e.p = "", e(e.s = 1);
        }([function(t, e, r) {
          function n(t2) {
            try {
              return JSON.stringify(t2);
            } catch (e2) {
              return "Unable to serialize object of type " + typeof t2;
            }
          }
          Object.defineProperty(e, "__esModule", { value: true }), e.toJson = n;
          var i = function() {
            function t2() {
              this.start = Date.now();
            }
            return Object.defineProperty(t2.prototype, "duration", { get: function() {
              return Date.now() - this.start;
            }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "startTime", { get: function() {
              return this.start;
            }, enumerable: true, configurable: true }), t2.prototype.reset = function() {
              this.start = Date.now();
            }, t2;
          }();
          e.Timespan = i;
        }, function(t, e, r) {
          function n(t2, e2, r2) {
            return new f3(t2, e2, r2);
          }
          var i = this && this.__extends || function() {
            var t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e2) {
              t3.__proto__ = e2;
            } || function(t3, e2) {
              for (var r2 in e2)
                e2.hasOwnProperty(r2) && (t3[r2] = e2[r2]);
            };
            return function(e2, r2) {
              function n2() {
                this.constructor = e2;
              }
              t2(e2, r2), e2.prototype = null === r2 ? Object.create(r2) : (n2.prototype = r2.prototype, new n2());
            };
          }(), o = this && this.__awaiter || function(t2, e2, r2, n2) {
            return new (r2 || (r2 = Promise))(function(i2, o2) {
              function s2(t3) {
                try {
                  c2(n2.next(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function a2(t3) {
                try {
                  c2(n2.throw(t3));
                } catch (t4) {
                  o2(t4);
                }
              }
              function c2(t3) {
                t3.done ? i2(t3.value) : new r2(function(e3) {
                  e3(t3.value);
                }).then(s2, a2);
              }
              c2((n2 = n2.apply(t2, e2 || [])).next());
            });
          }, s = this && this.__generator || function(t2, e2) {
            function r2(t3) {
              return function(e3) {
                return n2([t3, e3]);
              };
            }
            function n2(r3) {
              if (i2)
                throw new TypeError("Generator is already executing.");
              for (; c2; )
                try {
                  if (i2 = 1, o2 && (s2 = 2 & r3[0] ? o2.return : r3[0] ? o2.throw || ((s2 = o2.return) && s2.call(o2), 0) : o2.next) && !(s2 = s2.call(o2, r3[1])).done)
                    return s2;
                  switch (o2 = 0, s2 && (r3 = [2 & r3[0], s2.value]), r3[0]) {
                    case 0:
                    case 1:
                      s2 = r3;
                      break;
                    case 4:
                      return c2.label++, { value: r3[1], done: false };
                    case 5:
                      c2.label++, o2 = r3[1], r3 = [0];
                      continue;
                    case 7:
                      r3 = c2.ops.pop(), c2.trys.pop();
                      continue;
                    default:
                      if (s2 = c2.trys, !(s2 = s2.length > 0 && s2[s2.length - 1]) && (6 === r3[0] || 2 === r3[0])) {
                        c2 = 0;
                        continue;
                      }
                      if (3 === r3[0] && (!s2 || r3[1] > s2[0] && r3[1] < s2[3])) {
                        c2.label = r3[1];
                        break;
                      }
                      if (6 === r3[0] && c2.label < s2[1]) {
                        c2.label = s2[1], s2 = r3;
                        break;
                      }
                      if (s2 && c2.label < s2[2]) {
                        c2.label = s2[2], c2.ops.push(r3);
                        break;
                      }
                      s2[2] && c2.ops.pop(), c2.trys.pop();
                      continue;
                  }
                  r3 = e2.call(t2, c2);
                } catch (t3) {
                  r3 = [6, t3], o2 = 0;
                } finally {
                  i2 = s2 = 0;
                }
              if (5 & r3[0])
                throw r3[1];
              return { value: r3[0] ? r3[1] : void 0, done: true };
            }
            var i2, o2, s2, a2, c2 = { label: 0, sent: function() {
              if (1 & s2[0])
                throw s2[1];
              return s2[1];
            }, trys: [], ops: [] };
            return a2 = { next: r2(0), throw: r2(1), return: r2(2) }, "function" == typeof Symbol && (a2[Symbol.iterator] = function() {
              return this;
            }), a2;
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var a = r(0), c = function(t2) {
            function e2(e3) {
              var r2 = t2.call(this, e3) || this;
              return r2.name = "CancelationError", r2;
            }
            return i(e2, t2), e2;
          }(Error), u = function() {
            function t2(e2, r2, n2) {
              this.logger = e2, this.maxBackoffInMs = r2, this.initialDelay = n2, this.backoffCount = 0, this.id = ++t2.idCounter;
            }
            return t2.prototype.delay = function(t3) {
              var e2 = this;
              if (void 0 !== this.timerHandle)
                throw new Error("Retry sequence logical failure");
              if (-1 === this.backoffCount)
                return new Promise(function(t4, e3) {
                  e3(new c("Cancelled"));
                });
              var r2 = this.calculateNextBackoffMs();
              return this.backoffCount++, this.logger.info("[RegistrarClient] Backing off " + t3 + " for " + r2 + " milliseconds with ID " + this.id), new Promise(function(n2, i2) {
                e2.cancelFunc = i2, e2.timerHandle = setTimeout(function() {
                  e2.logger.info("[RegistrarClient] Back off for " + t3 + " with ID " + e2.id + " complete"), e2.timerHandle = void 0, n2();
                }, r2);
              });
            }, t2.prototype.cancel = function() {
              void 0 !== this.timerHandle && (this.logger.debug("Resetting back off"), clearTimeout(this.timerHandle), void 0 !== this.cancelFunc && this.cancelFunc(new c("Cancelled"))), this.backoffCount = -1;
            }, t2.prototype.calculateNextBackoffMs = function() {
              var t3 = 1 + 0.4 * (Math.random() - 0.5), e2 = this.initialDelay * Math.pow(2, this.backoffCount) * t3;
              return e2 = Math.round(e2), Math.min(this.maxBackoffInMs, e2);
            }, t2.idCounter = 0, t2;
          }(), f3 = function() {
            function t2(t3, e2, r2) {
              this.logger = t3, this.skypeTokenProvider = e2, this.options = r2, this.backoffs = {};
            }
            return t2.prototype.setTelemetryLogger = function(t3) {
              this.eventLogger = t3;
            }, t2.prototype.register = function(t3, e2) {
              return o(this, void 0, void 0, function() {
                return s(this, function(r2) {
                  switch (r2.label) {
                    case 0:
                      return [4, this.performRegistration(t3, e2, "pr_set_registration")];
                    case 1:
                      return r2.sent(), this.cachedRegistrationParams = [t3, e2], [2];
                  }
                });
              });
            }, t2.prototype.unregister = function() {
              return o(this, void 0, void 0, function() {
                var t3;
                return s(this, function(e2) {
                  switch (e2.label) {
                    case 0:
                      return this.logger.info("[RegistrarClient] sending unregister request"), t3 = new Request(this.options.registrarUrl + "/" + this.options.registrationId, { method: "DELETE", mode: "cors", headers: new Headers({ accept: "application/json, text/javascript" }) }), [4, this.callRegistrar(t3, "pr_delete_registration")];
                    case 1:
                      return e2.sent(), [2];
                  }
                });
              });
            }, t2.prototype.cancelPendingRequests = function() {
              var t3 = this;
              Object.keys(this.backoffs).forEach(function(e2) {
                t3.backoffs[e2].cancel();
              }), this.backoffs = {};
            }, t2.prototype.resendRegistration = function() {
              return o(this, void 0, void 0, function() {
                return s(this, function(t3) {
                  switch (t3.label) {
                    case 0:
                      if (!this.cachedRegistrationParams)
                        throw new Error("Re-registration failed because there is no registration parameters cached");
                      return [4, this.performRegistration(this.cachedRegistrationParams[0], this.cachedRegistrationParams[1], "pr_resend_registration")];
                    case 1:
                      return t3.sent(), [2];
                  }
                });
              });
            }, t2.prototype.performRegistration = function(t3, e2, r2) {
              return o(this, void 0, void 0, function() {
                var n2, i2;
                return s(this, function(o2) {
                  switch (o2.label) {
                    case 0:
                      return this.logger.info("[RegistrarClient] Sending register request"), n2 = { clientDescription: t3, registrationId: this.options.registrationId, nodeId: "", transports: e2 }, i2 = new Request(this.options.registrarUrl, { method: "POST", mode: "cors", headers: new Headers({ "content-type": "application/json", accept: "application/json, text/javascript" }), body: a.toJson(n2) }), [4, this.callRegistrar(i2, r2)];
                    case 1:
                      return o2.sent(), [2];
                  }
                });
              });
            }, t2.prototype.startBackoff = function() {
              var t3 = new u(this.logger, this.options.maxRetryDelayMs, this.options.initialRetryDelayMs);
              return this.backoffs[t3.id] = t3, t3;
            }, t2.prototype.stopBackoff = function(t3) {
              t3.cancel(), delete this.backoffs[t3.id];
            }, t2.prototype.getSkypeToken = function() {
              return o(this, void 0, void 0, function() {
                var t3, e2, r2, n2;
                return s(this, function(i2) {
                  switch (i2.label) {
                    case 0:
                      t3 = this.startBackoff(), i2.label = 1;
                    case 1:
                      return i2.trys.push([1, 3, , 8]), this.logger.info("[RegistrarClient] Asking for a new skypetoken"), [4, this.skypeTokenProvider(true)];
                    case 2:
                      return e2 = i2.sent(), this.stopBackoff(t3), [2, e2];
                    case 3:
                      r2 = i2.sent(), i2.label = 4;
                    case 4:
                      return i2.trys.push([4, 6, , 7]), [4, t3.delay("Fetching a new skypetoken")];
                    case 5:
                      return i2.sent(), [3, 8];
                    case 6:
                      throw n2 = i2.sent(), this.stopBackoff(t3), n2;
                    case 7:
                      return [3, 8];
                    case 8:
                      return [3, 1];
                    case 9:
                      return [2];
                  }
                });
              });
            }, t2.prototype.callRegistrar = function(t3, e2) {
              return o(this, void 0, void 0, function() {
                var r2, n2, i2, o2, c2, u2, f4, l, h, p, d, g, y, v;
                return s(this, function(s2) {
                  switch (s2.label) {
                    case 0:
                      return r2 = this.startBackoff(), [4, this.skypeTokenProvider(false)];
                    case 1:
                      n2 = s2.sent(), this.setSkypeTokenHeader(t3, n2), i2 = new a.Timespan(), s2.label = 2;
                    case 2:
                      o2 = void 0, s2.label = 3;
                    case 3:
                      return s2.trys.push([3, 8, 13, 14]), c2 = t3.clone(), [4, this.fetchWithTimeout(c2)];
                    case 4:
                      return o2 = s2.sent(), 401 !== o2.status ? [3, 6] : (u2 = this.setSkypeTokenHeader, f4 = [t3], [4, this.getSkypeToken()]);
                    case 5:
                      return u2.apply(this, f4.concat([s2.sent()])), [3, 20];
                    case 6:
                      if (o2.status >= 500 && o2.status < 600)
                        throw new Error("Fetch for '" + t3.url + "' failed with " + o2.status + " " + o2.statusText);
                      s2.label = 7;
                    case 7:
                      return [3, 14];
                    case 8:
                      l = s2.sent(), this.logger.error("[RegistrarClient] Request failed with " + l), s2.label = 9;
                    case 9:
                      return s2.trys.push([9, 11, , 12]), [4, r2.delay("Registrar call retry")];
                    case 10:
                      return s2.sent(), [3, 20];
                    case 11:
                      throw h = s2.sent(), this.logger.error("[RegistrarClient] Request cancelled"), this.stopBackoff(r2), h;
                    case 12:
                      return [3, 14];
                    case 13:
                      return this.sendTelemetryEvent(e2, t3, o2, i2), [7];
                    case 14:
                      return this.stopBackoff(r2), o2.ok ? [2, o2] : [3, 15];
                    case 15:
                      p = void 0, s2.label = 16;
                    case 16:
                      return s2.trys.push([16, 18, , 19]), g = (d = JSON).stringify, [4, o2.json()];
                    case 17:
                      return p = g.apply(d, [s2.sent()]), [3, 19];
                    case 18:
                      return y = s2.sent(), p = "no details", [3, 19];
                    case 19:
                      throw v = "Fetch for '" + t3.url + "' failed with " + o2.status + " " + o2.statusText + " (" + p + ", MS-CV: " + o2.headers.get("MS-CV") + ")", this.logger.error("[RegistrarClient] " + v), new Error(v);
                    case 20:
                      return [3, 2];
                    case 21:
                      return [2];
                  }
                });
              });
            }, t2.prototype.setSkypeTokenHeader = function(t3, e2) {
              t3.headers.set("X-Skypetoken", e2);
            }, t2.prototype.fetchWithTimeout = function(t3) {
              var e2 = this;
              return new Promise(function(r2, n2) {
                fetch(t3).then(r2).catch(n2), 0 !== e2.options.requestTimeoutMs && setTimeout(n2, e2.options.requestTimeoutMs, new Error("Fetch for '" + t3.url + "' timed out"));
              });
            }, t2.prototype.sendTelemetryEvent = function(t3, e2, r2, n2) {
              if (void 0 !== this.eventLogger) {
                var i2 = { name: t3, properties: { url: { value: e2.url }, result_code: { value: void 0 !== r2 ? r2.status : 0 }, begin_timestamp: { value: n2.startTime }, elapsed: { value: n2.duration } } };
                this.eventLogger.logEvent(i2);
              }
            }, t2;
          }();
          e.RegistrarClient = f3, e.createRegistrarClient = n;
        }]);
      });
    });
    unwrapExports(tsregistrar);
    var tstrouter = createCommonjsModule(function(module, exports) {
      !function(t, e) {
        module.exports = e(tsregistrar);
      }(commonjsGlobal, function(__WEBPACK_EXTERNAL_MODULE_20__) {
        return function(t) {
          function e(o) {
            if (n[o])
              return n[o].exports;
            var i = n[o] = { i: o, l: false, exports: {} };
            return t[o].call(i.exports, i, i.exports, e), i.l = true, i.exports;
          }
          var n = {};
          return e.m = t, e.c = n, e.i = function(t2) {
            return t2;
          }, e.d = function(t2, n2, o) {
            e.o(t2, n2) || Object.defineProperty(t2, n2, { configurable: false, enumerable: true, get: o });
          }, e.n = function(t2) {
            var n2 = t2 && t2.__esModule ? function() {
              return t2.default;
            } : function() {
              return t2;
            };
            return e.d(n2, "a", n2), n2;
          }, e.o = function(t2, e2) {
            return Object.prototype.hasOwnProperty.call(t2, e2);
          }, e.p = "", e(e.s = 19);
        }([function(t, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function() {
            function t2(t3, e2) {
              this.name = t3, this.logger = e2;
            }
            return t2.prototype.debug = function(t3) {
              this.logger.debug("[" + this.name + "] " + t3);
            }, t2.prototype.info = function(t3) {
              this.logger.info("[" + this.name + "] " + t3);
            }, t2.prototype.warn = function(t3) {
              this.logger.warn("[" + this.name + "] " + t3);
            }, t2.prototype.error = function(t3) {
              this.logger.error("[" + this.name + "] " + t3);
            }, t2;
          }();
          e.Logger = o;
        }, function(t, e, n) {
          Object.defineProperty(e, "__esModule", { value: true }), e.constants = { TROUTER_INIT: "trouterinit", TROUTER_READY_EVENT: "trouterReadyEvent", TROUTER_READY_TIMEOUT: "trouterReadyTimeout", TROUTER_TOKEN_REQUEST: "trouterTokenRequest", TROUTER_TOKEN_GET_SUCCEEDED: "trouterTokenGetSucceeded", TROUTER_TOKEN_GET_FAILED: "trouterTokenGetFailed", TROUTER_RECONNECTING: "trouterReconnecting", RENEWAL: "renewal", NEW_CONNECTION: "newConnection", ENDPOINT_REGISTRATION_FAILED: "endpointRegistrationFailed" }, e.CLIENT_VERSION = "2021.32.00.1", e.HANDLED_MESSAGE_ACK = 200, e.UNHANDLED_MESSAGE_ACK = 404, e.FAILED_MESSAGE_ACK = 500;
        }, function(t, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          !function(t2) {
            t2[t2.Unknown = 0] = "Unknown", t2[t2.Active = 1] = "Active", t2[t2.Inactive = 2] = "Inactive";
          }(e.UserActivityState || (e.UserActivityState = {}));
          var o = function() {
            function t2() {
            }
            return t2;
          }();
          e.HttpHeaders = o;
          !function(t2) {
            t2[t2.Unknown = 0] = "Unknown", t2[t2.Connected = 2] = "Connected", t2[t2.Disconnected = 3] = "Disconnected", t2[t2.Switching = 9] = "Switching";
          }(e.TrouterState || (e.TrouterState = {}));
        }, function(t, e, n) {
          function o(t2) {
            try {
              return JSON.stringify(t2);
            } catch (e2) {
              return "Unable to serialize object of type " + typeof t2;
            }
          }
          function i(t2) {
            var e2 = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
            return void 0 !== t2 && t2 > e2 ? t2 - e2 : 0;
          }
          function r(t2) {
            return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) + t2;
          }
          Object.defineProperty(e, "__esModule", { value: true }), e.toJson = o, e.calculateTtlInSec = i, e.calculateExpireTsInSec = r;
          var s = function() {
            function t2(t3) {
              this.base = void 0 !== t3 ? t3 : this.createCorrelationVectorBase(), this.extension = 0;
            }
            return t2.extend = function(e2) {
              return new t2(e2);
            }, t2.prototype.increase = function() {
              this.extension++;
            }, t2.prototype.value = function() {
              return this.base + "." + this.extension;
            }, t2.prototype.createCorrelationVectorBase = function() {
              for (var t3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0987654321/+", e2 = "AQgw", n2 = "", o2 = 0; o2 < 21; o2++)
                n2 += t3.charAt(Math.floor(Math.random() * t3.length));
              return n2 += e2.charAt(Math.floor(Math.random() * e2.length));
            }, t2;
          }();
          e.CorrelationVector = s;
          var c = function() {
            function t2() {
              this.start = Date.now();
            }
            return Object.defineProperty(t2.prototype, "duration", { get: function() {
              return Date.now() - this.start;
            }, enumerable: true, configurable: true }), Object.defineProperty(t2.prototype, "startTime", { get: function() {
              return this.start;
            }, enumerable: true, configurable: true }), t2.prototype.reset = function() {
              this.start = Date.now();
            }, t2;
          }();
          e.Timespan = c;
        }, function(t, e) {
          var n;
          n = function() {
            return this;
          }();
          try {
            n = n || Function("return this")() || (0, eval)("this");
          } catch (t2) {
            "object" == typeof window && (n = window);
          }
          t.exports = n;
        }, function(t, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = n(3), i = function() {
            function t2(t3, e2, n2, o2, i2, r, s) {
              this.connectionId = t3, this.connectedClientId = e2, this.domId = n2, this.unsecureUrl = o2, this.url = i2, this.c2cUrlBase = r, this.expirationTsSec = s;
            }
            return t2.prototype.getRemainingTtlInSec = function() {
              return o.calculateTtlInSec(this.expirationTsSec);
            }, t2;
          }();
          e.ServerState = i;
          !function(t2) {
            t2[t2.Unknown = 0] = "Unknown", t2[t2.Modified = 1] = "Modified", t2[t2.Snapshot = 2] = "Snapshot", t2[t2.Connected = 3] = "Connected";
          }(e.UserActivityEventReason || (e.UserActivityEventReason = {}));
        }, function(t, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = n(1), i = function() {
            function t2(t3) {
              this.logger = t3, this.messageHandlers = [];
            }
            return t2.prototype.register = function(t3) {
              if (this.messageHandlers.some(function(e2) {
                return e2 === t3;
              }))
                throw new Error("Registering the same handler twice is not allowed");
              this.messageHandlers.push(t3);
            }, t2.prototype.clear = function() {
              this.logger.debug("Clearing message handlers"), this.messageHandlers = [];
            }, t2.prototype.active = function() {
              return this.messageHandlers.length > 0;
            }, t2.prototype.handleMessage = function(t3) {
              for (var e2 = { resultCode: o.UNHANDLED_MESSAGE_ACK, isHandled: false }, n2 = 0, i2 = this.messageHandlers; n2 < i2.length; n2++) {
                var r = i2[n2], s = this.safeExecuteHandle(r, t3);
                if (void 0 !== s && (void 0 === s.isHandled || s.isHandled))
                  return void 0 === s.resultCode && (s.resultCode = o.HANDLED_MESSAGE_ACK), s;
              }
              return e2;
            }, t2.prototype.safeExecuteHandle = function(t3, e2) {
              try {
                return t3.handleMessage(e2);
              } catch (t4) {
                return void this.logger.warn("A trouter message handler is throwing exceptions. exception: " + t4);
              }
            }, t2;
          }();
          e.MessageHandlerRegistry = i;
        }, function(t, e, n) {
          function o(t2) {
            var e2, n2 = this;
            return function(o2) {
              return i(n2, void 0, void 0, function() {
                return r(this, function(n3) {
                  return o2 && (e2 = void 0), [2, new Promise(function(n4, i2) {
                    t2(o2).then(function(t3) {
                      e2 = t3, n4(t3);
                    }).catch(function(t3) {
                      void 0 !== e2 && e2.length > 0 && n4(e2), i2(t3);
                    });
                  })];
                });
              });
            };
          }
          var i = this && this.__awaiter || function(t2, e2, n2, o2) {
            return new (n2 || (n2 = Promise))(function(i2, r2) {
              function s(t3) {
                try {
                  a(o2.next(t3));
                } catch (t4) {
                  r2(t4);
                }
              }
              function c(t3) {
                try {
                  a(o2.throw(t3));
                } catch (t4) {
                  r2(t4);
                }
              }
              function a(t3) {
                t3.done ? i2(t3.value) : new n2(function(e3) {
                  e3(t3.value);
                }).then(s, c);
              }
              a((o2 = o2.apply(t2, e2 || [])).next());
            });
          }, r = this && this.__generator || function(t2, e2) {
            function n2(t3) {
              return function(e3) {
                return o2([t3, e3]);
              };
            }
            function o2(n3) {
              if (i2)
                throw new TypeError("Generator is already executing.");
              for (; a; )
                try {
                  if (i2 = 1, r2 && (s = 2 & n3[0] ? r2.return : n3[0] ? r2.throw || ((s = r2.return) && s.call(r2), 0) : r2.next) && !(s = s.call(r2, n3[1])).done)
                    return s;
                  switch (r2 = 0, s && (n3 = [2 & n3[0], s.value]), n3[0]) {
                    case 0:
                    case 1:
                      s = n3;
                      break;
                    case 4:
                      return a.label++, { value: n3[1], done: false };
                    case 5:
                      a.label++, r2 = n3[1], n3 = [0];
                      continue;
                    case 7:
                      n3 = a.ops.pop(), a.trys.pop();
                      continue;
                    default:
                      if (s = a.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === n3[0] || 2 === n3[0])) {
                        a = 0;
                        continue;
                      }
                      if (3 === n3[0] && (!s || n3[1] > s[0] && n3[1] < s[3])) {
                        a.label = n3[1];
                        break;
                      }
                      if (6 === n3[0] && a.label < s[1]) {
                        a.label = s[1], s = n3;
                        break;
                      }
                      if (s && a.label < s[2]) {
                        a.label = s[2], a.ops.push(n3);
                        break;
                      }
                      s[2] && a.ops.pop(), a.trys.pop();
                      continue;
                  }
                  n3 = e2.call(t2, a);
                } catch (t3) {
                  n3 = [6, t3], r2 = 0;
                } finally {
                  i2 = s = 0;
                }
              if (5 & n3[0])
                throw n3[1];
              return { value: n3[0] ? n3[1] : void 0, done: true };
            }
            var i2, r2, s, c, a = { label: 0, sent: function() {
              if (1 & s[0])
                throw s[1];
              return s[1];
            }, trys: [], ops: [] };
            return c = { next: n2(0), throw: n2(1), return: n2(2) }, "function" == typeof Symbol && (c[Symbol.iterator] = function() {
              return this;
            }), c;
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.addCacheAsBackupTo = o;
        }, function(t, e, n) {
          var o = this && this.__awaiter || function(t2, e2, n2, o2) {
            return new (n2 || (n2 = Promise))(function(i2, r2) {
              function s2(t3) {
                try {
                  a2(o2.next(t3));
                } catch (t4) {
                  r2(t4);
                }
              }
              function c2(t3) {
                try {
                  a2(o2.throw(t3));
                } catch (t4) {
                  r2(t4);
                }
              }
              function a2(t3) {
                t3.done ? i2(t3.value) : new n2(function(e3) {
                  e3(t3.value);
                }).then(s2, c2);
              }
              a2((o2 = o2.apply(t2, e2 || [])).next());
            });
          }, i = this && this.__generator || function(t2, e2) {
            function n2(t3) {
              return function(e3) {
                return o2([t3, e3]);
              };
            }
            function o2(n3) {
              if (i2)
                throw new TypeError("Generator is already executing.");
              for (; a2; )
                try {
                  if (i2 = 1, r2 && (s2 = 2 & n3[0] ? r2.return : n3[0] ? r2.throw || ((s2 = r2.return) && s2.call(r2), 0) : r2.next) && !(s2 = s2.call(r2, n3[1])).done)
                    return s2;
                  switch (r2 = 0, s2 && (n3 = [2 & n3[0], s2.value]), n3[0]) {
                    case 0:
                    case 1:
                      s2 = n3;
                      break;
                    case 4:
                      return a2.label++, { value: n3[1], done: false };
                    case 5:
                      a2.label++, r2 = n3[1], n3 = [0];
                      continue;
                    case 7:
                      n3 = a2.ops.pop(), a2.trys.pop();
                      continue;
                    default:
                      if (s2 = a2.trys, !(s2 = s2.length > 0 && s2[s2.length - 1]) && (6 === n3[0] || 2 === n3[0])) {
                        a2 = 0;
                        continue;
                      }
                      if (3 === n3[0] && (!s2 || n3[1] > s2[0] && n3[1] < s2[3])) {
                        a2.label = n3[1];
                        break;
                      }
                      if (6 === n3[0] && a2.label < s2[1]) {
                        a2.label = s2[1], s2 = n3;
                        break;
                      }
                      if (s2 && a2.label < s2[2]) {
                        a2.label = s2[2], a2.ops.push(n3);
                        break;
                      }
                      s2[2] && a2.ops.pop(), a2.trys.pop();
                      continue;
                  }
                  n3 = e2.call(t2, a2);
                } catch (t3) {
                  n3 = [6, t3], r2 = 0;
                } finally {
                  i2 = s2 = 0;
                }
              if (5 & n3[0])
                throw n3[1];
              return { value: n3[0] ? n3[1] : void 0, done: true };
            }
            var i2, r2, s2, c2, a2 = { label: 0, sent: function() {
              if (1 & s2[0])
                throw s2[1];
              return s2[1];
            }, trys: [], ops: [] };
            return c2 = { next: n2(0), throw: n2(1), return: n2(2) }, "function" == typeof Symbol && (c2[Symbol.iterator] = function() {
              return this;
            }), c2;
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var r = n(3), s = n(2), c = n(0), a = n(16), u = n(18), h = function() {
            function t2(t3, e2) {
              this.state = t3, this.correlationVector = void 0 !== e2 ? e2 : r.CorrelationVector.extend();
            }
            return t2.prototype.getStateString = function() {
              switch (this.state) {
                case s.UserActivityState.Active:
                  return "active";
                case s.UserActivityState.Inactive:
                  return "inactive";
                case s.UserActivityState.Unknown:
                  return "unknown";
                default:
                  return "undefined";
              }
            }, t2.prototype.toEventObject = function() {
              return { state: this.getStateString(), cv: this.correlationVector.value() };
            }, t2.prototype.toEventJSON = function() {
              return r.toJson(this.toEventObject());
            }, t2;
          }();
          e.UserActivityObject = h;
          var l = function() {
            function t2(t3, e2, n2, o2) {
              this.logFunc = t3, this.options = e2, this.tokenProvider = n2, this.listener = o2, this.logger = new c.Logger("Manager", t3), this.logger.info("Created TrouterManager with options " + r.toJson(this.options)), this.fsm = new u.TrouterManagerFsm(t3, this), this.baseEndpointUrl = "", this.processedMessageLoss = {}, this.userActivityObject = new h(s.UserActivityState.Unknown);
            }
            return t2.prototype.start = function() {
              this.fsm.start();
            }, t2.prototype.stop = function(t3) {
              this.fsm.stop(t3);
            }, t2.prototype.configure = function(t3) {
              this.options = t3, void 0 !== this.firstConnection && this.firstConnection.configure(t3), void 0 !== this.secondConnection && this.secondConnection.configure(t3), this.logger.info("Reconfigured TrouterManager with options " + r.toJson(this.options));
            }, t2.prototype.checkConnection = function(t3) {
              void 0 !== this.firstConnection && this.firstConnection.checkConnection(t3), void 0 !== this.secondConnection && this.secondConnection.checkConnection(t3);
            }, t2.prototype.resendRegistration = function() {
              return o(this, void 0, void 0, function() {
                return i(this, function(t3) {
                  return void 0 !== this.secondConnection ? (this.logger.info("Resending registration on the second/new connection"), [2, this.secondConnection.resendRegistration()]) : void 0 !== this.firstConnection ? (this.logger.info("Resending registration on the first/current connection"), [2, this.firstConnection.resendRegistration()]) : (this.logger.info("No connection to resend registration on, will be done upon (re)connect"), [2]);
                });
              });
            }, t2.prototype.getServerState = function() {
              if (void 0 !== this.firstConnection)
                return this.firstConnection.getServerState();
            }, t2.prototype.getState = function() {
              return this.fsm.getState();
            }, t2.prototype.startFirstConnection = function() {
              var t3 = new a.TrouterConnection(this.logFunc, this.options, this, this.tokenProvider, this.userActivityObject);
              this.firstConnection = t3, this.getConnectionCache().then(function(e2) {
                t3.start(e2);
              }).catch();
            }, t2.prototype.startSecondConnection = function() {
              this.secondConnection = new a.TrouterConnection(this.logFunc, this.options, this, this.tokenProvider, this.userActivityObject), this.secondConnection.start();
            }, t2.prototype.stopFirstConnection = function(t3) {
              void 0 !== this.firstConnection && (this.firstConnection.stop(t3), this.storedFirstConnection = this.firstConnection, this.firstConnection = void 0);
            }, t2.prototype.stopSecondConnection = function(t3) {
              void 0 !== this.secondConnection && (this.secondConnection.stop(t3), this.secondConnection = void 0);
            }, t2.prototype.stopSecondConnectionDelayed = function() {
              if (void 0 !== this.secondConnection) {
                var t3 = this.secondConnection;
                this.secondConnection = void 0, this.logger.info("Closing an inactive connection in " + Math.round(this.options.lingeringConnectionDelayMs / 1e3) + "s"), setTimeout(function() {
                  t3.stop(true);
                }, this.options.lingeringConnectionDelayMs);
              }
            }, t2.prototype.forceStopLingeringConnection = function() {
              this.storedFirstConnection && (this.storedFirstConnection.stop(false), this.storedFirstConnection = void 0);
            }, t2.prototype.switchConnections = function() {
              var t3 = this.firstConnection;
              this.firstConnection = this.secondConnection, this.secondConnection = t3;
            }, t2.prototype.doesSecondConnectionExist = function() {
              return void 0 !== this.secondConnection;
            }, t2.prototype.dispatchConnected = function() {
              if (void 0 !== this.firstConnection) {
                var t3 = this.firstConnection.getServerState(), e2 = "/" === t3.url.slice(-1) ? t3.url.slice(0, -1) : t3.url, n2 = { baseEndpointUrl: e2, newEndpointUrl: e2 !== this.baseEndpointUrl, c2cUrlBase: t3.c2cUrlBase, clientId: t3.connectedClientId, connectionId: t3.connectionId, connectionTtlSec: t3.getRemainingTtlInSec() };
                this.baseEndpointUrl = e2, this.listener.onTrouterConnected(t3.url, n2);
              }
            }, t2.prototype.dispatchReconnecting = function() {
              this.listener.onTrouterDisconnected && this.listener.onTrouterDisconnected();
            }, t2.prototype.dispatchStopped = function() {
              this.listener.onTrouterDisconnected && this.listener.onTrouterDisconnected();
            }, t2.prototype.dispatchRegistrationState = function(t3) {
              this.options.registrationStateCallback && this.options.registrationStateCallback(t3);
            }, t2.prototype.onDownstreamRequest = function(t3, e2, n2) {
              var o2 = { id: e2.id, method: e2.method, path: "/" + e2.shortUrl, body: e2.body, headers: e2.headers }, i2 = { id: e2.id, status: 0, headers: {}, body: "", send: function() {
                return i2.status <= 100 || i2.status >= 999 ? 3 : (n2.writeHead(i2.status, i2.headers), n2.end(i2.body));
              } };
              this.listener.onTrouterRequest(o2, i2);
            }, t2.prototype.onConnected = function(t3) {
              this.fsm.onConnected(t3 === this.firstConnection);
            }, t2.prototype.onRegistered = function(t3) {
              this.fsm.onRegistered(t3 === this.firstConnection);
            }, t2.prototype.onUnregistered = function(t3) {
              this.fsm.onUnregistered(t3 === this.firstConnection || t3 === this.storedFirstConnection);
            }, t2.prototype.onReconnecting = function(t3) {
              this.fsm.onReconnecting(t3 === this.firstConnection);
            }, t2.prototype.onReconnectIsRequired = function(t3) {
              this.fsm.onReconnectionRequired(t3 === this.firstConnection);
            }, t2.prototype.onDisconnected = function(t3) {
              this.fsm.onDisconnected(t3 === this.storedFirstConnection), this.storedFirstConnection = void 0;
            }, t2.prototype.onUserActivityStateAccepted = function(t3) {
              this.listener.onTrouterUserActivityStateAccepted && this.listener.onTrouterUserActivityStateAccepted(t3);
            }, t2.prototype.onConnectionParametersUpdated = function(t3) {
              this.setConnectionCache(t3);
            }, t2.prototype.setUserActivityState = function(t3, e2) {
              return this.userActivityObject = new h(t3, r.CorrelationVector.extend(e2)), void 0 !== this.secondConnection ? (this.logger.info("Setting user activity " + this.userActivityObject.toEventJSON() + " on the second/new connection"), void this.secondConnection.setUserActivityState(this.userActivityObject)) : void 0 !== this.firstConnection ? (this.logger.info("Setting user activity " + this.userActivityObject.toEventJSON() + " on the first/current connection"), void this.firstConnection.setUserActivityState(this.userActivityObject)) : void 0;
            }, t2.prototype.onTrouterMessageLost = function(t3) {
              var e2 = this;
              if (this.listener.onTrouterMessageLoss)
                if (t3 && t3.length) {
                  var n2 = t3.filter(function(t4) {
                    return void 0 !== e2.processedMessageLoss[t4.tag + "-" + t4.etag];
                  });
                  if (n2.length && (this.logger.warn("onTrouterMessageLoss - removing duplicates and sending event to server"), this.sendProcessedDroppedIndicators(n2), t3 = t3.filter(function(t4) {
                    return void 0 === e2.processedMessageLoss[t4.tag + "-" + t4.etag];
                  }), !t3.length))
                    return void this.logger.warn("onTrouterMessageLoss - All the data are duplicated");
                  var o2 = this.listener.onTrouterMessageLoss(t3.map(function(t4) {
                    return t4.tag;
                  }));
                  if (!o2)
                    return void this.logger.warn("onTrouterMessageLoss - flow tags have not been processed by listeners");
                  t3.forEach(function(t4) {
                    e2.processedMessageLoss[t4.tag + "-" + t4.etag] = "";
                  }), this.sendProcessedDroppedIndicators(t3);
                } else
                  this.logger.warn("onTrouterMessageLoss - no flow tags have been provided");
            }, t2.prototype.getConnectionCache = function() {
              var t3 = this;
              return this.options.connectionCache ? (this.logger.debug("Querying host's connection cache"), this.options.connectionCache.onGetTrouterConnectionCache().then(function(t4) {
                return t4 ? JSON.parse(t4) : void 0;
              }).catch(function(e2) {
                return t3.logger.warn("Invalid connection cache content provided: " + e2), t3.connectionCache;
              })) : Promise.resolve(this.connectionCache);
            }, t2.prototype.setConnectionCache = function(t3) {
              if (this.connectionCache = t3, this.options.connectionCache)
                try {
                  this.options.connectionCache.onSetTrouterConnectionCache(JSON.stringify(t3));
                } catch (t4) {
                  this.logger.warn("Error setting external connection cache: " + t4);
                }
            }, t2.prototype.sendProcessedDroppedIndicators = function(t3) {
              return void 0 !== this.firstConnection ? void this.firstConnection.sendProcessedDroppedIndicators(t3) : void 0 !== this.secondConnection ? void this.secondConnection.sendProcessedDroppedIndicators(t3) : void 0;
            }, t2;
          }();
          e.TrouterManager = l;
        }, function(t, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function() {
            function t2(t3) {
              this.logger = t3;
            }
            return t2.prototype.getPromise = function() {
              var t3 = this;
              return void 0 !== this.url ? (this.logger.debug("[TrouterUrlPromise] returning previously resolved url: " + this.url), Promise.resolve(this.url)) : (void 0 === this.pendingPromise ? (this.logger.debug("[TrouterUrlPromise] creating and returning promise"), this.pendingPromise = new Promise(function(e2, n2) {
                t3.pendingPromiseResolveRef = e2, t3.pendingPromiseRejectRef = n2;
              })) : this.logger.debug("[TrouterUrlPromise] returning existing promise"), this.pendingPromise);
            }, t2.prototype.resolveUrl = function(t3) {
              this.url = t3, this.logger.debug("[TrouterUrlPromise] got url: " + this.url);
              var e2 = this.pendingPromiseResolveRef;
              this.pendingPromise = void 0, this.pendingPromiseResolveRef = void 0, this.pendingPromiseRejectRef = void 0, void 0 !== e2 && (this.logger.debug("[TrouterUrlPromise] resolving promise"), e2(t3));
            }, t2.prototype.rejectUrl = function(t3) {
              this.logger.debug("[TrouterUrlPromise] aborting");
              var e2 = this.pendingPromiseRejectRef;
              this.url = void 0, this.pendingPromise = void 0, this.pendingPromiseResolveRef = void 0, this.pendingPromiseRejectRef = void 0, void 0 !== e2 && (this.logger.debug("[TrouterUrlPromise] rejecting promise"), e2(t3));
            }, t2.prototype.resetUrl = function() {
              this.logger.debug("[TrouterUrlPromise] resetting url"), this.url = void 0;
            }, t2;
          }();
          e.TrouterUrlPromise = o;
        }, function(module, exports, __webpack_require__) {
          (function(global, module) {
            !function(t, e) {
              var n = t;
              n.version = "0.9.6", n.protocol = 1, n.transports = [], n.j = [], n.sockets = {}, n.connect = function(t2, o) {
                var i, r, s = n.util.parseUri(t2);
                e && e.location && (s.protocol = s.protocol || e.location.protocol.slice(0, -1), s.host = s.host || (e.document ? e.document.domain : e.location.hostname), s.port = s.port || e.location.port), i = n.util.uniqueUri(s);
                var c = { host: s.host, secure: "https" == s.protocol, port: s.port || ("https" == s.protocol ? 443 : 80), query: s.query || "" };
                return n.util.merge(c, o), !c["force new connection"] && n.sockets[i] || (r = new n.Socket(c)), !c["force new connection"] && r && (n.sockets[i] = r), r = r || n.sockets[i], r.of(s.path.length > 1 ? s.path : "");
              };
            }(module.exports, void 0 === global ? window : global);
            var io = module.exports;
            !function(t, e) {
              var n = t.util = {}, o = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, i = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
              n.parseUri = function(t2) {
                for (var e2 = o.exec(t2 || ""), n2 = {}, r2 = 14; r2--; )
                  n2[i[r2]] = e2[r2] || "";
                return n2;
              }, n.uniqueUri = function(t2) {
                var n2 = t2.protocol, o2 = t2.host, i2 = t2.port;
                return "document" in e ? (o2 = o2 || document.domain, i2 = i2 || ("https" == n2 && "https:" !== document.location.protocol ? 443 : document.location.port)) : (o2 = o2 || "localhost", i2 || "https" != n2 || (i2 = 443)), (n2 || "http") + "://" + o2 + ":" + (i2 || 80);
              }, n.query = function(t2, e2) {
                var o2 = n.chunkQuery(t2 || ""), i2 = [];
                n.merge(o2, n.chunkQuery(e2 || ""));
                for (var r2 in o2)
                  o2.hasOwnProperty(r2) && i2.push(r2 + "=" + o2[r2]);
                return i2.length ? "?" + i2.join("&") : "";
              }, n.chunkQuery = function(t2) {
                for (var e2, n2 = {}, o2 = t2.split("&"), i2 = 0, r2 = o2.length; i2 < r2; ++i2)
                  e2 = o2[i2].split("="), e2[0] && (n2[e2[0]] = e2[1]);
                return n2;
              };
              var r = false;
              n.load = function(t2) {
                if ("document" in e && "complete" === document.readyState || r)
                  return t2();
                n.on(e, "load", t2, false);
              }, n.on = function(t2, e2, n2, o2) {
                t2.attachEvent ? t2.attachEvent("on" + e2, n2) : t2.addEventListener && t2.addEventListener(e2, n2, o2);
              }, n.request = function(t2) {
                if (t2 && "undefined" != typeof XDomainRequest)
                  return new XDomainRequest();
                if ("undefined" != typeof XMLHttpRequest && (!t2 || n.ua.hasCORS))
                  return new XMLHttpRequest();
                if (!t2)
                  try {
                    return new window[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
                  } catch (t3) {
                  }
                return null;
              }, "undefined" != typeof window && n.load(function() {
                r = true;
              }), n.defer = function(t2) {
                if (!n.ua.webkit || "undefined" != typeof importScripts)
                  return t2();
                n.load(function() {
                  setTimeout(t2, 100);
                });
              }, n.merge = function(t2, e2, o2, i2) {
                var r2, s = i2 || [], c = void 0 === o2 ? 2 : o2;
                for (r2 in e2)
                  e2.hasOwnProperty(r2) && n.indexOf(s, r2) < 0 && ("object" == typeof t2[r2] && c ? n.merge(t2[r2], e2[r2], c - 1, s) : (t2[r2] = e2[r2], s.push(e2[r2])));
                return t2;
              }, n.mixin = function(t2, e2) {
                n.merge(t2.prototype, e2.prototype);
              }, n.inherit = function(t2, e2) {
                function n2() {
                }
                n2.prototype = e2.prototype, t2.prototype = new n2();
              }, n.isArray = Array.isArray || function(t2) {
                return "[object Array]" === Object.prototype.toString.call(t2);
              }, n.intersect = function(t2, e2) {
                for (var o2 = [], i2 = t2.length > e2.length ? t2 : e2, r2 = t2.length > e2.length ? e2 : t2, s = 0, c = r2.length; s < c; s++)
                  ~n.indexOf(i2, r2[s]) && o2.push(r2[s]);
                return o2;
              }, n.indexOf = function(t2, e2, n2) {
                for (var o2 = t2.length, n2 = n2 < 0 ? n2 + o2 < 0 ? 0 : n2 + o2 : n2 || 0; n2 < o2 && t2[n2] !== e2; n2++)
                  ;
                return o2 <= n2 ? -1 : n2;
              }, n.toArray = function(t2) {
                for (var e2 = [], n2 = 0, o2 = t2.length; n2 < o2; n2++)
                  e2.push(t2[n2]);
                return e2;
              }, n.ua = {}, n.ua.hasCORS = "undefined" != typeof XMLHttpRequest && function() {
                try {
                  var t2 = new XMLHttpRequest();
                } catch (t3) {
                  return false;
                }
                return void 0 != t2.withCredentials;
              }(), n.ua.webkit = "undefined" != typeof navigator && /webkit/i.test(navigator.userAgent);
            }(void 0 !== io ? io : module.exports, void 0 === global ? window : global), function(t, e) {
              function n() {
              }
              t.EventEmitter = n, n.prototype.on = function(t2, n2) {
                return this.$events || (this.$events = {}), this.$events[t2] ? e.util.isArray(this.$events[t2]) ? this.$events[t2].push(n2) : this.$events[t2] = [this.$events[t2], n2] : this.$events[t2] = n2, this;
              }, n.prototype.addListener = n.prototype.on, n.prototype.once = function(t2, e2) {
                function n2() {
                  o.removeListener(t2, n2), e2.apply(this, arguments);
                }
                var o = this;
                return n2.listener = e2, this.on(t2, n2), this;
              }, n.prototype.removeListener = function(t2, n2) {
                if (this.$events && this.$events[t2]) {
                  var o = this.$events[t2];
                  if (e.util.isArray(o)) {
                    for (var i = -1, r = 0, s = o.length; r < s; r++)
                      if (o[r] === n2 || o[r].listener && o[r].listener === n2) {
                        i = r;
                        break;
                      }
                    if (i < 0)
                      return this;
                    o.splice(i, 1), o.length || delete this.$events[t2];
                  } else
                    (o === n2 || o.listener && o.listener === n2) && delete this.$events[t2];
                }
                return this;
              }, n.prototype.removeAllListeners = function(t2) {
                return this.$events && this.$events[t2] && (this.$events[t2] = null), this;
              }, n.prototype.listeners = function(t2) {
                return this.$events || (this.$events = {}), this.$events[t2] || (this.$events[t2] = []), e.util.isArray(this.$events[t2]) || (this.$events[t2] = [this.$events[t2]]), this.$events[t2];
              }, n.prototype.emit = function(t2) {
                if (!this.$events)
                  return false;
                var n2 = this.$events[t2];
                if (!n2)
                  return false;
                var o = Array.prototype.slice.call(arguments, 1);
                if ("function" == typeof n2)
                  n2.apply(this, o);
                else {
                  if (!e.util.isArray(n2))
                    return false;
                  for (var i = n2.slice(), r = 0, s = i.length; r < s; r++)
                    i[r].apply(this, o);
                }
                return true;
              };
            }(void 0 !== io ? io : module.exports, void 0 !== io ? io : module.parent.exports), function(exports, nativeJSON) {
              function f(t) {
                return t < 10 ? "0" + t : t;
              }
              function date(t, e) {
                return isFinite(t.valueOf()) ? t.getUTCFullYear() + "-" + f(t.getUTCMonth() + 1) + "-" + f(t.getUTCDate()) + "T" + f(t.getUTCHours()) + ":" + f(t.getUTCMinutes()) + ":" + f(t.getUTCSeconds()) + "Z" : null;
              }
              function quote(t) {
                return escapable.lastIndex = 0, escapable.test(t) ? '"' + t.replace(escapable, function(t2) {
                  var e = meta[t2];
                  return "string" == typeof e ? e : "\\u" + ("0000" + t2.charCodeAt(0).toString(16)).slice(-4);
                }) + '"' : '"' + t + '"';
              }
              function str(t, e) {
                var n, o, i, r, s, c = gap, a = e[t];
                switch (a instanceof Date && (a = date(t)), "function" == typeof rep && (a = rep.call(e, t, a)), typeof a) {
                  case "string":
                    return quote(a);
                  case "number":
                    return isFinite(a) ? String(a) : "null";
                  case "boolean":
                  case "null":
                    return String(a);
                  case "object":
                    if (!a)
                      return "null";
                    if (gap += indent, s = [], "[object Array]" === Object.prototype.toString.apply(a)) {
                      for (r = a.length, n = 0; n < r; n += 1)
                        s[n] = str(n, a) || "null";
                      return i = 0 === s.length ? "[]" : gap ? "[\n" + gap + s.join(",\n" + gap) + "\n" + c + "]" : "[" + s.join(",") + "]", gap = c, i;
                    }
                    if (rep && "object" == typeof rep)
                      for (r = rep.length, n = 0; n < r; n += 1)
                        "string" == typeof rep[n] && (o = rep[n], (i = str(o, a)) && s.push(quote(o) + (gap ? ": " : ":") + i));
                    else
                      for (o in a)
                        Object.prototype.hasOwnProperty.call(a, o) && (i = str(o, a)) && s.push(quote(o) + (gap ? ": " : ":") + i);
                    return i = 0 === s.length ? "{}" : gap ? "{\n" + gap + s.join(",\n" + gap) + "\n" + c + "}" : "{" + s.join(",") + "}", gap = c, i;
                }
              }
              if (nativeJSON && nativeJSON.parse)
                return exports.JSON = { parse: nativeJSON.parse, stringify: nativeJSON.stringify };
              var JSON = exports.JSON = {}, cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = { "\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }, rep;
              JSON.stringify = function(t, e, n) {
                var o;
                if (gap = "", indent = "", "number" == typeof n)
                  for (o = 0; o < n; o += 1)
                    indent += " ";
                else
                  "string" == typeof n && (indent = n);
                if (rep = e, e && "function" != typeof e && ("object" != typeof e || "number" != typeof e.length))
                  throw new Error("JSON.stringify");
                return str("", { "": t });
              }, JSON.parse = function(text, reviver) {
                function walk(t, e) {
                  var n, o, i = t[e];
                  if (i && "object" == typeof i)
                    for (n in i)
                      Object.prototype.hasOwnProperty.call(i, n) && (o = walk(i, n), void 0 !== o ? i[n] = o : delete i[n]);
                  return reviver.call(t, e, i);
                }
                var j;
                if (text = String(text), cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function(t) {
                  return "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
                })), /^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, "")))
                  return j = eval("(" + text + ")"), "function" == typeof reviver ? walk({ "": j }, "") : j;
                throw new SyntaxError("JSON.parse");
              };
            }(void 0 !== io ? io : module.exports, "undefined" != typeof JSON ? JSON : void 0), function(t, e) {
              var n = t.parser = {}, o = n.packets = ["disconnect", "connect", "heartbeat", "message", "json", "event", "ack", "error", "noop"], i = n.reasons = ["transport not supported", "client not handshaken", "unauthorized"], r = n.advice = ["reconnect"], s = e.JSON, c = e.util.indexOf;
              n.encodePacket = function(t2) {
                var e2 = c(o, t2.type), n2 = t2.id || "", a2 = t2.endpoint || "", u = t2.ack, h = null;
                switch (t2.type) {
                  case "error":
                    var l = t2.reason ? c(i, t2.reason) : "", p = t2.advice ? c(r, t2.advice) : "";
                    "" === l && "" === p || (h = l + ("" !== p ? "+" + p : ""));
                    break;
                  case "message":
                    "" !== t2.data && (h = t2.data);
                    break;
                  case "event":
                    var d = { name: t2.name };
                    t2.args && t2.args.length && (d.args = t2.args), h = s.stringify(d);
                    break;
                  case "json":
                    h = s.stringify(t2.data);
                    break;
                  case "connect":
                    t2.qs && (h = t2.qs);
                    break;
                  case "ack":
                    h = t2.ackId + (t2.args && t2.args.length ? "+" + s.stringify(t2.args) : "");
                }
                var f3 = [e2, n2 + ("data" == u ? "+" : ""), a2];
                return null !== h && void 0 !== h && f3.push(h), f3.join(":");
              }, n.encodePayload = function(t2) {
                var e2 = "";
                if (1 == t2.length)
                  return t2[0];
                for (var n2 = 0, o2 = t2.length; n2 < o2; n2++) {
                  e2 += "�" + t2[n2].length + "�" + t2[n2];
                }
                return e2;
              };
              var a = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;
              n.decodePacket = function(t2) {
                var e2 = t2.match(a);
                if (!e2)
                  return {};
                var n2 = e2[2] || "", t2 = e2[5] || "", c2 = { type: o[e2[1]], endpoint: e2[4] || "" };
                switch (n2 && (c2.id = n2, e2[3] ? c2.ack = "data" : c2.ack = true), c2.type) {
                  case "error":
                    var e2 = t2.split("+");
                    c2.reason = i[e2[0]] || "", c2.advice = r[e2[1]] || "";
                    break;
                  case "message":
                    c2.data = t2 || "";
                    break;
                  case "event":
                    try {
                      var u = s.parse(t2);
                      c2.name = u.name, c2.args = u.args;
                    } catch (t3) {
                    }
                    c2.args = c2.args || [];
                    break;
                  case "json":
                    try {
                      c2.data = s.parse(t2);
                    } catch (t3) {
                    }
                    break;
                  case "connect":
                    c2.qs = t2 || "";
                    break;
                  case "ack":
                    var e2 = t2.match(/^([0-9]+)(\+)?(.*)/);
                    if (e2 && (c2.ackId = e2[1], c2.args = [], e2[3]))
                      try {
                        c2.args = e2[3] ? s.parse(e2[3]) : [];
                      } catch (t3) {
                      }
                    break;
                  case "disconnect":
                    c2.reason = t2;
                }
                return c2;
              }, n.decodePayload = function(t2) {
                if ("�" == t2.charAt(0)) {
                  for (var e2 = [], o2 = 1, i2 = ""; o2 < t2.length; o2++)
                    "�" == t2.charAt(o2) ? (e2.push(n.decodePacket(t2.substr(o2 + 1).substr(0, i2))), o2 += Number(i2) + 1, i2 = "") : i2 += t2.charAt(o2);
                  return e2;
                }
                return [n.decodePacket(t2)];
              };
            }(void 0 !== io ? io : module.exports, void 0 !== io ? io : module.parent.exports), function(t, e) {
              function n(t2, e2) {
                this.socket = t2, this.sessid = e2, this.connectErrorCallback = void 0, this.isOpened = false;
              }
              t.Transport = n, e.util.mixin(n, e.EventEmitter), n.prototype.onData = function(t2) {
                if (this.clearCloseTimeout(), (this.socket.connected || this.socket.connecting || this.socket.reconnecting) && this.setCloseTimeout(), "" !== t2) {
                  var n2 = e.parser.decodePayload(t2);
                  if (n2 && n2.length)
                    for (var o = 0, i = n2.length; o < i; o++)
                      this.onPacket(n2[o]);
                }
                return this;
              }, n.prototype.onPacket = function(t2) {
                return this.socket.setHeartbeatTimeout(), "heartbeat" == t2.type ? this.onHeartbeat() : ("connect" == t2.type && "" == t2.endpoint && this.onConnect(), "error" == t2.type && "reconnect" == t2.advice && (this.isOpened = false), this.socket.onPacket(t2), this);
              }, n.prototype.setCloseTimeout = function() {
                if (!this.closeTimeout) {
                  var t2 = this;
                  this.closeTimeout = setTimeout(function() {
                    t2.onDisconnect();
                  }, this.socket.closeTimeout);
                }
              }, n.prototype.onDisconnect = function() {
                return this.close && this.isOpened && this.close(), this.clearTimeouts(), this.socket.onDisconnect(), this;
              }, n.prototype.onConnect = function() {
                return this.socket.onConnect(), this.connectErrorCallback = void 0, this;
              }, n.prototype.clearCloseTimeout = function() {
                this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = null);
              }, n.prototype.clearTimeouts = function() {
                this.clearCloseTimeout(), this.reopenTimeout && clearTimeout(this.reopenTimeout);
              }, n.prototype.packet = function(t2) {
                this.send(e.parser.encodePacket(t2));
              }, n.prototype.onHeartbeat = function(t2) {
                this.packet({ type: "heartbeat" });
              }, n.prototype.onOpen = function() {
                this.isOpened = true, this.clearCloseTimeout(), this.socket.onOpen();
              }, n.prototype.onClose = function() {
                this.isOpened = false, this.socket.onClose(), this.onDisconnect();
              }, n.prototype.prepareUrl = function() {
                var t2 = this.socket.options;
                return this.scheme() + "://" + t2.host + ":" + t2.port + "/" + t2.resource + "/" + e.protocol + "/" + this.name + "/" + this.sessid;
              }, n.prototype.ready = function(t2, e2) {
                e2.call(this);
              }, n.prototype.clearEventHandlers = function() {
                return this;
              };
            }(void 0 !== io ? io : module.exports, void 0 !== io ? io : module.parent.exports), function(t, e, n) {
              function o(t2) {
                if (this.options = { port: 80, secure: false, document: "document" in n && document, resource: "socket.io", transports: e.transports.slice(), "connect timeout": 1e4, "try multiple transports": true, reconnect: true, "reconnection delay": 500, "reconnection limit": 1 / 0, "reopen delay": 3e3, "max reconnection attempts": 10, "sync disconnect on unload": true, "auto connect": true, "flash policy port": 10843 }, e.util.merge(this.options, t2), this.connected = false, this.open = false, this.connecting = false, this.reconnecting = false, this.namespaces = {}, this.buffer = [], this.doBuffer = false, this.disconnected = false, this.options["sync disconnect on unload"] && (!this.isXDomain() || e.util.ua.hasCORS)) {
                  var o2 = this;
                  e.util.on(n, "unload", function() {
                    o2.disconnectSync();
                  }, false);
                }
                this.options["auto connect"] && this.connect();
              }
              function i() {
              }
              t.Socket = o, e.util.mixin(o, e.EventEmitter), o.prototype.of = function(t2) {
                return this.namespaces[t2] || (this.namespaces[t2] = new e.SocketNamespace(this, t2), "" !== t2 && this.namespaces[t2].packet({ type: "connect" })), this.namespaces[t2];
              }, o.prototype.publish = function() {
                this.emit.apply(this, arguments);
                var t2;
                for (var e2 in this.namespaces)
                  this.namespaces.hasOwnProperty(e2) && (t2 = this.of(e2), t2.$emit.apply(t2, arguments));
              }, o.prototype.handshake = function(t2) {
                function n2(e2) {
                  e2 instanceof Error ? o2.onError(e2.message) : t2.apply(null, e2.split(":"));
                }
                var o2 = this, r = this.options;
                if (!o2.disconnected) {
                  var s = ["http" + (r.secure ? "s" : "") + ":/", r.host + ":" + r.port, r.resource, e.protocol, e.util.query(this.options.query, "t=" + +/* @__PURE__ */ new Date())].join("/");
                  if (this.isXDomain() && !e.util.ua.hasCORS) {
                    var c = document.getElementsByTagName("script")[0], a = document.createElement("script");
                    a.src = s + "&jsonp=" + e.j.length, c.parentNode.insertBefore(a, c), e.j.push(function(t3) {
                      n2(t3), a.parentNode.removeChild(a);
                    });
                  } else {
                    var u = e.util.request();
                    u.open("GET", s, true), u.withCredentials = true, u.onreadystatechange = function() {
                      4 == u.readyState && (u.onreadystatechange = i, 200 == u.status ? n2(u.responseText) : !o2.reconnecting && o2.onError(u.responseText));
                    }, u.send(null);
                  }
                }
              }, o.prototype.getTransport = function(t2) {
                for (var n2, o2 = t2 || this.transports, i2 = 0; n2 = o2[i2]; i2++)
                  if (e.Transport[n2] && e.Transport[n2].check(this) && (!this.isXDomain() || e.Transport[n2].xdomainCheck()))
                    return new e.Transport[n2](this, this.sessionid);
                return null;
              }, o.prototype.connect = function(t2) {
                if (this.connecting || this.disconnected)
                  return this;
                var n2 = this;
                return this.handshake(function(o2, i2, r, s) {
                  function c() {
                    if (!n2.connected && !n2.disconnected)
                      if (n2.connecting = false, clearTimeout(n2.connectTimeoutTimer), n2.options["try multiple transports"]) {
                        for (; n2.remainingTransports.length > 0 && n2.remainingTransports.splice(0, 1)[0] != n2.transport.name; )
                          ;
                        n2.remainingTransports.length ? a(n2.remainingTransports) : n2.publish("connect_failed");
                      } else
                        n2.publish("connect_failed");
                  }
                  function a(t3) {
                    if (n2.transport && (n2.transport.clearTimeouts(), n2.transport.clearEventHandlers()), n2.transport = n2.getTransport(t3), !n2.transport || n2.disconnected)
                      return n2.publish("connect_failed");
                    n2.transport.ready(n2, function() {
                      n2.connecting = true, n2.publish("connecting", n2.transport.name), n2.transport.open(c), n2.options["connect timeout"] && (n2.connectTimeoutTimer = setTimeout(function() {
                        c();
                      }, n2.options["connect timeout"]));
                    });
                  }
                  n2.sessionid = o2, n2.closeTimeout = 1e3 * r + 2e3, n2.heartbeatTimeout = 1e3 * i2 + 2e3, n2.transports = s ? e.util.intersect(s.split(","), n2.options.transports) : n2.options.transports, n2.setHeartbeatTimeout(), n2.remainingTransports = n2.transports.slice(0), a(n2.transports), n2.once("connect", function() {
                    clearTimeout(n2.connectTimeoutTimer), t2 && "function" == typeof t2 && t2();
                  });
                }), this;
              }, o.prototype.setHeartbeatTimeout = function() {
                clearTimeout(this.heartbeatTimeoutTimer);
                var t2 = this;
                this.heartbeatTimeoutTimer = setTimeout(function() {
                  t2.transport.onClose();
                }, this.heartbeatTimeout);
              }, o.prototype.packet = function(t2) {
                return this.connected && !this.doBuffer ? this.transport.packet(t2) : this.buffer.push(t2), this;
              }, o.prototype.setBuffer = function(t2) {
                this.doBuffer = t2, !t2 && this.connected && this.buffer.length && (this.transport.payload(this.buffer), this.buffer = []);
              }, o.prototype.disconnect = function() {
                return (this.connected || this.connecting) && (this.open && this.of("").packet({ type: "disconnect" }), this.onDisconnect("booted")), this.disconnected = true, this;
              }, o.prototype.disconnectSync = function() {
                var t2 = e.util.request(), n2 = this.resource + "/" + e.protocol + "/" + this.sessionid;
                t2.open("GET", n2, true), this.onDisconnect("booted");
              }, o.prototype.isXDomain = function() {
                var t2 = n.location.port || ("https:" == n.location.protocol ? 443 : 80);
                return this.options.host !== n.location.hostname || this.options.port != t2;
              }, o.prototype.onConnect = function() {
                this.connected || (this.connected = true, this.connecting = false, this.doBuffer || this.setBuffer(false), this.emit("connect"));
              }, o.prototype.onOpen = function() {
                this.open = true;
              }, o.prototype.onClose = function() {
                this.open = false, clearTimeout(this.heartbeatTimeoutTimer);
              }, o.prototype.onPacket = function(t2) {
                this.of(t2.endpoint).onPacket(t2);
              }, o.prototype.onError = function(t2) {
                t2 && t2.advice && "reconnect" === t2.advice && (this.connected || this.connecting) && (this.disconnect(), this.options.reconnect && this.reconnect()), this.publish("error", t2 && t2.reason ? t2.reason : t2);
              }, o.prototype.onDisconnect = function(t2) {
                var e2 = this.connected, n2 = this.connecting;
                this.connected = false, this.connecting = false, this.open = false, (e2 || n2) && (this.transport.close(), this.transport.clearTimeouts(), e2 && (this.publish("disconnect", t2), "booted" != t2 && this.options.reconnect && !this.reconnecting && this.reconnect()));
              }, o.prototype.reconnect = function() {
                function t2() {
                  if (n2.connected) {
                    for (var t3 in n2.namespaces)
                      n2.namespaces.hasOwnProperty(t3) && "" !== t3 && n2.namespaces[t3].packet({ type: "connect" });
                    n2.publish("reconnect", n2.transport.name, n2.reconnectionAttempts);
                  }
                  clearTimeout(n2.reconnectionTimer), n2.removeListener("connect_failed", e2), n2.removeListener("connect", e2), n2.reconnecting = false, delete n2.reconnectionAttempts, delete n2.reconnectionDelay, delete n2.reconnectionTimer, delete n2.redoTransports, n2.options["try multiple transports"] = i2;
                }
                function e2() {
                  if (n2.reconnecting)
                    return n2.connected ? t2() : n2.connecting && n2.reconnecting ? n2.reconnectionTimer = setTimeout(e2, 1e3) : void (n2.reconnectionAttempts++ >= o2 ? n2.redoTransports ? (n2.publish("reconnect_failed"), t2()) : (n2.on("connect_failed", e2), n2.options["try multiple transports"] = true, n2.transport = n2.getTransport(), n2.redoTransports = true, n2.connect()) : (n2.reconnectionDelay < r && (n2.reconnectionDelay *= 2), n2.connect(), n2.publish("reconnecting", n2.reconnectionDelay, n2.reconnectionAttempts), n2.reconnectionTimer = setTimeout(e2, n2.reconnectionDelay)));
                }
                this.reconnecting = true, this.reconnectionAttempts = 0, this.reconnectionDelay = this.options["reconnection delay"];
                var n2 = this, o2 = this.options["max reconnection attempts"], i2 = this.options["try multiple transports"], r = this.options["reconnection limit"];
                this.options["try multiple transports"] = false, this.reconnectionTimer = setTimeout(e2, this.reconnectionDelay), this.on("connect", e2);
              };
            }(void 0 !== io ? io : module.exports, void 0 !== io ? io : module.parent.exports, void 0 === global ? window : global), function(t, e) {
              function n(t2, e2) {
                this.socket = t2, this.name = e2 || "", this.flags = {}, this.json = new o(this, "json"), this.ackPackets = 0, this.acks = {};
              }
              function o(t2, e2) {
                this.namespace = t2, this.name = e2;
              }
              t.SocketNamespace = n, e.util.mixin(n, e.EventEmitter), n.prototype.$emit = e.EventEmitter.prototype.emit, n.prototype.of = function() {
                return this.socket.of.apply(this.socket, arguments);
              }, n.prototype.packet = function(t2) {
                return t2.endpoint = this.name, this.socket.packet(t2), this.flags = {}, this;
              }, n.prototype.send = function(t2, e2) {
                var n2 = { type: this.flags.json ? "json" : "message", data: t2 };
                return "function" == typeof e2 && (n2.id = ++this.ackPackets, n2.ack = true, this.acks[n2.id] = e2), this.packet(n2);
              }, n.prototype.emit = function(t2) {
                var e2 = Array.prototype.slice.call(arguments, 1), n2 = e2[e2.length - 1], o2 = { type: "event", name: t2 };
                return "function" == typeof n2 && (o2.id = ++this.ackPackets, o2.ack = "data", this.acks[o2.id] = n2, e2 = e2.slice(0, e2.length - 1)), o2.args = e2, this.packet(o2);
              }, n.prototype.disconnect = function() {
                return "" === this.name ? this.socket.disconnect() : (this.packet({ type: "disconnect" }), this.$emit("disconnect")), this;
              }, n.prototype.onPacket = function(t2) {
                function n2() {
                  o2.packet({ type: "ack", args: e.util.toArray(arguments), ackId: t2.id });
                }
                var o2 = this;
                switch (t2.type) {
                  case "connect":
                    this.$emit("connect");
                    break;
                  case "disconnect":
                    "" === this.name ? this.socket.onDisconnect(t2.reason || "booted") : this.$emit("disconnect", t2.reason || "");
                    break;
                  case "message":
                  case "json":
                    var i = ["message", t2.data];
                    "data" == t2.ack ? i.push(n2) : t2.ack && this.packet({ type: "ack", ackId: t2.id }), this.$emit.apply(this, i);
                    break;
                  case "event":
                    var i = [t2.name].concat(t2.args);
                    "data" == t2.ack && i.push(n2), this.$emit.apply(this, i);
                    break;
                  case "ack":
                    this.acks[t2.ackId] && (this.acks[t2.ackId].apply(this, t2.args), delete this.acks[t2.ackId]);
                    break;
                  case "error":
                    t2.advice ? this.socket.onError(t2) : "unauthorized" == t2.reason ? this.$emit("connect_failed", t2.reason) : this.$emit("error", t2.reason);
                }
              }, o.prototype.send = function() {
                this.namespace.flags[this.name] = true, this.namespace.send.apply(this.namespace, arguments);
              }, o.prototype.emit = function() {
                this.namespace.flags[this.name] = true, this.namespace.emit.apply(this.namespace, arguments);
              };
            }(void 0 !== io ? io : module.exports, void 0 !== io ? io : module.parent.exports), function(t, e, n) {
              function o(t2) {
                e.Transport.apply(this, arguments);
              }
              function i() {
              }
              t.websocket = o, e.util.inherit(o, e.Transport), o.prototype.name = "websocket", o.prototype.open = function(t2) {
                var o2, i2 = e.util.query(this.socket.options.query), r = this;
                return this.connectErrorCallback = t2, o2 || (o2 = n.MozWebSocket || n.WebSocket), this.websocket = new o2(this.prepareUrl() + i2), this.websocket.onopen = function() {
                  r.onOpen(), r.socket.setBuffer(false);
                }, this.websocket.onmessage = function(t3) {
                  r.onData(t3.data);
                }, this.websocket.onclose = function() {
                  r.onClose(), r.socket.setBuffer(true);
                }, this.websocket.onerror = function(t3) {
                  r.onError(t3);
                }, this;
              }, o.prototype.send = function(t2) {
                return this.websocket.send(t2), this;
              }, o.prototype.payload = function(t2) {
                for (var e2 = 0, n2 = t2.length; e2 < n2; e2++)
                  this.packet(t2[e2]);
                return this;
              }, o.prototype.close = function() {
                return this.websocket.close(), this;
              }, o.prototype.onError = function(t2) {
                void 0 !== this.connectErrorCallback && (this.connectErrorCallback(), this.connectErrorCallback = void 0), this.socket.onError(t2);
              }, o.prototype.scheme = function() {
                return this.socket.options.secure ? "wss" : "ws";
              }, o.check = function() {
                return "WebSocket" in n && !("__addTask" in WebSocket) || "MozWebSocket" in n;
              }, o.xdomainCheck = function() {
                return true;
              }, o.prototype.clearEventHandlers = function() {
                return this.websocket && (this.websocket.onopen = this.websocket.onmessage = this.websocket.onclose = this.websocket.onerror = i), this;
              }, e.transports.push("websocket");
            }(void 0 !== io ? io.Transport : module.exports, void 0 !== io ? io : module.parent.exports, void 0 === global ? window : global), function(t, e, n) {
              function o(t2) {
                t2 && (e.Transport.apply(this, arguments), this.sendBuffer = []);
              }
              function i() {
              }
              t.XHR = o, e.util.inherit(o, e.Transport), o.prototype.open = function() {
                return this.socket.setBuffer(false), this.onOpen(), this.get(), this.setCloseTimeout(), this;
              }, o.prototype.payload = function(t2) {
                for (var n2 = [], o2 = 0, i2 = t2.length; o2 < i2; o2++)
                  n2.push(e.parser.encodePacket(t2[o2]));
                this.send(e.parser.encodePayload(n2));
              }, o.prototype.send = function(t2) {
                return this.post(t2), this;
              }, o.prototype.post = function(t2) {
                function e2() {
                  4 == this.readyState && (this.onreadystatechange = i, r.posting = false, 200 == this.status ? (r.socket.setBuffer(false), clearTimeout(r.sendXHR.ackTimeoutTimer)) : r.onClose());
                }
                function o2() {
                  this.onload = i, r.socket.setBuffer(false);
                }
                var r = this;
                this.socket.setBuffer(true), this.sendXHR = this.request("POST"), n.XDomainRequest && this.sendXHR instanceof XDomainRequest ? this.sendXHR.onload = this.sendXHR.onerror = o2 : this.sendXHR.onreadystatechange = e2, this.sendXHR.send(t2), r.sendXHR.ackTimeoutTimer = setTimeout(function() {
                  r.onClose();
                }, r.socket.options.ackTimeoutMs);
              }, o.prototype.close = function() {
                return this.onClose(), this;
              }, o.prototype.request = function(t2) {
                var n2 = e.util.request(this.socket.isXDomain()), o2 = e.util.query(this.socket.options.query, "t=" + +/* @__PURE__ */ new Date());
                if (n2.open(t2 || "GET", this.prepareUrl() + o2, true), "POST" == t2)
                  try {
                    n2.setRequestHeader ? n2.setRequestHeader("Content-type", "text/plain;charset=UTF-8") : n2.contentType = "text/plain";
                  } catch (t3) {
                  }
                return n2;
              }, o.prototype.scheme = function() {
                return this.socket.options.secure ? "https" : "http";
              }, o.check = function(t2, o2) {
                try {
                  var i2 = e.util.request(o2), r = n.XDomainRequest && i2 instanceof XDomainRequest, s = t2 && t2.options && t2.options.secure ? "https:" : "http:", c = s != n.location.protocol;
                  if (i2 && (!r || !c))
                    return true;
                } catch (t3) {
                }
                return false;
              }, o.xdomainCheck = function() {
                return o.check(null, true);
              }, o.prototype.clearEventHandlers = function() {
                return this.sendXHR && (this.sendXHR.onreadystatechange = this.sendXHR.onload = i), this;
              };
            }(void 0 !== io ? io.Transport : module.exports, void 0 !== io ? io : module.parent.exports, void 0 === global ? window : global), function(t, e, n) {
              function o() {
                e.Transport.XHR.apply(this, arguments);
              }
              function i() {
              }
              t["xhr-polling"] = o, e.util.inherit(o, e.Transport.XHR), e.util.merge(o, e.Transport.XHR), o.prototype.name = "xhr-polling", o.prototype.open = function(t2) {
                var n2 = this;
                return n2.connectErrorCallback = t2, e.Transport.XHR.prototype.open.call(n2), false;
              }, o.prototype.get = function() {
                function t2() {
                  4 == this.readyState && (this.onreadystatechange = i, 200 == this.status ? (r.connectErrorCallback = void 0, r.onData(this.responseText), r.get()) : (r.onClose(), void 0 !== r.connectErrorCallback && (r.connectErrorCallback(), r.connectErrorCallback = void 0)));
                }
                function e2() {
                  r.connectErrorCallback = void 0, this.onload = i, this.onerror = i, r.onData(this.responseText), r.get();
                }
                function o2() {
                  r.onClose(), void 0 !== r.connectErrorCallback && (r.connectErrorCallback(), r.connectErrorCallback = void 0);
                }
                if (this.isOpened) {
                  var r = this;
                  this.xhr = this.request(), n.XDomainRequest && this.xhr instanceof XDomainRequest ? (this.xhr.onload = e2, this.xhr.onerror = o2) : this.xhr.onreadystatechange = t2, this.xhr.send(null);
                }
              }, o.prototype.onClose = function() {
                if (e.Transport.XHR.prototype.onClose.call(this), this.xhr) {
                  this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = i;
                  try {
                    this.xhr.abort();
                  } catch (t2) {
                  }
                  this.xhr = null;
                }
              }, o.prototype.ready = function(t2, n2) {
                var o2 = this;
                e.util.defer(function() {
                  n2.call(o2);
                });
              }, o.prototype.clearEventHandlers = function() {
                return e.Transport.XHR.prototype.clearEventHandlers.call(this), this.xhr && (this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = i), this;
              }, e.transports.push("xhr-polling");
            }(void 0 !== io ? io.Transport : module.exports, void 0 !== io ? io : module.parent.exports, void 0 === global ? window : global), exports.io = io;
          }).call(exports, __webpack_require__(4), __webpack_require__(13)(module));
        }, function(t, e, n) {
          (function(e2, o) {
            !function(e3, n2) {
              t.exports = n2();
            }(0, function() {
              function t2(t3) {
                return "function" == typeof t3 || "object" == typeof t3 && null !== t3;
              }
              function i(t3) {
                return "function" == typeof t3;
              }
              function r(t3) {
                $ = t3;
              }
              function s(t3) {
                V = t3;
              }
              function c() {
                return void 0 !== X ? function() {
                  X(u);
                } : a();
              }
              function a() {
                var t3 = setTimeout;
                return function() {
                  return t3(u, 1);
                };
              }
              function u() {
                for (var t3 = 0; t3 < J; t3 += 2) {
                  (0, Y[t3])(Y[t3 + 1]), Y[t3] = void 0, Y[t3 + 1] = void 0;
                }
                J = 0;
              }
              function h(t3, e3) {
                var n2 = arguments, o2 = this, i2 = new this.constructor(p);
                void 0 === i2[tt] && O(i2);
                var r2 = o2._state;
                return r2 ? function() {
                  var t4 = n2[r2 - 1];
                  V(function() {
                    return _(r2, i2, t4, o2._result);
                  });
                }() : b(o2, i2, t3, e3), i2;
              }
              function l(t3) {
                var e3 = this;
                if (t3 && "object" == typeof t3 && t3.constructor === e3)
                  return t3;
                var n2 = new e3(p);
                return k(n2, t3), n2;
              }
              function p() {
              }
              function d() {
                return new TypeError("You cannot resolve a promise with itself");
              }
              function f3() {
                return new TypeError("A promises callback cannot return that same promise.");
              }
              function g(t3) {
                try {
                  return t3.then;
                } catch (t4) {
                  return it.error = t4, it;
                }
              }
              function m(t3, e3, n2, o2) {
                try {
                  t3.call(e3, n2, o2);
                } catch (t4) {
                  return t4;
                }
              }
              function v(t3, e3, n2) {
                V(function(t4) {
                  var o2 = false, i2 = m(n2, e3, function(n3) {
                    o2 || (o2 = true, e3 !== n3 ? k(t4, n3) : w(t4, n3));
                  }, function(e4) {
                    o2 || (o2 = true, C(t4, e4));
                  }, "Settle: " + (t4._label || " unknown promise"));
                  !o2 && i2 && (o2 = true, C(t4, i2));
                }, t3);
              }
              function y(t3, e3) {
                e3._state === nt ? w(t3, e3._result) : e3._state === ot ? C(t3, e3._result) : b(e3, void 0, function(e4) {
                  return k(t3, e4);
                }, function(e4) {
                  return C(t3, e4);
                });
              }
              function T(t3, e3, n2) {
                e3.constructor === t3.constructor && n2 === h && e3.constructor.resolve === l ? y(t3, e3) : n2 === it ? C(t3, it.error) : void 0 === n2 ? w(t3, e3) : i(n2) ? v(t3, e3, n2) : w(t3, e3);
              }
              function k(e3, n2) {
                e3 === n2 ? C(e3, d()) : t2(n2) ? T(e3, n2, g(n2)) : w(e3, n2);
              }
              function S(t3) {
                t3._onerror && t3._onerror(t3._result), R(t3);
              }
              function w(t3, e3) {
                t3._state === et && (t3._result = e3, t3._state = nt, 0 !== t3._subscribers.length && V(R, t3));
              }
              function C(t3, e3) {
                t3._state === et && (t3._state = ot, t3._result = e3, V(S, t3));
              }
              function b(t3, e3, n2, o2) {
                var i2 = t3._subscribers, r2 = i2.length;
                t3._onerror = null, i2[r2] = e3, i2[r2 + nt] = n2, i2[r2 + ot] = o2, 0 === r2 && t3._state && V(R, t3);
              }
              function R(t3) {
                var e3 = t3._subscribers, n2 = t3._state;
                if (0 !== e3.length) {
                  for (var o2 = void 0, i2 = void 0, r2 = t3._result, s2 = 0; s2 < e3.length; s2 += 3)
                    o2 = e3[s2], i2 = e3[s2 + n2], o2 ? _(n2, o2, i2, r2) : i2(r2);
                  t3._subscribers.length = 0;
                }
              }
              function I() {
                this.error = null;
              }
              function E(t3, e3) {
                try {
                  return t3(e3);
                } catch (t4) {
                  return rt.error = t4, rt;
                }
              }
              function _(t3, e3, n2, o2) {
                var r2 = i(n2), s2 = void 0, c2 = void 0, a2 = void 0, u2 = void 0;
                if (r2) {
                  if (s2 = E(n2, o2), s2 === rt ? (u2 = true, c2 = s2.error, s2 = null) : a2 = true, e3 === s2)
                    return void C(e3, f3());
                } else
                  s2 = o2, a2 = true;
                e3._state !== et || (r2 && a2 ? k(e3, s2) : u2 ? C(e3, c2) : t3 === nt ? w(e3, s2) : t3 === ot && C(e3, s2));
              }
              function P(t3, e3) {
                try {
                  e3(function(e4) {
                    k(t3, e4);
                  }, function(e4) {
                    C(t3, e4);
                  });
                } catch (e4) {
                  C(t3, e4);
                }
              }
              function M() {
                return st++;
              }
              function O(t3) {
                t3[tt] = st++, t3._state = void 0, t3._result = void 0, t3._subscribers = [];
              }
              function U(t3, e3) {
                this._instanceConstructor = t3, this.promise = new t3(p), this.promise[tt] || O(this.promise), F(e3) ? (this._input = e3, this.length = e3.length, this._remaining = e3.length, this._result = new Array(this.length), 0 === this.length ? w(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(), 0 === this._remaining && w(this.promise, this._result))) : C(this.promise, x());
              }
              function x() {
                return new Error("Array Methods must be provided an Array");
              }
              function A(t3) {
                return new U(this, t3).promise;
              }
              function D(t3) {
                var e3 = this;
                return new e3(F(t3) ? function(n2, o2) {
                  for (var i2 = t3.length, r2 = 0; r2 < i2; r2++)
                    e3.resolve(t3[r2]).then(n2, o2);
                } : function(t4, e4) {
                  return e4(new TypeError("You must pass an array to race."));
                });
              }
              function L(t3) {
                var e3 = this, n2 = new e3(p);
                return C(n2, t3), n2;
              }
              function j2() {
                throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
              }
              function N() {
                throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
              }
              function q(t3) {
                this[tt] = M(), this._result = this._state = void 0, this._subscribers = [], p !== t3 && ("function" != typeof t3 && j2(), this instanceof q ? P(this, t3) : N());
              }
              function H() {
                var t3 = void 0;
                if (void 0 !== o)
                  t3 = o;
                else if ("undefined" != typeof self)
                  t3 = self;
                else
                  try {
                    t3 = Function("return this")();
                  } catch (t4) {
                    throw new Error("polyfill failed because global object is unavailable in this environment");
                  }
                var e3 = t3.Promise;
                if (e3) {
                  var n2 = null;
                  try {
                    n2 = Object.prototype.toString.call(e3.resolve());
                  } catch (t4) {
                  }
                  if ("[object Promise]" === n2 && !e3.cast)
                    return;
                }
                t3.Promise = q;
              }
              var B = void 0;
              B = Array.isArray ? Array.isArray : function(t3) {
                return "[object Array]" === Object.prototype.toString.call(t3);
              };
              var F = B, J = 0, X = void 0, $ = void 0, V = function(t3, e3) {
                Y[J] = t3, Y[J + 1] = e3, 2 === (J += 2) && ($ ? $(u) : Z());
              }, G = "undefined" != typeof window ? window : void 0, K = G || {}, W = K.MutationObserver || K.WebKitMutationObserver, Q = "undefined" == typeof self && void 0 !== e2 && "[object process]" === {}.toString.call(e2), z = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel, Y = new Array(1e3), Z = void 0;
              Z = Q ? function() {
                return function() {
                  return e2.nextTick(u);
                };
              }() : W ? function() {
                var t3 = 0, e3 = new W(u), n2 = document.createTextNode("");
                return e3.observe(n2, { characterData: true }), function() {
                  n2.data = t3 = ++t3 % 2;
                };
              }() : z ? function() {
                var t3 = new MessageChannel();
                return t3.port1.onmessage = u, function() {
                  return t3.port2.postMessage(0);
                };
              }() : void 0 === G ? function() {
                try {
                  var t3 = n(21);
                  return X = t3.runOnLoop || t3.runOnContext, c();
                } catch (t4) {
                  return a();
                }
              }() : a();
              var tt = Math.random().toString(36).substring(16), et = void 0, nt = 1, ot = 2, it = new I(), rt = new I(), st = 0;
              return U.prototype._enumerate = function() {
                for (var t3 = this.length, e3 = this._input, n2 = 0; this._state === et && n2 < t3; n2++)
                  this._eachEntry(e3[n2], n2);
              }, U.prototype._eachEntry = function(t3, e3) {
                var n2 = this._instanceConstructor, o2 = n2.resolve;
                if (o2 === l) {
                  var i2 = g(t3);
                  if (i2 === h && t3._state !== et)
                    this._settledAt(t3._state, e3, t3._result);
                  else if ("function" != typeof i2)
                    this._remaining--, this._result[e3] = t3;
                  else if (n2 === q) {
                    var r2 = new n2(p);
                    T(r2, t3, i2), this._willSettleAt(r2, e3);
                  } else
                    this._willSettleAt(new n2(function(e4) {
                      return e4(t3);
                    }), e3);
                } else
                  this._willSettleAt(o2(t3), e3);
              }, U.prototype._settledAt = function(t3, e3, n2) {
                var o2 = this.promise;
                o2._state === et && (this._remaining--, t3 === ot ? C(o2, n2) : this._result[e3] = n2), 0 === this._remaining && w(o2, this._result);
              }, U.prototype._willSettleAt = function(t3, e3) {
                var n2 = this;
                b(t3, void 0, function(t4) {
                  return n2._settledAt(nt, e3, t4);
                }, function(t4) {
                  return n2._settledAt(ot, e3, t4);
                });
              }, q.all = A, q.race = D, q.resolve = l, q.reject = L, q._setScheduler = r, q._setAsap = s, q._asap = V, q.prototype = { constructor: q, then: h, catch: function(t3) {
                return this.then(null, t3);
              } }, q.polyfill = H, q.Promise = q, q;
            });
          }).call(e, n(12), n(4));
        }, function(t, e) {
          function n() {
            throw new Error("setTimeout has not been defined");
          }
          function o() {
            throw new Error("clearTimeout has not been defined");
          }
          function i(t2) {
            if (h === setTimeout)
              return setTimeout(t2, 0);
            if ((h === n || !h) && setTimeout)
              return h = setTimeout, setTimeout(t2, 0);
            try {
              return h(t2, 0);
            } catch (e2) {
              try {
                return h.call(null, t2, 0);
              } catch (e3) {
                return h.call(this, t2, 0);
              }
            }
          }
          function r(t2) {
            if (l === clearTimeout)
              return clearTimeout(t2);
            if ((l === o || !l) && clearTimeout)
              return l = clearTimeout, clearTimeout(t2);
            try {
              return l(t2);
            } catch (e2) {
              try {
                return l.call(null, t2);
              } catch (e3) {
                return l.call(this, t2);
              }
            }
          }
          function s() {
            g && d && (g = false, d.length ? f3 = d.concat(f3) : m = -1, f3.length && c());
          }
          function c() {
            if (!g) {
              var t2 = i(s);
              g = true;
              for (var e2 = f3.length; e2; ) {
                for (d = f3, f3 = []; ++m < e2; )
                  d && d[m].run();
                m = -1, e2 = f3.length;
              }
              d = null, g = false, r(t2);
            }
          }
          function a(t2, e2) {
            this.fun = t2, this.array = e2;
          }
          function u() {
          }
          var h, l, p = t.exports = {};
          !function() {
            try {
              h = "function" == typeof setTimeout ? setTimeout : n;
            } catch (t2) {
              h = n;
            }
            try {
              l = "function" == typeof clearTimeout ? clearTimeout : o;
            } catch (t2) {
              l = o;
            }
          }();
          var d, f3 = [], g = false, m = -1;
          p.nextTick = function(t2) {
            var e2 = new Array(arguments.length - 1);
            if (arguments.length > 1)
              for (var n2 = 1; n2 < arguments.length; n2++)
                e2[n2 - 1] = arguments[n2];
            f3.push(new a(t2, e2)), 1 !== f3.length || g || i(c);
          }, a.prototype.run = function() {
            this.fun.apply(null, this.array);
          }, p.title = "browser", p.browser = true, p.env = {}, p.argv = [], p.version = "", p.versions = {}, p.on = u, p.addListener = u, p.once = u, p.off = u, p.removeListener = u, p.removeAllListeners = u, p.emit = u, p.prependListener = u, p.prependOnceListener = u, p.listeners = function(t2) {
            return [];
          }, p.binding = function(t2) {
            throw new Error("process.binding is not supported");
          }, p.cwd = function() {
            return "/";
          }, p.chdir = function(t2) {
            throw new Error("process.chdir is not supported");
          }, p.umask = function() {
            return 0;
          };
        }, function(t, e) {
          t.exports = function(t2) {
            return t2.webpackPolyfill || (t2.deprecate = function() {
            }, t2.paths = [], t2.children || (t2.children = []), Object.defineProperty(t2, "loaded", { enumerable: true, get: function() {
              return t2.l;
            } }), Object.defineProperty(t2, "id", { enumerable: true, get: function() {
              return t2.i;
            } }), t2.webpackPolyfill = 1), t2;
          };
        }, function(t, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = n(3), i = n(1), r = n(0), s = function() {
            function t2(t3) {
              this.id = t3, this.status = 200, this.headers = {}, this.body = "";
            }
            return t2;
          }();
          e.ResponseData = s;
          var c;
          !function(t2) {
            t2.Connected = "trouter_js_client_connected", t2.Disconnected = "trouter_js_client_disconnected", t2.Error = "trouter_js_client_error", t2.Progress = "trouter_js_client_progress", t2.Response = "trouter_js_client_response", t2.Request = "trouter_js_client_request", t2.CheckConnection = "trouter_js_client_check_connection", t2.Registration = "trouter_js_client_registration", t2.Unregistration = "trouter_js_client_unregistration";
          }(c = e.ClientEventName || (e.ClientEventName = {}));
          var a = function() {
            function t2(t3, e2, n2, o2, i2) {
              this.stepName = t3, this.operation = e2, this.delta = n2, this.ts = o2, this.error = i2;
            }
            return t2;
          }();
          e.TrackerStep = a;
          var u = function() {
            function t2() {
            }
            return t2;
          }();
          e.Properties = u;
          var h = function() {
            function t2() {
              this.numberOfPingReplies = 0, this.connectedTimestamp = 0, this.isNewUrl = false, this.transportType = "", this.connectionNumber = 0;
            }
            return t2;
          }(), l = function() {
            function t2() {
              this.enabled = false, this.numberOfStepsToMaintain = 40, this.logHealthCheckError = false, this.sendProgressTimeoutSecs = 55, this.logSendPingError = false, this.maxBackoffInMs = 12e4, this.trouter_js_client_connected = false, this.trouter_js_client_disconnected = false, this.trouter_js_client_error = false, this.trouter_js_client_progress = false, this.trouter_js_client_response = false, this.trouter_js_client_request = false, this.trouter_js_client_registration = false, this.trouter_js_client_unregistration = false, this.trouter_js_client_check_connection = true;
            }
            return t2;
          }(), p = function() {
            function t2(t3, e2, n2, i2, s2, c2, a2) {
              this.clientId = e2, this.clientInfo = n2, this.getServerState = i2, this.endpointId = s2, this.clientCorrelationID = c2, this.environment = a2, this.logger = new r.Logger("ConnectionTracker", t3), this.clientCorrelationID = void 0 !== c2 ? c2 : "", this.steps = [], this.connectionAttempt = 0, this.totalStepCount = 0, this.beginTimestamp = new o.Timespan(), this.eventLogSettings = new l(), this.connectedInfo = new h();
            }
            return t2.prototype.enable = function(t3) {
              this.eventLogSettings.enabled = true, this.eventLogger = t3;
            }, t2.prototype.disable = function() {
              this.eventLogSettings.enabled = false;
            }, t2.prototype.sendProgress = function(t3) {
              this.steps.length > 0 && this.sendTelemetry(c.Progress, t3, this.steps);
            }, t2.prototype.cancelProgressTimer = function() {
              void 0 !== this.progressTimeout && (clearTimeout(this.progressTimeout), this.progressTimeout = void 0);
            }, t2.prototype.resetProgressSendTimer = function() {
              var t3 = this;
              this.cancelProgressTimer(), void 0 !== this.eventLogSettings.sendProgressTimeoutSecs && this.eventLogSettings.sendProgressTimeoutSecs > 0 && (this.progressTimeout = setTimeout(function() {
                t3.sendProgress({ reason: "timeout", timeoutSecs: t3.eventLogSettings.sendProgressTimeoutSecs });
              }, 1e3 * this.eventLogSettings.sendProgressTimeoutSecs));
            }, t2.prototype.setConnectedInfo = function(t3, e2) {
              this.connectedInfo.numberOfPingReplies = 0, this.connectedInfo.connectedTimestamp = Date.now(), this.connectedInfo.isNewUrl = t3, this.connectedInfo.transportType = e2, ++this.connectedInfo.connectionNumber;
            }, t2.prototype.clearConnectedInfo = function() {
              this.connectedInfo.numberOfPingReplies = 0, this.connectedInfo.connectedTimestamp = 0, this.connectedInfo.isNewUrl = true, this.connectedInfo.transportType = "";
            }, t2.prototype.copyProperties = function(t3, e2) {
              for (var n2 = 0, o2 = Object.keys(e2); n2 < o2.length; n2++) {
                var i2 = o2[n2];
                e2.hasOwnProperty(i2) && void 0 !== e2[i2] && (t3[i2.replace(/-/g, "_")] = { value: e2[i2] });
              }
            }, t2.prototype.increasePingResponseCount = function() {
              ++this.connectedInfo.numberOfPingReplies;
            }, t2.prototype.sendTelemetry = function(t3, e2, n2) {
              try {
                if (true === this.eventLogSettings.enabled && true === this.eventLogSettings[t3] && void 0 !== this.eventLogger) {
                  var r2 = this.getServerState(), s2 = { name: t3, properties: { connectionAttempt: { value: this.connectionAttempt }, epid: { value: this.endpointId }, clientCorrelationID: { value: this.clientCorrelationID }, steps: { value: o.toJson(n2) }, clientID: { value: this.clientId }, eventVersion: { value: 3 }, environment: { value: this.environment }, cv: { value: i.CLIENT_VERSION }, ua: { value: this.clientInfo.ua }, connectionId: { value: r2.connectionId }, connectedClientId: { value: r2.connectedClientId }, domId: { value: r2.domId }, url: { value: r2.unsecureUrl }, surl: { value: r2.url }, ttlInSecs: { value: r2.getRemainingTtlInSec() }, numberOfPingReplies: { value: this.connectedInfo.numberOfPingReplies }, connectedTimestamp: { value: this.connectedInfo.connectedTimestamp }, isNewUrl: { value: this.connectedInfo.isNewUrl }, transportType: { value: this.connectedInfo.transportType }, connectionNumber: { value: this.connectedInfo.connectionNumber } } };
                  this.copyProperties(s2.properties, e2), this.eventLogger.logEvent(s2);
                }
              } catch (e3) {
                this.logger.warn("error in sending event " + t3 + ": " + o.toJson(e3));
              }
            }, t2.prototype.createStep = function(t3, e2, n2) {
              return new a(t3, e2, this.beginTimestamp.duration, Date.now(), n2);
            }, t2.prototype.addStep = function(t3, e2, n2) {
              if (false !== this.eventLogSettings.enabled && (0 === this.steps.length && this.beginTimestamp.reset(), this.steps.push(this.createStep(t3, e2, n2)), ++this.totalStepCount, void 0 !== this.eventLogSettings.numberOfStepsToMaintain && this.steps.length > this.eventLogSettings.numberOfStepsToMaintain)) {
                var o2 = this.steps.slice(0);
                this.steps.length = 0, this.sendTelemetry(c.Progress, { reason: "flush" }, o2);
              }
            }, t2.prototype.trackStart = function(t3) {
              this.addStep(t3, "start");
            }, t2.prototype.trackEnd = function(t3) {
              this.addStep(t3, "end");
            }, t2.prototype.trackError = function(t3, e2, n2, o2) {
              void 0 === n2 && (n2 = true), "health" === t3 && true !== this.eventLogSettings.logHealthCheckError || "ping" === t3 && false === this.eventLogSettings.logSendPingError || (void 0 === o2 && (o2 = "error"), true === n2 && this.addStep(t3, o2, e2), this.sendTelemetry(c.Error, {}, [this.createStep(t3, o2, e2)]));
            }, t2.prototype.trackProgress = function(t3, e2) {
              this.addStep(t3, e2);
            }, t2.prototype.trackConnected = function(t3, e2) {
              this.setConnectedInfo(t3, e2);
              var n2 = this.steps.slice(0), o2 = this.totalStepCount, i2 = this.beginTimestamp.duration;
              this.steps.length = 0, this.totalStepCount = 0, this.sendTelemetry(c.Connected, { stepCount: n2.length, totalStepCount: o2, connectionEstablishmentMs_Total: i2 }, n2), this.cancelProgressTimer();
            }, t2.prototype.trackDisconnected = function(t3) {
              t3.sessionLengthMS = Date.now() - this.connectedInfo.connectedTimestamp, this.sendTelemetry(c.Disconnected, t3, []), this.resetProgressSendTimer();
            }, t2.prototype.trackNewConnection = function() {
              ++this.connectionAttempt;
            }, t2.prototype.trackRequest = function(t3, e2) {
              var n2 = {};
              void 0 !== e2 && (n2.hasError = true, n2.error = e2);
              try {
                if (t3) {
                  n2.requestID = t3.id, n2.httpMethod = t3.method, n2.url = t3.url, n2.bodyLength = t3.body.length, n2.shortUrl = t3.shortUrl, n2.requestTimeStamp = t3.startTS, n2.correlationVector = t3.correlationVector;
                  for (var i2 = t3.headers, r2 = 0, s2 = Object.keys(i2); r2 < s2.length; r2++) {
                    var a2 = s2[r2];
                    i2.hasOwnProperty(a2) && (n2[a2] = i2[a2]);
                  }
                }
              } catch (t4) {
                n2.hasError = true, n2.error = n2.error + " error creating request context " + o.toJson(t4);
              }
              this.sendTelemetry(c.Request, n2, []);
            }, t2.prototype.trackResponse = function(t3, e2, n2, i2) {
              var r2 = {};
              void 0 !== i2 && (r2.hasError = true, r2.error = i2);
              try {
                if (r2.responseTimestamp = void 0 !== n2 ? n2.sentTS : Date.now(), t3) {
                  r2.requestID = t3.id, r2.httpMethod = t3.method, r2.shortUrl = t3.shortUrl, r2.correlationVector = t3.correlationVector;
                  for (var s2 = t3.headers, a2 = 0, u2 = Object.keys(s2); a2 < u2.length; a2++) {
                    var h2 = u2[a2];
                    s2.hasOwnProperty(h2) && (r2[h2] = s2[h2]);
                  }
                }
                n2 && (r2.latencyMS = e2, r2.responseCode = n2.status, r2.responseLength = n2.body.length);
              } catch (t4) {
                r2.hasError = true, r2.error = r2.error + " error creating response context " + o.toJson(t4);
              }
              this.sendTelemetry(c.Response, r2, []);
            }, t2.prototype.sendResponseError = function(t3, e2, n2) {
              this.trackResponse(e2, void 0, n2, t3);
            }, t2.prototype.close = function() {
              this.sendProgress({ reason: "closed" }), this.steps.length = 0, this.cancelProgressTimer();
            }, t2.prototype.mergeSettings = function(t3) {
              if (t3) {
                this.eventLogSettings.numberOfStepsToMaintain = Math.min(40, Math.max(10, void 0 !== t3.numberOfStepsToMaintain ? t3.numberOfStepsToMaintain : 0));
                var e2 = Math.min(3600, Math.max(55, void 0 !== t3.sendProgressTimeoutSecs ? t3.sendProgressTimeoutSecs : 0));
                this.eventLogSettings.logHealthCheckError = t3.logHealthCheckError, this.eventLogSettings.logSendPingError = t3.logSendPingError;
                for (var n2 = 0, o2 = Object.keys(c).map(function(t4) {
                  return c[t4];
                }); n2 < o2.length; n2++) {
                  var i2 = o2[n2];
                  t3.hasOwnProperty(i2) && void 0 !== t3[i2] && (this.eventLogSettings[i2] = t3[i2]);
                }
                this.eventLogSettings.sendProgressTimeoutSecs !== e2 && (this.eventLogSettings.sendProgressTimeoutSecs = e2, this.resetProgressSendTimer());
              }
            }, t2;
          }();
          e.ConnectionTracker = p;
        }, function(t, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = function() {
            function t2(t3, e2) {
              this.logger = t3, this.maxBackoffInMs = e2, this.backoffId = 0, this.backoffCount = 0;
            }
            return t2.calculateNextBackoffMs = function(t3, e2) {
              var n2 = 1 + 0.4 * (Math.random() - 0.5), o2 = 1e3 * Math.pow(2, t3) * n2;
              return o2 = Math.round(o2), Math.min(e2, o2);
            }, t2.prototype.setMaxBackoffMs = function(t3) {
              this.maxBackoffInMs = t3;
            }, t2.prototype.backoff = function(e2, n2) {
              var o2 = this;
              void 0 !== this.timerHandle && (this.logger.debug("Clearing current back off"), clearTimeout(this.timerHandle), this.timerHandle = void 0);
              var i = t2.calculateNextBackoffMs(this.backoffCount, this.maxBackoffInMs);
              this.backoffId++, this.backoffCount++, this.logger.info("Backing off " + e2 + " for " + i + " milliseconds with ID " + this.backoffId), this.timerHandle = setTimeout(function() {
                o2.logger.info("Back off for " + e2 + " with ID " + o2.backoffId + " complete, invoking handler"), o2.timerHandle = void 0, n2();
              }, i);
            }, t2.prototype.reset = function() {
              void 0 !== this.timerHandle && (this.logger.debug("Resetting back off"), clearTimeout(this.timerHandle), this.timerHandle = void 0), this.backoffCount = 0;
            }, t2;
          }();
          e.ExponentialBackoff = o;
        }, function(t, e, n) {
          var o = this && this.__assign || Object.assign || function(t2) {
            for (var e2, n2 = 1, o2 = arguments.length; n2 < o2; n2++) {
              e2 = arguments[n2];
              for (var i2 in e2)
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            }
            return t2;
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var i = n(20), r = n(11), s = n(3), c = n(14), a = n(1), u = n(15), h = n(2), l = n(5), p = n(0), d = n(17), f3 = n(10), g = function() {
            function t2() {
              this.cv = a.CLIENT_VERSION, this.ua = "", this.hr = "", this.v = "";
            }
            return t2;
          }(), m = function() {
            function t2() {
              this["force new connection"] = true, this.reconnect = false, this.query = "", this.ackTimeoutMs = 5e3;
            }
            return t2;
          }(), v = "MS-CV", y = function() {
            function t2(t3) {
              this.cvCounter = 0;
              var e2 = JSON.parse(t3);
              this.startTS = e2.hasOwnProperty("startTS") ? e2.startTS : 0, this.url = e2.hasOwnProperty("url") ? e2.url : "", this.shortUrl = e2.hasOwnProperty("shortUrl") ? e2.shortUrl : "", this.body = e2.hasOwnProperty("body") ? e2.body : "", this.headers = e2.hasOwnProperty("headers") ? e2.headers : {}, this.id = e2.hasOwnProperty("id") && "number" == typeof e2.id ? e2.id : -1, this.method = e2.hasOwnProperty("method") ? e2.method : "", this.replied = false, this.timedout = false, this.timeoutTimerId = 0, this.receivedCv = this.headers[v], this.updateCvHeader();
            }
            return Object.defineProperty(t2.prototype, "correlationVector", { get: function() {
              return this.receivedCv ? this.receivedCv + "." + this.cvCounter : "";
            }, enumerable: true, configurable: true }), t2.prototype.on = function(t3, e2) {
              "data" === t3 ? this.dataCallback = e2 : "end" === t3 && ("function" == typeof this.dataCallback && this.dataCallback(this.body), e2());
            }, t2.prototype.incrementCorrelationVector = function() {
              ++this.cvCounter, this.updateCvHeader();
            }, t2.prototype.updateCvHeader = function() {
              var t3 = this.correlationVector;
              t3 && (this.headers[v] = t3);
            }, t2;
          }(), T = function() {
            function t2(t3, e2, n2) {
              this.request = t3, this.responseData = e2, this.sendResponse = n2;
            }
            return t2.prototype.writeHead = function(t3, e2) {
              this.responseData.status = t3, this.responseData.headers = e2;
            }, t2.prototype.write = function(t3) {
              this.responseData.body += t3;
            }, t2.prototype.end = function(t3) {
              return t3 && (this.responseData.body += t3), this.sendResponse(this.request, this.responseData);
            }, t2;
          }(), k = function() {
            function t2(t3) {
              this.name = t3, this.args = {}, this.timeoutTimerId = 0;
            }
            return t2;
          }(), S = function() {
            function t2(t3, e2, n2, o2, r2) {
              var s2 = this;
              this.options = e2, this.manager = n2, this.tokenProvider = o2, this.connectionId = "", this.inIncallMode = false, this.connectionAttempt = 0, this.connectedClientId = "", this.c2cUrlBase = "", this.pendingTimers = {}, this.lastDisconnectReason = "", this.UNKNOWN_TRANSPORT = "unknown_transport", this.logger = new p.Logger("Connection", t3), this.timeoutOptions = this.options.timeoutOptions, this.healthBackoff = new u.ExponentialBackoff(this.logger, this.timeoutOptions.maxBackoffMs), this.tokenBackoff = new u.ExponentialBackoff(this.logger, this.timeoutOptions.maxBackoffMs), this.clientID = Date.now(), "undefined" != typeof window && window.location && (this.domId = window.location.hostname), this.clientInfo = new g(), this.clientInfo.cv = a.CLIENT_VERSION, this.clientInfo.ua = "", this.options && this.options.clientInfo && (this.clientInfo.ua = this.safeString(this.options.clientInfo.ua), this.clientInfo.v = this.safeString(this.options.clientInfo.v)), this.connectionTracker = new c.ConnectionTracker(t3, this.clientID, this.clientInfo, function() {
                return s2.getServerState();
              }, this.options.endpointId, this.options.clientCorrelationID, this.options.environment), this.applyConnectionTrackerOptions(e2);
              var h2 = this.options.incallModeTimeoutMs > 0;
              if (this.fsm = new d.TrouterFsm(t3, this, h2), e2.registration) {
                var l2 = { registrarUrl: e2.registration.registrarUrl, registrationId: e2.registration.registrationId, requestTimeoutMs: e2.timeoutOptions.fetchTimeoutMs, initialRetryDelayMs: 1e3, maxRetryDelayMs: e2.timeoutOptions.maxBackoffMs };
                this.registrarClient = i.createRegistrarClient(t3, this.tokenProvider, l2);
              }
              this.userActivityState = r2;
            }
            return t2.prototype.start = function(t3) {
              this.logger.info("Starting"), this.externalConnectParams = t3, this.fsm.start();
            }, t2.prototype.stop = function(t3) {
              this.logger.info("Stopping"), this.connectionTracker.close(), this.fsm.stop(t3);
            }, t2.prototype.configure = function(t3) {
              var e2 = this.options.trouterUrl !== t3.trouterUrl;
              this.options = t3, this.applyConnectionTrackerOptions(t3), e2 && this.onTrouterReconnect();
            }, t2.prototype.checkConnection = function(t3) {
              this.logger.info("checkConnection called with " + t3), this.fsm.checkConnection(t3), t3 && this.connectionTracker.sendTelemetry(c.ClientEventName.CheckConnection, { disconnectDetected: t3 }, []);
            }, t2.prototype.getServerState = function() {
              return new l.ServerState(this.connectionId, this.connectedClientId, this.domId ? this.domId : "", this.allocateResult ? this.allocateResult.url : "", this.allocateResult ? this.allocateResult.surl : "", this.c2cUrlBase, this.connectionExpireTimestampInSecs);
            }, t2.prototype.getToken = function(t3, e2) {
              var n2 = this;
              this.logger.info("Getting token " + (e2 ? "with backoff" : "without backoff"));
              var o2 = function() {
                n2.connectionTracker.trackStart("token"), n2.tokenProvider(!t3).then(function(t4) {
                  n2.logger.debug("token is received"), n2.connectionTracker.trackEnd("token"), n2.fsm.onTokenReceived(t4);
                }).catch(function(e3) {
                  var o3 = s.toJson(e3.stack);
                  n2.logger.error("Getting token failed, will retry after timeout. Error: " + o3), n2.connectionTracker.trackError("token", o3), n2.getToken(t3, true);
                });
              };
              e2 ? this.tokenBackoff.backoff("getting token", o2) : (this.tokenBackoff.reset(), o2());
            }, t2.prototype.startConnectionTimer = function() {
              var t3 = this;
              this.stopConnectionTimer(), this.logger.debug("Starting connection timeout for " + this.timeoutOptions.connectionTimeoutMs + " ms"), this.connectionTimeoutId = setTimeout(function() {
                t3.logger.info("Connection timeout is fired"), t3.fsm.onConnectingTimeout();
              }, this.timeoutOptions.connectionTimeoutMs);
            }, t2.prototype.stopConnectionTimer = function() {
              this.connectionTimeoutId && (this.logger.debug("Stopping connection timeout"), clearTimeout(this.connectionTimeoutId), this.connectionTimeoutId = void 0);
            }, t2.prototype.startPingTimer = function() {
              var t3 = this;
              "websocket" === this.transportTypeName ? (this.logger.debug("Starting ping timeout for " + this.timeoutOptions.pingTimeoutMs + " ms"), this.pingTimerId = setInterval(function() {
                t3.logger.info("Ping interval fired"), t3.fsm.onPingInterval();
              }, this.timeoutOptions.pingTimeoutMs)) : this.logger.debug("Not starting ping for transport " + this.transportTypeName);
            }, t2.prototype.stopPingTimer = function() {
              this.pingTimerId && (this.logger.debug("Stopping ping timeout"), this.clearPingResponseTimer(), clearInterval(this.pingTimerId), this.pingTimerId = void 0);
            }, t2.prototype.shouldSkipRegistration = function() {
              return void 0 === this.options.registration;
            }, t2.prototype.hasCustomRegisterTtl = function() {
              return this.options.registration && this.options.registration.registrarTtlSec;
            }, t2.prototype.startRegisterTimer = function() {
              var t3 = this;
              void 0 !== this.registrationTimerId && this.stopRegisterTimer();
              var e2 = this.getRegistrationTtl() - 30;
              this.logger.debug("Starting registration timeout for " + e2 + " sec"), this.registrationTimerId = setTimeout(function() {
                t3.logger.info("Registration timeout is fired"), t3.registrationTimerId = setTimeout(function() {
                  t3.registrationTimerId = void 0, t3.logger.debug("Re-registration did not happen in time"), t3.dispatchUnregistered();
                }, 3e4), t3.fsm.onRegistrationTimeout();
              }, 1e3 * e2);
            }, t2.prototype.stopRegisterTimer = function() {
              this.registrationTimerId && (this.logger.debug("Stopping registration timeout"), clearTimeout(this.registrationTimerId), this.registrationTimerId = void 0);
            }, t2.prototype.resendRegistration = function() {
              if (!this.registrarClient)
                throw new Error("Trouter Client not configured to handle registrations");
              return this.registrarClient.resendRegistration();
            }, t2.prototype.buildSocketIoUrlParams = function() {
              if (!this.allocateResult)
                throw new Error("Allocate result is undefined in buildSocketIoUrlParams()");
              var t3 = {};
              if (this.allocateResult.connectparams)
                for (var e2 = this.allocateResult.connectparams, n2 = 0, o2 = Object.keys(e2); n2 < o2.length; n2++) {
                  var i2 = o2[n2];
                  e2.hasOwnProperty(i2) && void 0 !== e2[i2] && (t3[i2] = e2[i2]);
                }
              return t3.v = "v4", t3.tc = encodeURI(s.toJson(this.clientInfo)), t3.timeout = this.timeoutOptions.pingTimeoutMs / 1e3, t3.auth = "true", this.options.endpointId && (t3.epid = this.options.endpointId), this.userActivityState.state !== h.UserActivityState.Unknown && (t3.userActivity = encodeURI(s.toJson(this.userActivityState.toEventObject()))), this.appendConnectedClientIds(this.buildQuery(t3), true);
            }, t2.prototype.startSocketIo = function() {
              var t3 = this;
              if (this.logger.info("Starting socket io"), this.connectionTracker.trackStart("connectSocket"), !this.allocateResult)
                throw new Error("Allocate result is undefined in startSocketIo()");
              var e2 = this.options.ioOptions || new m();
              if (e2["force new connection"] = true, e2.reconnect = false, e2.query = this.buildSocketIoUrlParams(), this.logger.info("connecting to " + this.allocateResult.socketio + "?" + e2.query), this.stopSocketIo(), this.socket = (this.options.io || f3).connect(this.allocateResult.socketio, e2), void 0 === this.socket)
                throw new Error("Can't create Socket.io object");
              this.socket.on("connecting", function(e3) {
                t3.onSocketConnecting(e3);
              }), this.socket.on("connect", function() {
                t3.onSocketConnect();
              }), this.socket.on("connect_failed", function(e3) {
                t3.onSocketConnectFailed(e3);
              }), this.socket.on("disconnect", function(e3) {
                t3.onSocketDisconnect(e3);
              }), this.socket.on("reconnect", function() {
                t3.onSocketReconnect();
              }), this.socket.on("reconnect_failed", function(e3) {
                t3.onSocketReconnectFailed(e3);
              }), this.socket.on("reconnecting", function() {
                t3.onSocketReconnecting();
              }), this.socket.on("error", function(e3) {
                t3.onSocketError(e3);
              }), this.socket.on("message", function(e3) {
                t3.onSocketMessage(e3);
              }), this.socket.on("trouter.connected", function(e3) {
                t3.onTrouterConnected(e3);
              }), this.socket.on("trouter.reconnect", function() {
                t3.onTrouterReconnect();
              }), this.socket.on("trouter.message_loss", function(e3) {
                t3.onTrouterMessageLoss(e3);
              });
            }, t2.prototype.stopSocketIo = function() {
              if (this.socket) {
                this.logger.info("clearing socket.io");
                try {
                  for (var t3 = 0, e2 = ["connecting", "connect", "connect_failed", "disconnect", "reconnect", "reconnect_failed", "reconnecting", "error", "message", "trouter.connected", "trouter.reconnect", "trouter.message_loss"]; t3 < e2.length; t3++) {
                    var n2 = e2[t3];
                    this.socket.removeAllListeners(n2);
                  }
                  this.socket.disconnect(), this.logger.debug("cleared socket"), this.socket = void 0;
                } catch (t4) {
                  this.logger.error("exception in disconnecting previous socket. Error: " + s.toJson(t4.stack));
                }
              }
            }, t2.prototype.dispatchConnected = function() {
              this.logger.info("dispatching connected"), this.manager.onConnected(this);
            }, t2.prototype.dispatchRegistered = function() {
              this.logger.info("dispatching registered"), this.manager.onRegistered(this);
            }, t2.prototype.dispatchUnregistered = function() {
              this.logger.info("dispatching unregistered"), this.manager.onUnregistered(this);
            }, t2.prototype.dispatchDownstreamRequest = function(t3) {
              var e2 = this;
              this.logger.info("dispatching downstream request");
              try {
                var n2 = new T(t3, new c.ResponseData(t3.id), function(t4, n3) {
                  return e2.logger.info("sending response to downstream"), e2.sendResponse(t4, n3);
                });
                this.manager.onDownstreamRequest(this, t3, n2);
              } catch (t4) {
                this.logger.error("exception in socket.on message. Error : " + s.toJson(t4.stack));
              }
            }, t2.prototype.dispatchReconnecting = function() {
              this.logger.info("dispatching reconnecting"), this.manager.onReconnecting(this);
            }, t2.prototype.dispatchReconnectIsRequired = function() {
              this.logger.info("dispatching reconnect is required by server"), this.manager.onReconnectIsRequired(this);
            }, t2.prototype.dispatchDisconnected = function() {
              this.logger.info("dispatching disconnected"), this.manager.onDisconnected(this);
            }, t2.prototype.dispatchTrouterMessageLost = function(t3) {
              this.logger.info("dispatching trouter lost message"), this.manager.onTrouterMessageLost(t3);
            }, t2.prototype.sendProcessedDroppedIndicators = function(t3) {
              var e2 = this;
              try {
                this.logger.info("emitting processed flow tags to the server");
                var n2 = new k("trouter.processed_message_loss");
                n2.args = { droppedIndicators: t3 }, this.sendDownstreamEvent(n2, function() {
                  e2.logger.info("emitted processed flow tags to the server");
                });
              } catch (t4) {
                var o2 = s.toJson(t4.stack);
                this.logger.error("unable to send processed message loss event. Error: " + o2), this.connectionTracker.trackError("trouter.processed_message_loss", o2, false);
              }
            }, t2.prototype.resetAllocationConnectionParams = function() {
              this.allocateResult && (this.logger.info("Resetting allocation connection parameters"), this.allocateResult.connectparams = void 0);
            }, t2.prototype.sendAllocateRequest = function(t3) {
              var e2 = this;
              this.connectionAttempt++, this.connectionTracker.trackNewConnection();
              var n2 = this.options.trouterUrl, i2 = n2, r2 = this.allocateResult && this.allocateResult.connectparams;
              if (!r2) {
                var s2 = this.externalConnectParams;
                s2 && s2.se && parseInt(s2.se, 10) <= Date.now() + 36e5 && (this.logger.warn("Dropping expired cached connection parameters: " + new Date(parseInt(s2.se, 10))), this.externalConnectParams = s2 = void 0), s2 && s2.serviceUrl !== i2 && (this.logger.warn("Dropping cached connection parameters for a different environment (" + s2.serviceUrl + ", now " + i2 + ")"), this.externalConnectParams = s2 = void 0), s2 && s2.reconnectUrl ? (i2 = s2.reconnectUrl, r2 = o({}, s2, { reconnectUrl: void 0 })) : r2 = s2;
              }
              i2 = this.appendCorrelationIds(i2, false), i2 = this.appendEndpointId(i2, false), r2 && (i2 += "&" + this.buildQuery(r2), r2.v || (i2 += "&v=v4"));
              var c2 = new Request(i2, { method: "POST", mode: "cors", headers: new Headers({ "X-Skypetoken": t3, "Content-Type": "text/plain" }) });
              this.logger.info("sendAllocateRequest: POST " + i2), this.connectionTracker.trackStart("allocation");
              var a2 = -1;
              this.fetchWithTimeout(c2, this.timeoutOptions.fetchTimeoutMs).then(function(t4) {
                if (a2 = t4.status, !t4.ok)
                  throw new Error(t4.statusText);
                var n3 = t4.headers.get("content-type");
                if (!n3 || "application/json" !== n3 && "application/json;" !== n3.substring(0, 17))
                  throw new Error("Content-type '" + n3 + "' is unexpected");
                return e2.connectionTracker.trackEnd("allocation"), t4.json();
              }).then(function(t4) {
                e2.onAllocationResponse(t4, n2);
              }).catch(function(t4) {
                var n3 = t4 + ", status code " + a2;
                e2.logger.error("Allocation request failed. Error: " + n3), e2.connectionTracker.trackError("allocation", n3), e2.externalConnectParams && e2.connectionAttempt > 2 && (a2 >= 400 && a2 <= 599 ? (e2.logger.warn(e2.connectionAttempt + " connection attempts, server-side failure: erasing external connection parameters"), e2.externalConnectParams = void 0) : e2.externalConnectParams.reconnectUrl && (e2.logger.warn(e2.connectionAttempt + " connection attempts, erasing reconnect URL"), delete e2.externalConnectParams.reconnectUrl)), e2.fsm.onAllocationFailed(401 === a2);
              });
            }, t2.prototype.sendPingRequest = function() {
              var t3 = this;
              if (this.socket && void 0 === this.pingResponseTimerId)
                try {
                  this.logger.info("emitting ping event"), this.socket.emit("ping", function() {
                    t3.onPingResponse();
                  }), this.pingResponseTimerId = setTimeout(function() {
                    t3.logger.error("Ping response timeout is fired"), t3.clearPingResponseTimer(), t3.fsm.onPingResponseTimeout();
                  }, this.timeoutOptions.pongTimeoutMs);
                } catch (t4) {
                  var e2 = s.toJson(t4.stack);
                  this.logger.error("unable to send ping. Error: " + e2), this.connectionTracker.trackError("ping", e2, false);
                }
            }, t2.prototype.setUserActivityState = function(t3) {
              var e2 = t3.state !== this.userActivityState.state;
              this.userActivityState = t3, this.fsm.onSetUserActivityState(t3, e2);
            }, t2.prototype.sendUserActivityState = function(t3, e2) {
              this.userActivityState.state !== h.UserActivityState.Unknown && ("websocket" === this.transportTypeName && e2 ? t3 === l.UserActivityEventReason.Connected ? this.sendUserActivityStateMultiple(2) : this.sendUserActivityStateMultiple(1) : "xhr-polling" === this.transportTypeName && t3 === l.UserActivityEventReason.Modified && this.fsm.forceReconnect());
            }, t2.prototype.sendRegisterRequest = function() {
              var t3 = this;
              if (!this.options.registration || !this.registrarClient)
                throw new Error("Internal error - options.registration is undefined");
              if (!this.allocateResult)
                throw new Error("Allocate result is undefined in sendRegisterRequest()");
              this.logger.info("sending register request");
              var e2 = new s.Timespan();
              this.connectionTracker.trackStart("registration"), this.registrarClient.register({ appId: this.options.registration.pnhAppId, aesKey: "", languageId: "en-US", platform: this.options.registration.platform, templateKey: this.options.registration.pnhTemplateKey, platformUIVersion: this.options.registration.platformUIVersion, productContext: this.options.registration.productContext }, { TROUTER: [{ context: this.options.registration.context, path: this.allocateResult.surl, ttl: this.getRegistrationTtl() }] }).then(function() {
                t3.logger.info("Register request successful"), t3.connectionTracker.trackEnd("registration"), t3.fsm.onRegistrationSucceed(), t3.connectionTracker.sendTelemetry(c.ClientEventName.Registration, { duration: e2.duration }, []);
              }).catch(function(n2) {
                t3.logger.error("Register request failed. Error: " + n2), t3.connectionTracker.trackError("registration", n2.message), t3.fsm.onRegistrationFailed(false), t3.connectionTracker.sendTelemetry(c.ClientEventName.Registration, { duration: e2.duration }, []);
              });
            }, t2.prototype.sendUnregisterRequest = function() {
              var t3 = this;
              this.logger.info("sending unregister request");
              var e2 = new s.Timespan();
              if (!this.options.registration || !this.registrarClient)
                throw new Error("Internal error - options.registration is undefined");
              this.connectionTracker.trackStart("unregistration"), this.registrarClient.unregister().then(function() {
                t3.logger.info("Unregister request successful"), t3.connectionTracker.trackEnd("unregistration"), t3.fsm.onUnregistrationSucceed(), t3.connectionTracker.sendTelemetry(c.ClientEventName.Unregistration, { duration: e2.duration }, []);
              }).catch(function(n2) {
                t3.logger.error("Unregister request failed. Error: " + n2), t3.connectionTracker.trackError("unregistration", n2.message), t3.fsm.onUnregistrationFailed(false), t3.connectionTracker.sendTelemetry(c.ClientEventName.Unregistration, { duration: e2.duration }, []);
              });
            }, t2.prototype.fetchWithTimeout = function(t3, e2) {
              return new r.Promise(function(n2, o2) {
                fetch(t3).then(n2).catch(o2), 0 !== e2 && setTimeout(o2, e2, new Error("Fetch for '" + t3.url + "' timed out"));
              });
            }, t2.prototype.resetTokenBackoff = function() {
              this.tokenBackoff.reset();
            }, t2.prototype.resetRegisterBackoff = function() {
              this.registrarClient && this.registrarClient.cancelPendingRequests();
            }, t2.prototype.clearTimers = function() {
              this.logger.debug("Clearing all pending downstream events related timers");
              for (var t3 = 0, e2 = Object.keys(this.pendingTimers); t3 < e2.length; t3++) {
                var n2 = e2[t3];
                this.clearTimer(Number(n2));
              }
            }, t2.prototype.restartIncallModeTimer = function() {
              var t3 = this;
              this.clearIncallModeTimerId(), this.logger.debug("Restarting incall mode timer"), this.incallModeTimerId = setTimeout(function() {
                t3.logger.info("Call mode timer fired"), t3.fsm.onIncallModeTimer();
              }, this.options.incallModeTimeoutMs);
            }, t2.prototype.enterIncallMode = function() {
              this.logger.info("Entering incall mode"), this.timeoutOptions = this.options.incallTimeoutOptions, this.healthBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.inIncallMode = true;
            }, t2.prototype.exitIncallMode = function() {
              this.logger.info("Exiting incall mode"), this.clearIncallModeTimerId(), this.timeoutOptions = this.options.timeoutOptions, this.healthBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.inIncallMode = false;
            }, t2.prototype.isIncallMode = function() {
              return this.inIncallMode;
            }, t2.prototype.onSocketConnecting = function(t3) {
              this.logger.info("onSocketConnecting(" + t3 + ")"), this.transportTypeName = t3, this.connectionTracker.trackProgress("connecting", this.transportTypeName), this.fsm.onConnecting();
            }, t2.prototype.onSocketConnect = function() {
              this.logger.info("onSocketConnect");
            }, t2.prototype.onSocketConnectFailed = function(t3) {
              this.logger.error("onSocketConnectFailed"), this.connectionTracker.trackError("connect_failed", t3, true, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT), this.fsm.onConnectingFailed();
            }, t2.prototype.onSocketDisconnect = function(t3) {
              this.logger.error("onSocketDisconnect, reason: " + t3);
              var e2 = { reason: t3, serverClosed: !this.fsm.isActive() };
              this.connectionTracker.trackDisconnected(e2), this.connectionTracker.clearConnectedInfo();
              var n2 = e2.sessionLengthMS || 0;
              "dup" === t3 && "dup" === this.lastDisconnectReason && n2 < this.options.duplicateDisconnectThresholdMs && (this.logger.warn("Socket was closed by server as Duplicate for the second time in a row after " + n2 + " ms which is below the threshold of " + this.options.duplicateDisconnectThresholdMs + " ms. Resetting cached connection parameters and making a new allocation."), this.resetAllocationConnectionParams()), this.lastDisconnectReason = t3, this.fsm.onSocketError(void 0), this.connectionExpireTimestampInSecs = void 0;
            }, t2.prototype.onSocketReconnect = function() {
              this.logger.error("onSocketReconnect"), this.fsm.onTrouterConnected();
            }, t2.prototype.onSocketReconnectFailed = function(t3) {
              this.logger.error("onSocketReconnectFailed with '" + t3 + "'"), this.fsm.onSocketError("string" == typeof t3 ? t3 : void 0);
            }, t2.prototype.onSocketReconnecting = function() {
              this.logger.error("onSocketReconnecting");
            }, t2.prototype.onSocketError = function(t3) {
              this.logger.error("onSocketError with '" + s.toJson(t3) + "'"), this.connectionTracker.trackError("connectSocket", t3), this.fsm.onSocketError("string" == typeof t3 ? t3 : void 0);
            }, t2.prototype.onSocketMessage = function(t3) {
              var e2 = this;
              this.logger.info("onSocketMessage");
              var n2;
              try {
                n2 = new y(t3);
                var o2 = n2.headers && n2.headers["X-Microsoft-Skype-Chain-ID"], i2 = o2 ? " Chain-Id " + o2 : "";
                this.logger.info("Received request N " + n2.id + i2 + " CV " + n2.correlationVector + " to '" + n2.url + "'"), n2.startTS = Date.now(), n2.url && this.urlPath && 0 === n2.url.indexOf(this.urlPath) && (n2.shortUrl = n2.url.substring(this.urlPath.length));
              } catch (t4) {
                var r2 = s.toJson(t4.stack);
                return this.logger.error("unable to parse request. Error: " + r2), this.connectionTracker.trackRequest(void 0, r2), void this.connectionTracker.sendResponseError("unable to parse request, error: " + t4);
              }
              n2.timeoutTimerId = setTimeout(function() {
                if (!n2.replied) {
                  e2.logger.error("Request " + n2.id + " timed out");
                  var t4 = new c.ResponseData(n2.id);
                  t4.status = 504, t4.headers = { "Trouter-Responder": "ClientLib" }, e2.sendResponse(n2, t4), n2.timedout = true;
                }
              }, this.timeoutOptions.requestTimeoutMs);
              try {
                this.connectionTracker.trackRequest(n2), this.fsm.onDownstreamRequest(n2);
              } catch (t4) {
                this.logger.error("exception in socket.on message. Error: " + s.toJson(t4.stack)), this.connectionTracker.sendResponseError(t4.message, n2, void 0);
              }
            }, t2.prototype.onTrouterConnected = function(t3) {
              if (!this.allocateResult)
                return void this.logger.error("Invalid internal state - received onTrouterConnected while allocateResult is not set");
              this.logger.info("onTrouterConnected: " + this.allocateResult.url), this.socket && this.socket.socket && this.socket.socket.options && this.socket.socket.options.query && (this.socket.socket.options.query += "&connected=true"), this.urlPath = this.allocateResult.url.replace(/https?:\/\/([A-z0-9\:\$\-\_\.\+\!\*\"\(\)\,]*)\//, "/");
              var e2 = this.connectedUrl !== this.allocateResult.url;
              this.connectedUrl = this.allocateResult.url, this.connectionExpireTimestampInSecs = s.calculateExpireTsInSec(t3.ttl), this.connectionTracker.trackEnd("connectSocket"), this.connectionTracker.trackConnected(e2, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT), this.fsm.onTrouterConnected();
            }, t2.prototype.onTrouterReconnect = function() {
              this.logger.info("onTrouterReconnect"), this.fsm.onReconnectRequired();
            }, t2.prototype.onTrouterMessageLoss = function(t3) {
              this.logger.info("onTrouterMessageLoss"), this.fsm.onTrouterMessageLost(t3.droppedIndicators);
            }, t2.prototype.onAllocationResponse = function(t3, e2) {
              this.logger.info("Received allocation response " + JSON.stringify(t3)), this.allocateResult = t3, this.externalConnectParams = void 0;
              var n2 = +t3.ttl;
              if (this.connectionExpireTimestampInSecs = s.calculateExpireTsInSec(n2), this.connectionId = this.allocateResult.id || "", this.connectedClientId = this.allocateResult.ccid, this.logger.info("connected client id set {connectedClientId:" + this.connectedClientId + "}"), this.c2cUrlBase = t3.curlb || "", "" === this.c2cUrlBase) {
                var i2 = t3.surl.indexOf("://");
                i2 >= 0 && (i2 = t3.surl.indexOf("/", i2 + 3)) >= 5 && ":3443" === t3.surl.substr(i2 - 5, 5) && (this.c2cUrlBase = t3.surl.substr(0, i2 - 5));
              }
              var r2 = o({ serviceUrl: e2, reconnectUrl: t3.socketio + "v4/a" }, t3.connectparams);
              this.manager.onConnectionParametersUpdated(r2), this.fsm.onAllocationSucceed();
            }, t2.prototype.onPingResponse = function() {
              this.logger.info("onPingResponse"), this.connectionTracker.increasePingResponseCount(), this.clearPingResponseTimer(), this.fsm.onPingResponse();
            }, t2.prototype.clearPingResponseTimer = function() {
              void 0 !== this.pingResponseTimerId && (clearTimeout(this.pingResponseTimerId), this.pingResponseTimerId = void 0);
            }, t2.prototype.buildQuery = function(t3) {
              for (var e2 = [], n2 = 0, o2 = Object.keys(t3); n2 < o2.length; n2++) {
                var i2 = o2[n2];
                t3.hasOwnProperty(i2) && void 0 !== t3[i2] && e2.push(i2 + "=" + t3[i2]);
              }
              return e2.join("&");
            }, t2.prototype.appendConnectedClientIds = function(t3, e2) {
              var n2 = "";
              t3.indexOf("ccid=") < 0 && (n2 = "ccid=" + this.connectedClientId + "&"), this.domId && (n2 += "dom=" + this.domId + "&"), n2.length > 0 && (n2 = n2.slice(0, -1));
              var o2 = e2 || -1 !== t3.indexOf("?") ? "&" : "?";
              return this.appendCorrelationIds(t3 + o2 + n2, e2);
            }, t2.prototype.appendEndpointId = function(t3, e2) {
              var n2 = e2 || -1 !== t3.indexOf("?") ? "&" : "?";
              return t3.indexOf("epid") < 0 && this.options.endpointId ? "" + t3 + n2 + "epid=" + this.options.endpointId : t3;
            }, t2.prototype.appendCorrelationIds = function(t3, e2) {
              var n2 = e2 || -1 !== t3.indexOf("?") ? "&" : "?";
              return t3.indexOf("cor_id") < 0 ? "" + t3 + n2 + "cor_id=" + this.options.clientCorrelationID + "&con_num=" + this.clientID + "_" + this.connectionAttempt : t3;
            }, t2.prototype.getHealthUrl = function(t3) {
              return t3.substring(0, t3.lastIndexOf("/a")) + "/h";
            }, t2.prototype.safeString = function(t3) {
              return "string" == typeof t3 ? t3 : "";
            }, t2.prototype.sendResponse = function(t3, e2) {
              if (t3.timedout)
                return this.logger.error("Request " + t3.id + " already timed out"), 1;
              if (t3.replied)
                return this.logger.error("Response for request " + t3.id + " already sent"), 2;
              clearTimeout(t3.timeoutTimerId), t3.timeoutTimerId = 0, t3.replied = true, e2.headers = e2.headers || {};
              var n2 = t3.correlationVector;
              this.logger.info("Sending response for request N " + t3.id + " CV " + n2 + " with status " + e2.status), n2 && (e2.headers[v] = n2), t3.headers && t3.headers["trouter-request"] && !e2.headers["trouter-request"] && (e2.headers["trouter-request"] = t3.headers["trouter-request"]);
              var o2 = Date.now() - t3.startTS;
              if (e2.headers["trouter-client"] = s.toJson({ cd: o2 }), this.logger.debug("response: " + s.toJson(e2)), !this.socket)
                return this.connectionTracker.sendResponseError("no socket", t3, e2), 4;
              try {
                return this.socket.send(s.toJson(e2)), e2.sentTS = Date.now(), t3.incrementCorrelationVector(), this.connectionTracker.trackResponse(t3, o2, e2), "websocket" === this.transportTypeName && this.sendPingRequest(), 0;
              } catch (n3) {
                var i2 = "unable to send data on response.end. Error: " + s.toJson(n3.stack);
                return this.logger.error(i2), this.connectionTracker.sendResponseError(i2, t3, e2), 4;
              }
            }, t2.prototype.sendUserActivityStateMultiple = function(t3) {
              var e2 = this, n2 = new k("user.activity"), o2 = this.userActivityState.toEventObject();
              n2.args = o2, this.userActivityState.correlationVector.increase(), this.logger.debug("Sending user activity '" + this.userActivityState.toEventJSON() + "', remaining " + (t3 - 1)), this.sendDownstreamEvent(n2, function() {
                if (e2.logger.info("User activity state: " + o2.state + ", cv: " + o2.cv + " accepted"), e2.manager.onUserActivityStateAccepted && e2.manager.onUserActivityStateAccepted(o2.cv), e2.clearTimer(n2.timeoutTimerId), t3 > 1) {
                  var i2 = setTimeout(function() {
                    e2.clearTimer(i2), e2.sendUserActivityStateMultiple(t3 - 1);
                  }, e2.options.userActivitySecondResendDelayMs);
                  e2.registerTimer(i2, "user.activity/resend");
                }
              }), n2.timeoutTimerId = setTimeout(function() {
                e2.logger.error("Activity state response timeout is fired"), e2.fsm.onActivityStateResponseTimeout(), e2.clearTimer(n2.timeoutTimerId);
              }, this.timeoutOptions.userActivityResponseTimeoutMs), this.registerTimer(n2.timeoutTimerId, "user.activity/response");
            }, t2.prototype.sendDownstreamEvent = function(t3, e2) {
              this.logger.info("Sending downstream event " + t3.name), this.socket && this.socket.emit(t3.name, t3.args, e2);
            }, t2.prototype.registerTimer = function(t3, e2) {
              this.logger.debug("registering timer " + t3 + " -> " + e2), this.pendingTimers[t3] = e2;
            }, t2.prototype.clearTimer = function(t3) {
              var e2 = this.pendingTimers[t3];
              this.logger.debug("clearing timer " + t3 + " -> " + e2), delete this.pendingTimers[t3], clearTimeout(t3);
            }, t2.prototype.getRegistrationTtl = function() {
              var t3 = s.calculateTtlInSec(this.connectionExpireTimestampInSecs);
              return this.logger.debug("Current connectionID will expire in " + t3 + " seconds"), this.options.registration && this.options.registration.registrarTtlSec && t3 > 0 ? Math.min(this.options.registration.registrarTtlSec, t3) : this.options.registration && this.options.registration.registrarTtlSec ? this.options.registration.registrarTtlSec : t3 > 0 ? t3 : 3600;
            }, t2.prototype.clearIncallModeTimerId = function() {
              void 0 !== this.incallModeTimerId && (this.logger.debug("Clearing in-call mode timer"), clearTimeout(this.incallModeTimerId), this.incallModeTimerId = void 0);
            }, t2.prototype.applyConnectionTrackerOptions = function(t3) {
              try {
                t3.eventLogger && "function" == typeof t3.eventLogger.logEvent ? (this.connectionTracker.mergeSettings(t3.telemetrySettings), this.connectionTracker.enable(t3.eventLogger)) : this.logger.warn("Trouter client event logging disabled due to invalid configuration.");
              } catch (t4) {
                this.logger.warn("Trouter client event logging disabled. Error: " + s.toJson(t4.stack)), this.connectionTracker.disable();
              }
            }, t2;
          }();
          e.TrouterConnection = S;
        }, function(t, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o, i = n(5), r = n(0);
          !function(t2) {
            t2[t2.Initial = 0] = "Initial", t2[t2.RetrievingToken = 1] = "RetrievingToken", t2[t2.Allocating = 2] = "Allocating", t2[t2.Handshaking = 3] = "Handshaking", t2[t2.Connecting = 4] = "Connecting", t2[t2.Connected = 5] = "Connected", t2[t2.UnregisteringRetrievingToken = 6] = "UnregisteringRetrievingToken", t2[t2.Unregistering = 7] = "Unregistering";
          }(o = e.State || (e.State = {}));
          var s;
          !function(t2) {
            t2[t2.Initial = 0] = "Initial", t2[t2.RetrievingToken = 1] = "RetrievingToken", t2[t2.Registering = 2] = "Registering", t2[t2.Registered = 3] = "Registered", t2[t2.NotRegistered = 4] = "NotRegistered";
          }(s || (s = {}));
          var c = function() {
            function t2(t3, e2, n2) {
              this.worker = e2, this.incallModeEnabled = n2, this.state = o.Initial, this.connectionErrors = 0, this.logger = new r.Logger("ConnectionFsm", t3), this.connectedSubstate = s.Initial;
            }
            return t2.prototype.getState = function() {
              return this.state;
            }, t2.prototype.isActive = function() {
              return this.state === o.Allocating || this.state === o.Connected || this.state === o.Handshaking || this.state === o.Connecting || this.state === o.RetrievingToken;
            }, t2.prototype.start = function() {
              return this.state === o.Initial ? (this.setState(o.RetrievingToken), this.worker.getToken(true, false), true) : (this.showIgnored("start"), false);
            }, t2.prototype.stop = function(t3) {
              t3 && (this.connectedSubstate = s.Initial), this.worker.isIncallMode() && this.worker.exitIncallMode(), this.worker.resetTokenBackoff(), this.worker.resetRegisterBackoff(), this.worker.stopConnectionTimer(), this.worker.stopPingTimer(), this.worker.clearTimers(), this.state !== o.Connecting && this.state !== o.Handshaking && this.state !== o.Connected || this.worker.stopSocketIo(), this.isRegistered() && this.state !== o.UnregisteringRetrievingToken && this.state !== o.Unregistering ? (this.setState(o.UnregisteringRetrievingToken), this.worker.stopRegisterTimer(), this.worker.getToken(true, false)) : (this.setState(o.Initial), this.worker.dispatchDisconnected());
            }, t2.prototype.onTokenReceived = function(t3) {
              this.state === o.RetrievingToken ? (this.setState(o.Allocating), this.worker.startConnectionTimer(), this.worker.sendAllocateRequest(t3)) : this.state === o.Connected && this.connectedSubstate === s.RetrievingToken ? (this.connectedSubstate = s.Registering, this.worker.sendRegisterRequest()) : this.state === o.UnregisteringRetrievingToken ? (this.setState(o.Unregistering), this.worker.sendUnregisterRequest()) : this.showIgnored("onTokenReceived");
            }, t2.prototype.checkConnection = function(t3) {
              t3 && this.onPingInterval();
            }, t2.prototype.onAllocationSucceed = function() {
              return this.state === o.Allocating ? (this.setState(o.Handshaking), this.connectedSubstate === s.Registered && this.worker.dispatchUnregistered(), this.connectedSubstate = s.Initial, this.worker.startSocketIo(), true) : (this.showIgnored("onAllocationSucceed"), false);
            }, t2.prototype.onAllocationFailed = function(t3) {
              this.state === o.Allocating ? (this.setState(o.RetrievingToken), this.worker.stopConnectionTimer(), this.worker.getToken(!t3, true)) : this.showIgnored("onAllocationFailed");
            }, t2.prototype.onConnectingTimeout = function() {
              this.state === o.Allocating || this.state === o.Connecting || this.state === o.Handshaking ? (this.setState(o.RetrievingToken), this.resetAllocationIfNecessary(void 0), this.worker.stopSocketIo(), this.worker.getToken(true, false)) : this.showIgnored("onConnectingTimeout");
            }, t2.prototype.onConnecting = function() {
              this.state === o.Handshaking ? this.setState(o.Connecting) : this.showIgnored("onConnecting");
            }, t2.prototype.onConnectingFailed = function() {
              this.state === o.Connecting ? this.onConnectingTimeout() : this.state === o.Handshaking ? (this.logger.error("Unexpected error in Socket.io - no valid transports"), this.onConnectingTimeout()) : this.showIgnored("onConnectingFailed");
            }, t2.prototype.onSocketError = function(t3) {
              this.state === o.Handshaking || this.state === o.Connected ? (this.worker.stopSocketIo(), this.worker.stopPingTimer(), this.worker.clearTimers(), this.worker.stopConnectionTimer(), this.state !== o.Connected && this.worker.resetAllocationConnectionParams(), this.setState(o.RetrievingToken), this.worker.dispatchReconnecting(), this.worker.getToken(true, false)) : this.showIgnored("onSocketError");
            }, t2.prototype.onTrouterConnected = function() {
              this.state === o.Connecting ? (this.setState(o.Connected), this.worker.resetTokenBackoff(), this.worker.stopConnectionTimer(), this.worker.sendUserActivityState(i.UserActivityEventReason.Connected, true), this.worker.startPingTimer(), this.worker.dispatchConnected(), this.connectionErrors = 0, this.worker.shouldSkipRegistration() ? (this.connectedSubstate = s.NotRegistered, this.worker.dispatchRegistered()) : (this.connectedSubstate = s.RetrievingToken, this.worker.getToken(true, false))) : this.showIgnored("onTrouterConnected");
            }, t2.prototype.onReconnectRequired = function() {
              this.worker.dispatchReconnectIsRequired();
            }, t2.prototype.onDownstreamRequest = function(t3) {
              this.state === o.Connected ? (this.switchToIncallModeIfEnabled(), this.worker.dispatchDownstreamRequest(t3)) : this.showIgnored("onDownstreamRequest");
            }, t2.prototype.onTrouterMessageLost = function(t3) {
              this.state === o.Connected ? this.worker.dispatchTrouterMessageLost(t3) : this.showIgnored("onTrouterMessageLost");
            }, t2.prototype.onPingInterval = function() {
              this.state === o.Connected ? this.worker.sendPingRequest() : this.showIgnored("onPingInterval");
            }, t2.prototype.onPingResponseTimeout = function() {
              this.onMissedResponse("onPingResponseTimeout");
            }, t2.prototype.onPingResponse = function() {
              this.state === o.Connected || this.showIgnored("onPingResponse");
            }, t2.prototype.onRegistrationFailed = function(t3) {
              this.state === o.Connected && this.connectedSubstate === s.Registering ? (this.connectedSubstate = s.RetrievingToken, this.worker.getToken(!t3, true)) : this.showIgnored("onRegistrationFailed");
            }, t2.prototype.onRegistrationSucceed = function() {
              this.state === o.Connected ? (this.connectedSubstate === s.Registering && (this.connectedSubstate = s.Registered, this.worker.dispatchRegistered()), this.worker.hasCustomRegisterTtl() && this.worker.startRegisterTimer()) : this.showIgnored("onRegistrationSucceed");
            }, t2.prototype.onRegistrationTimeout = function() {
              this.state === o.Connected && this.connectedSubstate !== s.NotRegistered ? (this.connectedSubstate = s.RetrievingToken, this.worker.getToken(true, false)) : this.showIgnored("onRegistrationTimeout");
            }, t2.prototype.onUnregistrationFailed = function(t3) {
              this.state === o.Unregistering ? (this.setState(o.UnregisteringRetrievingToken), this.worker.getToken(!t3, !t3)) : this.showIgnored("onUnregistrationFailed");
            }, t2.prototype.onUnregistrationSucceed = function() {
              this.state === o.Unregistering ? (this.setState(o.Initial), this.worker.dispatchUnregistered(), this.worker.dispatchDisconnected()) : this.showIgnored("onUnregistrationSucceed");
            }, t2.prototype.onIncallModeTimer = function() {
              this.worker.exitIncallMode(), this.state === o.Connected ? (this.worker.stopPingTimer(), this.worker.startPingTimer()) : this.showIgnored("onIncallModeTimer");
            }, t2.prototype.onSetUserActivityState = function(t3, e2) {
              e2 ? (this.logger.info("Changing user activity state to '" + t3.toEventJSON() + "'"), this.worker.sendUserActivityState(i.UserActivityEventReason.Modified, this.state === o.Connected)) : this.logger.debug("Not changing the same user activity state '" + t3.toEventJSON() + "'");
            }, t2.prototype.onActivityStateResponseTimeout = function() {
              this.onMissedResponse("onActivityStateResponseTimeout");
            }, t2.prototype.forceReconnect = function() {
              this.setState(o.RetrievingToken), this.worker.resetTokenBackoff(), this.worker.stopConnectionTimer(), this.worker.stopPingTimer(), this.worker.clearTimers(), this.worker.stopSocketIo(), this.worker.dispatchReconnecting(), this.worker.getToken(true, false);
            }, t2.prototype.onMissedResponse = function(t3) {
              this.state === o.Connected ? (this.setState(o.RetrievingToken), this.worker.stopPingTimer(), this.worker.clearTimers(), this.worker.stopSocketIo(), this.worker.dispatchReconnecting(), this.worker.getToken(true, false)) : this.showIgnored(t3);
            }, t2.prototype.showIgnored = function(t3) {
              this.logger.debug("Ignoring event '" + t3 + "' in state '" + o[this.state] + "'");
            }, t2.prototype.setState = function(t3) {
              if (this.logger.info("Switching from state '" + o[this.state] + "' to state '" + o[t3] + "'"), this.state === t3)
                return void this.logger.error("Attempt to switching into the current state '" + o[t3] + "'");
              this.state = t3;
            }, t2.prototype.resetAllocationIfNecessary = function(t3) {
              this.connectionErrors++, this.connectionErrors >= 2 || void 0 !== t3 && /^4\d\d /.test(t3) ? (this.logger.error("Connection error count is " + this.connectionErrors + " - will reset allocation"), this.connectionErrors = 0) : this.logger.info("Connection error count is " + this.connectionErrors + " - will NOT reset allocation");
            }, t2.prototype.isRegistered = function() {
              return this.connectedSubstate === s.Registered || this.connectedSubstate === s.Registering;
            }, t2.prototype.switchToIncallModeIfEnabled = function() {
              this.incallModeEnabled && (this.worker.isIncallMode() || (this.worker.enterIncallMode(), this.worker.stopPingTimer(), this.worker.startPingTimer()), this.worker.restartIncallModeTimer());
            }, t2;
          }();
          e.TrouterFsm = c;
        }, function(t, e, n) {
          Object.defineProperty(e, "__esModule", { value: true });
          var o = n(2), i = n(0), r = function() {
            function t2(t3, e2) {
              this.worker = e2, this.state = o.TrouterState.Unknown, this.logger = new i.Logger("ManagerFsm", t3);
            }
            return t2.prototype.start = function() {
              this.state === o.TrouterState.Unknown ? (this.setState(o.TrouterState.Disconnected), this.worker.forceStopLingeringConnection(), this.worker.startFirstConnection()) : this.showIgnored("start");
            }, t2.prototype.stop = function(t3) {
              this.state !== o.TrouterState.Unknown ? (this.setState(o.TrouterState.Unknown), this.worker.stopFirstConnection(true === t3), this.worker.stopSecondConnection(true === t3)) : this.showIgnored("stop");
            }, t2.prototype.getState = function() {
              return this.state;
            }, t2.prototype.onConnected = function(t3) {
              this.state === o.TrouterState.Disconnected && t3 ? this.worker.doesSecondConnectionExist() ? this.setState(o.TrouterState.Switching) : (this.setState(o.TrouterState.Connected), this.worker.dispatchConnected()) : this.showIgnored("onConnected(" + t3 + ")");
            }, t2.prototype.onRegistered = function(t3) {
              this.state !== o.TrouterState.Disconnected || t3 ? this.state !== o.TrouterState.Switching || t3 || (this.setState(o.TrouterState.Connected), this.worker.switchConnections(), this.worker.stopSecondConnectionDelayed(), this.worker.dispatchConnected()) : (this.setState(o.TrouterState.Connected), this.worker.switchConnections(), this.worker.stopSecondConnection(true), this.worker.dispatchConnected()), this.worker.dispatchRegistrationState(true);
            }, t2.prototype.onUnregistered = function(t3) {
              t3 && this.worker.dispatchRegistrationState(false);
            }, t2.prototype.onReconnecting = function(t3) {
              this.state === o.TrouterState.Connected && t3 ? (this.setState(o.TrouterState.Disconnected), this.worker.dispatchReconnecting()) : this.state === o.TrouterState.Switching && t3 ? (this.setState(o.TrouterState.Disconnected), this.worker.dispatchReconnecting()) : this.showIgnored("onReconnecting(" + t3 + ")");
            }, t2.prototype.onReconnectionRequired = function(t3) {
              this.state === o.TrouterState.Connected && t3 ? (this.setState(o.TrouterState.Switching), this.worker.startSecondConnection()) : this.state === o.TrouterState.Disconnected && t3 ? this.worker.startSecondConnection() : this.showIgnored("onReconnectionRequired(" + t3 + ")");
            }, t2.prototype.onDisconnected = function(t3) {
              this.state === o.TrouterState.Unknown && t3 ? this.worker.dispatchStopped() : this.showIgnored("onDisconnected(" + t3 + ")");
            }, t2.prototype.showIgnored = function(t3) {
              this.logger.info("Ignoring event '" + t3 + "' in state '" + o.TrouterState[this.state] + "'");
            }, t2.prototype.setState = function(t3) {
              if (this.logger.info("Switching from state '" + o.TrouterState[this.state] + "' to state '" + o.TrouterState[t3] + "'"), this.state === t3)
                return void this.logger.error("Attempt to switching into the current state '" + o.TrouterState[t3] + "'");
              this.state = t3;
            }, t2;
          }();
          e.TrouterManagerFsm = r;
        }, function(t, e, n) {
          function o(t2, e2) {
            if (!e2)
              return t2;
            var n2 = a({}, t2, { enabled: e2.TelemetryEnabled });
            return void 0 !== e2.ClientTelemetryEventEnabled && (n2 = a({}, n2, e2.ClientTelemetryEventEnabled)), n2;
          }
          function i(t2, e2) {
            return { clientInfo: { ua: t2.trouterSettings.productName, v: t2.trouterSettings.version }, ioOptions: { ackTimeoutMs: 5e3 }, clientCorrelationID: t2.trouterSettings.sessionId, environment: t2.trouterSettings.environment, telemetrySettings: o(t2.telemetryConfig.settings, e2), eventLogger: t2.telemetryConfig.eventLogger, endpointId: t2.trouterSettings.registrationId, trouterUrl: e2 && e2.TrouterConnectionUrl || t2.trouterSettings.trouterServiceUrl, registration: t2.trouterSettings.registrarServiceUrl ? { registrarUrl: t2.trouterSettings.registrarServiceUrl, registrationId: t2.trouterSettings.registrationId || "", pnhAppId: t2.trouterSettings.pnhAppId || "", platform: t2.trouterSettings.platform || "", pnhTemplateKey: t2.trouterSettings.pnhTemplate || "", platformUIVersion: t2.trouterSettings.platformUIVersion || "", productContext: t2.trouterSettings.pnhProductContext || void 0, context: t2.trouterSettings.pnhContext || "", registrarTtlSec: (t2.trouterSettings.maxRegistrationTimeInMs || 0) / 1e3 } : void 0, timeoutOptions: a({ connectionTimeoutMs: t2.trouterSettings.trouterConnectTimeoutInMs || 3e4, fetchTimeoutMs: 1e4, pingTimeoutMs: 4e4, pongTimeoutMs: 5e3, maxBackoffMs: 3e4, requestTimeoutMs: 5e3, userActivityResponseTimeoutMs: 1e4 }, t2.trouterSettings.timeoutOptions), incallTimeoutOptions: a({ connectionTimeoutMs: 1e4, fetchTimeoutMs: 5e3, pingTimeoutMs: 5e3, pongTimeoutMs: 2e3, maxBackoffMs: 1e4, requestTimeoutMs: 5e3, userActivityResponseTimeoutMs: 1e4 }, t2.trouterSettings.incallTimeoutOptions), incallModeTimeoutMs: t2.trouterSettings.incallModeTimeoutMs || 0, lingeringConnectionDelayMs: 6e4, userActivitySecondResendDelayMs: t2.trouterSettings.userActivitySecondResendDelayMs || 1e4, duplicateDisconnectThresholdMs: 1e4, connectionCache: t2.connectionCache, registrationStateCallback: t2.registrationStateCallbackForAcsDoNotUse };
          }
          function r(t2) {
            return new y(t2);
          }
          function s() {
            return l.CLIENT_VERSION;
          }
          function c(t2, e2) {
            var n2 = t2.indexOf("://");
            if (n2 >= 0) {
              var o2 = t2.indexOf("/", n2 + 3);
              if (o2 >= 0)
                return e2 + t2.substr(o2);
            }
            return "";
          }
          var a = this && this.__assign || Object.assign || function(t2) {
            for (var e2, n2 = 1, o2 = arguments.length; n2 < o2; n2++) {
              e2 = arguments[n2];
              for (var i2 in e2)
                Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
            }
            return t2;
          }, u = this && this.__awaiter || function(t2, e2, n2, o2) {
            return new (n2 || (n2 = Promise))(function(i2, r2) {
              function s2(t3) {
                try {
                  a2(o2.next(t3));
                } catch (t4) {
                  r2(t4);
                }
              }
              function c2(t3) {
                try {
                  a2(o2.throw(t3));
                } catch (t4) {
                  r2(t4);
                }
              }
              function a2(t3) {
                t3.done ? i2(t3.value) : new n2(function(e3) {
                  e3(t3.value);
                }).then(s2, c2);
              }
              a2((o2 = o2.apply(t2, e2 || [])).next());
            });
          }, h = this && this.__generator || function(t2, e2) {
            function n2(t3) {
              return function(e3) {
                return o2([t3, e3]);
              };
            }
            function o2(n3) {
              if (i2)
                throw new TypeError("Generator is already executing.");
              for (; a2; )
                try {
                  if (i2 = 1, r2 && (s2 = 2 & n3[0] ? r2.return : n3[0] ? r2.throw || ((s2 = r2.return) && s2.call(r2), 0) : r2.next) && !(s2 = s2.call(r2, n3[1])).done)
                    return s2;
                  switch (r2 = 0, s2 && (n3 = [2 & n3[0], s2.value]), n3[0]) {
                    case 0:
                    case 1:
                      s2 = n3;
                      break;
                    case 4:
                      return a2.label++, { value: n3[1], done: false };
                    case 5:
                      a2.label++, r2 = n3[1], n3 = [0];
                      continue;
                    case 7:
                      n3 = a2.ops.pop(), a2.trys.pop();
                      continue;
                    default:
                      if (s2 = a2.trys, !(s2 = s2.length > 0 && s2[s2.length - 1]) && (6 === n3[0] || 2 === n3[0])) {
                        a2 = 0;
                        continue;
                      }
                      if (3 === n3[0] && (!s2 || n3[1] > s2[0] && n3[1] < s2[3])) {
                        a2.label = n3[1];
                        break;
                      }
                      if (6 === n3[0] && a2.label < s2[1]) {
                        a2.label = s2[1], s2 = n3;
                        break;
                      }
                      if (s2 && a2.label < s2[2]) {
                        a2.label = s2[2], a2.ops.push(n3);
                        break;
                      }
                      s2[2] && a2.ops.pop(), a2.trys.pop();
                      continue;
                  }
                  n3 = e2.call(t2, a2);
                } catch (t3) {
                  n3 = [6, t3], r2 = 0;
                } finally {
                  i2 = s2 = 0;
                }
              if (5 & n3[0])
                throw n3[1];
              return { value: n3[0] ? n3[1] : void 0, done: true };
            }
            var i2, r2, s2, c2, a2 = { label: 0, sent: function() {
              if (1 & s2[0])
                throw s2[1];
              return s2[1];
            }, trys: [], ops: [] };
            return c2 = { next: n2(0), throw: n2(1), return: n2(2) }, "function" == typeof Symbol && (c2[Symbol.iterator] = function() {
              return this;
            }), c2;
          };
          Object.defineProperty(e, "__esModule", { value: true });
          var l = n(1), p = n(2);
          e.TrouterState = p.TrouterState, e.UserActivityState = p.UserActivityState;
          var d = n(0), f3 = n(6), g = n(7), m = n(8), v = n(9), y = function() {
            function t2(t3) {
              this.logProvider = t3, this.stateChangedListeners = [], this.logger = new d.Logger("Trouter", t3), this.trouterUrlPromise = new v.TrouterUrlPromise(t3), this.messageHandlers = new f3.MessageHandlerRegistry(t3), this.listeners = {}, this.connectionInfo = null, this.logger.info("Created TrouterService version " + l.CLIENT_VERSION);
            }
            return t2.prototype.start = function(t3) {
              if (this.logger.info("Start"), !t3.trouterSettings.disableInternalSkypeTokenCache) {
                var e2 = t3.skypeTokenProvider;
                t3.skypeTokenProvider = g.addCacheAsBackupTo(e2);
              }
              this.trouterCfg = t3;
              var n2 = i(t3, this.ecsCfg);
              void 0 === this.trouterServer && (this.trouterServer = new m.TrouterManager(this.logProvider, n2, t3.skypeTokenProvider, this)), this.trouterServer.start();
            }, t2.prototype.stop = function(t3) {
              this.logger.info("close connection"), this.trouterUrlPromise.rejectUrl(new Error("TrouterService is stopped")), void 0 !== this.trouterServer && this.trouterServer.stop(t3);
            }, t2.prototype.setEcsConfig = function(t3) {
              return u(this, void 0, void 0, function() {
                var e2 = this;
                return h(this, function(n2) {
                  return [2, new Promise(function(n3, o2) {
                    if (e2.ecsCfg = t3.TrouterJScriptClient, e2.logger.info("Setting ECS configuration to " + JSON.stringify(e2.ecsCfg)), void 0 !== e2.trouterServer && void 0 !== e2.trouterCfg) {
                      var r2 = i(e2.trouterCfg, e2.ecsCfg);
                      e2.trouterServer.configure(r2);
                    }
                    n3();
                  })];
                });
              });
            }, t2.prototype.checkConnection = function(t3) {
              void 0 !== this.trouterServer && this.trouterServer.checkConnection(t3 || false);
            }, t2.prototype.resendRegistration = function() {
              return u(this, void 0, void 0, function() {
                return h(this, function(t3) {
                  if (!this.trouterServer)
                    throw new Error("resendRegistration called too early");
                  return [2, this.trouterServer.resendRegistration()];
                });
              });
            }, t2.prototype.registerListener = function(t3, e2) {
              return "" === e2 || "/" !== e2[0] || e2.indexOf("?") >= 0 || e2.indexOf("#") >= 0 ? (this.logger.error("Listener path '" + e2 + "' is not valid"), false) : this.listeners[e2] ? (this.logger.error("Another listener is already registered for path '" + e2 + "'"), false) : (this.listeners[e2] = t3, this.logger.debug("Listener for path '" + e2 + "' registered"), this.connectionInfo && t3.onTrouterConnected(this.connectionInfo.baseEndpointUrl + e2, this.connectionInfo), true);
            }, t2.prototype.unregisterListener = function(t3) {
              for (var e2 = [], n2 = 0, o2 = Object.keys(this.listeners); n2 < o2.length; n2++) {
                var i2 = o2[n2];
                this.listeners[i2] === t3 && e2.push(i2);
              }
              if (0 === e2.length)
                return false;
              for (var r2 = 0, s2 = e2; r2 < s2.length; r2++) {
                var i2 = s2[r2];
                delete this.listeners[i2];
              }
              return this.logger.debug("Listener for path(s) '" + e2.join("', '") + "' unregistered"), true;
            }, t2.prototype.onTrouterConnected = function(t3, e2) {
              this.logger.debug("Trouter is now connected");
              for (var n2 = 0, o2 = Object.keys(this.listeners); n2 < o2.length; n2++) {
                var i2 = o2[n2];
                try {
                  this.listeners[i2].onTrouterConnected(e2.baseEndpointUrl + i2, e2);
                } catch (t4) {
                  this.logger.error("Listener '" + i2 + "' threw an exception from onTrouterConnected(): " + t4);
                }
              }
              this.connectionInfo = e2, this.trouterUrlPromise.resolveUrl(t3), this.notifyStateChanged(p.TrouterState.Connected, { url: t3, getRemainingTtlInSec: function() {
                return e2.connectionTtlSec;
              } });
            }, t2.prototype.onTrouterDisconnected = function() {
              this.logger.debug("Trouter is now disconnected"), this.connectionInfo = null;
              for (var t3 = 0, e2 = Object.keys(this.listeners); t3 < e2.length; t3++) {
                var n2 = e2[t3], o2 = this.listeners[n2];
                if (o2.onTrouterDisconnected)
                  try {
                    o2.onTrouterDisconnected();
                  } catch (t4) {
                    this.logger.error("Listener '" + n2 + "' threw an exception from onTrouterDisconnected(): " + t4);
                  }
              }
              this.notifyStateChanged(p.TrouterState.Disconnected);
            }, t2.prototype.onTrouterRequest = function(t3, e2) {
              for (var n2 = "", o2 = 0, i2 = Object.keys(this.listeners); o2 < i2.length; o2++) {
                var r2 = i2[o2];
                t3.path.substring(0, r2.length) === r2 && r2.length > n2.length && (n2 = r2);
              }
              if ("" === n2)
                this.tryMessageHandlers(t3, e2) || (e2.status = 404, e2.headers = { "Trouter-Responder": "ClientLib" }, e2.send());
              else
                try {
                  this.listeners[n2].onTrouterRequest(t3, e2);
                } catch (t4) {
                  this.logger.error("Listener '" + n2 + "' threw an exception from onTrouterRequest(): " + t4), e2.status = 500, e2.headers = { "Trouter-Responder": "ClientLib" }, e2.send();
                }
            }, t2.prototype.onTrouterMessageLoss = function(t3) {
              this.logger.info("onTrouterMessageLoss called with value " + t3);
              for (var e2 = true, n2 = 0, o2 = Object.keys(this.listeners); n2 < o2.length; n2++) {
                var i2 = o2[n2], r2 = this.listeners[i2];
                if (r2.onTrouterMessageLoss)
                  try {
                    e2 = r2.onTrouterMessageLoss(t3) && e2, void 0 === e2 && (this.logger.error("Listener '" + i2 + "' did not response with boolean value onTrouterMessageLoss()"), e2 = false);
                  } catch (t4) {
                    this.logger.error("Listener '" + i2 + "' threw an exception from onTrouterMessageLoss(): " + t4), e2 = false;
                  }
              }
              return e2;
            }, t2.prototype.onTrouterUserActivityStateAccepted = function(t3) {
              this.logger.debug("onTrouterUserActivityStateAccepted cv: " + t3);
              for (var e2 = 0, n2 = Object.keys(this.listeners); e2 < n2.length; e2++) {
                var o2 = n2[e2], i2 = this.listeners[o2];
                if (i2.onTrouterUserActivityStateAccepted)
                  try {
                    i2.onTrouterUserActivityStateAccepted(t3);
                  } catch (t4) {
                    this.logger.error("Listener '" + o2 + "' threw an exception from onTrouterUserActivityStateAccepted(): " + t4);
                  }
              }
            }, t2.prototype.setUserActivityState = function(t3, e2) {
              if (t3 !== p.UserActivityState.Active && t3 !== p.UserActivityState.Inactive)
                throw new Error("setUserActivityState called with unsupported value " + t3);
              if (this.logger.info("setUserActivityState called with value " + p.UserActivityState[t3]), !this.trouterServer || this.state() === p.TrouterState.Unknown)
                throw new Error("setUserActivityState called too early");
              this.trouterServer.setUserActivityState(t3, e2);
            }, t2.prototype.state = function() {
              return void 0 !== this.trouterServer ? this.trouterServer.getState() : p.TrouterState.Unknown;
            }, t2.prototype.getServerState = function() {
              if (void 0 !== this.trouterServer)
                return this.trouterServer.getServerState();
            }, t2.prototype.getTrouterUrlAsync = function() {
              return void 0 !== this.trouterServer ? this.trouterUrlPromise.getPromise() : Promise.reject(new Error("TrouterService has not been started"));
            }, t2.prototype.onStateChanged = function(t3) {
              if (this.logger.info("onStateChanged called"), void 0 === t3)
                this.stateChangedListeners = this.stateChangedListeners.filter(function(t4) {
                  return void 0 === t4.wrappedCallback;
                });
              else {
                this.offStateChanged(t3);
                var e2 = function(e3, n2) {
                  t3(e3, n2 ? n2.url : "");
                };
                e2.wrappedCallback = t3, this.stateChangedListeners.push(e2);
              }
            }, t2.prototype.offStateChanged = function(t3) {
              this.logger.info("offStateChanged called");
              var e2 = this.stateChangedListeners.length;
              return this.stateChangedListeners = this.stateChangedListeners.filter(function(e3) {
                return e3.wrappedCallback !== t3;
              }), e2 > this.stateChangedListeners.length;
            }, t2.prototype.addCallback = function(t3) {
              this.logger.info("addListener called"), -1 === this.stateChangedListeners.indexOf(t3, 0) && void 0 !== t3 && this.stateChangedListeners.push(t3);
            }, t2.prototype.removeCallback = function(t3) {
              this.logger.info("removeListener called");
              var e2 = this.stateChangedListeners.indexOf(t3, 0);
              return e2 > -1 && (this.stateChangedListeners.splice(e2, 1), true);
            }, t2.prototype.registerMessageHandler = function(t3) {
              this.logger.info("registerMessageHandler is called"), this.messageHandlers.register(t3);
            }, t2.prototype.clearMessageHandlers = function() {
              this.logger.info("clearMessageHandlers is called"), this.messageHandlers.clear();
            }, t2.prototype.notifyStateChanged = function(t3, e2) {
              var n2 = this;
              this.logger.info("notifyStateChanged called, will forward to " + this.stateChangedListeners.length + " listeners"), this.stateChangedListeners.forEach(function(o2) {
                try {
                  o2(t3, e2);
                } catch (t4) {
                  n2.logger.error("Error in callback " + t4);
                }
              });
            }, t2.prototype.tryMessageHandlers = function(t3, e2) {
              if (!this.messageHandlers.active())
                return false;
              var n2, o2 = null;
              try {
                n2 = JSON.parse(t3.body), o2 = n2 && (n2.evt || n2.eventId) || null;
              } catch (t4) {
              }
              var i2 = { eventId: o2, url: (this.connectionInfo ? this.connectionInfo.baseEndpointUrl : "") + t3.path, body: n2, rawBody: t3.body, headers: t3.headers }, r2 = this.messageHandlers.handleMessage(i2);
              return !!r2.isHandled && (e2.status = r2.resultCode, r2.responseHeaders && (e2.headers = r2.responseHeaders), r2.responseBody && (e2.body = r2.responseBody), e2.send(), true);
            }, t2;
          }();
          e.TrouterService = y, e.createTrouterService = r, e.getTrouterServiceVersion = s, e.replaceTrouterUrlBase = c;
        }, function(t, e) {
          t.exports = __WEBPACK_EXTERNAL_MODULE_20__;
        }, function(t, e) {
        }]);
      });
    });
    unwrapExports(tstrouter);
    var constants = createCommonjsModule(function(module2, exports2) {
      exports2.__esModule = true;
      exports2.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES = 3;
      exports2.GCCHIGH_TROUTER_SERVICE_URL = "https://go.trouter.gov.teams.microsoft.us/v4/a";
      exports2.GCCHIGH_REGISTRAR_SERVICE_URL = "https://registrar.gov.teams.microsoft.us/V3/registrations";
      exports2.DOD_TROUTER_SERVICE_URL = "https://go.trouter.dod.teams.microsoft.us/v4/a";
      exports2.DOD_REGISTRAR_SERVICE_URL = "https://registrar.dod.teams.microsoft.us/V3/registrations";
      exports2.INT_TROUTER_SERVICE_URL = "https://go.trouter-int.skype.net/v4/a";
      exports2.INT_REGISTRAR_SERVICE_URL = "https://edge.skype.net/registrar/testenv/v3/registrations";
      exports2.PUBLIC_TROUTER_SERVICE_URL = "https://go.trouter.skype.com/v4/a";
      exports2.PUBLIC_REGISTRAR_SERVICE_URL = "https://edge.skype.com/registrar/prod/v3/registrations";
      var CloudType;
      (function(CloudType2) {
        CloudType2["Public"] = "Public";
        CloudType2["GccHigh"] = "GCC High";
        CloudType2["Dod"] = "DoD";
      })(CloudType = exports2.CloudType || (exports2.CloudType = {}));
      var CloudPrefix;
      (function(CloudPrefix2) {
        CloudPrefix2["OrgId"] = "orgid";
        CloudPrefix2["Acs"] = "acs";
        CloudPrefix2["Spool"] = "spool";
        CloudPrefix2["GccHigh"] = "gcch";
        CloudPrefix2["GccHighAcs"] = "gcch-acs";
        CloudPrefix2["Dod"] = "dod";
        CloudPrefix2["DodAcs"] = "dod-acs";
      })(CloudPrefix = exports2.CloudPrefix || (exports2.CloudPrefix = {}));
    });
    unwrapExports(constants);
    var constants_1 = constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES;
    var constants_2 = constants.GCCHIGH_TROUTER_SERVICE_URL;
    var constants_3 = constants.GCCHIGH_REGISTRAR_SERVICE_URL;
    var constants_4 = constants.DOD_TROUTER_SERVICE_URL;
    var constants_5 = constants.DOD_REGISTRAR_SERVICE_URL;
    var constants_6 = constants.INT_TROUTER_SERVICE_URL;
    var constants_7 = constants.INT_REGISTRAR_SERVICE_URL;
    var constants_8 = constants.PUBLIC_TROUTER_SERVICE_URL;
    var constants_9 = constants.PUBLIC_REGISTRAR_SERVICE_URL;
    var constants_10 = constants.CloudType;
    var constants_11 = constants.CloudPrefix;
    var TrouterUtils = createCommonjsModule(function(module2, exports2) {
      var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f3, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f3 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      exports2.__esModule = true;
      var eventIds = /* @__PURE__ */ new Map([
        ["chatMessageReceived", 200],
        ["typingIndicatorReceived", 245],
        ["readReceiptReceived", 246],
        ["chatMessageEdited", 247],
        ["chatMessageDeleted", 248],
        ["chatThreadCreated", 257],
        ["chatThreadPropertiesUpdated", 258],
        ["chatThreadDeleted", 259],
        ["participantsAdded", 260],
        ["participantsRemoved", 261]
      ]);
      var publicTeamsUserPrefix = "8:orgid:";
      var dodTeamsUserPrefix = "8:dod:";
      var gcchTeamsUserPrefix = "8:gcch:";
      var teamsVisitorUserPrefix = "8:teamsvisitor:";
      var phoneNumberPrefix = "4:";
      var acsUserPrefix = "8:acs:";
      var spoolUserPrefix = "8:spool:";
      exports2.toMessageHandler = function(event, listener) {
        var eventId = eventIds.get(event);
        return {
          handleMessage: function(message) {
            var genericPayload = null;
            if (message === null || message === void 0 ? void 0 : message.rawBody) {
              genericPayload = JSON.parse(message.rawBody);
            }
            if (genericPayload === null || genericPayload.eventId !== eventId) {
              return void 0;
            }
            var eventPayload = toEventPayload(event, genericPayload);
            if (eventPayload === null) {
              return void 0;
            }
            listener(eventPayload);
            return { isHandled: true, resultCode: 200 };
          }
        };
      };
      var toEventPayload = function(event, genericPayload) {
        if (event === "chatMessageReceived") {
          var payload = genericPayload;
          var eventPayload = {
            threadId: payload.groupId,
            sender: constructIdentifierKindFromMri(payload.senderId),
            senderDisplayName: payload.senderDisplayName,
            recipient: constructIdentifierKindFromMri(payload.recipientMri),
            id: payload.messageId,
            createdOn: new Date(payload.originalArrivalTime),
            version: payload.version,
            type: payload.messageType,
            message: payload.messageBody,
            metadata: parseMetadata(payload.acsChatMessageMetadata)
          };
          return eventPayload;
        }
        if (event === "chatMessageEdited") {
          var payload = genericPayload;
          var eventPayload = {
            threadId: payload.groupId,
            sender: constructIdentifierKindFromMri(payload.senderId),
            senderDisplayName: payload.senderDisplayName,
            recipient: constructIdentifierKindFromMri(payload.recipientMri),
            id: payload.messageId,
            createdOn: new Date(payload.originalArrivalTime),
            version: payload.version,
            message: payload.messageBody,
            editedOn: new Date(payload.edittime),
            type: payload.messageType,
            metadata: parseMetadata(payload.acsChatMessageMetadata)
          };
          return eventPayload;
        }
        if (event === "chatMessageDeleted") {
          var payload = genericPayload;
          var eventPayload = {
            threadId: payload.groupId,
            sender: constructIdentifierKindFromMri(payload.senderId),
            senderDisplayName: payload.senderDisplayName,
            recipient: constructIdentifierKindFromMri(payload.recipientMri),
            id: payload.messageId,
            createdOn: new Date(payload.originalArrivalTime),
            version: payload.version,
            deletedOn: new Date(payload.deletetime),
            type: payload.messageType
          };
          return eventPayload;
        }
        if (event === "typingIndicatorReceived") {
          var payload = genericPayload;
          var eventPayload = {
            threadId: payload.groupId,
            sender: constructIdentifierKindFromMri(payload.senderId),
            senderDisplayName: payload.senderDisplayName,
            recipient: constructIdentifierKindFromMri(payload.recipientMri),
            version: payload.version,
            receivedOn: new Date(payload.originalArrivalTime)
          };
          return eventPayload;
        }
        if (event === "readReceiptReceived") {
          var payload = genericPayload;
          var readReceiptMessageBody = JSON.parse(payload.messageBody);
          var consumptionHorizon = readReceiptMessageBody.consumptionhorizon.split(";");
          var eventPayload = {
            threadId: payload.groupId,
            sender: constructIdentifierKindFromMri(payload.senderId),
            senderDisplayName: "",
            recipient: constructIdentifierKindFromMri(payload.recipientMri),
            chatMessageId: payload.messageId,
            readOn: /* @__PURE__ */ new Date(+consumptionHorizon[1])
          };
          return eventPayload;
        }
        if (event === "chatThreadCreated") {
          var payload = genericPayload;
          var createdByPayload = JSON.parse(unescape(payload.createdBy));
          var membersPayload = JSON.parse(unescape(payload.members));
          var propertiesPayload = JSON.parse(unescape(payload.properties));
          var createdBy = {
            id: constructIdentifierKindFromMri(createdByPayload.participantId),
            displayName: createdByPayload.displayName
          };
          var chatParticipants = membersPayload.map(function(m) {
            return {
              id: constructIdentifierKindFromMri(m.participantId),
              displayName: m.displayName
            };
          });
          var eventPayload = {
            threadId: payload.threadId,
            createdOn: new Date(payload.createTime),
            createdBy,
            version: payload.version,
            participants: chatParticipants,
            properties: propertiesPayload
          };
          return eventPayload;
        }
        if (event === "chatThreadPropertiesUpdated") {
          var payload = genericPayload;
          var updatedByPayload = JSON.parse(unescape(payload.editedBy));
          var propertiesPayload = JSON.parse(unescape(payload.properties));
          var updatedBy = {
            id: constructIdentifierKindFromMri(updatedByPayload.participantId),
            displayName: updatedByPayload.displayName
          };
          var eventPayload = {
            threadId: payload.threadId,
            updatedOn: new Date(payload.editTime),
            updatedBy,
            version: payload.version,
            properties: propertiesPayload
          };
          return eventPayload;
        }
        if (event === "chatThreadDeleted") {
          var payload = genericPayload;
          var deletedByPayload = JSON.parse(unescape(payload.deletedBy));
          var deletedBy = {
            id: constructIdentifierKindFromMri(deletedByPayload.participantId),
            displayName: deletedByPayload.displayName
          };
          var eventPayload = {
            threadId: payload.threadId,
            deletedOn: new Date(payload.deleteTime),
            deletedBy,
            version: payload.version
          };
          return eventPayload;
        }
        if (event === "participantsAdded") {
          var payload = genericPayload;
          var addedByPayload = JSON.parse(unescape(payload.addedBy));
          var participantsAddedPayload = JSON.parse(unescape(payload.participantsAdded));
          var addedBy = {
            id: constructIdentifierKindFromMri(addedByPayload.participantId),
            displayName: addedByPayload.displayName
          };
          var chatParticipants = participantsAddedPayload.map(function(m) {
            return {
              id: constructIdentifierKindFromMri(m.participantId),
              displayName: m.displayName,
              shareHistoryTime: new Date(m.shareHistoryTime)
            };
          });
          var eventPayload = {
            threadId: payload.threadId,
            addedOn: new Date(payload.time),
            addedBy,
            version: payload.version,
            participantsAdded: chatParticipants
          };
          return eventPayload;
        }
        if (event === "participantsRemoved") {
          var payload = genericPayload;
          var removedByPayload = JSON.parse(unescape(payload.removedBy));
          var participantsRemovedPayload = JSON.parse(unescape(payload.participantsRemoved));
          var removedBy = {
            id: constructIdentifierKindFromMri(removedByPayload.participantId),
            displayName: removedByPayload.displayName
          };
          var chatParticipants = participantsRemovedPayload.map(function(m) {
            return {
              id: constructIdentifierKindFromMri(m.participantId),
              displayName: m.displayName,
              shareHistoryTime: new Date(m.shareHistoryTime)
            };
          });
          var eventPayload = {
            threadId: payload.threadId,
            removedOn: new Date(payload.time),
            removedBy,
            version: payload.version,
            participantsRemoved: chatParticipants
          };
          return eventPayload;
        }
        return null;
      };
      exports2.toLogProvider = function(logger5) {
        return {
          log: function() {
            var message = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              message[_i] = arguments[_i];
            }
            return logger5.info(message);
          },
          warn: function() {
            var message = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              message[_i] = arguments[_i];
            }
            return logger5.warning(message);
          },
          error: function() {
            var message = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              message[_i] = arguments[_i];
            }
            return logger5.error(message);
          },
          debug: function() {
            var message = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              message[_i] = arguments[_i];
            }
            return logger5.verbose(message);
          },
          info: function() {
            var message = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              message[_i] = arguments[_i];
            }
            return logger5.verbose(message);
          }
        };
      };
      exports2.toTelemetrySender = function(logger5) {
        return {
          logEvent: function(clientEvent) {
            return logger5.info(clientEvent);
          }
        };
      };
      var constructIdentifierKindFromMri = function(mri) {
        if (mri.startsWith(publicTeamsUserPrefix)) {
          return {
            kind: "microsoftTeamsUser",
            rawId: mri,
            microsoftTeamsUserId: mri.substring(publicTeamsUserPrefix.length),
            isAnonymous: false,
            cloud: "public"
          };
        } else if (mri.startsWith(dodTeamsUserPrefix)) {
          return {
            kind: "microsoftTeamsUser",
            rawId: mri,
            microsoftTeamsUserId: mri.substring(dodTeamsUserPrefix.length),
            isAnonymous: false,
            cloud: "dod"
          };
        } else if (mri.startsWith(gcchTeamsUserPrefix)) {
          return {
            kind: "microsoftTeamsUser",
            rawId: mri,
            microsoftTeamsUserId: mri.substring(gcchTeamsUserPrefix.length),
            isAnonymous: false,
            cloud: "gcch"
          };
        } else if (mri.startsWith(teamsVisitorUserPrefix)) {
          return {
            kind: "microsoftTeamsUser",
            rawId: mri,
            microsoftTeamsUserId: mri.substring(teamsVisitorUserPrefix.length),
            isAnonymous: true
          };
        } else if (mri.startsWith(phoneNumberPrefix)) {
          return {
            kind: "phoneNumber",
            rawId: mri,
            phoneNumber: mri.substring(phoneNumberPrefix.length)
          };
        } else if (mri.startsWith(acsUserPrefix) || mri.startsWith(spoolUserPrefix)) {
          return { kind: "communicationUser", communicationUserId: mri };
        } else {
          return { kind: "unknown", id: mri };
        }
      };
      var parseMetadata = function(metadata) {
        if (metadata === void 0 || metadata === null || metadata === "" || metadata === "null") {
          return {};
        }
        return JSON.parse(metadata);
      };
      function base64decode(encodedString) {
        return !coreHttp.isNode ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
      }
      exports2.base64decode = base64decode;
      var parseJWT = function(token) {
        var _a2 = token === null || token === void 0 ? void 0 : token.split("."), payload = _a2[1];
        if (payload === void 0) {
          throw new Error("Invalid token");
        }
        payload = payload.replace(/-/g, "+").replace(/_/g, "/");
        return JSON.parse(decodeURIComponent(escape(base64decode(payload))));
      };
      exports2.getCloudTypeFromCredential = function(credential) {
        return __awaiter(void 0, void 0, void 0, function() {
          var accessToken, jwtToken, parsedJwtToken, identityMri;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, credential.getToken()];
              case 1:
                accessToken = _a2.sent();
                jwtToken = accessToken === null || accessToken === void 0 ? void 0 : accessToken.token;
                parsedJwtToken = parseJWT(jwtToken);
                identityMri = parsedJwtToken.skypeid;
                return [2, getCloudTypeFromSkypeId(identityMri)];
            }
          });
        });
      };
      function getCloudTypeFromSkypeId(skypeId) {
        var cloudPrefix = skypeId.substring(0, skypeId.indexOf(":"));
        switch (cloudPrefix) {
          case constants.CloudPrefix.OrgId:
          case constants.CloudPrefix.Acs:
          case constants.CloudPrefix.Spool: {
            return constants.CloudType.Public;
          }
          case constants.CloudPrefix.GccHigh:
          case constants.CloudPrefix.GccHighAcs: {
            return constants.CloudType.GccHigh;
          }
          case constants.CloudPrefix.Dod:
          case constants.CloudPrefix.DodAcs: {
            return constants.CloudType.Dod;
          }
          default: {
            return constants.CloudType.Public;
          }
        }
      }
    });
    unwrapExports(TrouterUtils);
    var TrouterUtils_1 = TrouterUtils.toMessageHandler;
    var TrouterUtils_2 = TrouterUtils.toLogProvider;
    var TrouterUtils_3 = TrouterUtils.toTelemetrySender;
    var TrouterUtils_4 = TrouterUtils.base64decode;
    var TrouterUtils_5 = TrouterUtils.getCloudTypeFromCredential;
    var TrouterSettings = createCommonjsModule(function(module2, exports2) {
      var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f3, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f3 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      exports2.__esModule = true;
      var defaultSettings = {
        version: "1.0.0",
        registrationId: "",
        sessionId: "",
        pnhAppId: "AcsWeb",
        pnhTemplate: "AcsWeb_Chat_1.2",
        platform: "SPOOL",
        platformUIVersion: "0.0.0",
        environment: "",
        productName: "acs-chat-web",
        trouterServiceUrl: constants.PUBLIC_TROUTER_SERVICE_URL,
        registrarServiceUrl: constants.PUBLIC_REGISTRAR_SERVICE_URL,
        registrarRefreshTimeoutInMs: 35e4,
        timeoutOptions: {
          connectionTimeoutMs: 2e4,
          fetchTimeoutMs: 1e4,
          pingTimeoutMs: 4e4,
          pongTimeoutMs: 5e3,
          maxBackoffMs: 5e4,
          requestTimeoutMs: 5e3
        },
        maxRegistrationTimeInMs: 72e5
      };
      var createDefaultSettings = function() {
        var settings = defaultSettings;
        settings.registrationId = coreHttp.generateUuid();
        settings.sessionId = coreHttp.generateUuid();
        return settings;
      };
      var createIntSettings = function() {
        var settings = createDefaultSettings();
        settings.pnhAppId = "cns-e2e-test";
        settings.pnhTemplate = "cns-e2e-test:1.2";
        settings.registrarServiceUrl = constants.INT_REGISTRAR_SERVICE_URL;
        settings.trouterServiceUrl = constants.INT_TROUTER_SERVICE_URL;
        return settings;
      };
      var createGcchSettings = function() {
        var settings = createDefaultSettings();
        settings.registrarServiceUrl = constants.GCCHIGH_REGISTRAR_SERVICE_URL;
        settings.trouterServiceUrl = constants.GCCHIGH_TROUTER_SERVICE_URL;
        return settings;
      };
      var createDodSettings = function() {
        var settings = createDefaultSettings();
        settings.registrarServiceUrl = constants.DOD_REGISTRAR_SERVICE_URL;
        settings.trouterServiceUrl = constants.DOD_TROUTER_SERVICE_URL;
        return settings;
      };
      exports2.createSettings = function(credential, options) {
        return __awaiter(void 0, void 0, void 0, function() {
          var settings, cloud;
          var _a2;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!((options === null || options === void 0 ? void 0 : options.environment) === "INT"))
                  return [3, 1];
                settings = createIntSettings();
                return [3, 3];
              case 1:
                return [4, TrouterUtils.getCloudTypeFromCredential(credential)];
              case 2:
                cloud = _b.sent();
                if (cloud === constants.CloudType.GccHigh) {
                  settings = createGcchSettings();
                } else if (cloud === constants.CloudType.Dod) {
                  settings = createDodSettings();
                } else {
                  settings = createDefaultSettings();
                }
                _b.label = 3;
              case 3:
                settings.maxRegistrationTimeInMs = (_a2 = options === null || options === void 0 ? void 0 : options.registrationTimeInMs) !== null && _a2 !== void 0 ? _a2 : defaultSettings.maxRegistrationTimeInMs;
                return [2, settings];
            }
          });
        });
      };
      exports2.defaultTelemetrySettings = {
        // TBD Can we hook up OpenTelemetry?
        enabled: false
      };
    });
    unwrapExports(TrouterSettings);
    var TrouterSettings_1 = TrouterSettings.createSettings;
    var TrouterSettings_2 = TrouterSettings.defaultTelemetrySettings;
    var SignalingClient = createCommonjsModule(function(module2, exports2) {
      var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f3, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f3)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f3 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f3 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      exports2.__esModule = true;
      var ConnectionState;
      (function(ConnectionState2) {
        ConnectionState2[ConnectionState2["Unknown"] = 0] = "Unknown";
        ConnectionState2[ConnectionState2["Connected"] = 2] = "Connected";
        ConnectionState2[ConnectionState2["Disconnected"] = 3] = "Disconnected";
        ConnectionState2[ConnectionState2["Switching"] = 9] = "Switching";
      })(ConnectionState = exports2.ConnectionState || (exports2.ConnectionState = {}));
      var CommunicationSignalingClient2 = (
        /** @class */
        function() {
          function CommunicationSignalingClient3(credential, logger5, options) {
            this.credential = credential;
            this.logger = logger5;
            this.options = options;
            this.stateChangedListener = null;
            this.tokenFetchRetries = 0;
            this.trouter = tstrouter.createTrouterService(TrouterUtils.toLogProvider(logger5));
          }
          CommunicationSignalingClient3.prototype.start = function() {
            return __awaiter(this, void 0, void 0, function() {
              var _a2, _b;
              var _this = this;
              return __generator(this, function(_c) {
                switch (_c.label) {
                  case 0:
                    if (!(this.config === void 0))
                      return [3, 2];
                    _a2 = this;
                    _b = {};
                    return [4, TrouterSettings.createSettings(this.credential, this.options)];
                  case 1:
                    _a2.config = (_b.trouterSettings = _c.sent(), _b.skypeTokenProvider = function(forceRefresh) {
                      return __awaiter(_this, void 0, void 0, function() {
                        var _a3, _b2;
                        return __generator(this, function(_c2) {
                          switch (_c2.label) {
                            case 0:
                              if (!forceRefresh)
                                return [3, 3];
                              this.tokenFetchRetries += 1;
                              if (!(this.tokenFetchRetries > constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES))
                                return [3, 2];
                              return [4, this.stop(true)];
                            case 1:
                              _c2.sent();
                              throw new Error("Access token is expired and failed to fetch a valid one after " + constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES + " retries");
                            case 2:
                              return [3, 4];
                            case 3:
                              this.tokenFetchRetries = 0;
                              _c2.label = 4;
                            case 4:
                              _b2 = (_a3 = Promise).resolve;
                              return [4, this.credential.getToken()];
                            case 5:
                              return [2, _b2.apply(_a3, [_c2.sent().token])];
                          }
                        });
                      });
                    }, _b.telemetryConfig = {
                      eventLogger: TrouterUtils.toTelemetrySender(this.logger),
                      settings: TrouterSettings.defaultTelemetrySettings
                    }, _b);
                    _c.label = 2;
                  case 2:
                    this.trouter.start(this.config);
                    this.trouter.setUserActivityState(tstrouter.UserActivityState.Active);
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          CommunicationSignalingClient3.prototype.stop = function(isTokenExpired) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                this.trouter.offStateChanged(this.stateChangedListener);
                this.trouter.clearMessageHandlers();
                this.trouter.stop(isTokenExpired !== null && isTokenExpired !== void 0 ? isTokenExpired : this.tokenFetchRetries > constants.MAX_NUMBER_OF_TOKEN_FETCH_RETRIES);
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          CommunicationSignalingClient3.prototype.on = function(event, listener) {
            if (event === "connectionChanged") {
              this.trouter.offStateChanged(this.stateChangedListener);
              this.stateChangedListener = function(state, _url) {
                return listener(state);
              };
              this.trouter.onStateChanged(this.stateChangedListener);
              return;
            }
            this.trouter.registerMessageHandler(TrouterUtils.toMessageHandler(event, listener));
          };
          return CommunicationSignalingClient3;
        }()
      );
      exports2.CommunicationSignalingClient = CommunicationSignalingClient2;
    });
    unwrapExports(SignalingClient);
    var SignalingClient_1 = SignalingClient.ConnectionState;
    var SignalingClient_2 = SignalingClient.CommunicationSignalingClient;
    var src = createCommonjsModule(function(module2, exports2) {
      function __export2(m) {
        for (var p in m)
          if (!exports2.hasOwnProperty(p))
            exports2[p] = m[p];
      }
      exports2.__esModule = true;
      __export2(SignalingClient);
    });
    var index = unwrapExports(src);
    module.exports = index;
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/signaling/signalingClient.browser.js
var import_communication_signaling, getSignalingClient;
var init_signalingClient_browser = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/signaling/signalingClient.browser.js"() {
    import_communication_signaling = __toESM(require_dist());
    getSignalingClient = (credential, logger5, options) => {
      var _a2;
      return new import_communication_signaling.CommunicationSignalingClient(credential, logger5, {
        environment: (_a2 = options === null || options === void 0 ? void 0 : options.environment) !== null && _a2 !== void 0 ? _a2 : void 0
      });
    };
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/tracing.js
var createSpan2;
var init_tracing = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/tracing.js"() {
    init_src5();
    createSpan2 = createSpanFunction({
      packagePrefix: "Azure.Communication",
      namespace: "Microsoft.Communication"
    });
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/models/mappers.js
var mapToCreateChatThreadOptionsRestModel, mapToChatParticipantRestModel, mapToAddChatParticipantsRequestRestModel, mapToChatParticipantSdkModel, mapToChatContentSdkModel, mapToChatMessageSdkModel, mapToChatThreadPropertiesSdkModel, mapToCreateChatThreadResultSdkModel, mapToReadReceiptSdkModel;
var init_mappers = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/models/mappers.js"() {
    init_tslib_es6();
    init_src7();
    mapToCreateChatThreadOptionsRestModel = (options) => {
      const { participants, idempotencyToken } = options, rest = __rest(options, ["participants", "idempotencyToken"]);
      return Object.assign({ repeatabilityRequestId: idempotencyToken }, rest);
    };
    mapToChatParticipantRestModel = (chatParticipant) => {
      const { id } = chatParticipant, rest = __rest(chatParticipant, ["id"]);
      return Object.assign(Object.assign({}, rest), { communicationIdentifier: serializeCommunicationIdentifier(id) });
    };
    mapToAddChatParticipantsRequestRestModel = (addParticipantsRequest) => {
      var _a2;
      return {
        participants: (_a2 = addParticipantsRequest.participants) === null || _a2 === void 0 ? void 0 : _a2.map((participant) => mapToChatParticipantRestModel(participant))
      };
    };
    mapToChatParticipantSdkModel = (chatParticipant) => {
      const { communicationIdentifier } = chatParticipant, rest = __rest(chatParticipant, ["communicationIdentifier"]);
      return Object.assign(Object.assign({}, rest), { id: deserializeCommunicationIdentifier(communicationIdentifier) });
    };
    mapToChatContentSdkModel = (content) => {
      const { participants, initiatorCommunicationIdentifier } = content, otherChatContents = __rest(content, ["participants", "initiatorCommunicationIdentifier"]);
      let result = Object.assign({}, otherChatContents);
      if (initiatorCommunicationIdentifier) {
        const initiator = deserializeCommunicationIdentifier(initiatorCommunicationIdentifier);
        result = Object.assign(Object.assign({}, result), { initiator });
      }
      if (participants) {
        result = Object.assign(Object.assign({}, result), { participants: participants === null || participants === void 0 ? void 0 : participants.map((participant) => mapToChatParticipantSdkModel(participant)) });
      }
      return result;
    };
    mapToChatMessageSdkModel = (chatMessage) => {
      const { content, senderCommunicationIdentifier } = chatMessage, otherChatMessage = __rest(chatMessage, ["content", "senderCommunicationIdentifier"]);
      let result = Object.assign({}, otherChatMessage);
      if (content) {
        result = Object.assign(Object.assign({}, result), { content: mapToChatContentSdkModel(content) });
      }
      if (senderCommunicationIdentifier) {
        const sender = deserializeCommunicationIdentifier(senderCommunicationIdentifier);
        result = Object.assign(Object.assign({}, result), { sender });
      }
      return result;
    };
    mapToChatThreadPropertiesSdkModel = (chatThread) => {
      const { createdByCommunicationIdentifier } = chatThread, rest = __rest(chatThread, ["createdByCommunicationIdentifier"]);
      if (createdByCommunicationIdentifier) {
        return Object.assign(Object.assign({}, rest), { createdBy: deserializeCommunicationIdentifier(createdByCommunicationIdentifier) });
      } else {
        return Object.assign({}, rest);
      }
    };
    mapToCreateChatThreadResultSdkModel = (result) => {
      const { chatThread } = result, rest = __rest(result, ["chatThread"]);
      if (chatThread) {
        return Object.assign(Object.assign({}, rest), { chatThread: mapToChatThreadPropertiesSdkModel(chatThread) });
      } else {
        return Object.assign({}, rest);
      }
    };
    mapToReadReceiptSdkModel = (readReceipt) => {
      const { senderCommunicationIdentifier } = readReceipt, rest = __rest(readReceipt, ["senderCommunicationIdentifier"]);
      return Object.assign(Object.assign({}, rest), { sender: deserializeCommunicationIdentifier(senderCommunicationIdentifier) });
    };
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/models/index.js
var KnownCommunicationCloudEnvironmentModel;
var init_models2 = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/models/index.js"() {
    (function(KnownCommunicationCloudEnvironmentModel2) {
      KnownCommunicationCloudEnvironmentModel2["Public"] = "public";
      KnownCommunicationCloudEnvironmentModel2["Dod"] = "dod";
      KnownCommunicationCloudEnvironmentModel2["Gcch"] = "gcch";
    })(KnownCommunicationCloudEnvironmentModel || (KnownCommunicationCloudEnvironmentModel = {}));
  }
});

// node_modules/@azure/core-client/dist-esm/src/base64.browser.js
function encodeByteArray2(value) {
  let str2 = "";
  for (let i = 0; i < value.length; i++) {
    str2 += String.fromCharCode(value[i]);
  }
  return btoa(str2);
}
function decodeString2(value) {
  const byteString = atob(value);
  const arr = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    arr[i] = byteString.charCodeAt(i);
  }
  return arr;
}
var init_base64_browser3 = __esm({
  "node_modules/@azure/core-client/dist-esm/src/base64.browser.js"() {
  }
});

// node_modules/@azure/core-client/dist-esm/src/interfaces.js
var XML_ATTRKEY2, XML_CHARKEY2;
var init_interfaces2 = __esm({
  "node_modules/@azure/core-client/dist-esm/src/interfaces.js"() {
    XML_ATTRKEY2 = "$";
    XML_CHARKEY2 = "_";
  }
});

// node_modules/@azure/core-client/dist-esm/src/utils.js
function isPrimitiveBody(value, mapperTypeName) {
  return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === void 0 || value === null);
}
function isDuration2(value) {
  return validateISODuration2.test(value);
}
function isValidUuid2(uuid) {
  return validUuidRegex2.test(uuid);
}
function handleNullableResponseAndWrappableBody(responseObject) {
  const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
    return responseObject.shouldWrapBody ? { body: null } : null;
  } else {
    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
  }
}
function flattenResponse2(fullResponse, responseSpec) {
  var _a2, _b;
  const parsedHeaders = fullResponse.parsedHeaders;
  if (fullResponse.request.method === "HEAD") {
    return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
  }
  const bodyMapper = responseSpec && responseSpec.bodyMapper;
  const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);
  const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;
  if (expectedBodyTypeName === "Stream") {
    return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
  }
  const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
  const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
  if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
    const arrayResponse = (_a2 = fullResponse.parsedBody) !== null && _a2 !== void 0 ? _a2 : [];
    for (const key of Object.keys(modelProperties)) {
      if (modelProperties[key].serializedName) {
        arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];
      }
    }
    if (parsedHeaders) {
      for (const key of Object.keys(parsedHeaders)) {
        arrayResponse[key] = parsedHeaders[key];
      }
    }
    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
  }
  return handleNullableResponseAndWrappableBody({
    body: fullResponse.parsedBody,
    headers: parsedHeaders,
    hasNullableType: isNullable,
    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
  });
}
var validateISODuration2, validUuidRegex2;
var init_utils4 = __esm({
  "node_modules/@azure/core-client/dist-esm/src/utils.js"() {
    validateISODuration2 = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    validUuidRegex2 = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
  }
});

// node_modules/@azure/core-client/dist-esm/src/serializer.js
function createSerializer(modelMappers = {}, isXML = false) {
  return new SerializerImpl(modelMappers, isXML);
}
function trimEnd2(str2, ch) {
  let len = str2.length;
  while (len - 1 >= 0 && str2[len - 1] === ch) {
    --len;
  }
  return str2.substr(0, len);
}
function bufferToBase64Url2(buffer) {
  if (!buffer) {
    return void 0;
  }
  if (!(buffer instanceof Uint8Array)) {
    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
  }
  const str2 = encodeByteArray2(buffer);
  return trimEnd2(str2, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64UrlToByteArray2(str2) {
  if (!str2) {
    return void 0;
  }
  if (str2 && typeof str2.valueOf() !== "string") {
    throw new Error("Please provide an input of type string for converting to Uint8Array");
  }
  str2 = str2.replace(/-/g, "+").replace(/_/g, "/");
  return decodeString2(str2);
}
function splitSerializeName2(prop) {
  const classes = [];
  let partialclass = "";
  if (prop) {
    const subwords = prop.split(".");
    for (const item of subwords) {
      if (item.charAt(item.length - 1) === "\\") {
        partialclass += item.substr(0, item.length - 1) + ".";
      } else {
        partialclass += item;
        classes.push(partialclass);
        partialclass = "";
      }
    }
  }
  return classes;
}
function dateToUnixTime2(d) {
  if (!d) {
    return void 0;
  }
  if (typeof d.valueOf() === "string") {
    d = new Date(d);
  }
  return Math.floor(d.getTime() / 1e3);
}
function unixTimeToDate2(n) {
  if (!n) {
    return void 0;
  }
  return new Date(n * 1e3);
}
function serializeBasicTypes2(typeName, objectName, value) {
  if (value !== null && value !== void 0) {
    if (typeName.match(/^Number$/i) !== null) {
      if (typeof value !== "number") {
        throw new Error(`${objectName} with value ${value} must be of type number.`);
      }
    } else if (typeName.match(/^String$/i) !== null) {
      if (typeof value.valueOf() !== "string") {
        throw new Error(`${objectName} with value "${value}" must be of type string.`);
      }
    } else if (typeName.match(/^Uuid$/i) !== null) {
      if (!(typeof value.valueOf() === "string" && isValidUuid2(value))) {
        throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
      }
    } else if (typeName.match(/^Boolean$/i) !== null) {
      if (typeof value !== "boolean") {
        throw new Error(`${objectName} with value ${value} must be of type boolean.`);
      }
    } else if (typeName.match(/^Stream$/i) !== null) {
      const objectType = typeof value;
      if (objectType !== "string" && typeof value.pipe !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && // File objects count as a type of Blob, so we want to use instanceof explicitly
      !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function") {
        throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, NodeJS.ReadableStream, or () => NodeJS.ReadableStream.`);
      }
    }
  }
  return value;
}
function serializeEnumType2(objectName, allowedValues, value) {
  if (!allowedValues) {
    throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
  }
  const isPresent = allowedValues.some((item) => {
    if (typeof item.valueOf() === "string") {
      return item.toLowerCase() === value.toLowerCase();
    }
    return item === value;
  });
  if (!isPresent) {
    throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
  }
  return value;
}
function serializeByteArrayType2(objectName, value) {
  if (value !== void 0 && value !== null) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    value = encodeByteArray2(value);
  }
  return value;
}
function serializeBase64UrlType2(objectName, value) {
  if (value !== void 0 && value !== null) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    value = bufferToBase64Url2(value);
  }
  return value;
}
function serializeDateTypes2(typeName, value, objectName) {
  if (value !== void 0 && value !== null) {
    if (typeName.match(/^Date$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
    } else if (typeName.match(/^DateTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
      }
      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
    } else if (typeName.match(/^UnixTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
      }
      value = dateToUnixTime2(value);
    } else if (typeName.match(/^TimeSpan$/i) !== null) {
      if (!isDuration2(value)) {
        throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
      }
    }
  }
  return value;
}
function serializeSequenceType2(serializer3, mapper, object, objectName, isXml, options) {
  var _a2;
  if (!Array.isArray(object)) {
    throw new Error(`${objectName} must be of type Array.`);
  }
  let elementType = mapper.type.element;
  if (!elementType || typeof elementType !== "object") {
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}.`);
  }
  if (elementType.type.name === "Composite" && elementType.type.className) {
    elementType = (_a2 = serializer3.modelMappers[elementType.type.className]) !== null && _a2 !== void 0 ? _a2 : elementType;
  }
  const tempArray = [];
  for (let i = 0; i < object.length; i++) {
    const serializedValue = serializer3.serialize(elementType, object[i], objectName, options);
    if (isXml && elementType.xmlNamespace) {
      const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
      if (elementType.type.name === "Composite") {
        tempArray[i] = Object.assign({}, serializedValue);
        tempArray[i][XML_ATTRKEY2] = { [xmlnsKey]: elementType.xmlNamespace };
      } else {
        tempArray[i] = {};
        tempArray[i][options.xml.xmlCharKey] = serializedValue;
        tempArray[i][XML_ATTRKEY2] = { [xmlnsKey]: elementType.xmlNamespace };
      }
    } else {
      tempArray[i] = serializedValue;
    }
  }
  return tempArray;
}
function serializeDictionaryType2(serializer3, mapper, object, objectName, isXml, options) {
  if (typeof object !== "object") {
    throw new Error(`${objectName} must be of type object.`);
  }
  const valueType = mapper.type.value;
  if (!valueType || typeof valueType !== "object") {
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}.`);
  }
  const tempDictionary = {};
  for (const key of Object.keys(object)) {
    const serializedValue = serializer3.serialize(valueType, object[key], objectName, options);
    tempDictionary[key] = getXmlObjectValue2(valueType, serializedValue, isXml, options);
  }
  if (isXml && mapper.xmlNamespace) {
    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
    const result = tempDictionary;
    result[XML_ATTRKEY2] = { [xmlnsKey]: mapper.xmlNamespace };
    return result;
  }
  return tempDictionary;
}
function resolveAdditionalProperties2(serializer3, mapper, objectName) {
  const additionalProperties = mapper.type.additionalProperties;
  if (!additionalProperties && mapper.type.className) {
    const modelMapper = resolveReferencedMapper2(serializer3, mapper, objectName);
    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
  }
  return additionalProperties;
}
function resolveReferencedMapper2(serializer3, mapper, objectName) {
  const className = mapper.type.className;
  if (!className) {
    throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, void 0, 2)}".`);
  }
  return serializer3.modelMappers[className];
}
function resolveModelProperties2(serializer3, mapper, objectName) {
  let modelProps = mapper.type.modelProperties;
  if (!modelProps) {
    const modelMapper = resolveReferencedMapper2(serializer3, mapper, objectName);
    if (!modelMapper) {
      throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
    }
    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
    if (!modelProps) {
      throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
    }
  }
  return modelProps;
}
function serializeCompositeType2(serializer3, mapper, object, objectName, isXml, options) {
  if (getPolymorphicDiscriminatorRecursively2(serializer3, mapper)) {
    mapper = getPolymorphicMapper2(serializer3, mapper, object, "clientName");
  }
  if (object !== void 0 && object !== null) {
    const payload = {};
    const modelProps = resolveModelProperties2(serializer3, mapper, objectName);
    for (const key of Object.keys(modelProps)) {
      const propertyMapper = modelProps[key];
      if (propertyMapper.readOnly) {
        continue;
      }
      let propName;
      let parentObject = payload;
      if (serializer3.isXML) {
        if (propertyMapper.xmlIsWrapped) {
          propName = propertyMapper.xmlName;
        } else {
          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
        }
      } else {
        const paths = splitSerializeName2(propertyMapper.serializedName);
        propName = paths.pop();
        for (const pathName of paths) {
          const childObject = parentObject[pathName];
          if ((childObject === void 0 || childObject === null) && (object[key] !== void 0 && object[key] !== null || propertyMapper.defaultValue !== void 0)) {
            parentObject[pathName] = {};
          }
          parentObject = parentObject[pathName];
        }
      }
      if (parentObject !== void 0 && parentObject !== null) {
        if (isXml && mapper.xmlNamespace) {
          const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
          parentObject[XML_ATTRKEY2] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY2]), { [xmlnsKey]: mapper.xmlNamespace });
        }
        const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
        let toSerialize = object[key];
        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively2(serializer3, mapper);
        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === void 0 || toSerialize === null)) {
          toSerialize = mapper.serializedName;
        }
        const serializedValue = serializer3.serialize(propertyMapper, toSerialize, propertyObjectName, options);
        if (serializedValue !== void 0 && propName !== void 0 && propName !== null) {
          const value = getXmlObjectValue2(propertyMapper, serializedValue, isXml, options);
          if (isXml && propertyMapper.xmlIsAttribute) {
            parentObject[XML_ATTRKEY2] = parentObject[XML_ATTRKEY2] || {};
            parentObject[XML_ATTRKEY2][propName] = serializedValue;
          } else if (isXml && propertyMapper.xmlIsWrapped) {
            parentObject[propName] = { [propertyMapper.xmlElementName]: value };
          } else {
            parentObject[propName] = value;
          }
        }
      }
    }
    const additionalPropertiesMapper = resolveAdditionalProperties2(serializer3, mapper, objectName);
    if (additionalPropertiesMapper) {
      const propNames = Object.keys(modelProps);
      for (const clientPropName in object) {
        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
        if (isAdditionalProperty) {
          payload[clientPropName] = serializer3.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
        }
      }
    }
    return payload;
  }
  return object;
}
function getXmlObjectValue2(propertyMapper, serializedValue, isXml, options) {
  if (!isXml || !propertyMapper.xmlNamespace) {
    return serializedValue;
  }
  const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
  if (["Composite"].includes(propertyMapper.type.name)) {
    if (serializedValue[XML_ATTRKEY2]) {
      return serializedValue;
    } else {
      const result2 = Object.assign({}, serializedValue);
      result2[XML_ATTRKEY2] = xmlNamespace;
      return result2;
    }
  }
  const result = {};
  result[options.xml.xmlCharKey] = serializedValue;
  result[XML_ATTRKEY2] = xmlNamespace;
  return result;
}
function isSpecialXmlProperty2(propertyName, options) {
  return [XML_ATTRKEY2, options.xml.xmlCharKey].includes(propertyName);
}
function deserializeCompositeType2(serializer3, mapper, responseBody, objectName, options) {
  var _a2, _b;
  const xmlCharKey = (_a2 = options.xml.xmlCharKey) !== null && _a2 !== void 0 ? _a2 : XML_CHARKEY2;
  if (getPolymorphicDiscriminatorRecursively2(serializer3, mapper)) {
    mapper = getPolymorphicMapper2(serializer3, mapper, responseBody, "serializedName");
  }
  const modelProps = resolveModelProperties2(serializer3, mapper, objectName);
  let instance = {};
  const handledPropertyNames = [];
  for (const key of Object.keys(modelProps)) {
    const propertyMapper = modelProps[key];
    const paths = splitSerializeName2(modelProps[key].serializedName);
    handledPropertyNames.push(paths[0]);
    const { serializedName, xmlName, xmlElementName } = propertyMapper;
    let propertyObjectName = objectName;
    if (serializedName !== "" && serializedName !== void 0) {
      propertyObjectName = objectName + "." + serializedName;
    }
    const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
    if (headerCollectionPrefix) {
      const dictionary = {};
      for (const headerKey of Object.keys(responseBody)) {
        if (headerKey.startsWith(headerCollectionPrefix)) {
          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer3.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
        }
        handledPropertyNames.push(headerKey);
      }
      instance[key] = dictionary;
    } else if (serializer3.isXML) {
      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY2]) {
        instance[key] = serializer3.deserialize(propertyMapper, responseBody[XML_ATTRKEY2][xmlName], propertyObjectName, options);
      } else if (propertyMapper.xmlIsMsText) {
        if (responseBody[xmlCharKey] !== void 0) {
          instance[key] = responseBody[xmlCharKey];
        } else if (typeof responseBody === "string") {
          instance[key] = responseBody;
        }
      } else {
        const propertyName = xmlElementName || xmlName || serializedName;
        if (propertyMapper.xmlIsWrapped) {
          const wrapped = responseBody[xmlName];
          const elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];
          instance[key] = serializer3.deserialize(propertyMapper, elementList, propertyObjectName, options);
          handledPropertyNames.push(xmlName);
        } else {
          const property = responseBody[propertyName];
          instance[key] = serializer3.deserialize(propertyMapper, property, propertyObjectName, options);
          handledPropertyNames.push(propertyName);
        }
      }
    } else {
      let propertyInstance;
      let res = responseBody;
      let steps = 0;
      for (const item of paths) {
        if (!res)
          break;
        steps++;
        res = res[item];
      }
      if (res === null && steps < paths.length) {
        res = void 0;
      }
      propertyInstance = res;
      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === void 0 || propertyInstance === null)) {
        propertyInstance = mapper.serializedName;
      }
      let serializedValue;
      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
        propertyInstance = responseBody[key];
        const arrayInstance = serializer3.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        for (const [k, v] of Object.entries(instance)) {
          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
            arrayInstance[k] = v;
          }
        }
        instance = arrayInstance;
      } else if (propertyInstance !== void 0 || propertyMapper.defaultValue !== void 0) {
        serializedValue = serializer3.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        instance[key] = serializedValue;
      }
    }
  }
  const additionalPropertiesMapper = mapper.type.additionalProperties;
  if (additionalPropertiesMapper) {
    const isAdditionalProperty = (responsePropName) => {
      for (const clientPropName in modelProps) {
        const paths = splitSerializeName2(modelProps[clientPropName].serializedName);
        if (paths[0] === responsePropName) {
          return false;
        }
      }
      return true;
    };
    for (const responsePropName in responseBody) {
      if (isAdditionalProperty(responsePropName)) {
        instance[responsePropName] = serializer3.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
      }
    }
  } else if (responseBody && !options.ignoreUnknownProperties) {
    for (const key of Object.keys(responseBody)) {
      if (instance[key] === void 0 && !handledPropertyNames.includes(key) && !isSpecialXmlProperty2(key, options)) {
        instance[key] = responseBody[key];
      }
    }
  }
  return instance;
}
function deserializeDictionaryType2(serializer3, mapper, responseBody, objectName, options) {
  const value = mapper.type.value;
  if (!value || typeof value !== "object") {
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}`);
  }
  if (responseBody) {
    const tempDictionary = {};
    for (const key of Object.keys(responseBody)) {
      tempDictionary[key] = serializer3.deserialize(value, responseBody[key], objectName, options);
    }
    return tempDictionary;
  }
  return responseBody;
}
function deserializeSequenceType2(serializer3, mapper, responseBody, objectName, options) {
  var _a2;
  let element = mapper.type.element;
  if (!element || typeof element !== "object") {
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}`);
  }
  if (responseBody) {
    if (!Array.isArray(responseBody)) {
      responseBody = [responseBody];
    }
    if (element.type.name === "Composite" && element.type.className) {
      element = (_a2 = serializer3.modelMappers[element.type.className]) !== null && _a2 !== void 0 ? _a2 : element;
    }
    const tempArray = [];
    for (let i = 0; i < responseBody.length; i++) {
      tempArray[i] = serializer3.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
    }
    return tempArray;
  }
  return responseBody;
}
function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
  const typeNamesToCheck = [typeName];
  while (typeNamesToCheck.length) {
    const currentName = typeNamesToCheck.shift();
    const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
    if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
      return discriminators[indexDiscriminator];
    } else {
      for (const [name, mapper] of Object.entries(discriminators)) {
        if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) {
          typeNamesToCheck.push(mapper.type.className);
        }
      }
    }
  }
  return void 0;
}
function getPolymorphicMapper2(serializer3, mapper, object, polymorphicPropertyName) {
  var _a2;
  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively2(serializer3, mapper);
  if (polymorphicDiscriminator) {
    let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
    if (discriminatorName) {
      if (polymorphicPropertyName === "serializedName") {
        discriminatorName = discriminatorName.replace(/\\/gi, "");
      }
      const discriminatorValue = object[discriminatorName];
      const typeName = (_a2 = mapper.type.uberParent) !== null && _a2 !== void 0 ? _a2 : mapper.type.className;
      if (typeof discriminatorValue === "string" && typeName) {
        const polymorphicMapper = getIndexDiscriminator(serializer3.modelMappers.discriminators, discriminatorValue, typeName);
        if (polymorphicMapper) {
          mapper = polymorphicMapper;
        }
      }
    }
  }
  return mapper;
}
function getPolymorphicDiscriminatorRecursively2(serializer3, mapper) {
  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely2(serializer3, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely2(serializer3, mapper.type.className);
}
function getPolymorphicDiscriminatorSafely2(serializer3, typeName) {
  return typeName && serializer3.modelMappers[typeName] && serializer3.modelMappers[typeName].type.polymorphicDiscriminator;
}
var SerializerImpl, MapperTypeNames;
var init_serializer2 = __esm({
  "node_modules/@azure/core-client/dist-esm/src/serializer.js"() {
    init_base64_browser3();
    init_interfaces2();
    init_utils4();
    SerializerImpl = class {
      constructor(modelMappers = {}, isXML = false) {
        this.modelMappers = modelMappers;
        this.isXML = isXML;
      }
      /**
       * @deprecated Removing the constraints validation on client side.
       */
      validateConstraints(mapper, value, objectName) {
        const failValidation = (constraintName, constraintValue) => {
          throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
        };
        if (mapper.constraints && value !== void 0 && value !== null) {
          const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
          if (ExclusiveMaximum !== void 0 && value >= ExclusiveMaximum) {
            failValidation("ExclusiveMaximum", ExclusiveMaximum);
          }
          if (ExclusiveMinimum !== void 0 && value <= ExclusiveMinimum) {
            failValidation("ExclusiveMinimum", ExclusiveMinimum);
          }
          if (InclusiveMaximum !== void 0 && value > InclusiveMaximum) {
            failValidation("InclusiveMaximum", InclusiveMaximum);
          }
          if (InclusiveMinimum !== void 0 && value < InclusiveMinimum) {
            failValidation("InclusiveMinimum", InclusiveMinimum);
          }
          if (MaxItems !== void 0 && value.length > MaxItems) {
            failValidation("MaxItems", MaxItems);
          }
          if (MaxLength !== void 0 && value.length > MaxLength) {
            failValidation("MaxLength", MaxLength);
          }
          if (MinItems !== void 0 && value.length < MinItems) {
            failValidation("MinItems", MinItems);
          }
          if (MinLength !== void 0 && value.length < MinLength) {
            failValidation("MinLength", MinLength);
          }
          if (MultipleOf !== void 0 && value % MultipleOf !== 0) {
            failValidation("MultipleOf", MultipleOf);
          }
          if (Pattern) {
            const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
            if (typeof value !== "string" || value.match(pattern) === null) {
              failValidation("Pattern", Pattern);
            }
          }
          if (UniqueItems && value.some((item, i, ar) => ar.indexOf(item) !== i)) {
            failValidation("UniqueItems", UniqueItems);
          }
        }
      }
      /**
       * Serialize the given object based on its metadata defined in the mapper
       *
       * @param mapper - The mapper which defines the metadata of the serializable object
       *
       * @param object - A valid Javascript object to be serialized
       *
       * @param objectName - Name of the serialized object
       *
       * @param options - additional options to serialization
       *
       * @returns A valid serialized Javascript object
       */
      serialize(mapper, object, objectName, options = { xml: {} }) {
        var _a2, _b, _c;
        const updatedOptions = {
          xml: {
            rootName: (_a2 = options.xml.rootName) !== null && _a2 !== void 0 ? _a2 : "",
            includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
            xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY2
          }
        };
        let payload = {};
        const mapperType = mapper.type.name;
        if (!objectName) {
          objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Sequence$/i) !== null) {
          payload = [];
        }
        if (mapper.isConstant) {
          object = mapper.defaultValue;
        }
        const { required, nullable } = mapper;
        if (required && nullable && object === void 0) {
          throw new Error(`${objectName} cannot be undefined.`);
        }
        if (required && !nullable && (object === void 0 || object === null)) {
          throw new Error(`${objectName} cannot be null or undefined.`);
        }
        if (!required && nullable === false && object === null) {
          throw new Error(`${objectName} cannot be null.`);
        }
        if (object === void 0 || object === null) {
          payload = object;
        } else {
          if (mapperType.match(/^any$/i) !== null) {
            payload = object;
          } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
            payload = serializeBasicTypes2(mapperType, objectName, object);
          } else if (mapperType.match(/^Enum$/i) !== null) {
            const enumMapper = mapper;
            payload = serializeEnumType2(objectName, enumMapper.type.allowedValues, object);
          } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
            payload = serializeDateTypes2(mapperType, object, objectName);
          } else if (mapperType.match(/^ByteArray$/i) !== null) {
            payload = serializeByteArrayType2(objectName, object);
          } else if (mapperType.match(/^Base64Url$/i) !== null) {
            payload = serializeBase64UrlType2(objectName, object);
          } else if (mapperType.match(/^Sequence$/i) !== null) {
            payload = serializeSequenceType2(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          } else if (mapperType.match(/^Dictionary$/i) !== null) {
            payload = serializeDictionaryType2(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          } else if (mapperType.match(/^Composite$/i) !== null) {
            payload = serializeCompositeType2(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
          }
        }
        return payload;
      }
      /**
       * Deserialize the given object based on its metadata defined in the mapper
       *
       * @param mapper - The mapper which defines the metadata of the serializable object
       *
       * @param responseBody - A valid Javascript entity to be deserialized
       *
       * @param objectName - Name of the deserialized object
       *
       * @param options - Controls behavior of XML parser and builder.
       *
       * @returns A valid deserialized Javascript object
       */
      deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
        var _a2, _b, _c, _d;
        const updatedOptions = {
          xml: {
            rootName: (_a2 = options.xml.rootName) !== null && _a2 !== void 0 ? _a2 : "",
            includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
            xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY2
          },
          ignoreUnknownProperties: (_d = options.ignoreUnknownProperties) !== null && _d !== void 0 ? _d : false
        };
        if (responseBody === void 0 || responseBody === null) {
          if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
            responseBody = [];
          }
          if (mapper.defaultValue !== void 0) {
            responseBody = mapper.defaultValue;
          }
          return responseBody;
        }
        let payload;
        const mapperType = mapper.type.name;
        if (!objectName) {
          objectName = mapper.serializedName;
        }
        if (mapperType.match(/^Composite$/i) !== null) {
          payload = deserializeCompositeType2(this, mapper, responseBody, objectName, updatedOptions);
        } else {
          if (this.isXML) {
            const xmlCharKey = updatedOptions.xml.xmlCharKey;
            if (responseBody[XML_ATTRKEY2] !== void 0 && responseBody[xmlCharKey] !== void 0) {
              responseBody = responseBody[xmlCharKey];
            }
          }
          if (mapperType.match(/^Number$/i) !== null) {
            payload = parseFloat(responseBody);
            if (isNaN(payload)) {
              payload = responseBody;
            }
          } else if (mapperType.match(/^Boolean$/i) !== null) {
            if (responseBody === "true") {
              payload = true;
            } else if (responseBody === "false") {
              payload = false;
            } else {
              payload = responseBody;
            }
          } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
            payload = responseBody;
          } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
            payload = new Date(responseBody);
          } else if (mapperType.match(/^UnixTime$/i) !== null) {
            payload = unixTimeToDate2(responseBody);
          } else if (mapperType.match(/^ByteArray$/i) !== null) {
            payload = decodeString2(responseBody);
          } else if (mapperType.match(/^Base64Url$/i) !== null) {
            payload = base64UrlToByteArray2(responseBody);
          } else if (mapperType.match(/^Sequence$/i) !== null) {
            payload = deserializeSequenceType2(this, mapper, responseBody, objectName, updatedOptions);
          } else if (mapperType.match(/^Dictionary$/i) !== null) {
            payload = deserializeDictionaryType2(this, mapper, responseBody, objectName, updatedOptions);
          }
        }
        if (mapper.isConstant) {
          payload = mapper.defaultValue;
        }
        return payload;
      }
    };
    MapperTypeNames = {
      Base64Url: "Base64Url",
      Boolean: "Boolean",
      ByteArray: "ByteArray",
      Composite: "Composite",
      Date: "Date",
      DateTime: "DateTime",
      DateTimeRfc1123: "DateTimeRfc1123",
      Dictionary: "Dictionary",
      Enum: "Enum",
      Number: "Number",
      Object: "Object",
      Sequence: "Sequence",
      String: "String",
      Stream: "Stream",
      TimeSpan: "TimeSpan",
      UnixTime: "UnixTime"
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js
function createEmptyPipeline() {
  return HttpPipeline.create();
}
var ValidPhaseNames, HttpPipeline;
var init_pipeline = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js"() {
    ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
    HttpPipeline = class _HttpPipeline {
      constructor(policies) {
        var _a2;
        this._policies = [];
        this._policies = (_a2 = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a2 !== void 0 ? _a2 : [];
        this._orderedPolicies = void 0;
      }
      addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) {
          throw new Error("Policies inside a phase cannot specify afterPhase.");
        }
        if (options.phase && !ValidPhaseNames.has(options.phase)) {
          throw new Error(`Invalid phase name: ${options.phase}`);
        }
        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
          throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        }
        this._policies.push({
          policy,
          options
        });
        this._orderedPolicies = void 0;
      }
      removePolicy(options) {
        const removedPolicies = [];
        this._policies = this._policies.filter((policyDescriptor) => {
          if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
            removedPolicies.push(policyDescriptor.policy);
            return false;
          } else {
            return true;
          }
        });
        this._orderedPolicies = void 0;
        return removedPolicies;
      }
      sendRequest(httpClient, request) {
        const policies = this.getOrderedPolicies();
        const pipeline = policies.reduceRight((next, policy) => {
          return (req) => {
            return policy.sendRequest(req, next);
          };
        }, (req) => httpClient.sendRequest(req));
        return pipeline(request);
      }
      getOrderedPolicies() {
        if (!this._orderedPolicies) {
          this._orderedPolicies = this.orderPolicies();
        }
        return this._orderedPolicies;
      }
      clone() {
        return new _HttpPipeline(this._policies);
      }
      static create() {
        return new _HttpPipeline();
      }
      orderPolicies() {
        const result = [];
        const policyMap = /* @__PURE__ */ new Map();
        function createPhase(name) {
          return {
            name,
            policies: /* @__PURE__ */ new Set(),
            hasRun: false,
            hasAfterPolicies: false
          };
        }
        const serializePhase = createPhase("Serialize");
        const noPhase = createPhase("None");
        const deserializePhase = createPhase("Deserialize");
        const retryPhase = createPhase("Retry");
        const signPhase = createPhase("Sign");
        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
        function getPhase(phase) {
          if (phase === "Retry") {
            return retryPhase;
          } else if (phase === "Serialize") {
            return serializePhase;
          } else if (phase === "Deserialize") {
            return deserializePhase;
          } else if (phase === "Sign") {
            return signPhase;
          } else {
            return noPhase;
          }
        }
        for (const descriptor of this._policies) {
          const policy = descriptor.policy;
          const options = descriptor.options;
          const policyName = policy.name;
          if (policyMap.has(policyName)) {
            throw new Error("Duplicate policy names not allowed in pipeline");
          }
          const node = {
            policy,
            dependsOn: /* @__PURE__ */ new Set(),
            dependants: /* @__PURE__ */ new Set()
          };
          if (options.afterPhase) {
            node.afterPhase = getPhase(options.afterPhase);
            node.afterPhase.hasAfterPolicies = true;
          }
          policyMap.set(policyName, node);
          const phase = getPhase(options.phase);
          phase.policies.add(node);
        }
        for (const descriptor of this._policies) {
          const { policy, options } = descriptor;
          const policyName = policy.name;
          const node = policyMap.get(policyName);
          if (!node) {
            throw new Error(`Missing node for policy ${policyName}`);
          }
          if (options.afterPolicies) {
            for (const afterPolicyName of options.afterPolicies) {
              const afterNode = policyMap.get(afterPolicyName);
              if (afterNode) {
                node.dependsOn.add(afterNode);
                afterNode.dependants.add(node);
              }
            }
          }
          if (options.beforePolicies) {
            for (const beforePolicyName of options.beforePolicies) {
              const beforeNode = policyMap.get(beforePolicyName);
              if (beforeNode) {
                beforeNode.dependsOn.add(node);
                node.dependants.add(beforeNode);
              }
            }
          }
        }
        function walkPhase(phase) {
          phase.hasRun = true;
          for (const node of phase.policies) {
            if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
              continue;
            }
            if (node.dependsOn.size === 0) {
              result.push(node.policy);
              for (const dependant of node.dependants) {
                dependant.dependsOn.delete(node);
              }
              policyMap.delete(node.policy.name);
              phase.policies.delete(node);
            }
          }
        }
        function walkPhases() {
          for (const phase of orderedPhases) {
            walkPhase(phase);
            if (phase.policies.size > 0 && phase !== noPhase) {
              if (!noPhase.hasRun) {
                walkPhase(noPhase);
              }
              return;
            }
            if (phase.hasAfterPolicies) {
              walkPhase(noPhase);
            }
          }
        }
        let iteration = 0;
        while (policyMap.size > 0) {
          iteration++;
          const initialResultLength = result.length;
          walkPhases();
          if (result.length <= initialResultLength && iteration > 1) {
            throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
          }
        }
        return result;
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js
var logger3;
var init_log2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js"() {
    init_src3();
    logger3 = createClientLogger("core-rest-pipeline");
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js
var RedactedString2, defaultAllowedHeaderNames2, defaultAllowedQueryParameters2, Sanitizer2;
var init_sanitizer2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js"() {
    init_src2();
    RedactedString2 = "REDACTED";
    defaultAllowedHeaderNames2 = [
      "x-ms-client-request-id",
      "x-ms-return-client-request-id",
      "x-ms-useragent",
      "x-ms-correlation-request-id",
      "x-ms-request-id",
      "client-request-id",
      "ms-cv",
      "return-client-request-id",
      "traceparent",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Origin",
      "Accept",
      "Accept-Encoding",
      "Cache-Control",
      "Connection",
      "Content-Length",
      "Content-Type",
      "Date",
      "ETag",
      "Expires",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "Last-Modified",
      "Pragma",
      "Request-Id",
      "Retry-After",
      "Server",
      "Transfer-Encoding",
      "User-Agent",
      "WWW-Authenticate"
    ];
    defaultAllowedQueryParameters2 = ["api-version"];
    Sanitizer2 = class {
      constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
        allowedHeaderNames = defaultAllowedHeaderNames2.concat(allowedHeaderNames);
        allowedQueryParameters = defaultAllowedQueryParameters2.concat(allowedQueryParameters);
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
      }
      sanitize(obj) {
        const seen = /* @__PURE__ */ new Set();
        return JSON.stringify(obj, (key, value) => {
          if (value instanceof Error) {
            return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
          }
          if (key === "headers") {
            return this.sanitizeHeaders(value);
          } else if (key === "url") {
            return this.sanitizeUrl(value);
          } else if (key === "query") {
            return this.sanitizeQuery(value);
          } else if (key === "body") {
            return void 0;
          } else if (key === "response") {
            return void 0;
          } else if (key === "operationSpec") {
            return void 0;
          } else if (Array.isArray(value) || isObject2(value)) {
            if (seen.has(value)) {
              return "[Circular]";
            }
            seen.add(value);
          }
          return value;
        }, 2);
      }
      sanitizeHeaders(obj) {
        const sanitized = {};
        for (const key of Object.keys(obj)) {
          if (this.allowedHeaderNames.has(key.toLowerCase())) {
            sanitized[key] = obj[key];
          } else {
            sanitized[key] = RedactedString2;
          }
        }
        return sanitized;
      }
      sanitizeQuery(value) {
        if (typeof value !== "object" || value === null) {
          return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
          if (this.allowedQueryParameters.has(k.toLowerCase())) {
            sanitized[k] = value[k];
          } else {
            sanitized[k] = RedactedString2;
          }
        }
        return sanitized;
      }
      sanitizeUrl(value) {
        if (typeof value !== "string" || value === null) {
          return value;
        }
        const url = new URL(value);
        if (!url.search) {
          return value;
        }
        for (const [key] of url.searchParams) {
          if (!this.allowedQueryParameters.has(key.toLowerCase())) {
            url.searchParams.set(key, RedactedString2);
          }
        }
        return url.toString();
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/logPolicy.js
function logPolicy2(options = {}) {
  var _a2;
  const logger5 = (_a2 = options.logger) !== null && _a2 !== void 0 ? _a2 : logger3.info;
  const sanitizer = new Sanitizer2({
    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  return {
    name: logPolicyName,
    async sendRequest(request, next) {
      if (!logger5.enabled) {
        return next(request);
      }
      logger5(`Request: ${sanitizer.sanitize(request)}`);
      const response = await next(request);
      logger5(`Response status code: ${response.status}`);
      logger5(`Headers: ${sanitizer.sanitize(response.headers)}`);
      return response;
    }
  };
}
var logPolicyName;
var init_logPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/logPolicy.js"() {
    init_log2();
    init_sanitizer2();
    logPolicyName = "logPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/redirectPolicy.js
function redirectPolicy2(options = {}) {
  const { maxRetries = 20 } = options;
  return {
    name: redirectPolicyName,
    async sendRequest(request, next) {
      const response = await next(request);
      return handleRedirect2(next, response, maxRetries);
    }
  };
}
async function handleRedirect2(next, response, maxRetries, currentRetries = 0) {
  const { request, status: status2, headers } = response;
  const locationHeader = headers.get("location");
  if (locationHeader && (status2 === 300 || status2 === 301 && allowedRedirect2.includes(request.method) || status2 === 302 && allowedRedirect2.includes(request.method) || status2 === 303 && request.method === "POST" || status2 === 307) && currentRetries < maxRetries) {
    const url = new URL(locationHeader, request.url);
    request.url = url.toString();
    if (status2 === 303) {
      request.method = "GET";
      request.headers.delete("Content-Length");
      delete request.body;
    }
    request.headers.delete("Authorization");
    const res = await next(request);
    return handleRedirect2(next, res, maxRetries, currentRetries + 1);
  }
  return response;
}
var redirectPolicyName, allowedRedirect2;
var init_redirectPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/redirectPolicy.js"() {
    redirectPolicyName = "redirectPolicy";
    allowedRedirect2 = ["GET", "HEAD"];
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgentPlatform.browser.js
function getHeaderName() {
  return "x-ms-useragent";
}
function setPlatformSpecificData(map) {
  var _a2, _b, _c;
  const localNavigator = globalThis.navigator;
  map.set("OS", ((_c = (_b = (_a2 = localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.userAgentData) === null || _a2 === void 0 ? void 0 : _a2.platform) !== null && _b !== void 0 ? _b : localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.platform) !== null && _c !== void 0 ? _c : "unknown").replace(" ", ""));
}
var init_userAgentPlatform_browser = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgentPlatform.browser.js"() {
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js
var SDK_VERSION, DEFAULT_RETRY_POLICY_COUNT;
var init_constants2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js"() {
    SDK_VERSION = "1.11.0";
    DEFAULT_RETRY_POLICY_COUNT = 3;
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js
function getUserAgentString2(telemetryInfo) {
  const parts = [];
  for (const [key, value] of telemetryInfo) {
    const token = value ? `${key}/${value}` : key;
    parts.push(token);
  }
  return parts.join(" ");
}
function getUserAgentHeaderName() {
  return getHeaderName();
}
function getUserAgentValue(prefix) {
  const runtimeInfo = /* @__PURE__ */ new Map();
  runtimeInfo.set("core-rest-pipeline", SDK_VERSION);
  setPlatformSpecificData(runtimeInfo);
  const defaultAgent = getUserAgentString2(runtimeInfo);
  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  return userAgentValue;
}
var init_userAgent = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js"() {
    init_userAgentPlatform_browser();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/userAgentPolicy.js
function userAgentPolicy2(options = {}) {
  const userAgentValue = getUserAgentValue(options.userAgentPrefix);
  return {
    name: userAgentPolicyName,
    async sendRequest(request, next) {
      if (!request.headers.has(UserAgentHeaderName)) {
        request.headers.set(UserAgentHeaderName, userAgentValue);
      }
      return next(request);
    }
  };
}
var UserAgentHeaderName, userAgentPolicyName;
var init_userAgentPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/userAgentPolicy.js"() {
    init_userAgent();
    UserAgentHeaderName = getUserAgentHeaderName();
    userAgentPolicyName = "userAgentPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/decompressResponsePolicy.browser.js
function decompressResponsePolicy() {
  throw NotSupported;
}
var NotSupported;
var init_decompressResponsePolicy_browser = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/decompressResponsePolicy.browser.js"() {
    NotSupported = new Error("decompressResponsePolicy is not supported in browser environment");
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js
function delay2(delayInMs, value, options) {
  return new Promise((resolve, reject) => {
    let timer = void 0;
    let onAborted = void 0;
    const rejectOnAbort = () => {
      return reject(new AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage3));
    };
    const removeListeners = () => {
      if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
        options.abortSignal.removeEventListener("abort", onAborted);
      }
    };
    onAborted = () => {
      if (timer) {
        clearTimeout(timer);
      }
      removeListeners();
      return rejectOnAbort();
    };
    if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
      return rejectOnAbort();
    }
    timer = setTimeout(() => {
      removeListeners();
      resolve(value);
    }, delayInMs);
    if (options === null || options === void 0 ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", onAborted);
    }
  });
}
function parseHeaderValueAsNumber(response, headerName) {
  const value = response.headers.get(headerName);
  if (!value)
    return;
  const valueAsNum = Number(value);
  if (Number.isNaN(valueAsNum))
    return;
  return valueAsNum;
}
var StandardAbortMessage3;
var init_helpers = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js"() {
    init_src();
    StandardAbortMessage3 = "The operation was aborted.";
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js
function getRetryAfterInMs(response) {
  if (!(response && [429, 503].includes(response.status)))
    return void 0;
  try {
    for (const header of AllRetryAfterHeaders) {
      const retryAfterValue = parseHeaderValueAsNumber(response, header);
      if (retryAfterValue === 0 || retryAfterValue) {
        const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
        return retryAfterValue * multiplyingFactor;
      }
    }
    const retryAfterHeader = response.headers.get(RetryAfterHeader);
    if (!retryAfterHeader)
      return;
    const date2 = Date.parse(retryAfterHeader);
    const diff = date2 - Date.now();
    return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
  } catch (e) {
    return void 0;
  }
}
function isThrottlingRetryResponse(response) {
  return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
  return {
    name: "throttlingRetryStrategy",
    retry({ response }) {
      const retryAfterInMs = getRetryAfterInMs(response);
      if (!Number.isFinite(retryAfterInMs)) {
        return { skipStrategy: true };
      }
      return {
        retryAfterInMs
      };
    }
  };
}
var RetryAfterHeader, AllRetryAfterHeaders;
var init_throttlingRetryStrategy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js"() {
    init_helpers();
    RetryAfterHeader = "Retry-After";
    AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js
function exponentialRetryStrategy(options = {}) {
  var _a2, _b;
  const retryInterval = (_a2 = options.retryDelayInMs) !== null && _a2 !== void 0 ? _a2 : DEFAULT_CLIENT_RETRY_INTERVAL2;
  const maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== void 0 ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL2;
  let retryAfterInMs = retryInterval;
  return {
    name: "exponentialRetryStrategy",
    retry({ retryCount, response, responseError }) {
      const matchedSystemError = isSystemError(responseError);
      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
      const isExponential = isExponentialRetryResponse(response);
      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
        return { skipStrategy: true };
      }
      if (responseError && !matchedSystemError && !isExponential) {
        return { errorToThrow: responseError };
      }
      const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
      const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
      retryAfterInMs = clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
      return { retryAfterInMs };
    }
  };
}
function isExponentialRetryResponse(response) {
  return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
}
function isSystemError(err) {
  if (!err) {
    return false;
  }
  return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT";
}
var DEFAULT_CLIENT_RETRY_INTERVAL2, DEFAULT_CLIENT_MAX_RETRY_INTERVAL2;
var init_exponentialRetryStrategy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js"() {
    init_src2();
    init_throttlingRetryStrategy2();
    DEFAULT_CLIENT_RETRY_INTERVAL2 = 1e3;
    DEFAULT_CLIENT_MAX_RETRY_INTERVAL2 = 1e3 * 64;
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js
function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
  const logger5 = options.logger || retryPolicyLogger;
  return {
    name: retryPolicyName,
    async sendRequest(request, next) {
      var _a2, _b;
      let response;
      let responseError;
      let retryCount = -1;
      retryRequest:
        while (true) {
          retryCount += 1;
          response = void 0;
          responseError = void 0;
          try {
            logger5.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
            response = await next(request);
            logger5.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
          } catch (e) {
            logger5.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
            responseError = e;
            if (!e || responseError.name !== "RestError") {
              throw e;
            }
            response = responseError.response;
          }
          if ((_a2 = request.abortSignal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
            logger5.error(`Retry ${retryCount}: Request aborted.`);
            const abortError = new AbortError();
            throw abortError;
          }
          if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {
            logger5.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
            if (responseError) {
              throw responseError;
            } else if (response) {
              return response;
            } else {
              throw new Error("Maximum retries reached with no response or error to throw");
            }
          }
          logger5.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
          strategiesLoop:
            for (const strategy of strategies) {
              const strategyLogger = strategy.logger || retryPolicyLogger;
              strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
              const modifiers = strategy.retry({
                retryCount,
                response,
                responseError
              });
              if (modifiers.skipStrategy) {
                strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                continue strategiesLoop;
              }
              const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
              if (errorToThrow) {
                strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                throw errorToThrow;
              }
              if (retryAfterInMs || retryAfterInMs === 0) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                await delay2(retryAfterInMs, void 0, { abortSignal: request.abortSignal });
                continue retryRequest;
              }
              if (redirectTo) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                request.url = redirectTo;
                continue retryRequest;
              }
            }
          if (responseError) {
            logger5.info(`None of the retry strategies could work with the received error. Throwing it.`);
            throw responseError;
          }
          if (response) {
            logger5.info(`None of the retry strategies could work with the received response. Returning it.`);
            return response;
          }
        }
    }
  };
}
var retryPolicyLogger, retryPolicyName;
var init_retryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js"() {
    init_helpers();
    init_src3();
    init_src();
    init_constants2();
    retryPolicyLogger = createClientLogger("core-rest-pipeline retryPolicy");
    retryPolicyName = "retryPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/defaultRetryPolicy.js
function defaultRetryPolicy(options = {}) {
  var _a2;
  return {
    name: defaultRetryPolicyName,
    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
      maxRetries: (_a2 = options.maxRetries) !== null && _a2 !== void 0 ? _a2 : DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}
var defaultRetryPolicyName;
var init_defaultRetryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/defaultRetryPolicy.js"() {
    init_exponentialRetryStrategy();
    init_throttlingRetryStrategy2();
    init_retryPolicy();
    init_constants2();
    defaultRetryPolicyName = "defaultRetryPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/formDataPolicy.browser.js
function formDataPolicy() {
  return {
    name: formDataPolicyName,
    async sendRequest(request, next) {
      if (request.formData) {
        const formData = request.formData;
        const requestForm = new FormData();
        for (const formKey of Object.keys(formData)) {
          const formValue = formData[formKey];
          if (Array.isArray(formValue)) {
            for (const subValue of formValue) {
              requestForm.append(formKey, subValue);
            }
          } else {
            requestForm.append(formKey, formValue);
          }
        }
        request.body = requestForm;
        request.formData = void 0;
        const contentType2 = request.headers.get("Content-Type");
        if (contentType2 && contentType2.indexOf("application/x-www-form-urlencoded") !== -1) {
          request.body = new URLSearchParams(requestForm).toString();
        } else if (contentType2 && contentType2.indexOf("multipart/form-data") !== -1) {
          request.headers.delete("Content-Type");
        }
      }
      return next(request);
    }
  };
}
var formDataPolicyName;
var init_formDataPolicy_browser = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/formDataPolicy.browser.js"() {
    formDataPolicyName = "formDataPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/proxyPolicy.browser.js
function proxyPolicy2() {
  throw NotSupported2;
}
var NotSupported2;
var init_proxyPolicy_browser2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/proxyPolicy.browser.js"() {
    NotSupported2 = new Error("proxyPolicy is not supported in browser environment");
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/setClientRequestIdPolicy.js
function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
  return {
    name: setClientRequestIdPolicyName,
    async sendRequest(request, next) {
      if (!request.headers.has(requestIdHeaderName)) {
        request.headers.set(requestIdHeaderName, request.requestId);
      }
      return next(request);
    }
  };
}
var setClientRequestIdPolicyName;
var init_setClientRequestIdPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/setClientRequestIdPolicy.js"() {
    setClientRequestIdPolicyName = "setClientRequestIdPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tlsPolicy.js
function tlsPolicy(tlsSettings) {
  return {
    name: tlsPolicyName,
    sendRequest: async (req, next) => {
      if (!req.tlsSettings) {
        req.tlsSettings = tlsSettings;
      }
      return next(req);
    }
  };
}
var tlsPolicyName;
var init_tlsPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tlsPolicy.js"() {
    tlsPolicyName = "tlsPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js
function createTracingContext(options = {}) {
  let context3 = new TracingContextImpl(options.parentContext);
  if (options.span) {
    context3 = context3.setValue(knownContextKeys.span, options.span);
  }
  if (options.namespace) {
    context3 = context3.setValue(knownContextKeys.namespace, options.namespace);
  }
  return context3;
}
var knownContextKeys, TracingContextImpl;
var init_tracingContext = __esm({
  "node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js"() {
    knownContextKeys = {
      span: Symbol.for("@azure/core-tracing span"),
      namespace: Symbol.for("@azure/core-tracing namespace")
    };
    TracingContextImpl = class _TracingContextImpl {
      constructor(initialContext) {
        this._contextMap = initialContext instanceof _TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
      }
      setValue(key, value) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.set(key, value);
        return newContext;
      }
      getValue(key) {
        return this._contextMap.get(key);
      }
      deleteValue(key) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.delete(key);
        return newContext;
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist-esm/src/instrumenter.js
function createDefaultTracingSpan() {
  return {
    end: () => {
    },
    isRecording: () => false,
    recordException: () => {
    },
    setAttribute: () => {
    },
    setStatus: () => {
    }
  };
}
function createDefaultInstrumenter() {
  return {
    createRequestHeaders: () => {
      return {};
    },
    parseTraceparentHeader: () => {
      return void 0;
    },
    startSpan: (_name, spanOptions) => {
      return {
        span: createDefaultTracingSpan(),
        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext })
      };
    },
    withContext(_context, callback, ...callbackArgs) {
      return callback(...callbackArgs);
    }
  };
}
function getInstrumenter() {
  if (!instrumenterImplementation) {
    instrumenterImplementation = createDefaultInstrumenter();
  }
  return instrumenterImplementation;
}
var instrumenterImplementation;
var init_instrumenter = __esm({
  "node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist-esm/src/instrumenter.js"() {
    init_tracingContext();
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js
function createTracingClient(options) {
  const { namespace, packageName, packageVersion } = options;
  function startSpan(name, operationOptions, spanOptions) {
    var _a2;
    const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a2 = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a2 === void 0 ? void 0 : _a2.tracingContext }));
    let tracingContext = startSpanResult.tracingContext;
    const span = startSpanResult.span;
    if (!tracingContext.getValue(knownContextKeys.namespace)) {
      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
    }
    span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
    const updatedOptions = Object.assign({}, operationOptions, {
      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext })
    });
    return {
      span,
      updatedOptions
    };
  }
  async function withSpan(name, operationOptions, callback, spanOptions) {
    const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
    try {
      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
      span.setStatus({ status: "success" });
      return result;
    } catch (err) {
      span.setStatus({ status: "error", error: err });
      throw err;
    } finally {
      span.end();
    }
  }
  function withContext(context3, callback, ...callbackArgs) {
    return getInstrumenter().withContext(context3, callback, ...callbackArgs);
  }
  function parseTraceparentHeader(traceparentHeader) {
    return getInstrumenter().parseTraceparentHeader(traceparentHeader);
  }
  function createRequestHeaders(tracingContext) {
    return getInstrumenter().createRequestHeaders(tracingContext);
  }
  return {
    startSpan,
    withSpan,
    withContext,
    parseTraceparentHeader,
    createRequestHeaders
  };
}
var init_tracingClient = __esm({
  "node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js"() {
    init_instrumenter();
    init_tracingContext();
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist-esm/src/index.js
var init_src8 = __esm({
  "node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist-esm/src/index.js"() {
    init_instrumenter();
    init_tracingClient();
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/inspect.browser.js
var custom2;
var init_inspect_browser2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/util/inspect.browser.js"() {
    custom2 = {};
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js
function isRestError(e) {
  if (e instanceof RestError2) {
    return true;
  }
  return isError(e) && e.name === "RestError";
}
var errorSanitizer2, RestError2;
var init_restError2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js"() {
    init_src2();
    init_inspect_browser2();
    init_sanitizer2();
    errorSanitizer2 = new Sanitizer2();
    RestError2 = class _RestError extends Error {
      constructor(message, options = {}) {
        super(message);
        this.name = "RestError";
        this.code = options.code;
        this.statusCode = options.statusCode;
        this.request = options.request;
        this.response = options.response;
        Object.setPrototypeOf(this, _RestError.prototype);
      }
      /**
       * Logging method for util.inspect in Node
       */
      [custom2]() {
        return `RestError: ${this.message} 
 ${errorSanitizer2.sanitize(this)}`;
      }
    };
    RestError2.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    RestError2.PARSE_ERROR = "PARSE_ERROR";
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js
function tracingPolicy2(options = {}) {
  const userAgent = getUserAgentValue(options.userAgentPrefix);
  const tracingClient = tryCreateTracingClient();
  return {
    name: tracingPolicyName,
    async sendRequest(request, next) {
      var _a2, _b;
      if (!tracingClient || !((_a2 = request.tracingOptions) === null || _a2 === void 0 ? void 0 : _a2.tracingContext)) {
        return next(request);
      }
      const { span, tracingContext } = (_b = tryCreateSpan(tracingClient, request, userAgent)) !== null && _b !== void 0 ? _b : {};
      if (!span || !tracingContext) {
        return next(request);
      }
      try {
        const response = await tracingClient.withContext(tracingContext, next, request);
        tryProcessResponse(span, response);
        return response;
      } catch (err) {
        tryProcessError(span, err);
        throw err;
      }
    }
  };
}
function tryCreateTracingClient() {
  try {
    return createTracingClient({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: SDK_VERSION
    });
  } catch (e) {
    logger3.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryCreateSpan(tracingClient, request, userAgent) {
  try {
    const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
      spanKind: "client",
      spanAttributes: {
        "http.method": request.method,
        "http.url": request.url,
        requestId: request.requestId
      }
    });
    if (!span.isRecording()) {
      span.end();
      return void 0;
    }
    if (userAgent) {
      span.setAttribute("http.user_agent", userAgent);
    }
    const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
    for (const [key, value] of Object.entries(headers)) {
      request.headers.set(key, value);
    }
    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
  } catch (e) {
    logger3.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryProcessError(span, error) {
  try {
    span.setStatus({
      status: "error",
      error: isError(error) ? error : void 0
    });
    if (isRestError(error) && error.statusCode) {
      span.setAttribute("http.status_code", error.statusCode);
    }
    span.end();
  } catch (e) {
    logger3.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
function tryProcessResponse(span, response) {
  try {
    span.setAttribute("http.status_code", response.status);
    const serviceRequestId = response.headers.get("x-ms-request-id");
    if (serviceRequestId) {
      span.setAttribute("serviceRequestId", serviceRequestId);
    }
    span.setStatus({
      status: "success"
    });
    span.end();
  } catch (e) {
    logger3.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
var tracingPolicyName;
var init_tracingPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js"() {
    init_src8();
    init_constants2();
    init_userAgent();
    init_log2();
    init_src2();
    init_restError2();
    tracingPolicyName = "tracingPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/createPipelineFromOptions.js
function createPipelineFromOptions2(options) {
  const pipeline = createEmptyPipeline();
  if (isNode2) {
    if (options.tlsOptions) {
      pipeline.addPolicy(tlsPolicy(options.tlsOptions));
    }
    pipeline.addPolicy(proxyPolicy2(options.proxyOptions));
    pipeline.addPolicy(decompressResponsePolicy());
  }
  pipeline.addPolicy(formDataPolicy());
  pipeline.addPolicy(userAgentPolicy2(options.userAgentOptions));
  pipeline.addPolicy(setClientRequestIdPolicy());
  pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
  pipeline.addPolicy(tracingPolicy2(options.userAgentOptions), { afterPhase: "Retry" });
  if (isNode2) {
    pipeline.addPolicy(redirectPolicy2(options.redirectOptions), { afterPhase: "Retry" });
  }
  pipeline.addPolicy(logPolicy2(options.loggingOptions), { afterPhase: "Sign" });
  return pipeline;
}
var init_createPipelineFromOptions = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/createPipelineFromOptions.js"() {
    init_logPolicy2();
    init_pipeline();
    init_redirectPolicy2();
    init_userAgentPolicy2();
    init_decompressResponsePolicy_browser();
    init_defaultRetryPolicy();
    init_formDataPolicy_browser();
    init_src2();
    init_proxyPolicy_browser2();
    init_setClientRequestIdPolicy();
    init_tlsPolicy();
    init_tracingPolicy2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js
function normalizeName(name) {
  return name.toLowerCase();
}
function* headerIterator(map) {
  for (const entry of map.values()) {
    yield [entry.name, entry.value];
  }
}
function createHttpHeaders(rawHeaders) {
  return new HttpHeadersImpl(rawHeaders);
}
var HttpHeadersImpl;
var init_httpHeaders2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js"() {
    HttpHeadersImpl = class {
      constructor(rawHeaders) {
        this._headersMap = /* @__PURE__ */ new Map();
        if (rawHeaders) {
          for (const headerName of Object.keys(rawHeaders)) {
            this.set(headerName, rawHeaders[headerName]);
          }
        }
      }
      /**
       * Set a header in this collection with the provided name and value. The name is
       * case-insensitive.
       * @param name - The name of the header to set. This value is case-insensitive.
       * @param value - The value of the header to set.
       */
      set(name, value) {
        this._headersMap.set(normalizeName(name), { name, value: String(value) });
      }
      /**
       * Get the header value for the provided header name, or undefined if no header exists in this
       * collection with the provided name.
       * @param name - The name of the header. This value is case-insensitive.
       */
      get(name) {
        var _a2;
        return (_a2 = this._headersMap.get(normalizeName(name))) === null || _a2 === void 0 ? void 0 : _a2.value;
      }
      /**
       * Get whether or not this header collection contains a header entry for the provided header name.
       * @param name - The name of the header to set. This value is case-insensitive.
       */
      has(name) {
        return this._headersMap.has(normalizeName(name));
      }
      /**
       * Remove the header with the provided headerName.
       * @param name - The name of the header to remove.
       */
      delete(name) {
        this._headersMap.delete(normalizeName(name));
      }
      /**
       * Get the JSON object representation of this HTTP header collection.
       */
      toJSON(options = {}) {
        const result = {};
        if (options.preserveCase) {
          for (const entry of this._headersMap.values()) {
            result[entry.name] = entry.value;
          }
        } else {
          for (const [normalizedName, entry] of this._headersMap) {
            result[normalizedName] = entry.value;
          }
        }
        return result;
      }
      /**
       * Get the string representation of this HTTP header collection.
       */
      toString() {
        return JSON.stringify(this.toJSON({ preserveCase: true }));
      }
      /**
       * Iterate over tuples of header [name, value] pairs.
       */
      [Symbol.iterator]() {
        return headerIterator(this._headersMap);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/fetchHttpClient.js
function isNodeReadableStream(body) {
  return body && typeof body.pipe === "function";
}
function isReadableStream(body) {
  return Boolean(body && typeof body.getReader === "function" && typeof body.tee === "function");
}
function isBlob(body) {
  return (typeof Blob === "function" || typeof Blob === "object") && body instanceof Blob;
}
async function makeRequest(request) {
  const { abortController, abortControllerCleanup } = setupAbortSignal(request);
  try {
    const headers = buildFetchHeaders(request.headers);
    const requestBody = buildRequestBody(request);
    const response = await fetch(request.url, {
      body: requestBody,
      method: request.method,
      headers,
      signal: abortController.signal,
      credentials: request.withCredentials ? "include" : "same-origin",
      cache: "no-store"
    });
    if (isBlob(request.body) && request.onUploadProgress) {
      request.onUploadProgress({ loadedBytes: request.body.size });
    }
    return buildPipelineResponse(response, request);
  } finally {
    if (abortControllerCleanup) {
      abortControllerCleanup();
    }
  }
}
async function buildPipelineResponse(httpResponse, request) {
  var _a2, _b;
  const headers = buildPipelineHeaders(httpResponse);
  const response = {
    request,
    headers,
    status: httpResponse.status
  };
  const bodyStream = isReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, request.onDownloadProgress) : httpResponse.body;
  if (
    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
    ((_a2 = request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(Number.POSITIVE_INFINITY)) || ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))
  ) {
    if (request.enableBrowserStreams) {
      response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : void 0;
    } else {
      const responseStream = new Response(bodyStream);
      response.blobBody = responseStream.blob();
    }
  } else {
    const responseStream = new Response(bodyStream);
    response.bodyAsText = await responseStream.text();
  }
  return response;
}
function setupAbortSignal(request) {
  const abortController = new AbortController();
  let abortControllerCleanup;
  let abortListener;
  if (request.abortSignal) {
    if (request.abortSignal.aborted) {
      throw new AbortError("The operation was aborted.");
    }
    abortListener = (event) => {
      if (event.type === "abort") {
        abortController.abort();
      }
    };
    request.abortSignal.addEventListener("abort", abortListener);
    abortControllerCleanup = () => {
      var _a2;
      if (abortListener) {
        (_a2 = request.abortSignal) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("abort", abortListener);
      }
    };
  }
  if (request.timeout > 0) {
    setTimeout(() => {
      abortController.abort();
    }, request.timeout);
  }
  return { abortController, abortControllerCleanup };
}
function getError(e, request) {
  var _a2;
  if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
    return e;
  } else {
    return new RestError2(`Error sending request: ${e.message}`, {
      code: (_a2 = e === null || e === void 0 ? void 0 : e.code) !== null && _a2 !== void 0 ? _a2 : RestError2.REQUEST_SEND_ERROR,
      request
    });
  }
}
function buildFetchHeaders(pipelineHeaders) {
  const headers = new Headers();
  for (const [name, value] of pipelineHeaders) {
    headers.append(name, value);
  }
  return headers;
}
function buildPipelineHeaders(httpResponse) {
  const responseHeaders = createHttpHeaders();
  for (const [name, value] of httpResponse.headers) {
    responseHeaders.set(name, value);
  }
  return responseHeaders;
}
function buildRequestBody(request) {
  const body = typeof request.body === "function" ? request.body() : request.body;
  if (isNodeReadableStream(body)) {
    throw new Error("Node streams are not supported in browser environment.");
  }
  return isReadableStream(body) ? buildBodyStream(body, request.onUploadProgress) : body;
}
function buildBodyStream(readableStream, onProgress) {
  let loadedBytes = 0;
  if (isTransformStreamSupported(readableStream)) {
    return readableStream.pipeThrough(new TransformStream({
      transform(chunk, controller) {
        if (chunk === null) {
          controller.terminate();
          return;
        }
        controller.enqueue(chunk);
        loadedBytes += chunk.length;
        if (onProgress) {
          onProgress({ loadedBytes });
        }
      }
    }));
  } else {
    const reader = readableStream.getReader();
    return new ReadableStream({
      async pull(controller) {
        var _a2;
        const { done, value } = await reader.read();
        if (done || !value) {
          controller.close();
          reader.releaseLock();
          return;
        }
        loadedBytes += (_a2 = value === null || value === void 0 ? void 0 : value.length) !== null && _a2 !== void 0 ? _a2 : 0;
        controller.enqueue(value);
        if (onProgress) {
          onProgress({ loadedBytes });
        }
      }
    });
  }
}
function createFetchHttpClient() {
  return new FetchHttpClient();
}
function isTransformStreamSupported(readableStream) {
  return readableStream.pipeThrough !== void 0 && self.TransformStream !== void 0;
}
var FetchHttpClient;
var init_fetchHttpClient = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/fetchHttpClient.js"() {
    init_src();
    init_restError2();
    init_httpHeaders2();
    FetchHttpClient = class {
      /**
       * Makes a request over an underlying transport layer and returns the response.
       * @param request - The request to be made.
       */
      async sendRequest(request) {
        const url = new URL(request.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request.allowInsecureConnection) {
          throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
        }
        if (request.proxySettings) {
          throw new Error("HTTP proxy is not supported in browser environment");
        }
        try {
          return await makeRequest(request);
        } catch (e) {
          throw getError(e, request);
        }
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/defaultHttpClient.browser.js
function createDefaultHttpClient() {
  return createFetchHttpClient();
}
var init_defaultHttpClient_browser2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/defaultHttpClient.browser.js"() {
    init_fetchHttpClient();
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js
function createPipelineRequest(options) {
  return new PipelineRequestImpl(options);
}
var PipelineRequestImpl;
var init_pipelineRequest = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js"() {
    init_httpHeaders2();
    init_src2();
    PipelineRequestImpl = class {
      constructor(options) {
        var _a2, _b, _c, _d, _e, _f, _g;
        this.url = options.url;
        this.body = options.body;
        this.headers = (_a2 = options.headers) !== null && _a2 !== void 0 ? _a2 : createHttpHeaders();
        this.method = (_b = options.method) !== null && _b !== void 0 ? _b : "GET";
        this.timeout = (_c = options.timeout) !== null && _c !== void 0 ? _c : 0;
        this.formData = options.formData;
        this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== void 0 ? _d : false;
        this.proxySettings = options.proxySettings;
        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
        this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
        this.abortSignal = options.abortSignal;
        this.tracingOptions = options.tracingOptions;
        this.onUploadProgress = options.onUploadProgress;
        this.onDownloadProgress = options.onDownloadProgress;
        this.requestId = options.requestId || randomUUID();
        this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
        this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/exponentialRetryPolicy.js
var init_exponentialRetryPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/exponentialRetryPolicy.js"() {
    init_exponentialRetryStrategy();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/systemErrorRetryPolicy.js
var init_systemErrorRetryPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/systemErrorRetryPolicy.js"() {
    init_exponentialRetryStrategy();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/throttlingRetryPolicy.js
var init_throttlingRetryPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/throttlingRetryPolicy.js"() {
    init_throttlingRetryStrategy2();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/tokenCycler.js
async function beginRefresh2(getAccessToken, retryIntervalInMs, refreshTimeout) {
  async function tryGetAccessToken() {
    if (Date.now() < refreshTimeout) {
      try {
        return await getAccessToken();
      } catch (_a2) {
        return null;
      }
    } else {
      const finalToken = await getAccessToken();
      if (finalToken === null) {
        throw new Error("Failed to refresh access token.");
      }
      return finalToken;
    }
  }
  let token = await tryGetAccessToken();
  while (token === null) {
    await delay2(retryIntervalInMs);
    token = await tryGetAccessToken();
  }
  return token;
}
function createTokenCycler2(credential, tokenCyclerOptions) {
  let refreshWorker = null;
  let token = null;
  let tenantId;
  const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS2), tokenCyclerOptions);
  const cycler = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return refreshWorker !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      var _a2;
      return !cycler.isRefreshing && ((_a2 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a2 !== void 0 ? _a2 : 0) - options.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  function refresh(scopes, getTokenOptions) {
    var _a2;
    if (!cycler.isRefreshing) {
      const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
      refreshWorker = beginRefresh2(
        tryGetAccessToken,
        options.retryIntervalInMs,
        // If we don't have a token, then we should timeout immediately
        (_a2 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a2 !== void 0 ? _a2 : Date.now()
      ).then((_token) => {
        refreshWorker = null;
        token = _token;
        tenantId = getTokenOptions.tenantId;
        return token;
      }).catch((reason) => {
        refreshWorker = null;
        token = null;
        tenantId = void 0;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return async (scopes, tokenOptions) => {
    const mustRefresh = tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;
    if (mustRefresh)
      return refresh(scopes, tokenOptions);
    if (cycler.shouldRefresh) {
      refresh(scopes, tokenOptions);
    }
    return token;
  };
}
var DEFAULT_CYCLER_OPTIONS2;
var init_tokenCycler = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/util/tokenCycler.js"() {
    init_helpers();
    DEFAULT_CYCLER_OPTIONS2 = {
      forcedRefreshWindowInMs: 1e3,
      retryIntervalInMs: 3e3,
      refreshWindowInMs: 1e3 * 60 * 2
      // Start refreshing 2m before expiry
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js
async function defaultAuthorizeRequest(options) {
  const { scopes, getAccessToken, request } = options;
  const getTokenOptions = {
    abortSignal: request.abortSignal,
    tracingOptions: request.tracingOptions
  };
  const accessToken = await getAccessToken(scopes, getTokenOptions);
  if (accessToken) {
    options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
  }
}
function getChallenge(response) {
  const challenge = response.headers.get("WWW-Authenticate");
  if (response.status === 401 && challenge) {
    return challenge;
  }
  return;
}
function bearerTokenAuthenticationPolicy2(options) {
  var _a2;
  const { credential, scopes, challengeCallbacks } = options;
  const logger5 = options.logger || logger3;
  const callbacks = Object.assign({ authorizeRequest: (_a2 = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a2 !== void 0 ? _a2 : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);
  const getAccessToken = credential ? createTokenCycler2(
    credential
    /* , options */
  ) : () => Promise.resolve(null);
  return {
    name: bearerTokenAuthenticationPolicyName,
    /**
     * If there's no challenge parameter:
     * - It will try to retrieve the token using the cache, or the credential's getToken.
     * - Then it will try the next policy with or without the retrieved token.
     *
     * It uses the challenge parameters to:
     * - Skip a first attempt to get the token from the credential if there's no cached token,
     *   since it expects the token to be retrievable only after the challenge.
     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
     * - Send an initial request to receive the challenge if it fails.
     * - Process a challenge if the response contains it.
     * - Retrieve a token with the challenge information, then re-send the request.
     */
    async sendRequest(request, next) {
      if (!request.url.toLowerCase().startsWith("https://")) {
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      }
      await callbacks.authorizeRequest({
        scopes: Array.isArray(scopes) ? scopes : [scopes],
        request,
        getAccessToken,
        logger: logger5
      });
      let response;
      let error;
      try {
        response = await next(request);
      } catch (err) {
        error = err;
        response = err.response;
      }
      if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {
        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request,
          response,
          getAccessToken,
          logger: logger5
        });
        if (shouldSendRequest) {
          return next(request);
        }
      }
      if (error) {
        throw error;
      } else {
        return response;
      }
    }
  };
}
var bearerTokenAuthenticationPolicyName;
var init_bearerTokenAuthenticationPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js"() {
    init_tokenCycler();
    init_log2();
    bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/ndJsonPolicy.js
var init_ndJsonPolicy2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/ndJsonPolicy.js"() {
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/auxiliaryAuthenticationHeaderPolicy.js
var init_auxiliaryAuthenticationHeaderPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/auxiliaryAuthenticationHeaderPolicy.js"() {
    init_tokenCycler();
    init_log2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist-esm/src/index.js
var init_src9 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist-esm/src/index.js"() {
    init_pipeline();
    init_createPipelineFromOptions();
    init_defaultHttpClient_browser2();
    init_httpHeaders2();
    init_pipelineRequest();
    init_restError2();
    init_decompressResponsePolicy_browser();
    init_exponentialRetryPolicy2();
    init_setClientRequestIdPolicy();
    init_logPolicy2();
    init_proxyPolicy_browser2();
    init_redirectPolicy2();
    init_systemErrorRetryPolicy2();
    init_throttlingRetryPolicy2();
    init_retryPolicy();
    init_tracingPolicy2();
    init_defaultRetryPolicy();
    init_userAgentPolicy2();
    init_tlsPolicy();
    init_formDataPolicy_browser();
    init_bearerTokenAuthenticationPolicy2();
    init_ndJsonPolicy2();
    init_auxiliaryAuthenticationHeaderPolicy();
  }
});

// node_modules/@azure/core-client/dist-esm/src/operationHelpers.js
function getOperationArgumentValueFromParameter2(operationArguments, parameter, fallbackObject) {
  let parameterPath = parameter.parameterPath;
  const parameterMapper = parameter.mapper;
  let value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        let propertySearchResult = getPropertyFromParameterPath2(operationArguments, parameterPath);
        if (!propertySearchResult.propertyFound && fallbackObject) {
          propertySearchResult = getPropertyFromParameterPath2(fallbackObject, parameterPath);
        }
        let useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }
        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (const propertyName in parameterPath) {
      const propertyMapper = parameterMapper.type.modelProperties[propertyName];
      const propertyPath = parameterPath[propertyName];
      const propertyValue = getOperationArgumentValueFromParameter2(operationArguments, {
        parameterPath: propertyPath,
        mapper: propertyMapper
      }, fallbackObject);
      if (propertyValue !== void 0) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath2(parent, parameterPath) {
  const result = { propertyFound: false };
  let i = 0;
  for (; i < parameterPath.length; ++i) {
    const parameterPathPart = parameterPath[i];
    if (parent && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
function hasOriginalRequest(request) {
  return originalRequestSymbol in request;
}
function getOperationRequestInfo(request) {
  if (hasOriginalRequest(request)) {
    return getOperationRequestInfo(request[originalRequestSymbol]);
  }
  let info = operationRequestMap.get(request);
  if (!info) {
    info = {};
    operationRequestMap.set(request, info);
  }
  return info;
}
var operationRequestMap, originalRequestSymbol;
var init_operationHelpers = __esm({
  "node_modules/@azure/core-client/dist-esm/src/operationHelpers.js"() {
    operationRequestMap = /* @__PURE__ */ new WeakMap();
    originalRequestSymbol = Symbol.for("@azure/core-client original request");
  }
});

// node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js
function deserializationPolicy2(options = {}) {
  var _a2, _b, _c, _d, _e, _f, _g;
  const jsonContentTypes = (_b = (_a2 = options.expectedContentTypes) === null || _a2 === void 0 ? void 0 : _a2.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes2;
  const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes2;
  const parseXML2 = options.parseXML;
  const serializerOptions = options.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : "",
      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,
      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY2
    }
  };
  return {
    name: deserializationPolicyName,
    async sendRequest(request, next) {
      const response = await next(request);
      return deserializeResponseBody2(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML2);
    }
  };
}
function getOperationResponseMap(parsedResponse) {
  let result;
  const request = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (operationSpec) {
    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
    }
  }
  return result;
}
function shouldDeserializeResponse2(parsedResponse) {
  const request = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request);
  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;
  let result;
  if (shouldDeserialize === void 0) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }
  return result;
}
async function deserializeResponseBody2(jsonContentTypes, xmlContentTypes, response, options, parseXML2) {
  const parsedResponse = await parse3(jsonContentTypes, xmlContentTypes, response, options, parseXML2);
  if (!shouldDeserializeResponse2(parsedResponse)) {
    return parsedResponse;
  }
  const operationInfo = getOperationRequestInfo(parsedResponse.request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (!operationSpec || !operationSpec.responses) {
    return parsedResponse;
  }
  const responseSpec = getOperationResponseMap(parsedResponse);
  const { error, shouldReturnResponse } = handleErrorResponse2(parsedResponse, operationSpec, responseSpec, options);
  if (error) {
    throw error;
  } else if (shouldReturnResponse) {
    return parsedResponse;
  }
  if (responseSpec) {
    if (responseSpec.bodyMapper) {
      let valueToDeserialize = parsedResponse.parsedBody;
      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {
        valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
      }
      try {
        parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
      } catch (deserializeError) {
        const restError = new RestError2(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
          statusCode: parsedResponse.status,
          request: parsedResponse.request,
          response: parsedResponse
        });
        throw restError;
      }
    } else if (operationSpec.httpMethod === "HEAD") {
      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
    }
    if (responseSpec.headersMapper) {
      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
    }
  }
  return parsedResponse;
}
function isOperationSpecEmpty2(operationSpec) {
  const expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse2(parsedResponse, operationSpec, responseSpec, options) {
  var _a2;
  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  const isExpectedStatusCode = isOperationSpecEmpty2(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return { error: null, shouldReturnResponse: false };
      }
    } else {
      return { error: null, shouldReturnResponse: false };
    }
  }
  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
  const initialErrorMessage = ((_a2 = parsedResponse.request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
  const error = new RestError2(initialErrorMessage, {
    statusCode: parsedResponse.status,
    request: parsedResponse.request,
    response: parsedResponse
  });
  if (!errorResponseSpec) {
    throw error;
  }
  const defaultBodyMapper = errorResponseSpec.bodyMapper;
  const defaultHeadersMapper = errorResponseSpec.headersMapper;
  try {
    if (parsedResponse.parsedBody) {
      const parsedBody = parsedResponse.parsedBody;
      let deserializedError;
      if (defaultBodyMapper) {
        let valueToDeserialize = parsedBody;
        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {
          valueToDeserialize = [];
          const elementName = defaultBodyMapper.xmlElementName;
          if (typeof parsedBody === "object" && elementName) {
            valueToDeserialize = parsedBody[elementName];
          }
        }
        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
      }
      const internalError = parsedBody.error || deserializedError || parsedBody;
      error.code = internalError.code;
      if (internalError.message) {
        error.message = internalError.message;
      }
      if (defaultBodyMapper) {
        error.response.parsedBody = deserializedError;
      }
    }
    if (parsedResponse.headers && defaultHeadersMapper) {
      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
  }
  return { error, shouldReturnResponse: false };
}
async function parse3(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML2) {
  var _a2;
  if (!((_a2 = operationResponse.request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(operationResponse.status)) && operationResponse.bodyAsText) {
    const text2 = operationResponse.bodyAsText;
    const contentType2 = operationResponse.headers.get("Content-Type") || "";
    const contentComponents = !contentType2 ? [] : contentType2.split(";").map((component) => component.toLowerCase());
    try {
      if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
        operationResponse.parsedBody = JSON.parse(text2);
        return operationResponse;
      } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
        if (!parseXML2) {
          throw new Error("Parsing XML not supported.");
        }
        const body = await parseXML2(text2, opts.xml);
        operationResponse.parsedBody = body;
        return operationResponse;
      }
    } catch (err) {
      const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
      const errCode = err.code || RestError2.PARSE_ERROR;
      const e = new RestError2(msg, {
        code: errCode,
        statusCode: operationResponse.status,
        request: operationResponse.request,
        response: operationResponse
      });
      throw e;
    }
  }
  return operationResponse;
}
var defaultJsonContentTypes2, defaultXmlContentTypes2, deserializationPolicyName;
var init_deserializationPolicy2 = __esm({
  "node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js"() {
    init_interfaces2();
    init_src9();
    init_serializer2();
    init_operationHelpers();
    defaultJsonContentTypes2 = ["application/json", "text/json"];
    defaultXmlContentTypes2 = ["application/xml", "application/atom+xml"];
    deserializationPolicyName = "deserializationPolicy";
  }
});

// node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js
function getStreamingResponseStatusCodes(operationSpec) {
  const result = /* @__PURE__ */ new Set();
  for (const statusCode in operationSpec.responses) {
    const operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperTypeNames.Stream) {
      result.add(Number(statusCode));
    }
  }
  return result;
}
function getPathStringFromParameter2(parameter) {
  const { parameterPath, mapper } = parameter;
  let result;
  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }
  return result;
}
var init_interfaceHelpers = __esm({
  "node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js"() {
    init_serializer2();
  }
});

// node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js
function serializationPolicy(options = {}) {
  const stringifyXML2 = options.stringifyXML;
  return {
    name: serializationPolicyName,
    async sendRequest(request, next) {
      const operationInfo = getOperationRequestInfo(request);
      const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
      const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;
      if (operationSpec && operationArguments) {
        serializeHeaders(request, operationArguments, operationSpec);
        serializeRequestBody2(request, operationArguments, operationSpec, stringifyXML2);
      }
      return next(request);
    }
  };
}
function serializeHeaders(request, operationArguments, operationSpec) {
  var _a2, _b;
  if (operationSpec.headerParameters) {
    for (const headerParameter of operationSpec.headerParameters) {
      let headerValue = getOperationArgumentValueFromParameter2(operationArguments, headerParameter);
      if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter2(headerParameter));
        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
          for (const key of Object.keys(headerValue)) {
            request.headers.set(headerCollectionPrefix + key, headerValue[key]);
          }
        } else {
          request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter2(headerParameter), headerValue);
        }
      }
    }
  }
  const customHeaders = (_b = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;
  if (customHeaders) {
    for (const customHeaderName of Object.keys(customHeaders)) {
      request.headers.set(customHeaderName, customHeaders[customHeaderName]);
    }
  }
}
function serializeRequestBody2(request, operationArguments, operationSpec, stringifyXML2 = function() {
  throw new Error("XML serialization unsupported!");
}) {
  var _a2, _b, _c, _d, _e;
  const serializerOptions = (_a2 = operationArguments.options) === null || _a2 === void 0 ? void 0 : _a2.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : "",
      includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,
      xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY2
    }
  };
  const xmlCharKey = updatedOptions.xml.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    request.body = getOperationArgumentValueFromParameter2(operationArguments, operationSpec.requestBody);
    const bodyMapper = operationSpec.requestBody.mapper;
    const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
    const typeName = bodyMapper.type.name;
    try {
      if (request.body !== void 0 && request.body !== null || nullable && request.body === null || required) {
        const requestBodyParameterPathString = getPathStringFromParameter2(operationSpec.requestBody);
        request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
        const isStream = typeName === MapperTypeNames.Stream;
        if (operationSpec.isXML) {
          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
          const value = getXmlValueWithNamespace2(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
          if (typeName === MapperTypeNames.Sequence) {
            request.body = stringifyXML2(prepareXMLRootList2(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
          } else if (!isStream) {
            request.body = stringifyXML2(value, {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          }
        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
          return;
        } else if (!isStream) {
          request.body = JSON.stringify(request.body);
        }
      }
    } catch (error) {
      throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    request.formData = {};
    for (const formDataParameter of operationSpec.formDataParameters) {
      const formDataParameterValue = getOperationArgumentValueFromParameter2(operationArguments, formDataParameter);
      if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter2(formDataParameter);
        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter2(formDataParameter), updatedOptions);
      }
    }
  }
}
function getXmlValueWithNamespace2(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[XML_ATTRKEY2] = { [xmlnsKey]: xmlNamespace };
    return result;
  }
  return serializedValue;
}
function prepareXMLRootList2(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  if (!Array.isArray(obj)) {
    obj = [obj];
  }
  if (!xmlNamespaceKey || !xmlNamespace) {
    return { [elementName]: obj };
  }
  const result = { [elementName]: obj };
  result[XML_ATTRKEY2] = { [xmlNamespaceKey]: xmlNamespace };
  return result;
}
var serializationPolicyName;
var init_serializationPolicy = __esm({
  "node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js"() {
    init_interfaces2();
    init_operationHelpers();
    init_serializer2();
    init_interfaceHelpers();
    serializationPolicyName = "serializationPolicy";
  }
});

// node_modules/@azure/core-client/dist-esm/src/pipeline.js
function createClientPipeline(options = {}) {
  const pipeline = createPipelineFromOptions2(options !== null && options !== void 0 ? options : {});
  if (options.credentialOptions) {
    pipeline.addPolicy(bearerTokenAuthenticationPolicy2({
      credential: options.credentialOptions.credential,
      scopes: options.credentialOptions.credentialScopes
    }));
  }
  pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: "Serialize" });
  pipeline.addPolicy(deserializationPolicy2(options.deserializationOptions), {
    phase: "Deserialize"
  });
  return pipeline;
}
var init_pipeline2 = __esm({
  "node_modules/@azure/core-client/dist-esm/src/pipeline.js"() {
    init_deserializationPolicy2();
    init_src9();
    init_serializationPolicy();
  }
});

// node_modules/@azure/core-client/dist-esm/src/httpClientCache.js
function getCachedDefaultHttpClient2() {
  if (!cachedHttpClient2) {
    cachedHttpClient2 = createDefaultHttpClient();
  }
  return cachedHttpClient2;
}
var cachedHttpClient2;
var init_httpClientCache2 = __esm({
  "node_modules/@azure/core-client/dist-esm/src/httpClientCache.js"() {
    init_src9();
  }
});

// node_modules/@azure/core-client/dist-esm/src/urlHelpers.js
function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
  let isAbsolutePath = false;
  let requestUrl = replaceAll2(baseUri, urlReplacements);
  if (operationSpec.path) {
    let path = replaceAll2(operationSpec.path, urlReplacements);
    if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) {
      path = path.substring(1);
    }
    if (isAbsoluteUrl(path)) {
      requestUrl = path;
      isAbsolutePath = true;
    } else {
      requestUrl = appendPath(requestUrl, path);
    }
  }
  const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
  return requestUrl;
}
function replaceAll2(input, replacements) {
  let result = input;
  for (const [searchValue, replaceValue] of replacements) {
    result = result.split(searchValue).join(replaceValue);
  }
  return result;
}
function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
  var _a2;
  const result = /* @__PURE__ */ new Map();
  if ((_a2 = operationSpec.urlParameters) === null || _a2 === void 0 ? void 0 : _a2.length) {
    for (const urlParameter of operationSpec.urlParameters) {
      let urlParameterValue = getOperationArgumentValueFromParameter2(operationArguments, urlParameter, fallbackObject);
      const parameterPathString = getPathStringFromParameter2(urlParameter);
      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
      if (!urlParameter.skipEncoding) {
        urlParameterValue = encodeURIComponent(urlParameterValue);
      }
      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
    }
  }
  return result;
}
function isAbsoluteUrl(url) {
  return url.includes("://");
}
function appendPath(url, pathToAppend) {
  if (!pathToAppend) {
    return url;
  }
  const parsedUrl = new URL(url);
  let newPath = parsedUrl.pathname;
  if (!newPath.endsWith("/")) {
    newPath = `${newPath}/`;
  }
  if (pathToAppend.startsWith("/")) {
    pathToAppend = pathToAppend.substring(1);
  }
  const searchStart = pathToAppend.indexOf("?");
  if (searchStart !== -1) {
    const path = pathToAppend.substring(0, searchStart);
    const search = pathToAppend.substring(searchStart + 1);
    newPath = newPath + path;
    if (search) {
      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
    }
  } else {
    newPath = newPath + pathToAppend;
  }
  parsedUrl.pathname = newPath;
  return parsedUrl.toString();
}
function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
  var _a2;
  const result = /* @__PURE__ */ new Map();
  const sequenceParams = /* @__PURE__ */ new Set();
  if ((_a2 = operationSpec.queryParameters) === null || _a2 === void 0 ? void 0 : _a2.length) {
    for (const queryParameter of operationSpec.queryParameters) {
      if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
        sequenceParams.add(queryParameter.mapper.serializedName);
      }
      let queryParameterValue = getOperationArgumentValueFromParameter2(operationArguments, queryParameter, fallbackObject);
      if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter2(queryParameter));
        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
        if (Array.isArray(queryParameterValue)) {
          queryParameterValue = queryParameterValue.map((item) => {
            if (item === null || item === void 0) {
              return "";
            }
            return item;
          });
        }
        if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
          continue;
        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        if (!queryParameter.skipEncoding) {
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              return encodeURIComponent(item);
            });
          } else {
            queryParameterValue = encodeURIComponent(queryParameterValue);
          }
        }
        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter2(queryParameter), queryParameterValue);
      }
    }
  }
  return {
    queryParams: result,
    sequenceParams
  };
}
function simpleParseQueryParams(queryString) {
  const result = /* @__PURE__ */ new Map();
  if (!queryString || queryString[0] !== "?") {
    return result;
  }
  queryString = queryString.slice(1);
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const [name, value] = pair.split("=", 2);
    const existingValue = result.get(name);
    if (existingValue) {
      if (Array.isArray(existingValue)) {
        existingValue.push(value);
      } else {
        result.set(name, [existingValue, value]);
      }
    } else {
      result.set(name, value);
    }
  }
  return result;
}
function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
  if (queryParams.size === 0) {
    return url;
  }
  const parsedUrl = new URL(url);
  const combinedParams = simpleParseQueryParams(parsedUrl.search);
  for (const [name, value] of queryParams) {
    const existingValue = combinedParams.get(name);
    if (Array.isArray(existingValue)) {
      if (Array.isArray(value)) {
        existingValue.push(...value);
        const valueSet = new Set(existingValue);
        combinedParams.set(name, Array.from(valueSet));
      } else {
        existingValue.push(value);
      }
    } else if (existingValue) {
      if (Array.isArray(value)) {
        value.unshift(existingValue);
      } else if (sequenceParams.has(name)) {
        combinedParams.set(name, [existingValue, value]);
      }
      if (!noOverwrite) {
        combinedParams.set(name, value);
      }
    } else {
      combinedParams.set(name, value);
    }
  }
  const searchPieces = [];
  for (const [name, value] of combinedParams) {
    if (typeof value === "string") {
      searchPieces.push(`${name}=${value}`);
    } else if (Array.isArray(value)) {
      for (const subValue of value) {
        searchPieces.push(`${name}=${subValue}`);
      }
    } else {
      searchPieces.push(`${name}=${value}`);
    }
  }
  parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
  return parsedUrl.toString();
}
var CollectionFormatToDelimiterMap;
var init_urlHelpers = __esm({
  "node_modules/@azure/core-client/dist-esm/src/urlHelpers.js"() {
    init_operationHelpers();
    init_interfaceHelpers();
    CollectionFormatToDelimiterMap = {
      CSV: ",",
      SSV: " ",
      Multi: "Multi",
      TSV: "	",
      Pipes: "|"
    };
  }
});

// node_modules/@azure/core-client/dist-esm/src/log.js
var logger4;
var init_log3 = __esm({
  "node_modules/@azure/core-client/dist-esm/src/log.js"() {
    init_src3();
    logger4 = createClientLogger("core-client");
  }
});

// node_modules/@azure/core-client/dist-esm/src/serviceClient.js
function createDefaultPipeline(options) {
  const credentialScopes = getCredentialScopes2(options);
  const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : void 0;
  return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));
}
function getCredentialScopes2(options) {
  if (options.credentialScopes) {
    return options.credentialScopes;
  }
  if (options.endpoint) {
    return `${options.endpoint}/.default`;
  }
  if (options.baseUri) {
    return `${options.baseUri}/.default`;
  }
  if (options.credential && !options.credentialScopes) {
    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
  }
  return void 0;
}
var ServiceClient2;
var init_serviceClient2 = __esm({
  "node_modules/@azure/core-client/dist-esm/src/serviceClient.js"() {
    init_src9();
    init_pipeline2();
    init_utils4();
    init_httpClientCache2();
    init_operationHelpers();
    init_urlHelpers();
    init_interfaceHelpers();
    init_log3();
    ServiceClient2 = class {
      /**
       * The ServiceClient constructor
       * @param credential - The credentials used for authentication with the service.
       * @param options - The service client options that govern the behavior of the client.
       */
      constructor(options = {}) {
        var _a2, _b;
        this._requestContentType = options.requestContentType;
        this._endpoint = (_a2 = options.endpoint) !== null && _a2 !== void 0 ? _a2 : options.baseUri;
        if (options.baseUri) {
          logger4.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
        }
        this._allowInsecureConnection = options.allowInsecureConnection;
        this._httpClient = options.httpClient || getCachedDefaultHttpClient2();
        this.pipeline = options.pipeline || createDefaultPipeline(options);
        if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {
          for (const { policy, position } of options.additionalPolicies) {
            const afterPhase = position === "perRetry" ? "Sign" : void 0;
            this.pipeline.addPolicy(policy, {
              afterPhase
            });
          }
        }
      }
      /**
       * Send the provided httpRequest.
       */
      async sendRequest(request) {
        return this.pipeline.sendRequest(this._httpClient, request);
      }
      /**
       * Send an HTTP request that is populated using the provided OperationSpec.
       * @typeParam T - The typed result of the request, based on the OperationSpec.
       * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
       * @param operationSpec - The OperationSpec to use to populate the httpRequest.
       */
      async sendOperationRequest(operationArguments, operationSpec) {
        const endpoint2 = operationSpec.baseUrl || this._endpoint;
        if (!endpoint2) {
          throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
        }
        const url = getRequestUrl(endpoint2, operationSpec, operationArguments, this);
        const request = createPipelineRequest({
          url
        });
        request.method = operationSpec.httpMethod;
        const operationInfo = getOperationRequestInfo(request);
        operationInfo.operationSpec = operationSpec;
        operationInfo.operationArguments = operationArguments;
        const contentType2 = operationSpec.contentType || this._requestContentType;
        if (contentType2 && operationSpec.requestBody) {
          request.headers.set("Content-Type", contentType2);
        }
        const options = operationArguments.options;
        if (options) {
          const requestOptions = options.requestOptions;
          if (requestOptions) {
            if (requestOptions.timeout) {
              request.timeout = requestOptions.timeout;
            }
            if (requestOptions.onUploadProgress) {
              request.onUploadProgress = requestOptions.onUploadProgress;
            }
            if (requestOptions.onDownloadProgress) {
              request.onDownloadProgress = requestOptions.onDownloadProgress;
            }
            if (requestOptions.shouldDeserialize !== void 0) {
              operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
            }
            if (requestOptions.allowInsecureConnection) {
              request.allowInsecureConnection = true;
            }
          }
          if (options.abortSignal) {
            request.abortSignal = options.abortSignal;
          }
          if (options.tracingOptions) {
            request.tracingOptions = options.tracingOptions;
          }
        }
        if (this._allowInsecureConnection) {
          request.allowInsecureConnection = true;
        }
        if (request.streamResponseStatusCodes === void 0) {
          request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);
        }
        try {
          const rawResponse = await this.sendRequest(request);
          const flatResponse = flattenResponse2(rawResponse, operationSpec.responses[rawResponse.status]);
          if (options === null || options === void 0 ? void 0 : options.onResponse) {
            options.onResponse(rawResponse, flatResponse);
          }
          return flatResponse;
        } catch (error) {
          if (typeof error === "object" && (error === null || error === void 0 ? void 0 : error.response)) {
            const rawResponse = error.response;
            const flatResponse = flattenResponse2(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
            error.details = flatResponse;
            if (options === null || options === void 0 ? void 0 : options.onResponse) {
              options.onResponse(rawResponse, flatResponse, error);
            }
          }
          throw error;
        }
      }
    };
  }
});

// node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnClaimChallenge.js
var init_authorizeRequestOnClaimChallenge = __esm({
  "node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnClaimChallenge.js"() {
    init_log3();
    init_base64_browser3();
  }
});

// node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnTenantChallenge.js
var init_authorizeRequestOnTenantChallenge = __esm({
  "node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnTenantChallenge.js"() {
  }
});

// node_modules/@azure/core-client/dist-esm/src/index.js
var init_src10 = __esm({
  "node_modules/@azure/core-client/dist-esm/src/index.js"() {
    init_serializer2();
    init_serviceClient2();
    init_pipeline2();
    init_interfaces2();
    init_deserializationPolicy2();
    init_serializationPolicy();
    init_authorizeRequestOnClaimChallenge();
    init_authorizeRequestOnTenantChallenge();
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/models/mappers.js
var mappers_exports = {};
__export(mappers_exports, {
  AddChatParticipantsRequest: () => AddChatParticipantsRequest,
  AddChatParticipantsResult: () => AddChatParticipantsResult,
  ChatError: () => ChatError,
  ChatMessage: () => ChatMessage,
  ChatMessageContent: () => ChatMessageContent,
  ChatMessageReadReceipt: () => ChatMessageReadReceipt,
  ChatMessageReadReceiptsCollection: () => ChatMessageReadReceiptsCollection,
  ChatMessagesCollection: () => ChatMessagesCollection,
  ChatParticipant: () => ChatParticipant,
  ChatParticipantsCollection: () => ChatParticipantsCollection,
  ChatThreadItem: () => ChatThreadItem,
  ChatThreadProperties: () => ChatThreadProperties,
  ChatThreadsItemCollection: () => ChatThreadsItemCollection,
  CommunicationErrorResponse: () => CommunicationErrorResponse,
  CommunicationIdentifierModel: () => CommunicationIdentifierModel,
  CommunicationUserIdentifierModel: () => CommunicationUserIdentifierModel,
  CreateChatThreadRequest: () => CreateChatThreadRequest,
  CreateChatThreadResult: () => CreateChatThreadResult,
  MicrosoftTeamsUserIdentifierModel: () => MicrosoftTeamsUserIdentifierModel,
  PhoneNumberIdentifierModel: () => PhoneNumberIdentifierModel,
  SendChatMessageRequest: () => SendChatMessageRequest,
  SendChatMessageResult: () => SendChatMessageResult,
  SendReadReceiptRequest: () => SendReadReceiptRequest,
  SendTypingNotificationRequest: () => SendTypingNotificationRequest,
  UpdateChatMessageRequest: () => UpdateChatMessageRequest,
  UpdateChatThreadRequest: () => UpdateChatThreadRequest
});
var ChatMessageReadReceiptsCollection, ChatMessageReadReceipt, CommunicationIdentifierModel, CommunicationUserIdentifierModel, PhoneNumberIdentifierModel, MicrosoftTeamsUserIdentifierModel, CommunicationErrorResponse, ChatError, SendReadReceiptRequest, SendChatMessageRequest, SendChatMessageResult, ChatMessagesCollection, ChatMessage, ChatMessageContent, ChatParticipant, UpdateChatMessageRequest, ChatParticipantsCollection, AddChatParticipantsRequest, AddChatParticipantsResult, CreateChatThreadRequest, CreateChatThreadResult, ChatThreadProperties, ChatThreadsItemCollection, ChatThreadItem, UpdateChatThreadRequest, SendTypingNotificationRequest;
var init_mappers2 = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/models/mappers.js"() {
    ChatMessageReadReceiptsCollection = {
      type: {
        name: "Composite",
        className: "ChatMessageReadReceiptsCollection",
        modelProperties: {
          value: {
            serializedName: "value",
            required: true,
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ChatMessageReadReceipt"
                }
              }
            }
          },
          nextLink: {
            serializedName: "nextLink",
            readOnly: true,
            type: {
              name: "String"
            }
          }
        }
      }
    };
    ChatMessageReadReceipt = {
      type: {
        name: "Composite",
        className: "ChatMessageReadReceipt",
        modelProperties: {
          senderCommunicationIdentifier: {
            serializedName: "senderCommunicationIdentifier",
            type: {
              name: "Composite",
              className: "CommunicationIdentifierModel"
            }
          },
          chatMessageId: {
            serializedName: "chatMessageId",
            required: true,
            type: {
              name: "String"
            }
          },
          readOn: {
            serializedName: "readOn",
            required: true,
            type: {
              name: "DateTime"
            }
          }
        }
      }
    };
    CommunicationIdentifierModel = {
      type: {
        name: "Composite",
        className: "CommunicationIdentifierModel",
        modelProperties: {
          rawId: {
            serializedName: "rawId",
            type: {
              name: "String"
            }
          },
          communicationUser: {
            serializedName: "communicationUser",
            type: {
              name: "Composite",
              className: "CommunicationUserIdentifierModel"
            }
          },
          phoneNumber: {
            serializedName: "phoneNumber",
            type: {
              name: "Composite",
              className: "PhoneNumberIdentifierModel"
            }
          },
          microsoftTeamsUser: {
            serializedName: "microsoftTeamsUser",
            type: {
              name: "Composite",
              className: "MicrosoftTeamsUserIdentifierModel"
            }
          }
        }
      }
    };
    CommunicationUserIdentifierModel = {
      type: {
        name: "Composite",
        className: "CommunicationUserIdentifierModel",
        modelProperties: {
          id: {
            serializedName: "id",
            required: true,
            type: {
              name: "String"
            }
          }
        }
      }
    };
    PhoneNumberIdentifierModel = {
      type: {
        name: "Composite",
        className: "PhoneNumberIdentifierModel",
        modelProperties: {
          value: {
            serializedName: "value",
            required: true,
            type: {
              name: "String"
            }
          }
        }
      }
    };
    MicrosoftTeamsUserIdentifierModel = {
      type: {
        name: "Composite",
        className: "MicrosoftTeamsUserIdentifierModel",
        modelProperties: {
          userId: {
            serializedName: "userId",
            required: true,
            type: {
              name: "String"
            }
          },
          isAnonymous: {
            serializedName: "isAnonymous",
            type: {
              name: "Boolean"
            }
          },
          cloud: {
            serializedName: "cloud",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    CommunicationErrorResponse = {
      type: {
        name: "Composite",
        className: "CommunicationErrorResponse",
        modelProperties: {
          error: {
            serializedName: "error",
            type: {
              name: "Composite",
              className: "ChatError"
            }
          }
        }
      }
    };
    ChatError = {
      type: {
        name: "Composite",
        className: "ChatError",
        modelProperties: {
          code: {
            serializedName: "code",
            required: true,
            type: {
              name: "String"
            }
          },
          message: {
            serializedName: "message",
            required: true,
            type: {
              name: "String"
            }
          },
          target: {
            serializedName: "target",
            readOnly: true,
            type: {
              name: "String"
            }
          },
          details: {
            serializedName: "details",
            readOnly: true,
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ChatError"
                }
              }
            }
          },
          innerError: {
            serializedName: "innererror",
            type: {
              name: "Composite",
              className: "ChatError"
            }
          }
        }
      }
    };
    SendReadReceiptRequest = {
      type: {
        name: "Composite",
        className: "SendReadReceiptRequest",
        modelProperties: {
          chatMessageId: {
            serializedName: "chatMessageId",
            required: true,
            type: {
              name: "String"
            }
          }
        }
      }
    };
    SendChatMessageRequest = {
      type: {
        name: "Composite",
        className: "SendChatMessageRequest",
        modelProperties: {
          content: {
            serializedName: "content",
            required: true,
            type: {
              name: "String"
            }
          },
          senderDisplayName: {
            serializedName: "senderDisplayName",
            type: {
              name: "String"
            }
          },
          type: {
            serializedName: "type",
            type: {
              name: "Enum",
              allowedValues: [
                "text",
                "html",
                "topicUpdated",
                "participantAdded",
                "participantRemoved"
              ]
            }
          },
          metadata: {
            serializedName: "metadata",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          }
        }
      }
    };
    SendChatMessageResult = {
      type: {
        name: "Composite",
        className: "SendChatMessageResult",
        modelProperties: {
          id: {
            serializedName: "id",
            required: true,
            type: {
              name: "String"
            }
          }
        }
      }
    };
    ChatMessagesCollection = {
      type: {
        name: "Composite",
        className: "ChatMessagesCollection",
        modelProperties: {
          value: {
            serializedName: "value",
            required: true,
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ChatMessage"
                }
              }
            }
          },
          nextLink: {
            serializedName: "nextLink",
            readOnly: true,
            type: {
              name: "String"
            }
          }
        }
      }
    };
    ChatMessage = {
      type: {
        name: "Composite",
        className: "ChatMessage",
        modelProperties: {
          id: {
            serializedName: "id",
            required: true,
            type: {
              name: "String"
            }
          },
          type: {
            serializedName: "type",
            required: true,
            type: {
              name: "Enum",
              allowedValues: [
                "text",
                "html",
                "topicUpdated",
                "participantAdded",
                "participantRemoved"
              ]
            }
          },
          sequenceId: {
            serializedName: "sequenceId",
            required: true,
            type: {
              name: "String"
            }
          },
          version: {
            serializedName: "version",
            required: true,
            type: {
              name: "String"
            }
          },
          content: {
            serializedName: "content",
            type: {
              name: "Composite",
              className: "ChatMessageContent"
            }
          },
          senderDisplayName: {
            serializedName: "senderDisplayName",
            type: {
              name: "String"
            }
          },
          createdOn: {
            serializedName: "createdOn",
            required: true,
            type: {
              name: "DateTime"
            }
          },
          senderCommunicationIdentifier: {
            serializedName: "senderCommunicationIdentifier",
            type: {
              name: "Composite",
              className: "CommunicationIdentifierModel"
            }
          },
          deletedOn: {
            serializedName: "deletedOn",
            type: {
              name: "DateTime"
            }
          },
          editedOn: {
            serializedName: "editedOn",
            type: {
              name: "DateTime"
            }
          },
          metadata: {
            serializedName: "metadata",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          }
        }
      }
    };
    ChatMessageContent = {
      type: {
        name: "Composite",
        className: "ChatMessageContent",
        modelProperties: {
          message: {
            serializedName: "message",
            type: {
              name: "String"
            }
          },
          topic: {
            serializedName: "topic",
            type: {
              name: "String"
            }
          },
          participants: {
            serializedName: "participants",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ChatParticipant"
                }
              }
            }
          },
          initiatorCommunicationIdentifier: {
            serializedName: "initiatorCommunicationIdentifier",
            type: {
              name: "Composite",
              className: "CommunicationIdentifierModel"
            }
          }
        }
      }
    };
    ChatParticipant = {
      type: {
        name: "Composite",
        className: "ChatParticipant",
        modelProperties: {
          communicationIdentifier: {
            serializedName: "communicationIdentifier",
            type: {
              name: "Composite",
              className: "CommunicationIdentifierModel"
            }
          },
          displayName: {
            serializedName: "displayName",
            type: {
              name: "String"
            }
          },
          shareHistoryTime: {
            serializedName: "shareHistoryTime",
            type: {
              name: "DateTime"
            }
          }
        }
      }
    };
    UpdateChatMessageRequest = {
      type: {
        name: "Composite",
        className: "UpdateChatMessageRequest",
        modelProperties: {
          content: {
            serializedName: "content",
            type: {
              name: "String"
            }
          },
          metadata: {
            serializedName: "metadata",
            type: {
              name: "Dictionary",
              value: { type: { name: "String" } }
            }
          }
        }
      }
    };
    ChatParticipantsCollection = {
      type: {
        name: "Composite",
        className: "ChatParticipantsCollection",
        modelProperties: {
          value: {
            serializedName: "value",
            required: true,
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ChatParticipant"
                }
              }
            }
          },
          nextLink: {
            serializedName: "nextLink",
            readOnly: true,
            type: {
              name: "String"
            }
          }
        }
      }
    };
    AddChatParticipantsRequest = {
      type: {
        name: "Composite",
        className: "AddChatParticipantsRequest",
        modelProperties: {
          participants: {
            serializedName: "participants",
            required: true,
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ChatParticipant"
                }
              }
            }
          }
        }
      }
    };
    AddChatParticipantsResult = {
      type: {
        name: "Composite",
        className: "AddChatParticipantsResult",
        modelProperties: {
          invalidParticipants: {
            serializedName: "invalidParticipants",
            readOnly: true,
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ChatError"
                }
              }
            }
          }
        }
      }
    };
    CreateChatThreadRequest = {
      type: {
        name: "Composite",
        className: "CreateChatThreadRequest",
        modelProperties: {
          topic: {
            serializedName: "topic",
            required: true,
            type: {
              name: "String"
            }
          },
          participants: {
            serializedName: "participants",
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ChatParticipant"
                }
              }
            }
          }
        }
      }
    };
    CreateChatThreadResult = {
      type: {
        name: "Composite",
        className: "CreateChatThreadResult",
        modelProperties: {
          chatThread: {
            serializedName: "chatThread",
            type: {
              name: "Composite",
              className: "ChatThreadProperties"
            }
          },
          invalidParticipants: {
            serializedName: "invalidParticipants",
            readOnly: true,
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ChatError"
                }
              }
            }
          }
        }
      }
    };
    ChatThreadProperties = {
      type: {
        name: "Composite",
        className: "ChatThreadProperties",
        modelProperties: {
          id: {
            serializedName: "id",
            required: true,
            type: {
              name: "String"
            }
          },
          topic: {
            serializedName: "topic",
            required: true,
            type: {
              name: "String"
            }
          },
          createdOn: {
            serializedName: "createdOn",
            required: true,
            type: {
              name: "DateTime"
            }
          },
          createdByCommunicationIdentifier: {
            serializedName: "createdByCommunicationIdentifier",
            type: {
              name: "Composite",
              className: "CommunicationIdentifierModel"
            }
          },
          deletedOn: {
            serializedName: "deletedOn",
            type: {
              name: "DateTime"
            }
          }
        }
      }
    };
    ChatThreadsItemCollection = {
      type: {
        name: "Composite",
        className: "ChatThreadsItemCollection",
        modelProperties: {
          value: {
            serializedName: "value",
            required: true,
            type: {
              name: "Sequence",
              element: {
                type: {
                  name: "Composite",
                  className: "ChatThreadItem"
                }
              }
            }
          },
          nextLink: {
            serializedName: "nextLink",
            readOnly: true,
            type: {
              name: "String"
            }
          }
        }
      }
    };
    ChatThreadItem = {
      type: {
        name: "Composite",
        className: "ChatThreadItem",
        modelProperties: {
          id: {
            serializedName: "id",
            required: true,
            type: {
              name: "String"
            }
          },
          topic: {
            serializedName: "topic",
            required: true,
            type: {
              name: "String"
            }
          },
          deletedOn: {
            serializedName: "deletedOn",
            type: {
              name: "DateTime"
            }
          },
          lastMessageReceivedOn: {
            serializedName: "lastMessageReceivedOn",
            readOnly: true,
            type: {
              name: "DateTime"
            }
          }
        }
      }
    };
    UpdateChatThreadRequest = {
      type: {
        name: "Composite",
        className: "UpdateChatThreadRequest",
        modelProperties: {
          topic: {
            serializedName: "topic",
            type: {
              name: "String"
            }
          }
        }
      }
    };
    SendTypingNotificationRequest = {
      type: {
        name: "Composite",
        className: "SendTypingNotificationRequest",
        modelProperties: {
          senderDisplayName: {
            serializedName: "senderDisplayName",
            type: {
              name: "String"
            }
          }
        }
      }
    };
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/models/parameters.js
var accept, endpoint, chatThreadId, maxPageSize, skip, apiVersion, contentType, sendReadReceiptRequest, sendChatMessageRequest, startTime, chatMessageId, contentType1, updateChatMessageRequest, participantCommunicationIdentifier, addChatParticipantsRequest, updateChatThreadRequest, sendTypingNotificationRequest, nextLink, createChatThreadRequest, repeatabilityRequestId;
var init_parameters = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/models/parameters.js"() {
    init_mappers2();
    accept = {
      parameterPath: "accept",
      mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
          name: "String"
        }
      }
    };
    endpoint = {
      parameterPath: "endpoint",
      mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
          name: "String"
        }
      },
      skipEncoding: true
    };
    chatThreadId = {
      parameterPath: "chatThreadId",
      mapper: {
        serializedName: "chatThreadId",
        required: true,
        type: {
          name: "String"
        }
      }
    };
    maxPageSize = {
      parameterPath: ["options", "maxPageSize"],
      mapper: {
        serializedName: "maxPageSize",
        type: {
          name: "Number"
        }
      }
    };
    skip = {
      parameterPath: ["options", "skip"],
      mapper: {
        serializedName: "skip",
        type: {
          name: "Number"
        }
      }
    };
    apiVersion = {
      parameterPath: "apiVersion",
      mapper: {
        defaultValue: "2021-09-07",
        isConstant: true,
        serializedName: "api-version",
        type: {
          name: "String"
        }
      }
    };
    contentType = {
      parameterPath: ["options", "contentType"],
      mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
          name: "String"
        }
      }
    };
    sendReadReceiptRequest = {
      parameterPath: "sendReadReceiptRequest",
      mapper: SendReadReceiptRequest
    };
    sendChatMessageRequest = {
      parameterPath: "sendChatMessageRequest",
      mapper: SendChatMessageRequest
    };
    startTime = {
      parameterPath: ["options", "startTime"],
      mapper: {
        serializedName: "startTime",
        type: {
          name: "DateTime"
        }
      }
    };
    chatMessageId = {
      parameterPath: "chatMessageId",
      mapper: {
        serializedName: "chatMessageId",
        required: true,
        type: {
          name: "String"
        }
      }
    };
    contentType1 = {
      parameterPath: ["options", "contentType"],
      mapper: {
        defaultValue: "application/merge-patch+json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
          name: "String"
        }
      }
    };
    updateChatMessageRequest = {
      parameterPath: "updateChatMessageRequest",
      mapper: UpdateChatMessageRequest
    };
    participantCommunicationIdentifier = {
      parameterPath: "participantCommunicationIdentifier",
      mapper: CommunicationIdentifierModel
    };
    addChatParticipantsRequest = {
      parameterPath: "addChatParticipantsRequest",
      mapper: AddChatParticipantsRequest
    };
    updateChatThreadRequest = {
      parameterPath: "updateChatThreadRequest",
      mapper: UpdateChatThreadRequest
    };
    sendTypingNotificationRequest = {
      parameterPath: ["options", "sendTypingNotificationRequest"],
      mapper: SendTypingNotificationRequest
    };
    nextLink = {
      parameterPath: "nextLink",
      mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
          name: "String"
        }
      },
      skipEncoding: true
    };
    createChatThreadRequest = {
      parameterPath: "createChatThreadRequest",
      mapper: CreateChatThreadRequest
    };
    repeatabilityRequestId = {
      parameterPath: ["options", "repeatabilityRequestId"],
      mapper: {
        serializedName: "repeatability-request-id",
        type: {
          name: "String"
        }
      }
    };
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/operations/chatThread.js
var ChatThreadImpl, serializer, listChatReadReceiptsOperationSpec, sendChatReadReceiptOperationSpec, sendChatMessageOperationSpec, listChatMessagesOperationSpec, getChatMessageOperationSpec, updateChatMessageOperationSpec, deleteChatMessageOperationSpec, listChatParticipantsOperationSpec, removeChatParticipantOperationSpec, addChatParticipantsOperationSpec, updateChatThreadPropertiesOperationSpec, getChatThreadPropertiesOperationSpec, sendTypingNotificationOperationSpec, listChatReadReceiptsNextOperationSpec, listChatMessagesNextOperationSpec, listChatParticipantsNextOperationSpec;
var init_chatThread = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/operations/chatThread.js"() {
    init_src10();
    init_mappers2();
    init_parameters();
    ChatThreadImpl = class {
      /**
       * Initialize a new instance of the class ChatThread class.
       * @param client Reference to the service client
       */
      constructor(client) {
        this.client = client;
      }
      /**
       * Gets chat message read receipts for a thread.
       * @param chatThreadId Thread id to get the chat message read receipts for.
       * @param options The options parameters.
       */
      listChatReadReceipts(chatThreadId2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, listChatReadReceiptsOperationSpec);
      }
      /**
       * Sends a read receipt event to a thread, on behalf of a user.
       * @param chatThreadId Thread id to send the read receipt event to.
       * @param sendReadReceiptRequest Read receipt details.
       * @param options The options parameters.
       */
      sendChatReadReceipt(chatThreadId2, sendReadReceiptRequest2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, sendReadReceiptRequest: sendReadReceiptRequest2, options }, sendChatReadReceiptOperationSpec);
      }
      /**
       * Sends a message to a thread.
       * @param chatThreadId The thread id to send the message to.
       * @param sendChatMessageRequest Details of the message to send.
       * @param options The options parameters.
       */
      sendChatMessage(chatThreadId2, sendChatMessageRequest2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, sendChatMessageRequest: sendChatMessageRequest2, options }, sendChatMessageOperationSpec);
      }
      /**
       * Gets a list of messages from a thread.
       * @param chatThreadId The thread id of the message.
       * @param options The options parameters.
       */
      listChatMessages(chatThreadId2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, listChatMessagesOperationSpec);
      }
      /**
       * Gets a message by id.
       * @param chatThreadId The thread id to which the message was sent.
       * @param chatMessageId The message id.
       * @param options The options parameters.
       */
      getChatMessage(chatThreadId2, chatMessageId2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, chatMessageId: chatMessageId2, options }, getChatMessageOperationSpec);
      }
      /**
       * Updates a message.
       * @param chatThreadId The thread id to which the message was sent.
       * @param chatMessageId The message id.
       * @param updateChatMessageRequest Details of the request to update the message.
       * @param options The options parameters.
       */
      updateChatMessage(chatThreadId2, chatMessageId2, updateChatMessageRequest2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, chatMessageId: chatMessageId2, updateChatMessageRequest: updateChatMessageRequest2, options }, updateChatMessageOperationSpec);
      }
      /**
       * Deletes a message.
       * @param chatThreadId The thread id to which the message was sent.
       * @param chatMessageId The message id.
       * @param options The options parameters.
       */
      deleteChatMessage(chatThreadId2, chatMessageId2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, chatMessageId: chatMessageId2, options }, deleteChatMessageOperationSpec);
      }
      /**
       * Gets the participants of a thread.
       * @param chatThreadId Thread id to get participants for.
       * @param options The options parameters.
       */
      listChatParticipants(chatThreadId2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, listChatParticipantsOperationSpec);
      }
      /**
       * Remove a participant from a thread.
       * @param chatThreadId Thread id to remove the participant from.
       * @param participantCommunicationIdentifier Id of the thread participant to remove from the thread.
       * @param options The options parameters.
       */
      removeChatParticipant(chatThreadId2, participantCommunicationIdentifier2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, participantCommunicationIdentifier: participantCommunicationIdentifier2, options }, removeChatParticipantOperationSpec);
      }
      /**
       * Adds thread participants to a thread. If participants already exist, no change occurs.
       * @param chatThreadId Id of the thread to add participants to.
       * @param addChatParticipantsRequest Thread participants to be added to the thread.
       * @param options The options parameters.
       */
      addChatParticipants(chatThreadId2, addChatParticipantsRequest2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, addChatParticipantsRequest: addChatParticipantsRequest2, options }, addChatParticipantsOperationSpec);
      }
      /**
       * Updates a thread's properties.
       * @param chatThreadId The id of the thread to update.
       * @param updateChatThreadRequest Request payload for updating a chat thread.
       * @param options The options parameters.
       */
      updateChatThreadProperties(chatThreadId2, updateChatThreadRequest2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, updateChatThreadRequest: updateChatThreadRequest2, options }, updateChatThreadPropertiesOperationSpec);
      }
      /**
       * Gets a chat thread's properties.
       * @param chatThreadId Id of the thread.
       * @param options The options parameters.
       */
      getChatThreadProperties(chatThreadId2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, getChatThreadPropertiesOperationSpec);
      }
      /**
       * Posts a typing event to a thread, on behalf of a user.
       * @param chatThreadId Id of the thread.
       * @param options The options parameters.
       */
      sendTypingNotification(chatThreadId2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, sendTypingNotificationOperationSpec);
      }
      /**
       * ListChatReadReceiptsNext
       * @param chatThreadId Thread id to get the chat message read receipts for.
       * @param nextLink The nextLink from the previous successful call to the ListChatReadReceipts method.
       * @param options The options parameters.
       */
      listChatReadReceiptsNext(chatThreadId2, nextLink2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, nextLink: nextLink2, options }, listChatReadReceiptsNextOperationSpec);
      }
      /**
       * ListChatMessagesNext
       * @param chatThreadId The thread id of the message.
       * @param nextLink The nextLink from the previous successful call to the ListChatMessages method.
       * @param options The options parameters.
       */
      listChatMessagesNext(chatThreadId2, nextLink2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, nextLink: nextLink2, options }, listChatMessagesNextOperationSpec);
      }
      /**
       * ListChatParticipantsNext
       * @param chatThreadId Thread id to get participants for.
       * @param nextLink The nextLink from the previous successful call to the ListChatParticipants method.
       * @param options The options parameters.
       */
      listChatParticipantsNext(chatThreadId2, nextLink2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, nextLink: nextLink2, options }, listChatParticipantsNextOperationSpec);
      }
    };
    serializer = createSerializer(
      mappers_exports,
      /* isXml */
      false
    );
    listChatReadReceiptsOperationSpec = {
      path: "/chat/threads/{chatThreadId}/readReceipts",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: ChatMessageReadReceiptsCollection
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [
        maxPageSize,
        skip,
        apiVersion
      ],
      urlParameters: [endpoint, chatThreadId],
      headerParameters: [accept],
      serializer
    };
    sendChatReadReceiptOperationSpec = {
      path: "/chat/threads/{chatThreadId}/readReceipts",
      httpMethod: "POST",
      responses: {
        200: {},
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      requestBody: sendReadReceiptRequest,
      queryParameters: [apiVersion],
      urlParameters: [endpoint, chatThreadId],
      headerParameters: [accept, contentType],
      mediaType: "json",
      serializer
    };
    sendChatMessageOperationSpec = {
      path: "/chat/threads/{chatThreadId}/messages",
      httpMethod: "POST",
      responses: {
        201: {
          bodyMapper: SendChatMessageResult
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      requestBody: sendChatMessageRequest,
      queryParameters: [apiVersion],
      urlParameters: [endpoint, chatThreadId],
      headerParameters: [accept, contentType],
      mediaType: "json",
      serializer
    };
    listChatMessagesOperationSpec = {
      path: "/chat/threads/{chatThreadId}/messages",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: ChatMessagesCollection
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [
        maxPageSize,
        apiVersion,
        startTime
      ],
      urlParameters: [endpoint, chatThreadId],
      headerParameters: [accept],
      serializer
    };
    getChatMessageOperationSpec = {
      path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: ChatMessage
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [apiVersion],
      urlParameters: [
        endpoint,
        chatThreadId,
        chatMessageId
      ],
      headerParameters: [accept],
      serializer
    };
    updateChatMessageOperationSpec = {
      path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
      httpMethod: "PATCH",
      responses: {
        204: {},
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      requestBody: updateChatMessageRequest,
      queryParameters: [apiVersion],
      urlParameters: [
        endpoint,
        chatThreadId,
        chatMessageId
      ],
      headerParameters: [accept, contentType1],
      mediaType: "json",
      serializer
    };
    deleteChatMessageOperationSpec = {
      path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
      httpMethod: "DELETE",
      responses: {
        204: {},
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [apiVersion],
      urlParameters: [
        endpoint,
        chatThreadId,
        chatMessageId
      ],
      headerParameters: [accept],
      serializer
    };
    listChatParticipantsOperationSpec = {
      path: "/chat/threads/{chatThreadId}/participants",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: ChatParticipantsCollection
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [
        maxPageSize,
        skip,
        apiVersion
      ],
      urlParameters: [endpoint, chatThreadId],
      headerParameters: [accept],
      serializer
    };
    removeChatParticipantOperationSpec = {
      path: "/chat/threads/{chatThreadId}/participants/:remove",
      httpMethod: "POST",
      responses: {
        204: {},
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      requestBody: participantCommunicationIdentifier,
      queryParameters: [apiVersion],
      urlParameters: [endpoint, chatThreadId],
      headerParameters: [accept, contentType],
      mediaType: "json",
      serializer
    };
    addChatParticipantsOperationSpec = {
      path: "/chat/threads/{chatThreadId}/participants/:add",
      httpMethod: "POST",
      responses: {
        201: {
          bodyMapper: AddChatParticipantsResult
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      requestBody: addChatParticipantsRequest,
      queryParameters: [apiVersion],
      urlParameters: [endpoint, chatThreadId],
      headerParameters: [accept, contentType],
      mediaType: "json",
      serializer
    };
    updateChatThreadPropertiesOperationSpec = {
      path: "/chat/threads/{chatThreadId}",
      httpMethod: "PATCH",
      responses: {
        204: {},
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      requestBody: updateChatThreadRequest,
      queryParameters: [apiVersion],
      urlParameters: [endpoint, chatThreadId],
      headerParameters: [accept, contentType1],
      mediaType: "json",
      serializer
    };
    getChatThreadPropertiesOperationSpec = {
      path: "/chat/threads/{chatThreadId}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: ChatThreadProperties
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [apiVersion],
      urlParameters: [endpoint, chatThreadId],
      headerParameters: [accept],
      serializer
    };
    sendTypingNotificationOperationSpec = {
      path: "/chat/threads/{chatThreadId}/typing",
      httpMethod: "POST",
      responses: {
        200: {},
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      requestBody: sendTypingNotificationRequest,
      queryParameters: [apiVersion],
      urlParameters: [endpoint, chatThreadId],
      headerParameters: [accept, contentType],
      mediaType: "json",
      serializer
    };
    listChatReadReceiptsNextOperationSpec = {
      path: "{nextLink}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: ChatMessageReadReceiptsCollection
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [
        maxPageSize,
        skip,
        apiVersion
      ],
      urlParameters: [
        endpoint,
        chatThreadId,
        nextLink
      ],
      headerParameters: [accept],
      serializer
    };
    listChatMessagesNextOperationSpec = {
      path: "{nextLink}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: ChatMessagesCollection
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [
        maxPageSize,
        apiVersion,
        startTime
      ],
      urlParameters: [
        endpoint,
        chatThreadId,
        nextLink
      ],
      headerParameters: [accept],
      serializer
    };
    listChatParticipantsNextOperationSpec = {
      path: "{nextLink}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: ChatParticipantsCollection
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [
        maxPageSize,
        skip,
        apiVersion
      ],
      urlParameters: [
        endpoint,
        chatThreadId,
        nextLink
      ],
      headerParameters: [accept],
      serializer
    };
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/operations/chat.js
var ChatImpl, serializer2, createChatThreadOperationSpec, listChatThreadsOperationSpec, deleteChatThreadOperationSpec, listChatThreadsNextOperationSpec;
var init_chat = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/operations/chat.js"() {
    init_src10();
    init_mappers2();
    init_parameters();
    ChatImpl = class {
      /**
       * Initialize a new instance of the class Chat class.
       * @param client Reference to the service client
       */
      constructor(client) {
        this.client = client;
      }
      /**
       * Creates a chat thread.
       * @param createChatThreadRequest Request payload for creating a chat thread.
       * @param options The options parameters.
       */
      createChatThread(createChatThreadRequest2, options) {
        return this.client.sendOperationRequest({ createChatThreadRequest: createChatThreadRequest2, options }, createChatThreadOperationSpec);
      }
      /**
       * Gets the list of chat threads of a user.
       * @param options The options parameters.
       */
      listChatThreads(options) {
        return this.client.sendOperationRequest({ options }, listChatThreadsOperationSpec);
      }
      /**
       * Deletes a thread.
       * @param chatThreadId Id of the thread to be deleted.
       * @param options The options parameters.
       */
      deleteChatThread(chatThreadId2, options) {
        return this.client.sendOperationRequest({ chatThreadId: chatThreadId2, options }, deleteChatThreadOperationSpec);
      }
      /**
       * ListChatThreadsNext
       * @param nextLink The nextLink from the previous successful call to the ListChatThreads method.
       * @param options The options parameters.
       */
      listChatThreadsNext(nextLink2, options) {
        return this.client.sendOperationRequest({ nextLink: nextLink2, options }, listChatThreadsNextOperationSpec);
      }
    };
    serializer2 = createSerializer(
      mappers_exports,
      /* isXml */
      false
    );
    createChatThreadOperationSpec = {
      path: "/chat/threads",
      httpMethod: "POST",
      responses: {
        201: {
          bodyMapper: CreateChatThreadResult
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      requestBody: createChatThreadRequest,
      queryParameters: [apiVersion],
      urlParameters: [endpoint],
      headerParameters: [
        accept,
        contentType,
        repeatabilityRequestId
      ],
      mediaType: "json",
      serializer: serializer2
    };
    listChatThreadsOperationSpec = {
      path: "/chat/threads",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: ChatThreadsItemCollection
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [
        maxPageSize,
        apiVersion,
        startTime
      ],
      urlParameters: [endpoint],
      headerParameters: [accept],
      serializer: serializer2
    };
    deleteChatThreadOperationSpec = {
      path: "/chat/threads/{chatThreadId}",
      httpMethod: "DELETE",
      responses: {
        204: {},
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [apiVersion],
      urlParameters: [endpoint, chatThreadId],
      headerParameters: [accept],
      serializer: serializer2
    };
    listChatThreadsNextOperationSpec = {
      path: "{nextLink}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: ChatThreadsItemCollection
        },
        401: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        403: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        429: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        },
        503: {
          bodyMapper: CommunicationErrorResponse,
          isError: true
        }
      },
      queryParameters: [
        maxPageSize,
        apiVersion,
        startTime
      ],
      urlParameters: [endpoint, nextLink],
      headerParameters: [accept],
      serializer: serializer2
    };
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/operations/index.js
var init_operations = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/operations/index.js"() {
    init_chatThread();
    init_chat();
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/chatApiClientContext.js
var ChatApiClientContext;
var init_chatApiClientContext = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/chatApiClientContext.js"() {
    init_src10();
    ChatApiClientContext = class extends ServiceClient2 {
      /**
       * Initializes a new instance of the ChatApiClientContext class.
       * @param endpoint The endpoint of the Azure Communication resource.
       * @param options The parameter options
       */
      constructor(endpoint2, options) {
        if (endpoint2 === void 0) {
          throw new Error("'endpoint' cannot be null");
        }
        if (!options) {
          options = {};
        }
        const defaults = {
          requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-azure-communication-chat/1.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
          userAgentPrefix
        }, baseUri: options.endpoint || "{endpoint}" });
        super(optionsWithDefaults);
        this.endpoint = endpoint2;
        this.apiVersion = options.apiVersion || "2021-09-07";
      }
    };
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/chatApiClient.js
var ChatApiClient;
var init_chatApiClient = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/chatApiClient.js"() {
    init_operations();
    init_chatApiClientContext();
    ChatApiClient = class extends ChatApiClientContext {
      /**
       * Initializes a new instance of the ChatApiClient class.
       * @param endpoint The endpoint of the Azure Communication resource.
       * @param options The parameter options
       */
      constructor(endpoint2, options) {
        super(endpoint2, options);
        this.chatThread = new ChatThreadImpl(this);
        this.chat = new ChatImpl(this);
      }
    };
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/operationsInterfaces/chatThread.js
var init_chatThread2 = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/operationsInterfaces/chatThread.js"() {
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/operationsInterfaces/chat.js
var init_chat2 = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/operationsInterfaces/chat.js"() {
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/operationsInterfaces/index.js
var init_operationsInterfaces = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/operationsInterfaces/index.js"() {
    init_chatThread2();
    init_chat2();
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/generated/src/index.js
var init_src11 = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/generated/src/index.js"() {
    init_models2();
    init_chatApiClient();
    init_chatApiClientContext();
    init_operationsInterfaces();
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/credential/communicationTokenCredentialPolicy.js
var createCommunicationTokenCredentialPolicy;
var init_communicationTokenCredentialPolicy = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/credential/communicationTokenCredentialPolicy.js"() {
    init_src9();
    createCommunicationTokenCredentialPolicy = (credential) => {
      const policyOptions = {
        credential: {
          getToken: (_scopes, options) => credential.getToken({ abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal })
        },
        scopes: []
      };
      return bearerTokenAuthenticationPolicy2(policyOptions);
    };
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/chatThreadClient.js
var minimumTypingIntervalInMilliSeconds, ChatThreadClient;
var init_chatThreadClient = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/chatThreadClient.js"() {
    init_tslib_es6();
    init_logger();
    init_src7();
    init_src5();
    init_tracing();
    init_mappers();
    init_src11();
    init_communicationTokenCredentialPolicy();
    minimumTypingIntervalInMilliSeconds = 8e3;
    ChatThreadClient = class {
      constructor(endpoint2, threadId, credential, options = {}) {
        this.endpoint = endpoint2;
        this.timeOfLastTypingRequest = void 0;
        this.threadId = threadId;
        this.tokenCredential = credential;
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
          loggingOptions: {
            logger: logger2.info
          }
        });
        this.client = new ChatApiClient(this.endpoint, Object.assign({ endpoint: this.endpoint }, internalPipelineOptions));
        const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);
        this.client.pipeline.addPolicy(authPolicy);
      }
      /**
       * Gets a chat thread.
       * Returns the chat thread.
       * @param options -  Operation options.
       */
      async getProperties(options = {}) {
        const { span, updatedOptions } = createSpan2("ChatClient-GetProperties", options);
        try {
          const result = await this.client.chatThread.getChatThreadProperties(this.threadId, updatedOptions);
          return mapToChatThreadPropertiesSdkModel(result);
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      /**
       * Updates a thread's topic.
       * @param topic - The topic needs to be updated to.
       * @param options - Operation options.
       */
      async updateTopic(topic, options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-UpdateTopic", options);
        try {
          await this.client.chatThread.updateChatThreadProperties(this.threadId, { topic }, updatedOptions);
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      /**
       * Sends a chat message to a thread identified by threadId.
       * Returns the id of the created message.
       * @param request - Request for sending a message.
       * @param options - Operation options.
       */
      async sendMessage(request, options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-SendMessage", options);
        try {
          this.timeOfLastTypingRequest = void 0;
          const result = await this.client.chatThread.sendChatMessage(this.threadId, Object.assign(Object.assign({}, request), options), updatedOptions);
          return result;
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      /**
       * Gets a chat message identified by messageId.
       * Returns the specific message.
       * @param messageId - The message id of the message.
       * @param options - Operation options.
       */
      async getMessage(messageId, options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-GetMessage", options);
        try {
          const result = await this.client.chatThread.getChatMessage(this.threadId, messageId, updatedOptions);
          return mapToChatMessageSdkModel(result);
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      listMessagesPage(pageSettings, options = {}) {
        return __asyncGenerator(this, arguments, function* listMessagesPage_1() {
          if (!pageSettings.continuationToken) {
            const currentSetResponse = yield __await(this.client.chatThread.listChatMessages(this.threadId, options));
            pageSettings.continuationToken = currentSetResponse.nextLink;
            if (currentSetResponse.value) {
              yield yield __await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));
            }
          }
          while (pageSettings.continuationToken) {
            const currentSetResponse = yield __await(this.client.chatThread.listChatMessagesNext(this.threadId, pageSettings.continuationToken, options));
            pageSettings.continuationToken = currentSetResponse.nextLink;
            if (currentSetResponse.value) {
              yield yield __await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));
            } else {
              break;
            }
          }
        });
      }
      listMessagesAll(options) {
        return __asyncGenerator(this, arguments, function* listMessagesAll_1() {
          var e_1, _a2;
          try {
            for (var _b = __asyncValues(this.listMessagesPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done; ) {
              const page = _c.value;
              yield __await(yield* __asyncDelegator(__asyncValues(page)));
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b.return))
                yield __await(_a2.call(_b));
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        });
      }
      /**
       * Gets a list of message from a thread identified by threadId.
       * Returns the list of the messages.
       * @param options - Get messages options.
       */
      listMessages(options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-ListMessages", options);
        try {
          const iter = this.listMessagesAll(updatedOptions);
          return {
            next() {
              return iter.next();
            },
            [Symbol.asyncIterator]() {
              return this;
            },
            byPage: (settings = {}) => {
              return this.listMessagesPage(settings, updatedOptions);
            }
          };
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      /**
       * Deletes a message identified by threadId and messageId
       * @param messageId - The message id of the message.
       * @param options - Operation options.
       */
      async deleteMessage(messageId, options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-DeleteMessage", options);
        try {
          await this.client.chatThread.deleteChatMessage(this.threadId, messageId, updatedOptions);
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      /**
       * Updates a message identified by threadId and messageId
       * @param messageId - The message id of the message.
       * @param options - Operation options.
       */
      async updateMessage(messageId, options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-UpdateMessage", options);
        try {
          await this.client.chatThread.updateChatMessage(this.threadId, messageId, options, updatedOptions);
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      /**
       * Adds the details of chat participants belonging to the thread identified by threadId.
       * @param request - Thread participants' details to add in the thread roster
       * @param options - Operation options.
       */
      async addParticipants(request, options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-AddParticipants", options);
        try {
          const result = await this.client.chatThread.addChatParticipants(this.threadId, mapToAddChatParticipantsRequestRestModel(request), updatedOptions);
          return result;
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      listParticipantsPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listParticipantsPage_1() {
          if (!continuationState.continuationToken) {
            const currentSetResponse = yield __await(this.client.chatThread.listChatParticipants(this.threadId, options));
            continuationState.continuationToken = currentSetResponse.nextLink;
            if (currentSetResponse.value) {
              yield yield __await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));
            }
          }
          while (continuationState.continuationToken) {
            const currentSetResponse = yield __await(this.client.chatThread.listChatParticipantsNext(this.threadId, continuationState.continuationToken, options));
            continuationState.continuationToken = currentSetResponse.nextLink;
            if (currentSetResponse.value) {
              yield yield __await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));
            } else {
              break;
            }
          }
        });
      }
      listParticipantsAll(options) {
        return __asyncGenerator(this, arguments, function* listParticipantsAll_1() {
          var e_2, _a2;
          try {
            for (var _b = __asyncValues(this.listParticipantsPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done; ) {
              const page = _c.value;
              yield __await(yield* __asyncDelegator(__asyncValues(page)));
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b.return))
                yield __await(_a2.call(_b));
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        });
      }
      /**
       * Gets the participants of the thread identified by threadId.
       * Returns the lists of the participants.
       * @param options - Operation options.
       */
      listParticipants(options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-ListParticipants", options);
        try {
          const iter = this.listParticipantsAll(updatedOptions);
          return {
            next() {
              return iter.next();
            },
            [Symbol.asyncIterator]() {
              return this;
            },
            byPage: (settings = {}) => {
              return this.listParticipantsPage(settings, updatedOptions);
            }
          };
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      /**
       * Removes participant from the thread identified by threadId.
       * @param participant - Thread participant to remove from the thread roster
       * @param options - Operation options.
       */
      async removeParticipant(participant, options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-RemoveParticipant", options);
        try {
          await this.client.chatThread.removeChatParticipant(this.threadId, serializeCommunicationIdentifier(participant), updatedOptions);
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      /**
       * Sends a typing notification to the thread.
       * Doesn't attempt to send if the time since last notification is smaller than the minimum typing interval
       * @param options - - Operation options
       * @returns True if the typing message notification could be sent, otherwise false.
       */
      async sendTypingNotification(options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-SendTypingNotification", options);
        try {
          const dateNow = /* @__PURE__ */ new Date();
          const { senderDisplayName } = updatedOptions, restOptions = __rest(updatedOptions, ["senderDisplayName"]);
          if (this.canPostTypingNotification(dateNow)) {
            await this.client.chatThread.sendTypingNotification(this.threadId, Object.assign({ sendTypingNotificationRequest: { senderDisplayName } }, restOptions));
            this.timeOfLastTypingRequest = dateNow;
            return true;
          }
          logger2.info(`Typing Notification NOT Send. [thread_id=${this.threadId}]`);
          return false;
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      /**
       * Sends a read receipt to the thread identified by threadId.
       * @param messageId - The message id of the message that user latest read.
       * @param request - Request for sending a read receipt
       * @param options - Operation options.
       */
      async sendReadReceipt(request, options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-SendReadReceipt", options);
        try {
          await this.client.chatThread.sendChatReadReceipt(this.threadId, request, updatedOptions);
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      listReadReceiptsPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listReadReceiptsPage_1() {
          if (!continuationState.continuationToken) {
            const currentSetResponse = yield __await(this.client.chatThread.listChatReadReceipts(this.threadId, options));
            continuationState.continuationToken = currentSetResponse.nextLink;
            if (currentSetResponse.value) {
              yield yield __await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));
            }
          }
          while (continuationState.continuationToken) {
            const currentSetResponse = yield __await(this.client.chatThread.listChatReadReceiptsNext(this.threadId, continuationState.continuationToken, options));
            continuationState.continuationToken = currentSetResponse.nextLink;
            if (currentSetResponse.value) {
              yield yield __await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));
            } else {
              break;
            }
          }
        });
      }
      listReadReceiptsAll(options) {
        return __asyncGenerator(this, arguments, function* listReadReceiptsAll_1() {
          var e_3, _a2;
          try {
            for (var _b = __asyncValues(this.listReadReceiptsPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done; ) {
              const page = _c.value;
              yield __await(yield* __asyncDelegator(__asyncValues(page)));
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b.return))
                yield __await(_a2.call(_b));
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
        });
      }
      /**
       * Gets a list of read receipt from a thread identified by threadId.
       * Returns the list of the messages.
       * @param options - Get messages options.
       */
      listReadReceipts(options = {}) {
        const { span, updatedOptions } = createSpan2("ChatThreadClient-ListChatReadReceipts", options);
        try {
          const iter = this.listReadReceiptsAll(updatedOptions);
          return {
            next() {
              return iter.next();
            },
            [Symbol.asyncIterator]() {
              return this;
            },
            byPage: (settings = {}) => {
              return this.listReadReceiptsPage(settings, updatedOptions);
            }
          };
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      canPostTypingNotification(dateNow) {
        if (this.timeOfLastTypingRequest) {
          const timeSinceLastRequestInMilliSeconds = dateNow.getTime() - this.timeOfLastTypingRequest.getTime();
          if (timeSinceLastRequestInMilliSeconds < minimumTypingIntervalInMilliSeconds) {
            logger2.info(`Typing interval check failed. [last_request=${this.timeOfLastTypingRequest}]`);
            return false;
          }
        }
        return true;
      }
    };
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/models/uuid.js
function generateUuid2() {
  return v4_default();
}
var init_uuid = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/models/uuid.js"() {
    init_esm_browser();
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/chatClient.js
var import_events, ChatClient;
var init_chatClient = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/chatClient.js"() {
    init_tslib_es6();
    init_logger();
    import_events = __toESM(require_events());
    init_signalingClient_browser();
    init_src5();
    init_tracing();
    init_chatThreadClient();
    init_mappers();
    init_src11();
    init_communicationTokenCredentialPolicy();
    init_uuid();
    ChatClient = class {
      /**
       * Creates an instance of the ChatClient for a given resource and user.
       *
       * @param endpoint - The url of the Communication Services resouce.
       * @param credential - The token credential. Use AzureCommunicationTokenCredential from \@azure/communication-common to create a credential.
       * @param options - Additional client options.
       */
      constructor(endpoint2, credential, options = {}) {
        this.endpoint = endpoint2;
        this.signalingClient = void 0;
        this.emitter = new import_events.EventEmitter();
        this.isRealtimeNotificationsStarted = false;
        this.tokenCredential = credential;
        this.clientOptions = Object.assign({}, options);
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
          loggingOptions: {
            logger: logger2.info
          }
        });
        this.client = new ChatApiClient(this.endpoint, Object.assign({ endpoint: this.endpoint }, internalPipelineOptions));
        const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);
        this.client.pipeline.addPolicy(authPolicy);
        this.signalingClient = getSignalingClient(credential, logger2, options.signalingClientOptions);
      }
      /**
       * Returns ChatThreadClient with the specific thread id.
       * @param threadId - Thread ID for the ChatThreadClient
       */
      getChatThreadClient(threadId) {
        return new ChatThreadClient(this.endpoint, threadId, this.tokenCredential, this.clientOptions);
      }
      /**
       * Creates a chat thread.
       * Returns thread client with the id of the created thread.
       * @param request - Request for creating a chat thread.
       * @param options - Operation options.
       */
      async createChatThread(request, options = {}) {
        var _a2, _b;
        const { span, updatedOptions } = createSpan2("ChatClient-CreateChatThread", options);
        try {
          updatedOptions.idempotencyToken = (_a2 = updatedOptions.idempotencyToken) !== null && _a2 !== void 0 ? _a2 : generateUuid2();
          const updatedRestModelOptions = mapToCreateChatThreadOptionsRestModel(updatedOptions);
          const result = await this.client.chat.createChatThread({
            topic: request.topic,
            participants: (_b = options.participants) === null || _b === void 0 ? void 0 : _b.map((participant) => mapToChatParticipantRestModel(participant))
          }, updatedRestModelOptions);
          return mapToCreateChatThreadResultSdkModel(result);
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      listChatThreadsPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listChatThreadsPage_1() {
          if (!continuationState.continuationToken) {
            const currentSetResponse = yield __await(this.client.chat.listChatThreads(options));
            continuationState.continuationToken = currentSetResponse.nextLink;
            if (currentSetResponse.value) {
              yield yield __await(currentSetResponse.value);
            }
          }
          while (continuationState.continuationToken) {
            const currentSetResponse = yield __await(this.client.chat.listChatThreadsNext(continuationState.continuationToken, options));
            continuationState.continuationToken = currentSetResponse.nextLink;
            if (currentSetResponse.value) {
              yield yield __await(currentSetResponse.value);
            } else {
              break;
            }
          }
        });
      }
      listChatThreadsAll(options) {
        return __asyncGenerator(this, arguments, function* listChatThreadsAll_1() {
          var e_1, _a2;
          try {
            for (var _b = __asyncValues(this.listChatThreadsPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done; ) {
              const page = _c.value;
              yield __await(yield* __asyncDelegator(__asyncValues(page)));
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b.return))
                yield __await(_a2.call(_b));
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        });
      }
      /**
       * Gets the list of chat threads of a user.
       * @param options - List chat threads options.
       */
      listChatThreads(options = {}) {
        const { span, updatedOptions } = createSpan2("ChatClient-ListChatThreads", options);
        try {
          const iter = this.listChatThreadsAll(updatedOptions);
          return {
            next() {
              return iter.next();
            },
            [Symbol.asyncIterator]() {
              return this;
            },
            byPage: (settings = {}) => {
              return this.listChatThreadsPage(settings, updatedOptions);
            }
          };
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      /**
       * Deletes a chat thread.
       * @param threadId - The ID of the thread to delete.
       * @param options -  Operation options.
       */
      async deleteChatThread(threadId, options = {}) {
        const { span, updatedOptions } = createSpan2("ChatClient-DeleteChatThread", options);
        try {
          await this.client.chat.deleteChatThread(threadId, updatedOptions);
        } catch (e) {
          span.setStatus({
            code: SpanStatusCode2.ERROR,
            message: e.message
          });
          throw e;
        } finally {
          span.end();
        }
      }
      /**
       * Start receiving realtime notifications.
       * Call this function before subscribing to any event.
       */
      async startRealtimeNotifications() {
        if (this.signalingClient === void 0) {
          throw new Error("Realtime notifications are not supported in node js.");
        }
        if (this.isRealtimeNotificationsStarted) {
          return;
        }
        this.isRealtimeNotificationsStarted = true;
        await this.signalingClient.start();
        this.subscribeToSignalingEvents();
      }
      /**
       * Stop receiving realtime notifications.
       * This function would unsubscribe to all events.
       */
      async stopRealtimeNotifications() {
        if (this.signalingClient === void 0) {
          throw new Error("Realtime notifications are not supported in node js.");
        }
        this.isRealtimeNotificationsStarted = false;
        await this.signalingClient.stop();
        this.emitter.removeAllListeners();
      }
      on(event, listener) {
        if (this.signalingClient === void 0) {
          throw new Error("Realtime notifications are only supported in the browser.");
        }
        if (!this.isRealtimeNotificationsStarted) {
          throw new Error("You must call startRealtimeNotifications before you can subscribe to events.");
        }
        this.emitter.on(event, listener);
      }
      off(event, listener) {
        if (this.signalingClient === void 0) {
          throw new Error("Realtime notifications are only supported in the browser.");
        }
        this.emitter.removeListener(event, listener);
      }
      subscribeToSignalingEvents() {
        if (this.signalingClient === void 0) {
          throw new Error("Realtime notifications are only supported in the browser.");
        }
        this.signalingClient.on("chatMessageReceived", (payload) => {
          this.emitter.emit("chatMessageReceived", payload);
        });
        this.signalingClient.on("chatMessageEdited", (payload) => {
          this.emitter.emit("chatMessageEdited", payload);
        });
        this.signalingClient.on("chatMessageDeleted", (payload) => {
          this.emitter.emit("chatMessageDeleted", payload);
        });
        this.signalingClient.on("typingIndicatorReceived", (payload) => {
          this.emitter.emit("typingIndicatorReceived", payload);
        });
        this.signalingClient.on("readReceiptReceived", (payload) => {
          this.emitter.emit("readReceiptReceived", payload);
        });
        this.signalingClient.on("chatThreadCreated", (payload) => {
          this.emitter.emit("chatThreadCreated", payload);
        });
        this.signalingClient.on("chatThreadDeleted", (payload) => {
          this.emitter.emit("chatThreadDeleted", payload);
        });
        this.signalingClient.on("chatThreadPropertiesUpdated", (payload) => {
          this.emitter.emit("chatThreadPropertiesUpdated", payload);
        });
        this.signalingClient.on("participantsAdded", (payload) => {
          this.emitter.emit("participantsAdded", payload);
        });
        this.signalingClient.on("participantsRemoved", (payload) => {
          this.emitter.emit("participantsRemoved", payload);
        });
      }
    };
  }
});

// node_modules/@azure/communication-chat/dist-esm/src/index.js
var src_exports4 = {};
__export(src_exports4, {
  ChatClient: () => ChatClient,
  ChatThreadClient: () => ChatThreadClient
});
var init_src12 = __esm({
  "node_modules/@azure/communication-chat/dist-esm/src/index.js"() {
    init_options();
    init_requests();
    init_models();
    init_events();
    init_chatClient();
    init_chatThreadClient();
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports2, module2) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperty(obj, key, value) {
      key = toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module2.exports = _defineProperty, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports2, module2) {
    var _typeof = require_typeof()["default"];
    function _regeneratorRuntime() {
      "use strict";
      module2.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
        return exports3;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      var exports3 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function define2(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context3 = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context3)
        }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports3.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
          value: function value(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context3) {
        var state = "suspendedStart";
        return function(method, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method)
              throw arg;
            return doneResult();
          }
          for (context3.method = method, context3.arg = arg; ; ) {
            var delegate = context3.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context3);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context3.method)
              context3.sent = context3._sent = context3.arg;
            else if ("throw" === context3.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context3.arg;
              context3.dispatchException(context3.arg);
            } else
              "return" === context3.method && context3.abrupt("return", context3.arg);
            state = "executing";
            var record = tryCatch(innerFn, self2, context3);
            if ("normal" === record.type) {
              if (state = context3.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context3.done
              };
            }
            "throw" === record.type && (state = "completed", context3.method = "throw", context3.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context3) {
        var methodName = context3.method, method = delegate.iterator[methodName];
        if (void 0 === method)
          return context3.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context3.method = "return", context3.arg = void 0, maybeInvokeDelegate(delegate, context3), "throw" === context3.method) || "return" !== methodName && (context3.method = "throw", context3.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method, delegate.iterator, context3.arg);
        if ("throw" === record.type)
          return context3.method = "throw", context3.arg = record.arg, context3.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context3[delegate.resultName] = info.value, context3.next = delegate.nextLoc, "return" !== context3.method && (context3.method = "next", context3.arg = void 0), context3.delegate = null, ContinueSentinel) : info : (context3.method = "throw", context3.arg = new TypeError("iterator result is not an object"), context3.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              for (; ++i < iterable.length; )
                if (hasOwn.call(iterable, i))
                  return next2.value = iterable[i], next2.done = false, next2;
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports3.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports3.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports3.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports3.AsyncIterator = AsyncIterator, exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
      }), define(Gp, "toString", function() {
        return "[object Generator]";
      }), exports3.keys = function(val) {
        var object = Object(val), keys = [];
        for (var key in object)
          keys.push(key);
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports3.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context3 = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context3.next = loc, caught && (context3.method = "next", context3.arg = void 0), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i], record = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type)
            throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports3;
    }
    module2.exports = _regeneratorRuntime, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports2, module2) {
    var runtime = require_regeneratorRuntime()();
    module2.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports2, module2) {
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    module2.exports = _asyncToGenerator, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@microsoft/omnichannel-ic3core/package.json
var require_package2 = __commonJS({
  "node_modules/@microsoft/omnichannel-ic3core/package.json"(exports2, module2) {
    module2.exports = {
      name: "@microsoft/omnichannel-ic3core",
      version: "0.1.2",
      description: "Microsoft Omnichannel IC3Core",
      files: [
        "lib/**/*"
      ],
      main: "lib/index.js",
      types: "lib/index.d.ts",
      scripts: {
        "build:tsc": "tsc",
        lint: "eslint src --ext .ts",
        test: "jest"
      },
      author: "Microsoft Corporation",
      license: "MIT",
      repository: {
        type: "git",
        url: "https://github.com/microsoft/omnichannel-ic3core"
      },
      homepage: "https://github.com/microsoft/omnichannel-ic3core#omnichannel-ic3core",
      keywords: [],
      devDependencies: {
        "@types/jest": "^27.0.2",
        "@typescript-eslint/eslint-plugin": "^4.32.0",
        "@typescript-eslint/parser": "^4.32.0",
        eslint: "^7.32.0",
        "eslint-plugin-security": "^1.4.0",
        jest: "^27.2.2",
        "ts-jest": "^27.0.5",
        typescript: "^4.4.3"
      },
      dependencies: {
        axios: "^0.21.4",
        buffer: "^6.0.3"
      }
    };
  }
});

// node_modules/@azure/communication-chat/package.json
var require_package3 = __commonJS({
  "node_modules/@azure/communication-chat/package.json"(exports2, module2) {
    module2.exports = {
      name: "@azure/communication-chat",
      version: "1.1.1",
      description: "Azure client library for Azure Communication Chat services",
      "sdk-type": "client",
      main: "dist/index.js",
      module: "dist-esm/src/index.js",
      types: "types/communication-chat.d.ts",
      scripts: {
        audit: "node ../../../common/scripts/rush-audit.js && rimraf node_modules package-lock.json && npm i --package-lock-only 2>&1 && npm audit",
        "build:autorest": "autorest ./swagger/README.md --typescript --v3 && rushx format",
        "build:browser": "tsc -p . && cross-env ONLY_BROWSER=true rollup -c 2>&1",
        "build:node": "tsc -p . && cross-env ONLY_NODE=true rollup -c 2>&1",
        "build:samples": "echo Obsolete.",
        "build:test": "tsc -p . && rollup -c rollup.test.config.js 2>&1",
        build: "npm run clean && tsc -p . && rollup -c 2>&1 && api-extractor run --local",
        "check-format": 'prettier --list-different --config ../../../.prettierrc.json --ignore-path ../../../.prettierignore "src/**/*.ts" "test/**/*.ts" "samples-dev/**/*.ts" "*.{js,json}"',
        clean: "rimraf dist dist-* temp types *.tgz *.log",
        "execute:samples": "dev-tool samples run samples-dev",
        "extract-api": "tsc -p . && api-extractor run --local",
        format: 'prettier --write --config ../../../.prettierrc.json --ignore-path ../../../.prettierignore "src/**/*.ts" "test/**/*.ts" "samples-dev/**/*.ts" "*.{js,json}"',
        "integration-test:browser": "karma start --single-run",
        "integration-test:node": "nyc mocha -r esm --require source-map-support/register --reporter ../../../common/tools/mocha-multi-reporter.js --full-trace -t 300000 dist-esm/test/public/*.spec.js dist-esm/test/public/node/*.spec.js",
        "integration-test": "npm run integration-test:node && npm run integration-test:browser",
        "lint:fix": "eslint package.json api-extractor.json src test --ext .ts --fix --fix-type [problem,suggestion]",
        lint: "eslint package.json api-extractor.json src test --ext .ts",
        pack: "npm pack 2>&1",
        "test:browser": "npm run build:test && npm run unit-test:browser && npm run integration-test:browser",
        "test:node": "npm run build:test && npm run unit-test:node && npm run integration-test:node",
        test: "npm run build:test && npm run unit-test && npm run integration-test",
        "unit-test:browser": "karma start --single-run",
        "unit-test:node": 'mocha --reporter ../../../common/tools/mocha-multi-reporter.js "dist-test/index.node.js"',
        "unit-test": "npm run unit-test:node && npm run unit-test:browser",
        docs: "typedoc --excludePrivate --excludeNotExported --excludeExternals --stripInternal --mode file --out ./dist/docs ./src"
      },
      files: [
        "dist/",
        "dist-esm/src/",
        "types/",
        "README.md",
        "LICENSE"
      ],
      browser: {
        "./dist-esm/src/signaling/signalingClient.js": "./dist-esm/src/signaling/signalingClient.browser.js"
      },
      repository: "github:Azure/azure-sdk-for-js",
      keywords: [
        "azure",
        "cloud",
        "Azure",
        "communication",
        "chat"
      ],
      author: "Microsoft Corporation",
      license: "MIT",
      bugs: {
        url: "https://github.com/Azure/azure-sdk-for-js/issues"
      },
      engines: {
        node: ">=12.0.0"
      },
      homepage: "https://github.com/Azure/azure-sdk-for-js/tree/main/sdk/communication/communication-chat/",
      sideEffects: false,
      prettier: "@azure/eslint-plugin-azure-sdk/prettier.json",
      dependencies: {
        "@azure/abort-controller": "^1.0.0",
        "@azure/communication-common": "^1.1.0",
        "@azure/communication-signaling": "1.0.0-beta.11",
        "@azure/core-auth": "^1.3.0",
        "@azure/core-client": "^1.0.0",
        "@azure/core-rest-pipeline": "^1.1.0",
        "@azure/core-tracing": "1.0.0-preview.13",
        "@azure/logger": "^1.0.0",
        events: "^3.0.0",
        tslib: "^2.2.0",
        "@azure/core-paging": "^1.1.1",
        uuid: "^8.3.0"
      },
      devDependencies: {
        "@azure/core-util": "^1.0.0-beta.1",
        "@azure/communication-identity": "^1.0.0",
        "@azure/dev-tool": "^1.0.0",
        "@azure/eslint-plugin-azure-sdk": "^3.0.0",
        "@azure-tools/test-recorder": "^1.0.0",
        "@microsoft/api-extractor": "^7.18.11",
        "@rollup/plugin-commonjs": "11.0.2",
        "@rollup/plugin-json": "^4.0.0",
        "@rollup/plugin-multi-entry": "^3.0.0",
        "@rollup/plugin-node-resolve": "^8.0.0",
        "@rollup/plugin-replace": "^2.2.0",
        "@types/chai": "^4.1.6",
        "@types/mocha": "^7.0.2",
        "@types/node": "^12.0.0",
        "@types/sinon": "^9.0.4",
        "@types/uuid": "^8.0.0",
        assert: "^1.4.1",
        chai: "^4.2.0",
        "cross-env": "^7.0.2",
        dotenv: "^8.2.0",
        eslint: "^7.15.0",
        inherits: "^2.0.3",
        "karma-chrome-launcher": "^3.0.0",
        "karma-coverage": "^2.0.0",
        "karma-edge-launcher": "^0.4.2",
        "karma-env-preprocessor": "^0.1.1",
        "karma-json-preprocessor": "^0.3.3",
        "karma-json-to-file-reporter": "^1.0.1",
        "karma-firefox-launcher": "^1.1.0",
        "karma-ie-launcher": "^1.0.0",
        "karma-junit-reporter": "^2.0.1",
        "karma-mocha-reporter": "^2.2.5",
        "karma-mocha": "^2.0.1",
        "karma-sourcemap-loader": "^0.3.8",
        karma: "^6.2.0",
        "mocha-junit-reporter": "^1.18.0",
        mocha: "^7.1.1",
        nyc: "^14.0.0",
        prettier: "^1.16.4",
        rimraf: "^3.0.0",
        "rollup-plugin-sourcemaps": "^0.4.2",
        "rollup-plugin-shim": "^1.0.0",
        "rollup-plugin-terser": "^5.1.1",
        "rollup-plugin-visualizer": "^4.0.4",
        rollup: "^1.16.3",
        sinon: "^9.0.2",
        typescript: "~4.2.0",
        util: "^0.12.1",
        typedoc: "0.15.2"
      },
      "//metadata": {
        constantPaths: [
          {
            path: "src/generated/src/chatApiClientContext.ts",
            prefix: "packageDetails"
          },
          {
            path: "swagger/README.md",
            prefix: "package-version"
          }
        ]
      },
      "//sampleConfiguration": {
        productName: "Azure Communication Services - Chat",
        productSlugs: [
          "azure",
          "azure-communication-services"
        ],
        requiredResources: {
          "Azure Communication Services account": "https://docs.microsoft.com/azure/communication-services/quickstarts/create-communication-resource"
        }
      }
    };
  }
});

// node_modules/@azure/communication-common/package.json
var require_package4 = __commonJS({
  "node_modules/@azure/communication-common/package.json"(exports2, module2) {
    module2.exports = {
      name: "@azure/communication-common",
      version: "1.1.0",
      description: "Common package for Azure Communication services.",
      "sdk-type": "client",
      main: "dist/index.js",
      module: "dist-esm/src/index.js",
      types: "types/communication-common.d.ts",
      browser: {
        "./dist-esm/src/credential/cryptoUtils.js": "./dist-esm/src/credential/cryptoUtils.browser.js"
      },
      scripts: {
        audit: "node ../../../common/scripts/rush-audit.js && rimraf node_modules package-lock.json && npm i --package-lock-only 2>&1 && npm audit",
        "build:browser": "tsc -p . && cross-env ONLY_BROWSER=true rollup -c 2>&1",
        "build:node": "tsc -p . && cross-env ONLY_NODE=true rollup -c 2>&1",
        "build:samples": "echo Skipped.",
        "build:test": "tsc -p . && rollup -c rollup.test.config.js 2>&1",
        build: "tsc -p . && rollup -c 2>&1 && api-extractor run --local",
        "check-format": 'prettier --list-different --config ../../../.prettierrc.json --ignore-path ../../../.prettierignore "src/**/*.ts" "test/**/*.ts" "*.{js,json}"',
        clean: "rimraf dist dist-* temp types *.tgz *.log",
        "execute:samples": "echo skipped",
        "extract-api": "tsc -p . && api-extractor run --local",
        format: 'prettier --write --config ../../../.prettierrc.json --ignore-path ../../../.prettierignore "src/**/*.ts" "test/**/*.ts" "*.{js,json}"',
        "integration-test:browser": "karma start --single-run",
        "integration-test:node": "nyc mocha -r esm --require source-map-support/register --reporter ../../../common/tools/mocha-multi-reporter.js --full-trace -t 300000  dist-esm/test/*.spec.js dist-esm/test/node/*.spec.js",
        "integration-test": "npm run integration-test:node && npm run integration-test:browser",
        "lint:fix": "eslint package.json api-extractor.json src test --ext .ts --fix --fix-type [problem,suggestion]",
        lint: "eslint package.json api-extractor.json src test --ext .ts",
        pack: "npm pack 2>&1",
        prebuild: "npm run clean",
        "test:browser": "npm run build:test && npm run unit-test:browser && npm run integration-test:browser",
        "test:node": "npm run build:test && npm run unit-test:node && npm run integration-test:node",
        test: "npm run build:test && npm run unit-test && npm run integration-test",
        "unit-test:browser": "karma start --single-run",
        "unit-test:node": "mocha --reporter ../../../common/tools/mocha-multi-reporter.js dist-test/index.node.js",
        "unit-test": "npm run unit-test:node && npm run unit-test:browser",
        docs: "typedoc --excludePrivate --excludeNotExported --excludeExternals --stripInternal --mode file --out ./dist/docs ./src"
      },
      files: [
        "dist/",
        "dist-esm/src",
        "types/communication-common.d.ts",
        "README.md",
        "LICENSE"
      ],
      repository: "github:Azure/azure-sdk-for-js",
      keywords: [
        "azure",
        "cloud",
        "Azure",
        "communication",
        "common"
      ],
      author: "Microsoft Corporation",
      license: "MIT",
      bugs: {
        url: "https://github.com/Azure/azure-sdk-for-js/issues"
      },
      engines: {
        node: ">=12.0.0"
      },
      homepage: "https://github.com/Azure/azure-sdk-for-js/tree/main/sdk/communication/communication-common/",
      sideEffects: false,
      prettier: "@azure/eslint-plugin-azure-sdk/prettier.json",
      dependencies: {
        "@azure/abort-controller": "^1.0.0",
        "@azure/core-auth": "^1.3.0",
        "@azure/core-http": "^2.0.0",
        "@azure/core-tracing": "1.0.0-preview.13",
        events: "^3.0.0",
        "jwt-decode": "~2.2.0",
        tslib: "^2.2.0"
      },
      devDependencies: {
        "@azure/eslint-plugin-azure-sdk": "^3.0.0",
        "@azure/dev-tool": "^1.0.0",
        "@microsoft/api-extractor": "7.7.11",
        "@rollup/plugin-commonjs": "11.0.2",
        "@rollup/plugin-json": "^4.0.0",
        "@rollup/plugin-multi-entry": "^3.0.0",
        "@rollup/plugin-node-resolve": "^8.0.0",
        "@rollup/plugin-replace": "^2.2.0",
        "@types/chai-as-promised": "^7.1.0",
        "@types/chai": "^4.1.6",
        "@types/jwt-decode": "~2.2.1",
        "@types/mocha": "^7.0.2",
        "@types/node": "^12.0.0",
        "@types/sinon": "^9.0.4",
        assert: "^1.4.1",
        "chai-as-promised": "^7.1.1",
        chai: "^4.2.0",
        "cross-env": "^7.0.2",
        eslint: "^7.15.0",
        inherits: "^2.0.3",
        "karma-chrome-launcher": "^3.0.0",
        "karma-coverage": "^2.0.0",
        "karma-edge-launcher": "^0.4.2",
        "karma-env-preprocessor": "^0.1.1",
        "karma-firefox-launcher": "^1.1.0",
        "karma-ie-launcher": "^1.0.0",
        "karma-junit-reporter": "^2.0.1",
        "karma-mocha-reporter": "^2.2.5",
        "karma-mocha": "^2.0.1",
        "karma-sourcemap-loader": "^0.3.8",
        karma: "^6.2.0",
        "mocha-junit-reporter": "^1.18.0",
        mocha: "^7.1.1",
        nyc: "^14.0.0",
        prettier: "^1.16.4",
        rimraf: "^3.0.0",
        "rollup-plugin-sourcemaps": "^0.4.2",
        "rollup-plugin-terser": "^5.1.1",
        "rollup-plugin-visualizer": "^4.0.4",
        rollup: "^1.16.3",
        sinon: "^9.0.2",
        typescript: "~4.2.0",
        util: "^0.12.1",
        typedoc: "0.15.2"
      }
    };
  }
});

// node_modules/@microsoft/omnichannel-amsclient/package.json
var require_package5 = __commonJS({
  "node_modules/@microsoft/omnichannel-amsclient/package.json"(exports2, module2) {
    module2.exports = {
      name: "@microsoft/omnichannel-amsclient",
      version: "0.1.4",
      description: "Microsoft Omnichannel AMSClient",
      files: [
        "lib/**/*"
      ],
      main: "lib/index.js",
      types: "lib/index.d.ts",
      scripts: {
        "build:tsc": "tsc",
        test: "jest",
        lint: "eslint src --ext .ts"
      },
      author: "Microsoft Corporation",
      license: "MIT",
      repository: {
        type: "git",
        url: "https://github.com/microsoft/omnichannel-amsclient"
      },
      homepage: "https://github.com/microsoft/omnichannel-amsclient#readme",
      devDependencies: {
        "@types/jest": "^26.0.24",
        "@typescript-eslint/eslint-plugin": "^4.28.5",
        "@typescript-eslint/parser": "^4.28.5",
        "cross-env": "^7.0.3",
        esbuild: "^0.12.1",
        eslint: "^7.31.0",
        jest: "^27.0.6",
        "ts-jest": "^27.0.4",
        typescript: "^4.2.4"
      }
    };
  }
});

export {
  require_typeof,
  require_defineProperty,
  require_classCallCheck,
  require_createClass,
  esm_browser_exports,
  init_esm_browser,
  require_interopRequireDefault,
  require_regenerator,
  require_asyncToGenerator,
  require_axios2 as require_axios,
  require_crypto,
  require_MessageType,
  require_DeliveryMode,
  require_HostType,
  require_FileSharingProtocolType,
  require_MessageContentType,
  require_PersonType,
  require_ProtocoleType,
  require_lib,
  src_exports2 as src_exports,
  init_src7 as init_src,
  src_exports4 as src_exports2,
  init_src12 as init_src2,
  require_lib2,
  require_package2 as require_package,
  require_package3 as require_package2,
  require_package4 as require_package3,
  require_package5 as require_package4
};
/*! Bundled license information:

@azure/communication-signaling/dist/index.js:
  (*!
  * @overview es6-promise - a tiny implementation of Promises/A+.
  * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
  * @license   Licensed under MIT license
  *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
  * @version   4.0.5
  *)

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)
*/
//# sourceMappingURL=chunk-Z6QG7C7D.js.map
