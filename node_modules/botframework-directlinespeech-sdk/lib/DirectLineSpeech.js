"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _observable = _interopRequireDefault(require("core-js/features/observable"));

var _mathRandom = _interopRequireDefault(require("math-random"));

var _shareObservable = _interopRequireDefault(require("./shareObservable"));

var _SpeechSynthesisAudioStreamUtterance = _interopRequireDefault(require("./SpeechSynthesisAudioStreamUtterance"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function randomActivityId() {
  return (0, _mathRandom.default)().toString(36).substr(2);
}

var DirectLineSpeech = /*#__PURE__*/function () {
  function DirectLineSpeech(_ref) {
    var _this = this;

    var dialogServiceConnector = _ref.dialogServiceConnector;
    (0, _classCallCheck2.default)(this, DirectLineSpeech);
    var connectionStatusObserver;
    this.dialogServiceConnector = dialogServiceConnector;
    this.activity$ = (0, _shareObservable.default)(new _observable.default(function (observer) {
      _this._activityObserver = observer;
      connectionStatusObserver.next(0);
      connectionStatusObserver.next(1);
      dialogServiceConnector.connect(function () {
        connectionStatusObserver.next(2);
      }, function (error) {
        connectionStatusObserver.next(4);
        console.warn('botframework-directlinespeech-sdk: Failed to connect', {
          error: error
        });
      });
    }));
    this.connectionStatus$ = (0, _shareObservable.default)(new _observable.default(function (observer) {
      connectionStatusObserver = observer;
    }));

    dialogServiceConnector.activityReceived = function (_, _ref2) {
      var activity = _ref2.activity,
          audioStream = _ref2.audioStream;

      try {
        _this._activityObserver && _this._activityObserver.next(_objectSpread(_objectSpread({}, activity), {}, {
          channelData: _objectSpread(_objectSpread({}, activity.channelData), {}, {
            speechSynthesisUtterance: new _SpeechSynthesisAudioStreamUtterance.default(audioStream)
          }),
          from: _objectSpread(_objectSpread({}, activity.from), {}, {
            // Since DLSpeech service never ACK our outgoing activity, this activity must be from bot.
            role: 'bot'
          }),
          // Since DLSpeech never ACK our outgoing activity, the "replyToId" will rarely able to point to an existing activity.
          replyToId: undefined,
          // Direct Line Speech server currently do not timestamp outgoing activities.
          // Thus, it will be easier to just re-timestamp every incoming/outgoing activities using local time.
          timestamp: new Date().toISOString()
        }));
      } catch (error) {
        console.error(error);
      }
    };
  }

  (0, _createClass2.default)(DirectLineSpeech, [{
    key: "end",
    value: function end() {
      try {
        this.dialogServiceConnector.close();
      } catch (err) {
        if (!~err.message.indexOf('already disposed')) {
          throw err;
        }
      }
    }
  }, {
    key: "postActivity",
    value: function postActivity(activity) {
      // Currently, Web Chat set user ID on all outgoing activities.
      // As Direct Line Speech maintains its own user ID, Web Chat should not set the user ID.
      // TODO: [P2] We should move user ID into options of DirectLineJS, instead of Web Chat.
      activity = _objectSpread(_objectSpread({}, activity), {}, {
        from: {
          role: 'user'
        }
      });

      try {
        var _activity$channelData;

        // TODO: [P1] Direct Line Speech server currently do not ack the outgoing activities with any activity ID or timestamp.
        var pseudoActivityId = randomActivityId();
        var isSpeech = !!((_activity$channelData = activity.channelData) !== null && _activity$channelData !== void 0 && _activity$channelData.speech); // Do not send the activity if it was from speech.

        if (!isSpeech) {
          // Starting from Speech SDK 1.13.0, they accept JSON text instead of JavaScript object.
          // https://github.com/microsoft/cognitive-services-speech-sdk-js/commit/2f3a35446692b6d492a6c68e3237a48de67e293f
          this.dialogServiceConnector.sendActivityAsync(JSON.stringify(activity));
        }

        this._activityObserver && this._activityObserver.next(_objectSpread(_objectSpread({}, activity), {}, {
          id: pseudoActivityId,
          timestamp: new Date().toISOString()
        }));
        return _observable.default.of(pseudoActivityId);
      } catch (err) {
        return new _observable.default(function (observer) {
          return observer.error(err);
        });
      }
    }
  }]);
  return DirectLineSpeech;
}(); // Interfaces not yet implemented in Web Chat:
// referenceGrammarId?: string,
// getSessionId? : () => Observable<string>


exports.default = DirectLineSpeech;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJyYW5kb21BY3Rpdml0eUlkIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJEaXJlY3RMaW5lU3BlZWNoIiwiZGlhbG9nU2VydmljZUNvbm5lY3RvciIsImNvbm5lY3Rpb25TdGF0dXNPYnNlcnZlciIsImFjdGl2aXR5JCIsInNoYXJlT2JzZXJ2YWJsZSIsIk9ic2VydmFibGUiLCJvYnNlcnZlciIsIl9hY3Rpdml0eU9ic2VydmVyIiwibmV4dCIsImNvbm5lY3QiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiY29ubmVjdGlvblN0YXR1cyQiLCJhY3Rpdml0eVJlY2VpdmVkIiwiXyIsImFjdGl2aXR5IiwiYXVkaW9TdHJlYW0iLCJjaGFubmVsRGF0YSIsInNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSIsIlNwZWVjaFN5bnRoZXNpc0F1ZGlvU3RyZWFtVXR0ZXJhbmNlIiwiZnJvbSIsInJvbGUiLCJyZXBseVRvSWQiLCJ1bmRlZmluZWQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjbG9zZSIsImVyciIsIm1lc3NhZ2UiLCJpbmRleE9mIiwicHNldWRvQWN0aXZpdHlJZCIsImlzU3BlZWNoIiwic3BlZWNoIiwic2VuZEFjdGl2aXR5QXN5bmMiLCJKU09OIiwic3RyaW5naWZ5IiwiaWQiLCJvZiJdLCJzb3VyY2VSb290IjoiZGlyZWN0bGluZXNwZWVjaDovLy8iLCJzb3VyY2VzIjpbIi4uL3NyYy9EaXJlY3RMaW5lU3BlZWNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby1tYWdpYy1udW1iZXJzOiBbXCJlcnJvclwiLCB7IFwiaWdub3JlXCI6IFswLCAxLCAyLCA0LCAzNl0gfV0gKi9cblxuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnY29yZS1qcy9mZWF0dXJlcy9vYnNlcnZhYmxlJztcbmltcG9ydCByYW5kb20gZnJvbSAnbWF0aC1yYW5kb20nO1xuXG5pbXBvcnQgc2hhcmVPYnNlcnZhYmxlIGZyb20gJy4vc2hhcmVPYnNlcnZhYmxlJztcbmltcG9ydCBTcGVlY2hTeW50aGVzaXNBdWRpb1N0cmVhbVV0dGVyYW5jZSBmcm9tICcuL1NwZWVjaFN5bnRoZXNpc0F1ZGlvU3RyZWFtVXR0ZXJhbmNlJztcblxuZnVuY3Rpb24gcmFuZG9tQWN0aXZpdHlJZCgpIHtcbiAgcmV0dXJuIHJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpcmVjdExpbmVTcGVlY2gge1xuICBjb25zdHJ1Y3Rvcih7IGRpYWxvZ1NlcnZpY2VDb25uZWN0b3IgfSkge1xuICAgIGxldCBjb25uZWN0aW9uU3RhdHVzT2JzZXJ2ZXI7XG5cbiAgICB0aGlzLmRpYWxvZ1NlcnZpY2VDb25uZWN0b3IgPSBkaWFsb2dTZXJ2aWNlQ29ubmVjdG9yO1xuXG4gICAgdGhpcy5hY3Rpdml0eSQgPSBzaGFyZU9ic2VydmFibGUoXG4gICAgICBuZXcgT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XG4gICAgICAgIHRoaXMuX2FjdGl2aXR5T2JzZXJ2ZXIgPSBvYnNlcnZlcjtcblxuICAgICAgICBjb25uZWN0aW9uU3RhdHVzT2JzZXJ2ZXIubmV4dCgwKTtcbiAgICAgICAgY29ubmVjdGlvblN0YXR1c09ic2VydmVyLm5leHQoMSk7XG5cbiAgICAgICAgZGlhbG9nU2VydmljZUNvbm5lY3Rvci5jb25uZWN0KFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25TdGF0dXNPYnNlcnZlci5uZXh0KDIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29ubmVjdGlvblN0YXR1c09ic2VydmVyLm5leHQoNCk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYm90ZnJhbWV3b3JrLWRpcmVjdGxpbmVzcGVlY2gtc2RrOiBGYWlsZWQgdG8gY29ubmVjdCcsIHsgZXJyb3IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5jb25uZWN0aW9uU3RhdHVzJCA9IHNoYXJlT2JzZXJ2YWJsZShcbiAgICAgIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICAgICAgY29ubmVjdGlvblN0YXR1c09ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICBkaWFsb2dTZXJ2aWNlQ29ubmVjdG9yLmFjdGl2aXR5UmVjZWl2ZWQgPSAoXywgeyBhY3Rpdml0eSwgYXVkaW9TdHJlYW0gfSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlPYnNlcnZlciAmJlxuICAgICAgICAgIHRoaXMuX2FjdGl2aXR5T2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICAuLi5hY3Rpdml0eSxcbiAgICAgICAgICAgIGNoYW5uZWxEYXRhOiB7XG4gICAgICAgICAgICAgIC4uLmFjdGl2aXR5LmNoYW5uZWxEYXRhLFxuICAgICAgICAgICAgICBzcGVlY2hTeW50aGVzaXNVdHRlcmFuY2U6IG5ldyBTcGVlY2hTeW50aGVzaXNBdWRpb1N0cmVhbVV0dGVyYW5jZShhdWRpb1N0cmVhbSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIC4uLmFjdGl2aXR5LmZyb20sXG4gICAgICAgICAgICAgIC8vIFNpbmNlIERMU3BlZWNoIHNlcnZpY2UgbmV2ZXIgQUNLIG91ciBvdXRnb2luZyBhY3Rpdml0eSwgdGhpcyBhY3Rpdml0eSBtdXN0IGJlIGZyb20gYm90LlxuICAgICAgICAgICAgICByb2xlOiAnYm90J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFNpbmNlIERMU3BlZWNoIG5ldmVyIEFDSyBvdXIgb3V0Z29pbmcgYWN0aXZpdHksIHRoZSBcInJlcGx5VG9JZFwiIHdpbGwgcmFyZWx5IGFibGUgdG8gcG9pbnQgdG8gYW4gZXhpc3RpbmcgYWN0aXZpdHkuXG4gICAgICAgICAgICByZXBseVRvSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIERpcmVjdCBMaW5lIFNwZWVjaCBzZXJ2ZXIgY3VycmVudGx5IGRvIG5vdCB0aW1lc3RhbXAgb3V0Z29pbmcgYWN0aXZpdGllcy5cbiAgICAgICAgICAgIC8vIFRodXMsIGl0IHdpbGwgYmUgZWFzaWVyIHRvIGp1c3QgcmUtdGltZXN0YW1wIGV2ZXJ5IGluY29taW5nL291dGdvaW5nIGFjdGl2aXRpZXMgdXNpbmcgbG9jYWwgdGltZS5cbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZW5kKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmRpYWxvZ1NlcnZpY2VDb25uZWN0b3IuY2xvc2UoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghfmVyci5tZXNzYWdlLmluZGV4T2YoJ2FscmVhZHkgZGlzcG9zZWQnKSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcG9zdEFjdGl2aXR5KGFjdGl2aXR5KSB7XG4gICAgLy8gQ3VycmVudGx5LCBXZWIgQ2hhdCBzZXQgdXNlciBJRCBvbiBhbGwgb3V0Z29pbmcgYWN0aXZpdGllcy5cbiAgICAvLyBBcyBEaXJlY3QgTGluZSBTcGVlY2ggbWFpbnRhaW5zIGl0cyBvd24gdXNlciBJRCwgV2ViIENoYXQgc2hvdWxkIG5vdCBzZXQgdGhlIHVzZXIgSUQuXG4gICAgLy8gVE9ETzogW1AyXSBXZSBzaG91bGQgbW92ZSB1c2VyIElEIGludG8gb3B0aW9ucyBvZiBEaXJlY3RMaW5lSlMsIGluc3RlYWQgb2YgV2ViIENoYXQuXG4gICAgYWN0aXZpdHkgPSB7XG4gICAgICAuLi5hY3Rpdml0eSxcbiAgICAgIGZyb206IHsgcm9sZTogJ3VzZXInIH1cbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRPRE86IFtQMV0gRGlyZWN0IExpbmUgU3BlZWNoIHNlcnZlciBjdXJyZW50bHkgZG8gbm90IGFjayB0aGUgb3V0Z29pbmcgYWN0aXZpdGllcyB3aXRoIGFueSBhY3Rpdml0eSBJRCBvciB0aW1lc3RhbXAuXG4gICAgICBjb25zdCBwc2V1ZG9BY3Rpdml0eUlkID0gcmFuZG9tQWN0aXZpdHlJZCgpO1xuICAgICAgY29uc3QgaXNTcGVlY2ggPSAhIWFjdGl2aXR5LmNoYW5uZWxEYXRhPy5zcGVlY2g7XG5cbiAgICAgIC8vIERvIG5vdCBzZW5kIHRoZSBhY3Rpdml0eSBpZiBpdCB3YXMgZnJvbSBzcGVlY2guXG4gICAgICBpZiAoIWlzU3BlZWNoKSB7XG4gICAgICAgIC8vIFN0YXJ0aW5nIGZyb20gU3BlZWNoIFNESyAxLjEzLjAsIHRoZXkgYWNjZXB0IEpTT04gdGV4dCBpbnN0ZWFkIG9mIEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L2NvZ25pdGl2ZS1zZXJ2aWNlcy1zcGVlY2gtc2RrLWpzL2NvbW1pdC8yZjNhMzU0NDY2OTJiNmQ0OTJhNmM2OGUzMjM3YTQ4ZGU2N2UyOTNmXG4gICAgICAgIHRoaXMuZGlhbG9nU2VydmljZUNvbm5lY3Rvci5zZW5kQWN0aXZpdHlBc3luYyhKU09OLnN0cmluZ2lmeShhY3Rpdml0eSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hY3Rpdml0eU9ic2VydmVyICYmXG4gICAgICAgIHRoaXMuX2FjdGl2aXR5T2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgLi4uYWN0aXZpdHksXG4gICAgICAgICAgaWQ6IHBzZXVkb0FjdGl2aXR5SWQsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBPYnNlcnZhYmxlLm9mKHBzZXVkb0FjdGl2aXR5SWQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IG9ic2VydmVyLmVycm9yKGVycikpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBJbnRlcmZhY2VzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gV2ViIENoYXQ6XG4vLyByZWZlcmVuY2VHcmFtbWFySWQ/OiBzdHJpbmcsXG4vLyBnZXRTZXNzaW9uSWQ/IDogKCkgPT4gT2JzZXJ2YWJsZTxzdHJpbmc+XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztBQUNBOztBQUVBOztBQUNBOzs7Ozs7QUFFQSxTQUFTQSxnQkFBVCxHQUE0QjtFQUMxQixPQUFPLElBQUFDLG1CQUFBLElBQVNDLFFBQVQsQ0FBa0IsRUFBbEIsRUFBc0JDLE1BQXRCLENBQTZCLENBQTdCLENBQVA7QUFDRDs7SUFFb0JDLGdCO0VBQ25CLGdDQUF3QztJQUFBOztJQUFBLElBQTFCQyxzQkFBMEIsUUFBMUJBLHNCQUEwQjtJQUFBO0lBQ3RDLElBQUlDLHdCQUFKO0lBRUEsS0FBS0Qsc0JBQUwsR0FBOEJBLHNCQUE5QjtJQUVBLEtBQUtFLFNBQUwsR0FBaUIsSUFBQUMsd0JBQUEsRUFDZixJQUFJQyxtQkFBSixDQUFlLFVBQUFDLFFBQVEsRUFBSTtNQUN6QixLQUFJLENBQUNDLGlCQUFMLEdBQXlCRCxRQUF6QjtNQUVBSix3QkFBd0IsQ0FBQ00sSUFBekIsQ0FBOEIsQ0FBOUI7TUFDQU4sd0JBQXdCLENBQUNNLElBQXpCLENBQThCLENBQTlCO01BRUFQLHNCQUFzQixDQUFDUSxPQUF2QixDQUNFLFlBQU07UUFDSlAsd0JBQXdCLENBQUNNLElBQXpCLENBQThCLENBQTlCO01BQ0QsQ0FISCxFQUlFLFVBQUFFLEtBQUssRUFBSTtRQUNQUix3QkFBd0IsQ0FBQ00sSUFBekIsQ0FBOEIsQ0FBOUI7UUFFQUcsT0FBTyxDQUFDQyxJQUFSLENBQWEsc0RBQWIsRUFBcUU7VUFBRUYsS0FBSyxFQUFMQTtRQUFGLENBQXJFO01BQ0QsQ0FSSDtJQVVELENBaEJELENB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