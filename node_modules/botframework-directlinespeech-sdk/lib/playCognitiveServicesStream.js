"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = playCognitiveServicesStream;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _createMultiBufferingPlayer = _interopRequireDefault(require("./createMultiBufferingPlayer"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

// Safari requires an audio buffer with a sample rate of 22050 Hz.
// Using a minimum sample rate of 44100 Hz as an example, the Speech SDK's default 16000 Hz will be upsampled to 48000 Hz.
var MIN_SAMPLE_RATE = 44100; // The Speech SDK is hardcoded to chop packets to 4096 bytes.
// Web Chat's multi-buffering player is set up with 3 buffers; each is 4096 bytes (2048 16-bit samples).
// For simplicity, the multi-buffer player currently does not support progressive buffering.
// Progressive buffering allows queuing at any sample size and will be concatenated.
// If 1000 samples are queued, then 1048 samples are queued, they will be concatenated into a single buffer of size 2048.
// For simplicity, data will be queued to two buffers.
// The first buffer is 1000 samples followed by 1048 zeroes, and the second buffer is 1048 samples followed by 1000 zeroes.
// There is no plan to support progressive buffering until the Speech SDK chops data at dynamic size.

var DEFAULT_BUFFER_SIZE = 4096;

function average(array) {
  return array.reduce(function (sum, value) {
    return sum + value;
  }, 0) / array.length;
}

function formatTypedBitArrayToFloatArray(audioData, maxValue) {
  var float32Data = new Float32Array(audioData.length);

  for (var i = 0; i < audioData.length; i++) {
    float32Data[+i] = audioData[+i] / maxValue;
  }

  return float32Data;
}

function formatAudioDataArrayBufferToFloatArray(_ref, arrayBuffer) {
  var bitsPerSample = _ref.bitsPerSample;

  switch (bitsPerSample) {
    case 8:
      return formatTypedBitArrayToFloatArray(new Int8Array(arrayBuffer), 128);

    case 16:
      return formatTypedBitArrayToFloatArray(new Int16Array(arrayBuffer), 32768);

    case 32:
      return formatTypedBitArrayToFloatArray(new Int32Array(arrayBuffer), 2147483648);

    default:
      throw new Error('Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time');
  }
}

function abortToReject(signal) {
  return new Promise(function (_, reject) {
    signal.onabort = function () {
      return reject(new Error('aborted'));
    };
  });
} // In a 2 channel audio (e.g. A/B), the data arrives as interleaved, like "ABABABABAB".
// This function will take "ABABABABAB" and return an array ["AAAAA", "BBBBB"].


function deinterleave(channelInterleavedAudioData, _ref2) {
  var channels = _ref2.channels;
  var multiChannelArrayBuffer = new Array(channels);
  var frameSize = channelInterleavedAudioData.length / channels;

  for (var channel = 0; channel < channels; channel++) {
    var audioData = new Float32Array(frameSize);
    multiChannelArrayBuffer[+channel] = audioData;

    for (var offset = 0; offset < frameSize; offset++) {
      audioData[+offset] = channelInterleavedAudioData[offset * channels + channel];
    }
  }

  return multiChannelArrayBuffer;
} // This function upsamples the audio data via an integer multiplier.
// Web Chat uses simple anti-aliasing. For simplicity, the anti-aliasing does not roll over to next buffer.


function multiplySampleRate(source, sampleRateMultiplier) {
  if (sampleRateMultiplier === 1) {
    return source;
  }

  var lastValues = new Array(sampleRateMultiplier).fill(source[0]);
  var target = new Float32Array(source.length * sampleRateMultiplier);

  for (var sourceOffset = 0; sourceOffset < source.length; sourceOffset++) {
    var value = source[+sourceOffset];
    var targetOffset = sourceOffset * sampleRateMultiplier;

    for (var multiplierIndex = 0; multiplierIndex < sampleRateMultiplier; multiplierIndex++) {
      lastValues.shift();
      lastValues.push(value);
      target[targetOffset + multiplierIndex] = average(lastValues);
    }
  }

  return target;
}

function playCognitiveServicesStream(_x, _x2) {
  return _playCognitiveServicesStream.apply(this, arguments);
}

function _playCognitiveServicesStream() {
  _playCognitiveServicesStream = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(audioContext, stream) {
    var _ref3,
        _ref3$signal,
        signal,
        queuedBufferSourceNodes,
        _args2 = arguments;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref3 = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {}, _ref3$signal = _ref3.signal, signal = _ref3$signal === void 0 ? {} : _ref3$signal;

            if (audioContext) {
              _context2.next = 5;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: audioContext must be specified.');

          case 5:
            if (stream) {
              _context2.next = 9;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream must be specified.');

          case 9:
            if (stream.format) {
              _context2.next = 13;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream is missing format.');

          case 13:
            if (!(typeof stream.read !== 'function')) {
              _context2.next = 15;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream is missing read().');

          case 15:
            queuedBufferSourceNodes = [];
            _context2.prev = 16;
            return _context2.delegateYield( /*#__PURE__*/_regenerator.default.mark(function _callee() {
              var format, abortPromise, array, read, samplesPerSec, newSamplesPerSec, sampleRateMultiplier, player, chunk, maxChunks, interleavedArray, multiChannelArray, upsampledMultiChannelArray;
              return _regenerator.default.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      format = stream.format;
                      abortPromise = abortToReject(signal);
                      array = new Uint8Array(DEFAULT_BUFFER_SIZE);

                      read = function read() {
                        return Promise.race([abortPromise.catch(function () {// Abort will gracefully end the queue. We will check signal.aborted later to throw abort exception.
                        }), stream.read(array.buffer).then(function (numBytes) {
                          return numBytes === array.byteLength ? array : numBytes ? array.slice(0, numBytes) : undefined;
                        })]);
                      };

                      if (!signal.aborted) {
                        _context.next = 6;
                        break;
                      }

                      throw new Error('aborted');

                    case 6:
                      samplesPerSec = format.samplesPerSec; // TODO: [P0] #3692 Remove the following if-condition block when the underlying bugs are resolved.
                      //       There is a bug in Speech SDK 1.15.0 that returns 24kHz instead of 16kHz.
                      //       Even if we explicitly specify the output audio format to 16kHz, there is another bug that ignored it.
                      //       In short, DLSpeech service currently always streams in RIFF WAV format, instead of MP3.
                      //       https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/313
                      //       https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/314

                      if (format.requestAudioFormatString === 'audio-24khz-48kbitrate-mono-mp3') {
                        samplesPerSec = 16000;
                      }

                      newSamplesPerSec = samplesPerSec;
                      sampleRateMultiplier = 1; // Safari requires a minimum sample rate of 22100 Hz.
                      // A multiplier is calculated the the data meets the minimum sample rate.
                      // An integer-based multiplier to simplify our upsampler.
                      // For security, data will only be upsampled up to 96000 Hz.

                      while (newSamplesPerSec < MIN_SAMPLE_RATE && newSamplesPerSec < 96000) {
                        sampleRateMultiplier++;
                        newSamplesPerSec = samplesPerSec * sampleRateMultiplier;
                      } // The third parameter is the sample size in bytes.
                      // For example, if the Speech SDK sends Web Chat 4096 bytes of 16-bit samples, there will be 2048 samples per channel.
                      // The multi-buffering player is set up to handle 2048 samples per buffer.
                      // If the multiplier 3x, it will handle 6144 samples per buffer.


                      player = (0, _createMultiBufferingPlayer.default)(audioContext, _objectSpread(_objectSpread({}, format), {}, {
                        samplesPerSec: newSamplesPerSec
                      }), DEFAULT_BUFFER_SIZE / (format.bitsPerSample / 8) * sampleRateMultiplier); // For security, the maximum number of chunks handled will be 1000.

                      _context.next = 14;
                      return read();

                    case 14:
                      chunk = _context.sent;
                      maxChunks = 0;

                    case 16:
                      if (!(chunk && maxChunks < 1000 && !signal.aborted)) {
                        _context.next = 29;
                        break;
                      }

                      if (!signal.aborted) {
                        _context.next = 19;
                        break;
                      }

                      return _context.abrupt("break", 29);

                    case 19:
                      // Data received from Speech SDK is interleaved; 2 channels (e.g. A and B) will be sent as "ABABABABAB"
                      // And each sample (A/B) will be an 8 to 32-bit number.
                      // Convert the 8 - 32-bit number into a floating-point number, as required by Web Audio API.
                      interleavedArray = formatAudioDataArrayBufferToFloatArray(format, chunk.buffer); // Deinterleave data back into two array buffer, e.g. "AAAAA" and "BBBBB".

                      multiChannelArray = deinterleave(interleavedArray, format); // Upsample data if necessary. If the multiplier is 2x, "AAAAA" will be upsampled to "AAAAAAAAAA" (with anti-alias).

                      upsampledMultiChannelArray = multiChannelArray.map(function (array) {
                        return multiplySampleRate(array, sampleRateMultiplier);
                      }); // Queue to the buffering player.

                      player.push(upsampledMultiChannelArray);

                    case 23:
                      _context.next = 25;
                      return read();

                    case 25:
                      chunk = _context.sent;
                      maxChunks++;
                      _context.next = 16;
                      break;

                    case 29:
                      abortPromise.catch(function () {
                        return player.cancelAll();
                      });

                      if (!signal.aborted) {
                        _context.next = 32;
                        break;
                      }

                      throw new Error('aborted');

                    case 32:
                      _context.next = 34;
                      return Promise.race([abortPromise, player.flush()]);

                    case 34:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            })(), "t0", 18);

          case 18:
            _context2.prev = 18;
            queuedBufferSourceNodes.forEach(function (node) {
              return node.stop();
            });
            return _context2.finish(18);

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[16,, 18, 21]]);
  }));
  return _playCognitiveServicesStream.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJNSU5fU0FNUExFX1JBVEUiLCJERUZBVUxUX0JVRkZFUl9TSVpFIiwiYXZlcmFnZSIsImFycmF5IiwicmVkdWNlIiwic3VtIiwidmFsdWUiLCJsZW5ndGgiLCJmb3JtYXRUeXBlZEJpdEFycmF5VG9GbG9hdEFycmF5IiwiYXVkaW9EYXRhIiwibWF4VmFsdWUiLCJmbG9hdDMyRGF0YSIsIkZsb2F0MzJBcnJheSIsImkiLCJmb3JtYXRBdWRpb0RhdGFBcnJheUJ1ZmZlclRvRmxvYXRBcnJheSIsImFycmF5QnVmZmVyIiwiYml0c1BlclNhbXBsZSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiRXJyb3IiLCJhYm9ydFRvUmVqZWN0Iiwic2lnbmFsIiwiUHJvbWlzZSIsIl8iLCJyZWplY3QiLCJvbmFib3J0IiwiZGVpbnRlcmxlYXZlIiwiY2hhbm5lbEludGVybGVhdmVkQXVkaW9EYXRhIiwiY2hhbm5lbHMiLCJtdWx0aUNoYW5uZWxBcnJheUJ1ZmZlciIsIkFycmF5IiwiZnJhbWVTaXplIiwiY2hhbm5lbCIsIm9mZnNldCIsIm11bHRpcGx5U2FtcGxlUmF0ZSIsInNvdXJjZSIsInNhbXBsZVJhdGVNdWx0aXBsaWVyIiwibGFzdFZhbHVlcyIsImZpbGwiLCJ0YXJnZXQiLCJzb3VyY2VPZmZzZXQiLCJ0YXJnZXRPZmZzZXQiLCJtdWx0aXBsaWVySW5kZXgiLCJzaGlmdCIsInB1c2giLCJwbGF5Q29nbml0aXZlU2VydmljZXNTdHJlYW0iLCJhdWRpb0NvbnRleHQiLCJzdHJlYW0iLCJmb3JtYXQiLCJyZWFkIiwicXVldWVkQnVmZmVyU291cmNlTm9kZXMiLCJhYm9ydFByb21pc2UiLCJVaW50OEFycmF5IiwicmFjZSIsImNhdGNoIiwiYnVmZmVyIiwidGhlbiIsIm51bUJ5dGVzIiwiYnl0ZUxlbmd0aCIsInNsaWNlIiwidW5kZWZpbmVkIiwiYWJvcnRlZCIsInNhbXBsZXNQZXJTZWMiLCJyZXF1ZXN0QXVkaW9Gb3JtYXRTdHJpbmciLCJuZXdTYW1wbGVzUGVyU2VjIiwicGxheWVyIiwiY3JlYXRlTXVsdGlCdWZmZXJpbmdQbGF5ZXIiLCJjaHVuayIsIm1heENodW5rcyIsImludGVybGVhdmVkQXJyYXkiLCJtdWx0aUNoYW5uZWxBcnJheSIsInVwc2FtcGxlZE11bHRpQ2hhbm5lbEFycmF5IiwibWFwIiwiY2FuY2VsQWxsIiwiZmx1c2giLCJmb3JFYWNoIiwibm9kZSIsInN0b3AiXSwic291cmNlUm9vdCI6ImRpcmVjdGxpbmVzcGVlY2g6Ly8vIiwic291cmNlcyI6WyIuLi9zcmMvcGxheUNvZ25pdGl2ZVNlcnZpY2VzU3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby1tYWdpYy1udW1iZXJzOiBbXCJlcnJvclwiLCB7IFwiaWdub3JlXCI6IFswLCAxLCA4LCAxNiwgMzIsIDEyOCwgMTAwMCwgMTYwMDAsIDMyNzY4LCA5NjAwMCwgMjE0NzQ4MzY0OF0gfV0gKi9cbi8qIGVzbGludCBuby1hd2FpdC1pbi1sb29wOiBcIm9mZlwiICovXG4vKiBlc2xpbnQgcHJlZmVyLWRlc3RydWN0dXJpbmc6IFwib2ZmXCIgKi9cblxuaW1wb3J0IGNyZWF0ZU11bHRpQnVmZmVyaW5nUGxheWVyIGZyb20gJy4vY3JlYXRlTXVsdGlCdWZmZXJpbmdQbGF5ZXInO1xuXG4vLyBTYWZhcmkgcmVxdWlyZXMgYW4gYXVkaW8gYnVmZmVyIHdpdGggYSBzYW1wbGUgcmF0ZSBvZiAyMjA1MCBIei5cbi8vIFVzaW5nIGEgbWluaW11bSBzYW1wbGUgcmF0ZSBvZiA0NDEwMCBIeiBhcyBhbiBleGFtcGxlLCB0aGUgU3BlZWNoIFNESydzIGRlZmF1bHQgMTYwMDAgSHogd2lsbCBiZSB1cHNhbXBsZWQgdG8gNDgwMDAgSHouXG5jb25zdCBNSU5fU0FNUExFX1JBVEUgPSA0NDEwMDtcblxuLy8gVGhlIFNwZWVjaCBTREsgaXMgaGFyZGNvZGVkIHRvIGNob3AgcGFja2V0cyB0byA0MDk2IGJ5dGVzLlxuLy8gV2ViIENoYXQncyBtdWx0aS1idWZmZXJpbmcgcGxheWVyIGlzIHNldCB1cCB3aXRoIDMgYnVmZmVyczsgZWFjaCBpcyA0MDk2IGJ5dGVzICgyMDQ4IDE2LWJpdCBzYW1wbGVzKS5cbi8vIEZvciBzaW1wbGljaXR5LCB0aGUgbXVsdGktYnVmZmVyIHBsYXllciBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBwcm9ncmVzc2l2ZSBidWZmZXJpbmcuXG5cbi8vIFByb2dyZXNzaXZlIGJ1ZmZlcmluZyBhbGxvd3MgcXVldWluZyBhdCBhbnkgc2FtcGxlIHNpemUgYW5kIHdpbGwgYmUgY29uY2F0ZW5hdGVkLlxuLy8gSWYgMTAwMCBzYW1wbGVzIGFyZSBxdWV1ZWQsIHRoZW4gMTA0OCBzYW1wbGVzIGFyZSBxdWV1ZWQsIHRoZXkgd2lsbCBiZSBjb25jYXRlbmF0ZWQgaW50byBhIHNpbmdsZSBidWZmZXIgb2Ygc2l6ZSAyMDQ4LlxuXG4vLyBGb3Igc2ltcGxpY2l0eSwgZGF0YSB3aWxsIGJlIHF1ZXVlZCB0byB0d28gYnVmZmVycy5cbi8vIFRoZSBmaXJzdCBidWZmZXIgaXMgMTAwMCBzYW1wbGVzIGZvbGxvd2VkIGJ5IDEwNDggemVyb2VzLCBhbmQgdGhlIHNlY29uZCBidWZmZXIgaXMgMTA0OCBzYW1wbGVzIGZvbGxvd2VkIGJ5IDEwMDAgemVyb2VzLlxuXG4vLyBUaGVyZSBpcyBubyBwbGFuIHRvIHN1cHBvcnQgcHJvZ3Jlc3NpdmUgYnVmZmVyaW5nIHVudGlsIHRoZSBTcGVlY2ggU0RLIGNob3BzIGRhdGEgYXQgZHluYW1pYyBzaXplLlxuY29uc3QgREVGQVVMVF9CVUZGRVJfU0laRSA9IDQwOTY7XG5cbmZ1bmN0aW9uIGF2ZXJhZ2UoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LnJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUsIDApIC8gYXJyYXkubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUeXBlZEJpdEFycmF5VG9GbG9hdEFycmF5KGF1ZGlvRGF0YSwgbWF4VmFsdWUpIHtcbiAgY29uc3QgZmxvYXQzMkRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGF1ZGlvRGF0YS5sZW5ndGgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9EYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgZmxvYXQzMkRhdGFbK2ldID0gYXVkaW9EYXRhWytpXSAvIG1heFZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGZsb2F0MzJEYXRhO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBdWRpb0RhdGFBcnJheUJ1ZmZlclRvRmxvYXRBcnJheSh7IGJpdHNQZXJTYW1wbGUgfSwgYXJyYXlCdWZmZXIpIHtcbiAgc3dpdGNoIChiaXRzUGVyU2FtcGxlKSB7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkobmV3IEludDhBcnJheShhcnJheUJ1ZmZlciksIDEyOCk7XG5cbiAgICBjYXNlIDE2OlxuICAgICAgcmV0dXJuIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkobmV3IEludDE2QXJyYXkoYXJyYXlCdWZmZXIpLCAzMjc2OCk7XG5cbiAgICBjYXNlIDMyOlxuICAgICAgcmV0dXJuIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkobmV3IEludDMyQXJyYXkoYXJyYXlCdWZmZXIpLCAyMTQ3NDgzNjQ4KTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgV0FWRV9GT1JNQVRfUENNICg4LzE2LzMyIGJwcykgZm9ybWF0IHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFRvUmVqZWN0KHNpZ25hbCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgIHNpZ25hbC5vbmFib3J0ID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignYWJvcnRlZCcpKTtcbiAgfSk7XG59XG5cbi8vIEluIGEgMiBjaGFubmVsIGF1ZGlvIChlLmcuIEEvQiksIHRoZSBkYXRhIGFycml2ZXMgYXMgaW50ZXJsZWF2ZWQsIGxpa2UgXCJBQkFCQUJBQkFCXCIuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgdGFrZSBcIkFCQUJBQkFCQUJcIiBhbmQgcmV0dXJuIGFuIGFycmF5IFtcIkFBQUFBXCIsIFwiQkJCQkJcIl0uXG5mdW5jdGlvbiBkZWludGVybGVhdmUoY2hhbm5lbEludGVybGVhdmVkQXVkaW9EYXRhLCB7IGNoYW5uZWxzIH0pIHtcbiAgY29uc3QgbXVsdGlDaGFubmVsQXJyYXlCdWZmZXIgPSBuZXcgQXJyYXkoY2hhbm5lbHMpO1xuICBjb25zdCBmcmFtZVNpemUgPSBjaGFubmVsSW50ZXJsZWF2ZWRBdWRpb0RhdGEubGVuZ3RoIC8gY2hhbm5lbHM7XG5cbiAgZm9yIChsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBjaGFubmVsczsgY2hhbm5lbCsrKSB7XG4gICAgY29uc3QgYXVkaW9EYXRhID0gbmV3IEZsb2F0MzJBcnJheShmcmFtZVNpemUpO1xuXG4gICAgbXVsdGlDaGFubmVsQXJyYXlCdWZmZXJbK2NoYW5uZWxdID0gYXVkaW9EYXRhO1xuXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgZnJhbWVTaXplOyBvZmZzZXQrKykge1xuICAgICAgYXVkaW9EYXRhWytvZmZzZXRdID0gY2hhbm5lbEludGVybGVhdmVkQXVkaW9EYXRhW29mZnNldCAqIGNoYW5uZWxzICsgY2hhbm5lbF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG11bHRpQ2hhbm5lbEFycmF5QnVmZmVyO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHVwc2FtcGxlcyB0aGUgYXVkaW8gZGF0YSB2aWEgYW4gaW50ZWdlciBtdWx0aXBsaWVyLlxuLy8gV2ViIENoYXQgdXNlcyBzaW1wbGUgYW50aS1hbGlhc2luZy4gRm9yIHNpbXBsaWNpdHksIHRoZSBhbnRpLWFsaWFzaW5nIGRvZXMgbm90IHJvbGwgb3ZlciB0byBuZXh0IGJ1ZmZlci5cbmZ1bmN0aW9uIG11bHRpcGx5U2FtcGxlUmF0ZShzb3VyY2UsIHNhbXBsZVJhdGVNdWx0aXBsaWVyKSB7XG4gIGlmIChzYW1wbGVSYXRlTXVsdGlwbGllciA9PT0gMSkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBjb25zdCBsYXN0VmFsdWVzID0gbmV3IEFycmF5KHNhbXBsZVJhdGVNdWx0aXBsaWVyKS5maWxsKHNvdXJjZVswXSk7XG4gIGNvbnN0IHRhcmdldCA9IG5ldyBGbG9hdDMyQXJyYXkoc291cmNlLmxlbmd0aCAqIHNhbXBsZVJhdGVNdWx0aXBsaWVyKTtcblxuICBmb3IgKGxldCBzb3VyY2VPZmZzZXQgPSAwOyBzb3VyY2VPZmZzZXQgPCBzb3VyY2UubGVuZ3RoOyBzb3VyY2VPZmZzZXQrKykge1xuICAgIGNvbnN0IHZhbHVlID0gc291cmNlWytzb3VyY2VPZmZzZXRdO1xuICAgIGNvbnN0IHRhcmdldE9mZnNldCA9IHNvdXJjZU9mZnNldCAqIHNhbXBsZVJhdGVNdWx0aXBsaWVyO1xuXG4gICAgZm9yIChsZXQgbXVsdGlwbGllckluZGV4ID0gMDsgbXVsdGlwbGllckluZGV4IDwgc2FtcGxlUmF0ZU11bHRpcGxpZXI7IG11bHRpcGxpZXJJbmRleCsrKSB7XG4gICAgICBsYXN0VmFsdWVzLnNoaWZ0KCk7XG4gICAgICBsYXN0VmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgdGFyZ2V0W3RhcmdldE9mZnNldCArIG11bHRpcGxpZXJJbmRleF0gPSBhdmVyYWdlKGxhc3RWYWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBsYXlDb2duaXRpdmVTZXJ2aWNlc1N0cmVhbShhdWRpb0NvbnRleHQsIHN0cmVhbSwgeyBzaWduYWwgPSB7fSB9ID0ge30pIHtcbiAgaWYgKCFhdWRpb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGZyYW1ld29yay1kaXJlY3RsaW5lc3BlZWNoLXNkazogYXVkaW9Db250ZXh0IG11c3QgYmUgc3BlY2lmaWVkLicpO1xuICB9IGVsc2UgaWYgKCFzdHJlYW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGZyYW1ld29yay1kaXJlY3RsaW5lc3BlZWNoLXNkazogc3RyZWFtIG11c3QgYmUgc3BlY2lmaWVkLicpO1xuICB9IGVsc2UgaWYgKCFzdHJlYW0uZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib3RmcmFtZXdvcmstZGlyZWN0bGluZXNwZWVjaC1zZGs6IHN0cmVhbSBpcyBtaXNzaW5nIGZvcm1hdC4nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyZWFtLnJlYWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGZyYW1ld29yay1kaXJlY3RsaW5lc3BlZWNoLXNkazogc3RyZWFtIGlzIG1pc3NpbmcgcmVhZCgpLicpO1xuICB9XG5cbiAgY29uc3QgcXVldWVkQnVmZmVyU291cmNlTm9kZXMgPSBbXTtcblxuICB0cnkge1xuICAgIGNvbnN0IHsgZm9ybWF0IH0gPSBzdHJlYW07XG4gICAgY29uc3QgYWJvcnRQcm9taXNlID0gYWJvcnRUb1JlamVjdChzaWduYWwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoREVGQVVMVF9CVUZGRVJfU0laRSk7XG5cbiAgICBjb25zdCByZWFkID0gKCkgPT5cbiAgICAgIFByb21pc2UucmFjZShbXG4gICAgICAgIGFib3J0UHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLy8gQWJvcnQgd2lsbCBncmFjZWZ1bGx5IGVuZCB0aGUgcXVldWUuIFdlIHdpbGwgY2hlY2sgc2lnbmFsLmFib3J0ZWQgbGF0ZXIgdG8gdGhyb3cgYWJvcnQgZXhjZXB0aW9uLlxuICAgICAgICB9KSxcbiAgICAgICAgc3RyZWFtXG4gICAgICAgICAgLnJlYWQoYXJyYXkuYnVmZmVyKVxuICAgICAgICAgIC50aGVuKG51bUJ5dGVzID0+IChudW1CeXRlcyA9PT0gYXJyYXkuYnl0ZUxlbmd0aCA/IGFycmF5IDogbnVtQnl0ZXMgPyBhcnJheS5zbGljZSgwLCBudW1CeXRlcykgOiB1bmRlZmluZWQpKVxuICAgICAgXSk7XG5cbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWJvcnRlZCcpO1xuICAgIH1cblxuICAgIGxldCB7IHNhbXBsZXNQZXJTZWMgfSA9IGZvcm1hdDtcblxuICAgIC8vIFRPRE86IFtQMF0gIzM2OTIgUmVtb3ZlIHRoZSBmb2xsb3dpbmcgaWYtY29uZGl0aW9uIGJsb2NrIHdoZW4gdGhlIHVuZGVybHlpbmcgYnVncyBhcmUgcmVzb2x2ZWQuXG4gICAgLy8gICAgICAgVGhlcmUgaXMgYSBidWcgaW4gU3BlZWNoIFNESyAxLjE1LjAgdGhhdCByZXR1cm5zIDI0a0h6IGluc3RlYWQgb2YgMTZrSHouXG4gICAgLy8gICAgICAgRXZlbiBpZiB3ZSBleHBsaWNpdGx5IHNwZWNpZnkgdGhlIG91dHB1dCBhdWRpbyBmb3JtYXQgdG8gMTZrSHosIHRoZXJlIGlzIGFub3RoZXIgYnVnIHRoYXQgaWdub3JlZCBpdC5cbiAgICAvLyAgICAgICBJbiBzaG9ydCwgRExTcGVlY2ggc2VydmljZSBjdXJyZW50bHkgYWx3YXlzIHN0cmVhbXMgaW4gUklGRiBXQVYgZm9ybWF0LCBpbnN0ZWFkIG9mIE1QMy5cbiAgICAvLyAgICAgICBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L2NvZ25pdGl2ZS1zZXJ2aWNlcy1zcGVlY2gtc2RrLWpzL2lzc3Vlcy8zMTNcbiAgICAvLyAgICAgICBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L2NvZ25pdGl2ZS1zZXJ2aWNlcy1zcGVlY2gtc2RrLWpzL2lzc3Vlcy8zMTRcbiAgICBpZiAoZm9ybWF0LnJlcXVlc3RBdWRpb0Zvcm1hdFN0cmluZyA9PT0gJ2F1ZGlvLTI0a2h6LTQ4a2JpdHJhdGUtbW9uby1tcDMnKSB7XG4gICAgICBzYW1wbGVzUGVyU2VjID0gMTYwMDA7XG4gICAgfVxuXG4gICAgbGV0IG5ld1NhbXBsZXNQZXJTZWMgPSBzYW1wbGVzUGVyU2VjO1xuICAgIGxldCBzYW1wbGVSYXRlTXVsdGlwbGllciA9IDE7XG5cbiAgICAvLyBTYWZhcmkgcmVxdWlyZXMgYSBtaW5pbXVtIHNhbXBsZSByYXRlIG9mIDIyMTAwIEh6LlxuICAgIC8vIEEgbXVsdGlwbGllciBpcyBjYWxjdWxhdGVkIHRoZSB0aGUgZGF0YSBtZWV0cyB0aGUgbWluaW11bSBzYW1wbGUgcmF0ZS5cbiAgICAvLyBBbiBpbnRlZ2VyLWJhc2VkIG11bHRpcGxpZXIgdG8gc2ltcGxpZnkgb3VyIHVwc2FtcGxlci5cbiAgICAvLyBGb3Igc2VjdXJpdHksIGRhdGEgd2lsbCBvbmx5IGJlIHVwc2FtcGxlZCB1cCB0byA5NjAwMCBIei5cbiAgICB3aGlsZSAobmV3U2FtcGxlc1BlclNlYyA8IE1JTl9TQU1QTEVfUkFURSAmJiBuZXdTYW1wbGVzUGVyU2VjIDwgOTYwMDApIHtcbiAgICAgIHNhbXBsZVJhdGVNdWx0aXBsaWVyKys7XG4gICAgICBuZXdTYW1wbGVzUGVyU2VjID0gc2FtcGxlc1BlclNlYyAqIHNhbXBsZVJhdGVNdWx0aXBsaWVyO1xuICAgIH1cblxuICAgIC8vIFRoZSB0aGlyZCBwYXJhbWV0ZXIgaXMgdGhlIHNhbXBsZSBzaXplIGluIGJ5dGVzLlxuICAgIC8vIEZvciBleGFtcGxlLCBpZiB0aGUgU3BlZWNoIFNESyBzZW5kcyBXZWIgQ2hhdCA0MDk2IGJ5dGVzIG9mIDE2LWJpdCBzYW1wbGVzLCB0aGVyZSB3aWxsIGJlIDIwNDggc2FtcGxlcyBwZXIgY2hhbm5lbC5cbiAgICAvLyBUaGUgbXVsdGktYnVmZmVyaW5nIHBsYXllciBpcyBzZXQgdXAgdG8gaGFuZGxlIDIwNDggc2FtcGxlcyBwZXIgYnVmZmVyLlxuICAgIC8vIElmIHRoZSBtdWx0aXBsaWVyIDN4LCBpdCB3aWxsIGhhbmRsZSA2MTQ0IHNhbXBsZXMgcGVyIGJ1ZmZlci5cbiAgICBjb25zdCBwbGF5ZXIgPSBjcmVhdGVNdWx0aUJ1ZmZlcmluZ1BsYXllcihcbiAgICAgIGF1ZGlvQ29udGV4dCxcbiAgICAgIHsgLi4uZm9ybWF0LCBzYW1wbGVzUGVyU2VjOiBuZXdTYW1wbGVzUGVyU2VjIH0sXG4gICAgICAoREVGQVVMVF9CVUZGRVJfU0laRSAvIChmb3JtYXQuYml0c1BlclNhbXBsZSAvIDgpKSAqIHNhbXBsZVJhdGVNdWx0aXBsaWVyXG4gICAgKTtcblxuICAgIC8vIEZvciBzZWN1cml0eSwgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNodW5rcyBoYW5kbGVkIHdpbGwgYmUgMTAwMC5cbiAgICBmb3IgKFxuICAgICAgbGV0IGNodW5rID0gYXdhaXQgcmVhZCgpLCBtYXhDaHVua3MgPSAwO1xuICAgICAgY2h1bmsgJiYgbWF4Q2h1bmtzIDwgMTAwMCAmJiAhc2lnbmFsLmFib3J0ZWQ7XG4gICAgICBjaHVuayA9IGF3YWl0IHJlYWQoKSwgbWF4Q2h1bmtzKytcbiAgICApIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gRGF0YSByZWNlaXZlZCBmcm9tIFNwZWVjaCBTREsgaXMgaW50ZXJsZWF2ZWQ7IDIgY2hhbm5lbHMgKGUuZy4gQSBhbmQgQikgd2lsbCBiZSBzZW50IGFzIFwiQUJBQkFCQUJBQlwiXG4gICAgICAvLyBBbmQgZWFjaCBzYW1wbGUgKEEvQikgd2lsbCBiZSBhbiA4IHRvIDMyLWJpdCBudW1iZXIuXG5cbiAgICAgIC8vIENvbnZlcnQgdGhlIDggLSAzMi1iaXQgbnVtYmVyIGludG8gYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGFzIHJlcXVpcmVkIGJ5IFdlYiBBdWRpbyBBUEkuXG4gICAgICBjb25zdCBpbnRlcmxlYXZlZEFycmF5ID0gZm9ybWF0QXVkaW9EYXRhQXJyYXlCdWZmZXJUb0Zsb2F0QXJyYXkoZm9ybWF0LCBjaHVuay5idWZmZXIpO1xuXG4gICAgICAvLyBEZWludGVybGVhdmUgZGF0YSBiYWNrIGludG8gdHdvIGFycmF5IGJ1ZmZlciwgZS5nLiBcIkFBQUFBXCIgYW5kIFwiQkJCQkJcIi5cbiAgICAgIGNvbnN0IG11bHRpQ2hhbm5lbEFycmF5ID0gZGVpbnRlcmxlYXZlKGludGVybGVhdmVkQXJyYXksIGZvcm1hdCk7XG5cbiAgICAgIC8vIFVwc2FtcGxlIGRhdGEgaWYgbmVjZXNzYXJ5LiBJZiB0aGUgbXVsdGlwbGllciBpcyAyeCwgXCJBQUFBQVwiIHdpbGwgYmUgdXBzYW1wbGVkIHRvIFwiQUFBQUFBQUFBQVwiICh3aXRoIGFudGktYWxpYXMpLlxuICAgICAgY29uc3QgdXBzYW1wbGVkTXVsdGlDaGFubmVsQXJyYXkgPSBtdWx0aUNoYW5uZWxBcnJheS5tYXAoYXJyYXkgPT5cbiAgICAgICAgbXVsdGlwbHlTYW1wbGVSYXRlKGFycmF5LCBzYW1wbGVSYXRlTXVsdGlwbGllcilcbiAgICAgICk7XG5cbiAgICAgIC8vIFF1ZXVlIHRvIHRoZSBidWZmZXJpbmcgcGxheWVyLlxuICAgICAgcGxheWVyLnB1c2godXBzYW1wbGVkTXVsdGlDaGFubmVsQXJyYXkpO1xuICAgIH1cblxuICAgIGFib3J0UHJvbWlzZS5jYXRjaCgoKSA9PiBwbGF5ZXIuY2FuY2VsQWxsKCkpO1xuXG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fib3J0ZWQnKTtcbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLnJhY2UoW2Fib3J0UHJvbWlzZSwgcGxheWVyLmZsdXNoKCldKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBxdWV1ZWRCdWZmZXJTb3VyY2VOb2Rlcy5mb3JFYWNoKG5vZGUgPT4gbm9kZS5zdG9wKCkpO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUlBOzs7Ozs7QUFFQTtBQUNBO0FBQ0EsSUFBTUEsZUFBZSxHQUFHLEtBQXhCLEMsQ0FFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUNBLElBQU1DLG1CQUFtQixHQUFHLElBQTVCOztBQUVBLFNBQVNDLE9BQVQsQ0FBaUJDLEtBQWpCLEVBQXdCO0VBQ3RCLE9BQU9BLEtBQUssQ0FBQ0MsTUFBTixDQUFh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