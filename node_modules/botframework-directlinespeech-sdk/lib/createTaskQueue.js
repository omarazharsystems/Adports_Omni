"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTaskQueue;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _pDeferEs = _interopRequireDefault(require("p-defer-es5"));

function createTaskQueue() {
  var queueWithCurrent = [];
  var queue = {
    cancelAll: function cancelAll() {
      queueWithCurrent.forEach(function (_ref) {
        var cancel = _ref.cancel;
        return cancel();
      });
    },
    push: function push(fn) {
      var cancelDeferred = (0, _pDeferEs.default)();
      var resultDeferred = (0, _pDeferEs.default)();
      var entry = {
        promise: resultDeferred.promise
      };
      var abort;

      var cancel = entry.cancel = function () {
        // Override the "fn" so we don't call the actual "fn" later.
        // In this approach, we can reuse the logic inside "start" to handle post-cancellation.
        fn = function fn() {
          return {
            result: Promise.reject(new Error('cancelled before start'))
          };
        }; // Abort the task if it is currently running.


        abort && abort();
        cancelDeferred.reject(new Error('cancelled in the midway'));
      };

      var start = /*#__PURE__*/function () {
        var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
          var _fn, abortFn, result;

          return _regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _fn = fn(), abortFn = _fn.abort, result = _fn.result;
                  abort = abortFn;
                  _context.prev = 2;
                  _context.t0 = resultDeferred;
                  _context.next = 6;
                  return Promise.race([result, cancelDeferred.promise]);

                case 6:
                  _context.t1 = _context.sent;

                  _context.t0.resolve.call(_context.t0, _context.t1);

                  _context.next = 13;
                  break;

                case 10:
                  _context.prev = 10;
                  _context.t2 = _context["catch"](2);
                  resultDeferred.reject(_context.t2);

                case 13:
                  queueWithCurrent = queueWithCurrent.filter(function (e) {
                    return e !== entry;
                  });

                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[2, 10]]);
        }));

        return function start() {
          return _ref2.apply(this, arguments);
        };
      }();

      var lastEntry = queueWithCurrent[queueWithCurrent.length - 1];
      var lastPromise = lastEntry && lastEntry.promise || Promise.resolve();
      queueWithCurrent.push(entry); // After the last promise resolved/rejected, we will start this task.
      // We will start even if the last promise rejected.

      lastPromise.then(start, start);
      return {
        cancel: cancel,
        result: resultDeferred.promise
      };
    }
  };
  Object.defineProperty(queue, 'length', {
    get: function get() {
      return queueWithCurrent.length;
    }
  });
  return queue;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjcmVhdGVUYXNrUXVldWUiLCJxdWV1ZVdpdGhDdXJyZW50IiwicXVldWUiLCJjYW5jZWxBbGwiLCJmb3JFYWNoIiwiY2FuY2VsIiwicHVzaCIsImZuIiwiY2FuY2VsRGVmZXJyZWQiLCJjcmVhdGVEZWZlcnJlZCIsInJlc3VsdERlZmVycmVkIiwiZW50cnkiLCJwcm9taXNlIiwiYWJvcnQiLCJyZXN1bHQiLCJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJzdGFydCIsImFib3J0Rm4iLCJyYWNlIiwicmVzb2x2ZSIsImZpbHRlciIsImUiLCJsYXN0RW50cnkiLCJsZW5ndGgiLCJsYXN0UHJvbWlzZSIsInRoZW4iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCJdLCJzb3VyY2VSb290IjoiZGlyZWN0bGluZXNwZWVjaDovLy8iLCJzb3VyY2VzIjpbIi4uL3NyYy9jcmVhdGVUYXNrUXVldWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZURlZmVycmVkIGZyb20gJ3AtZGVmZXItZXM1JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlVGFza1F1ZXVlKCkge1xuICBsZXQgcXVldWVXaXRoQ3VycmVudCA9IFtdO1xuXG4gIGNvbnN0IHF1ZXVlID0ge1xuICAgIGNhbmNlbEFsbDogKCkgPT4ge1xuICAgICAgcXVldWVXaXRoQ3VycmVudC5mb3JFYWNoKCh7IGNhbmNlbCB9KSA9PiBjYW5jZWwoKSk7XG4gICAgfSxcbiAgICBwdXNoOiBmbiA9PiB7XG4gICAgICBjb25zdCBjYW5jZWxEZWZlcnJlZCA9IGNyZWF0ZURlZmVycmVkKCk7XG4gICAgICBjb25zdCByZXN1bHREZWZlcnJlZCA9IGNyZWF0ZURlZmVycmVkKCk7XG4gICAgICBjb25zdCBlbnRyeSA9IHsgcHJvbWlzZTogcmVzdWx0RGVmZXJyZWQucHJvbWlzZSB9O1xuICAgICAgbGV0IGFib3J0O1xuXG4gICAgICBjb25zdCBjYW5jZWwgPSAoZW50cnkuY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAvLyBPdmVycmlkZSB0aGUgXCJmblwiIHNvIHdlIGRvbid0IGNhbGwgdGhlIGFjdHVhbCBcImZuXCIgbGF0ZXIuXG4gICAgICAgIC8vIEluIHRoaXMgYXBwcm9hY2gsIHdlIGNhbiByZXVzZSB0aGUgbG9naWMgaW5zaWRlIFwic3RhcnRcIiB0byBoYW5kbGUgcG9zdC1jYW5jZWxsYXRpb24uXG4gICAgICAgIGZuID0gKCkgPT4gKHsgcmVzdWx0OiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2NhbmNlbGxlZCBiZWZvcmUgc3RhcnQnKSkgfSk7XG5cbiAgICAgICAgLy8gQWJvcnQgdGhlIHRhc2sgaWYgaXQgaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAgICAgIGFib3J0ICYmIGFib3J0KCk7XG4gICAgICAgIGNhbmNlbERlZmVycmVkLnJlamVjdChuZXcgRXJyb3IoJ2NhbmNlbGxlZCBpbiB0aGUgbWlkd2F5JykpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGFib3J0OiBhYm9ydEZuLCByZXN1bHQgfSA9IGZuKCk7XG5cbiAgICAgICAgYWJvcnQgPSBhYm9ydEZuO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gRWl0aGVyIHdhaXQgZm9yIHRoZSBhY3R1YWwgcmVzdWx0LCBvciB0aGUgdGFzayBpcyBiZWluZyBjYW5jZWxsZWQuXG4gICAgICAgICAgcmVzdWx0RGVmZXJyZWQucmVzb2x2ZShhd2FpdCBQcm9taXNlLnJhY2UoW3Jlc3VsdCwgY2FuY2VsRGVmZXJyZWQucHJvbWlzZV0pKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXN1bHREZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcXVldWVXaXRoQ3VycmVudCA9IHF1ZXVlV2l0aEN1cnJlbnQuZmlsdGVyKGUgPT4gZSAhPT0gZW50cnkpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgbGFzdEVudHJ5ID0gcXVldWVXaXRoQ3VycmVudFtxdWV1ZVdpdGhDdXJyZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgbGFzdFByb21pc2UgPSAobGFzdEVudHJ5ICYmIGxhc3RFbnRyeS5wcm9taXNlKSB8fCBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgICAgcXVldWVXaXRoQ3VycmVudC5wdXNoKGVudHJ5KTtcblxuICAgICAgLy8gQWZ0ZXIgdGhlIGxhc3QgcHJvbWlzZSByZXNvbHZlZC9yZWplY3RlZCwgd2Ugd2lsbCBzdGFydCB0aGlzIHRhc2suXG4gICAgICAvLyBXZSB3aWxsIHN0YXJ0IGV2ZW4gaWYgdGhlIGxhc3QgcHJvbWlzZSByZWplY3RlZC5cbiAgICAgIGxhc3RQcm9taXNlLnRoZW4oc3RhcnQsIHN0YXJ0KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FuY2VsLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdERlZmVycmVkLnByb21pc2VcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShxdWV1ZSwgJ2xlbmd0aCcsIHsgZ2V0OiAoKSA9PiBxdWV1ZVdpdGhDdXJyZW50Lmxlbmd0aCB9KTtcblxuICByZXR1cm4gcXVldWU7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFZSxTQUFTQSxlQUFULEdBQTJCO0VBQ3hDLElBQUlDLGdCQUFnQixHQUFHLEVBQXZCO0VBRUEsSUFBTUMsS0FBSyxHQUFHO0lBQ1pDLFNBQVMsRUFBRSxxQkFBTTtNQUNmRixnQkFBZ0IsQ0FBQ0csT0FBakIsQ0FBeUI7UUFBQSxJQUFHQyxNQUFILFFBQUdBLE1BQUg7UUFBQSxPQUFnQkEsTUFBTSxFQUF0QjtNQUFBLENBQXpCO0lBQ0QsQ0FIVztJQUlaQyxJQUFJLEVBQUUsY0FBQUMsRUFBRSxFQUFJO01BQ1YsSUFBTUMsY0FBYyxHQUFHLElBQUFDLGlCQUFBLEdBQXZCO01BQ0EsSUFBTUMsY0FBYyxHQUFHLElBQUFELGlCQUFBLEdBQXZCO01BQ0EsSUFBTUUsS0FBSyxHQUFHO1FBQUVDLE9BQU8sRUFBRUYsY0FBYyxDQUFDRTtNQUExQixDQUFkO01BQ0EsSUFBSUMsS0FBSjs7TUFFQSxJQUFNUixNQUFNLEdBQUlNLEtBQUssQ0FBQ04sTUFBTixHQUFlLFlBQU07UUFDbkM7UUFDQTtRQUNBRSxFQUFFLEdBQUc7VUFBQSxPQUFPO1lBQUVPLE1BQU0sRUFBRUMsT0FBTyxDQUFDQyxNQUFSLENBQWUsSUFBSUMsS0FBSixDQUFVLHdCQUFWLENBQWY7VUFBVixDQUFQO1FBQUEsQ0FBTCxDQUhtQyxDQUtuQzs7O1FBQ0FKLEtBQUssSUFBSUEsS0FBSyxFQUFkO1FBQ0FMLGNBQWMsQ0FBQ1EsTUFBZixDQUFzQixJQUFJQyxLQUFKLENBQVUseUJBQVYsQ0FBdEI7TUFDRCxDQVJEOztNQVVBLElBQU1DLEtBQUs7UUFBQSxvRkFBRztVQUFBOztVQUFBO1lBQUE7Y0FBQTtnQkFBQTtrQkFBQSxNQUN1QlgsRUFBRSxFQUR6QixFQUNHWSxPQURILE9BQ0pOLEtBREksRUFDWUMsTUFEWixPQUNZQSxNQURaO2tCQUdaRCxLQUFLLEdBQUdNLE9BQVI7a0JBSFk7a0JBQUEsY0FPVlQsY0FQVTtrQkFBQTtrQkFBQSxPQU9tQkssT0FBTyxDQUFDSyxJQUFSLENBQWEsQ0FBQ04sTUFBRCxFQUFTTixjQUFjLENBQUNJLE9BQXhCLENBQWIsQ0FQbkI7O2dCQUFBO2tCQUFBOztrQkFBQSxZQU9LUyxPQVBMOztrQkFBQTtrQkFBQTs7Z0JBQUE7a0JBQUE7a0JBQUE7a0JBU1ZYLGNBQWMsQ0FBQ00sTUFBZjs7Z0JBVFU7a0JBWVpmLGdCQUFnQixHQUFHQSxnQkFBZ0IsQ0FBQ3FCLE1BQWpCLENBQXdCLFVBQUFDLENBQUM7b0JBQUEsT0FBSUEsQ0FBQyxLQUFLWixLQUFWO2tCQUFBLENBQXpCLENBQW5COztnQkFaWTtnQkFBQTtrQkFBQTtjQUFBO1lBQUE7VUFBQTtRQUFBLENBQUg7O1FBQUEsZ0JBQUxPLEtBQUs7VUFBQTtRQUFBO01BQUEsR0FBWDs7TUFlQSxJQUFNTSxTQUFTLEdBQUd2QixnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUN3QixNQUFqQixHQUEwQixDQUEzQixDQUFsQztNQUNBLElBQU1DLFdBQVcsR0FBSUYsU0FBUyxJQUFJQSxTQUFTLENBQUNaLE9BQXhCLElBQW9DRyxPQUFPLENBQUNNLE9BQVIsRUFBeEQ7TUFFQXBCLGdCQUFnQixDQUFDSyxJQUFqQixDQUFzQkssS0FBdEIsRUFsQ1UsQ0FvQ1Y7TUFDQTs7TUFDQWUsV0FBVyxDQUFDQyxJQUFaLENBQWlCVCxLQUFqQixFQUF3QkEsS0FBeEI7TUFFQSxPQUFPO1FBQ0xiLE1BQU0sRUFBTkEsTUFESztRQUVMUyxNQUFNLEVBQUVKLGNBQWMsQ0FBQ0U7TUFGbEIsQ0FBUDtJQUlEO0VBaERXLENBQWQ7RUFtREFnQixNQUFNLENBQUNDLGNBQVAsQ0FBc0IzQixLQUF0QixFQUE2QixRQUE3QixFQUF1QztJQUFFNEIsR0FBRyxFQUFFO01BQUEsT0FBTTdCLGdCQUFnQixDQUFDd0IsTUFBdkI7SUFBQTtFQUFQLENBQXZDO0VBRUEsT0FBT3ZCLEtBQVA7QUFDRCJ9